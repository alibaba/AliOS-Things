; i.MX6 Series Peripheral Register Definitions

config 16. 8.
width 12.

tree "Cortex-A9 Registers"
width 0x8
;##################################################
; Identification registers
;##################################################
tree "ID Registers"

rgroup.long c15:0x0++0x0
 line.long 0x0 "MIDR,Main ID Register"
  hexmask.long.byte 0x0 24.--31. 0x1 " IMPL       ,Implementer code"
  bitfld.long 0x0 20.--23.  "              VAR        ,Variant" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
  bitfld.long 0x0 16.--19.  "             ARCH      , Architecture" "Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,Pre-ARMv7,ARMv7"
  textline "                 "
  hexmask.long.word 0x0 4.--15. 0x1 " PART       ,Primary Part Number"
  bitfld.long 0x0 0.--3. "            REV        ,Revision Number" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

rgroup.long c15:0x100++0x0
 line.long 0x0 "CTR,Cache Type Register"
  bitfld.long 0x0 29.--31. " FORMAT     ,Format" "Not ARMv7,Not ARMv7,Not ARMv7,Not ARMv7,ARMv7,Not ARMv7,Not ARMv7,Not ARMv7"
  bitfld.long 0x0 24.--27. "       CWG        ,Cache Writeback Granule" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
  textline "                 "
  bitfld.long 0x0 20.--23. " ERG        ,Exclusives Reservation Granule" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
  bitfld.long 0x0 16.--19. "              DMINLINE   ,D-Cache Minimum Line Size" "1 word,2 words,4 words,8 words,16 words,32 words,64 words,128 words,256 words,512 words,1024 words,2048 words,4096 words,8192 words,16384 words,32768 words"
  textline "                 "
  bitfld.long 0x0 14.--15. " L1POLICY   ,L1 Instruction cache policy" "Reserved,ASID,Virtual,Physical"
  bitfld.long 0x0 0.--3. "        IMINLINE   ,I-Cache Minimum Line Size" "1 word,2 words,4 words,8 words,16 words,32 words,64 words,128 words,256 words,512 words,1024 words,2048 words,4096 words,8192 words,16384 words,32768 words"

rgroup.long c15:0x200++0x0
 line.long 0x0 "TCMTR,Tighly-Coupled Memory Type Register"

rgroup.long c15:0x300++0x0
 line.long 0x0 "TLBTR,TLB Type Register"
  hexmask.long.byte 0x0 16.--23. 0x1 " ILSIZE     ,Specifies the number of instruction TLB lockable entries"
  hexmask.long.byte 0x0 8.--15. 0x1 "              DLSIZE     ,Specifies the number of unified or data TLB lockable entries"
  bitfld.long 0x0 1. "             TLB_size  ,TLB Size" "64,128"
  textline "                 "
  bitfld.long 0x0 0. " nU         ,Unified or Separate TLBs" "Unified,Separate"
  
rgroup.long c15:0x500++0x0
 line.long 0x0 "MPIDR,Multiprocessor Affinity Register"
  bitfld.long 0x00 30. " U          ,Processor is part of a multiprocessor or uniprocessor system" "Multiprocessor,Uniprocessor"
  bitfld.long 0x00 8.--11. "  ClusterID  ,Value read in CLUSTERID configuration pins" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
  bitfld.long 0x00 0.--1. "             CPUID     ,Value depends on the number of configured CPUs" "0,1,2,3"

rgroup.long c15:0x0410++0x00
 line.long 0x00 "MMFR0,Memory Model Feature Register 0"
  bitfld.long 0x00 24.--27. " FCSE       ,Fast Context Switch Memory Mappings Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "   ACR        ,Auxiliary Control Register Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 16.--19. "      TCM       ,TCM and Associated DMA Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
    bitfld.long 0x00 12.--15. " OSS        ,Outer Shareable Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "   CC_CPUA    ,Cache Coherency Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 4.--7. "      PMSA      ,Physical Memory System Architecture (PMSA) Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 0.--3. " VMSA       ,Virtual Memory System Architecture (VMSA) Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"   
rgroup.long c15:0x0510++0x00
 line.long 0x00 "MMFR1,Memory Model Feature Register 1"
  bitfld.long 0x00 28.--31. " BTB        ,Branch Predictor" "Reserved,Reserved,Required,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 24.--27. "        L1TCO      ,Test and Clean Operations on Data Cache/Harvard/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "  L1UCMO    ,L1 Cache/All Maintenance Operations/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 16.--19. " L1HCMO     ,L1 Cache/All Maintenance Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "   L1UCLMOSW  ,L1 Cache Line Maintenance Operations by Set and Way/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "  L1HCLMOSW ,L1 Cache Line Maintenance Operations by Set and Way/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 4.--7. " L1UCLMOMVA ,L1 Cache Line Maintenance Operations by VA/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "   L1HCLMOMVA ,L1 Cache Line Maintenance Operations by VA/Harvard Architecture" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved" 
rgroup.long c15:0x0610++0x00
 line.long 0x00 "MMFR2,Memory Model Feature Register 2"
  bitfld.long 0x00 28.--31. " HAF        ,Hardware Access Flag Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 24.--27. "   WFI        ,Wait for Interrupt Stalling Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "      MBF       ,Memory Barrier Operations Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 16.--19. " UTLBMO     ,TLB Maintenance Operations/Unified Architecture Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "       HTLBMO     ,TLB Maintenance Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "  HL1CMRO   ,Cache Maintenance Range Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 4.--7. " HL1BPCRO   ,Background Prefetch Cache Range Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "   HL1FPCRO   ,Foreground Prefetch Cache Range Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
rgroup.long c15:0x0710++0x00
 line.long 0x00 "MMFR3,Memory Model Feature Register 3"
  bitfld.long 0x00 28.--31. " SS         ,Supersection support" "Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "       CW         ,Coherent walk" "Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "      MB        ,Invalidate broadcast Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 8.--11. " BPM        ,Invalidate Branch predictor Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 4.--7. "       HCMOSW     ,Invalidate Cache by Set and Way/Clean by Set and Way/Invalidate and Clean by Set and Way Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "      HCMOMVA   ,Invalidate Cache MVA Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"    
rgroup.long c15:0x0020++0x00
 line.long 0x00 "ISAR0,Instruction Set Attribute Register 0"
  bitfld.long 0x00 24.--27. " DIVI       ,Divide Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "   DEBI       ,Debug Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 16.--19. "      CI        ,Coprocessor Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 12.--15. " CBI        ,Combined Compare and Branch Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "       BI         ,Bitfield Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 4.--7. "      BCI       ,Bit Counting Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 0.--3. " SI         ,Swap Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"   
rgroup.long c15:0x0120++0x00
 line.long 0x00 "ISAR1,Instruction Set Attribute Register 1"
  bitfld.long 0x00 28.--31. " JI         ,Jazelle Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 24.--27. "       INTI       ,Interwork Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "      IMMI      ,Immediate Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 16.--19. " ITEI       ,If Then Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "       EXTI       ,Extend Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "      E2I       ,Exception 2 Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 4.--7. " E1I        ,Exception 1 Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "       ENDI       ,Endian Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"   
rgroup.long c15:0x0220++0x00
 line.long 0x00 "ISAR2,Instruction Set Attribute Register 2"
  bitfld.long 0x00 28.--31. " RI         ,Reversal Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 24.--27. "       PSRI       ,PSR Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "      UMI       ,Advanced Unsigned Multiply Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 16.--19. " SMI        ,Advanced Signed Multiply Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "       MI         ,Multiply Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "      II        ,Multi-Access Interruptible Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 4.--7. " MHI        ,Memory Hint Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "       LSI        ,Load and Store Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
rgroup.long c15:0x0320++0x00
 line.long 0x00 "ISAR3,Instruction Set Attribute Register 3"
  bitfld.long 0x00 28.--31. " T2E        ,Thumb-2 Extensions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 24.--27. "       NOPI       ,True NOP Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "      TCI       ,Thumb Copy Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 16.--19. " TBI        ,Table Branch Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "       SPI        ,Synchronization Primitive Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "      SVCI      ,SVC Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 4.--7. " SIMDI      ,Single Instruction Multiple Data (SIMD) Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "       SI         ,Saturate Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"    
rgroup.long c15:0x0420++0x00
 line.long 0x00 "ISAR4,Instruction Set Attribute Register 4"
  bitfld.long 0x00 28.--31. " SWP_frac   ,SWAP_frac" "Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 24.--27. "       PSR_M_I    ,PSR_M Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 20.--23. "  SPRI      ,Synchronization Primitive instructions" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 16.--19. " BI         ,Barrier Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "       SMCI       ,SMC Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "      WBI       ,Write-Back Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    textline "                 "
  bitfld.long 0x00 4.--7. " WSI        ,With-Shift Instructions Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "       UI         ,Unprivileged Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"     
rgroup.long c15:0x0520++0x00
 line.long 0x00 "ISAR5,Instruction Set Attribute Registers 5 (Reserved)"
rgroup.long c15:0x0620++0x00
 line.long 0x00 "ISAR6,Instruction Set Attribute Registers 6 (Reserved)"
rgroup.long c15:0x0720++0x00
 line.long 0x00 "ISAR7,Instruction Set Attribute Registers 7 (Reserved)"   
rgroup.long c15:0x0010++0x00
 line.long 0x00 "PFR0,Processor Feature Register 0"
  bitfld.long 0x00 12.--15. " State3     ,Thumb-2 Execution Environment (Thumb-2EE) Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 8.--11. "       State2     ,Java Extension Interface Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 4.--7. "      State1    ,Thumb Encoding Supported by the Processor Type" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 0.--3. " State0     ,ARM Instruction Set Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
rgroup.long c15:0x0110++0x00
 line.long 0x00 "PFR1,Processor Feature Register 1"
  bitfld.long 0x00 8.--11. " MPM        ,Microcontroller Programmer's Model Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 4.--7. "   SE         ,Security Extensions Architecture v1 Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "      PM        ,Standard ARMv4 Programmer's Model Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
rgroup.long c15:0x0210++0x00
 line.long 0x00 "DFR0,Debug Feature Register 0"
  bitfld.long 0x00 20.--23. " MDM_MM     ,Microcontroller Debug Model Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 16.--19. "   TDM_MM     ,Trace Debug Model (Memory-Mapped) Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--15. "      TDM_CB    ,Coprocessor-Based Trace Debug Model Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  textline "                 "
  bitfld.long 0x00 8.--11. " CDM_MM     ,Memory-Mapped Debug Model Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 4.--7. "       SDM_CB     ,Secure Debug Model (Coprocessor) Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--3. "      CDM_CB    ,Coprocessor Debug Model Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
rgroup.long c15:0x0310++0x00
 line.long 0x00 "AFR0,Auxiliary Feature Register 0"
  hexmask.long 0x00 0.--31. 1. " AF         ,Auxiliary Feature"
tree.end
width 0x8
tree "System Control and Configuration"

group.long c15:0x1++0x0
 line.long 0x0 "SCTLR,Control Register"
  bitfld.long 0x0 30. " TE       ,Thumb exception enable" "ARM,Thumb"
  bitfld.long 0x0 29. "        AFE      ,Access Flag Enable" "Disabled,Enabled"
  bitfld.long 0x0 28. "     TRE      ,TEX remap enable" "Disabled,Enabled"
  textline "                 "
  bitfld.long 0x0 27. " NMFI     ,DNonmaskable Fast Interrupt enable" "Disabled,Enabled"
  bitfld.long 0x0 25. "     EE       ,Exception endianess" "Little,Big"
  bitfld.long 0x0 14. "       RR       ,Replacement strategy for caches, BTAC, and micro TLBs" "Random,Round robin"
  textline "                 "
  bitfld.long 0x0 13. " V        ,Base Location of Exception Registers" "0x00000000,0xFFFF0000"
  bitfld.long 0x0 12. "   I        ,Instruction Cache Enable" "Disabled,Enabled"
  bitfld.long 0x0 11. "     Z        ,Branch Prediction Enable" "Disabled,Enabled"
  textline "                 "
  bitfld.long 0x0 10. " SW       ,SWP/SWPB Enable" "Disabled,Enabled"
  bitfld.long 0x0 2. "     C        ,Enable unified cache or data cache" "Disabled,Enabled"
  bitfld.long 0x0 1. "     A        ,Strict Alignment" "Disabled,Enabled"
  textline "                 "
  bitfld.long 0x0 0. " M        ,MMU or Protection Unit" "Disabled,Enabled"   
group.long c15:0x101++0x0
 line.long 0x0 "ACTLR,Auxiliary Control Register"
  bitfld.long 0x00 9. " PARON    ,Parity On" "Disabled,Enabled"
     bitfld.long 0x00 7. "     EXCL     ,Exclusive cache Enable" "Disabled,Enabled"
  bitfld.long 0x00 6. "     SMP      ,Signals if the Cortex-A9 processor is taking part in coherency or not" "0,1"
  textline "                 "
  bitfld.long 0x00 3. " FOZ      ,Full Of Zero mode Enable" "Disabled,Enabled"
  bitfld.long 0x00 2. "     DP1      ,L1 Dside prefetch Enable" "Disabled,Enabled"   
  bitfld.long 0x00 1. "     DP2      ,L2 Dside prefetch Enable" "Disabled,Enabled"   
  textline "                 "
  bitfld.long 0x00 0. " FW       ,Cache and TLB maintenance broadcast" "Disabled,Enabled"   
group.long c15:0x201++0x0
 line.long 0x0 "CPACR,Coprocessor Access Control Register"
  bitfld.long 0x0 31. " ASEDIS   ,Disable Advanced SIMD Extension functionality" "No,Yes"
  bitfld.long 0x0 30. "          D32DIS   ,Disable use of D16-D31 of the VFP register file" "No,Yes"
  bitfld.long 0x0 22.--23. "          CP11     ,Coprocesor access control" "Denied,Privileged,Reserved,Full"
  textline "                 "
  bitfld.long 0x0 20.--21. " CP10     ,Coprocesor access control" "Denied,Privileged,Reserved,Full"
 textline " "
 
group.long c15:0x11++0x0
 line.long 0x0 "SCR,Secure Configuration Register"
  bitfld.long 0x00 6. " nET      ,Not early termination" "Not early,Early"
  bitfld.long 0x00 5. "    AW       ,Controls whether the Non-secure world can modify the A-bit in the CPSR" "Not allowed,Allowed"
  bitfld.long 0x00 4. "  FW       ,FW-bit controls whether the Non-secure world can modify the F-bit in the CPSR" "Not allowed,Allowed"
  textline "                 "
  bitfld.long 0x00 3. " EA       ,External Abort  exceptions handled in Abort mode or Monitor mode" "Abort,Monitor"
  bitfld.long 0x00 2. "      FIQ      ,FIQ exceptions handled in Abort mode or Monitor mode" "FIQ,Monitor"
  bitfld.long 0x00 1. "      IRQ      ,IRQ exceptions handled in Abort mode or Monitor mode" "IRQ,Monitor"
  textline "                 "
  bitfld.long 0x00 0. " NS       ,Secure mode " "Secure,Non-secure"
group.long c15:0x111++0x0
 line.long 0x0 "SDER,Secure Debug Enable Register"
  bitfld.long 0x00 1. " SUNIDEN  ,Non-Invasive Secure User Debug Enable bit" "Denied,Permitted"
  bitfld.long 0x00 0. "    SUIDEN   ,Invasive Secure User Debug Enable bit" "Denied,Permitted"   
group.long c15:0x0211++0x00
 line.long 0x00 "NSACR,Non-Secure Access Control Register"
  bitfld.long 0x00 18. " NS_SMP   ,Determines if the SMP bit of the Auxiliary Control Register is writable in Non-secure state" "Disabled,Enabled"
  bitfld.long 0x00 17. "     TL       ,Lockable Page Table Entries Allocation in Nonsecure World" "Denied,Permitted"
  bitfld.long 0x00 15. "    NSASEDIS ,Disable Non-secure Advanced SIMD Extension functionality" "Denied,Permitted"
  textline "                 "
  bitfld.long 0x00 14. " NSD32DIS ,Disable the Non-secure use of D16-D31 of the VFP register" "Denied,Permitted"
    bitfld.long 0x00 11. "    CP11     ,Coprocessor 11 in the Nonsecure World Access Permission" "Denied,Permitted"
  bitfld.long 0x00 10. "    CP10     ,Coprocessor 10 in the Nonsecure World Access Permission" "Denied,Permitted"
group.long c15:0x0311++0x00
 line.long 0x00 "VCR,Virtualization Control Register"
  bitfld.long 0x00 8. " AMO      ,Abort Mask Override" "0,1"
  bitfld.long 0x00 7. "            IMO      ,IRQ Mask Override" "0,1"
  bitfld.long 0x00 6. "            IFO      ,FIQ Mask Override" "0,1"
 textline " "
 
group.long c15:0x000c++0x00
 line.long 0x00 "VBAR,Secure or Nonsecure Vector Base Address Register"
  hexmask.long 0x00 5.--31. 0x20 " VBA      ,Base Address"
group.long c15:0x10c++0x00
 line.long 0x0 "MVBAR,Monitor Vector Base Address Register"
  hexmask.long 0x00 5.--31. 0x20 " MVBA     , Monitor Vector Base Address"
rgroup.long c15:0x1C++0x0
 line.long 0x0 "ISR,Interrupt status Register"
  bitfld.long 0x0 8. " A        ,Pending External Abort" "Not pending,Pending"
  bitfld.long 0x0 7. "  I        ,Pending IRQ" "Not pending,Pending"
  bitfld.long 0x0 6. "  F        ,Pending FIQ" "Not pending,Pending"
group.long c15:0x11c++0x0
 line.long 0x00 "VIR,Virtualization Interrupt Register"
  bitfld.long 0x00 8. " VA       ,Virtual Abort" "0,1"
  bitfld.long 0x00 7. "            VI       ,Virtual IRQ" "0,1"
  bitfld.long 0x00 6. "            VF       ,Virtual FIQ" "0,1"
 textline " "

group.long c15:0xf++0x0
 line.long 0x00 "PCR,Power Control Register"
  bitfld.long 0x00 8.--10. " MCL      ,Max Clock Latency" "0,1,2,3,4,5,6,7"
  bitfld.long 0x00 0. "            EDCG     ,Enable Dynamic Clock Gating" "Disabled,Enabled"
group.long c15:0x1f++0x0
 line.long 0x00 "NEONBR,NEON Busy Register"
  bitfld.long 0x00 0. " BUSY     ,NEON Busy" "No,Yes"
group.long c15:0x400f++0x0
 line.long 0x00 "CBAR,Configuration Base Address Register"
  hexmask.long 0x00 0.--31. 1. " CBAR     ,Configuration Base Address Register"
tree.end

width 0x0d
tree "Memory Management Unit"
group.long c15:0x1++0x0
 line.long 0x0 "SCTLR,Control Register"
  bitfld.long 0x0 30. " TE      ,Thumb exception enable" "ARM,Thumb"
  bitfld.long 0x0 29. "        AFE     ,Access Flag Enable" "Disabled,Enabled"
  bitfld.long 0x0 28. "     TRE      ,TEX remap enable" "Disabled,Enabled"
  textline "                      "
  bitfld.long 0x0 27. " NMFI    ,DNonmaskable Fast Interrupt enable" "Disabled,Enabled"
  bitfld.long 0x0 25. "     EE      ,Exception endianess" "Little,Big"
  bitfld.long 0x0 14. "       RR       ,Replacement strategy for caches, BTAC, and micro TLBs" "Random,Round robin"
  textline "                      "
  bitfld.long 0x0 13. " V       ,Base Location of Exception Registers" "0x00000000,0xFFFF0000"
  bitfld.long 0x0 12. "   I       ,Instruction Cache Enable" "Disabled,Enabled"
  bitfld.long 0x0 11. "     Z        ,Branch Prediction Enable" "Disabled,Enabled"
  textline "                      "
  bitfld.long 0x0 10. " SW      ,SWP/SWPB Enable" "Disabled,Enabled"
  bitfld.long 0x0 2. "     C       ,Enable unified cache or data cache" "Disabled,Enabled"
  bitfld.long 0x0 1. "     A        ,Strict Alignment" "Disabled,Enabled"
  textline "                      "
  bitfld.long 0x0 0. " M       ,MMU or Protection Unit" "Disabled,Enabled"   
 textline " "
 
group.long c15:0x0002++0x00
 line.long 0x00 "TTBR0,Translation Table Base Register 0"
  hexmask.long 0x00 14.--31. 0x4000 " TTB0    ,Translation Table Base Address"
  bitfld.long 0x00 6. 0. "                IRGN[1:0] ,Indicates inner cacheability" "Noncacheable,Back/allocated,Through,Back/not allocated"
  textline "                      "
  bitfld.long 0x00 3.--4. " RGN     ,Outer Cacheable Attributes for Page Table Walking" "Noncacheable,Back/allocated,Through,Back/not allocated"
  bitfld.long 0x00 1. "      S         ,Page Table Walk to Shared Memory" "Nonshared,Shared"
group.long c15:0x0102++0x00
 line.long 0x00 "TTBR1,Translation Table Base Register 1"
  hexmask.long 0x00 14.--31. 0x4000 " TTB1    ,Translation Table Base Address"
  bitfld.long 0x00 6. 0. "                IRGN[1:0] ,Indicates inner cacheability" "Noncacheable,Back/allocated,Through,Back/not allocated"
  textline "                      "
  bitfld.long 0x00 3.--4. " RGN     ,Outer Cacheable Attributes for Page Table Walking" "Noncacheable,Back/allocated,Through,Back/not allocated"
  bitfld.long 0x00 1. "      S         ,Page Table Walk to Shared Memory" "Nonshared,Shared"
group.long c15:0x0202++0x00
 line.long 0x00 "TTBCR,Translation Table Base Control Register"
   bitfld.long 0x00 5. " PD1     ,Page Table Walk on a TLB Miss When Using Translation Table Base Register 1" "Enable,Disable"
   bitfld.long 0x00 4. "  PD0  ,Page Table Walk on a TLB Miss When Using Translation Table Base Register 0" "Enable,Disable"
   bitfld.long 0x0 0.--2. "   N    ,Translation Table Base Register 0 page table boundary size" "Off,0x80000000,0x40000000,0x20000000,0x10000000,0x08000000,0x04000000,0x02000000"
 textline " "
 
group.long c15:0x3--0x3 
 line.long 0x0 "DACR,Domain Access Control Register"
  bitfld.long 0x0 30.--31. " D15  ,Domain Access 15" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 28.--29. "  D14 ,Domain Access 14" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 26.--27. "  D13 ,Domain Access 13" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 24.--25. "  D12 ,Domain Access 12" "Denied,Client,Reserved,Manager"
 textline "                      "
  bitfld.long 0x0 22.--23. " D11  ,Domain Access 11" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 20.--21. "  D10 ,Domain Access 10" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 18.--19. "  D9  ,Domain Access 9" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 16.--17. "  D8  ,Domain Access 8" "Denied,Client,Reserved,Manager"
 textline "                      "
  bitfld.long 0x0 14.--15. " D7   ,Domain Access 7" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 12.--13. "  D6  ,Domain Access 6" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 10.--11. "  D5  ,Domain Access 5" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 8.--9. "  D4  ,Domain Access 4" "Denied,Client,Reserved,Manager"
 textline "                      "
  bitfld.long 0x0 6.--7. " D3   ,Domain Access 3" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 4.--5. "  D2  ,Domain Access 2" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 2.--3. "  D1  ,Domain Access 1" "Denied,Client,Reserved,Manager"
  bitfld.long 0x0 0.--1. "  D0  ,Domain Access 0" "Denied,Client,Reserved,Manager"
 textline " "
 
group.long c15:0x0005++0x00
 line.long 0x00 "DFSR,Data Fault Status Register"
  bitfld.long 0x00 12. " EXT     ,External Abort Qualifier" "DECERR,SLVERR"
  bitfld.long 0x00 11. "                  RW        ,Access Caused an Abort Type" "Read,Write"
  textline "                      "
  bitfld.long 0x00 4.--7. " DOMAIN  ,Domain Accessed When a Data Fault Occurs" "D0,D1,D2,D3,D4,D5,D6,D7,D8,D9,D10,D11,D12,D13,D14,D15"
  bitfld.long 0x00 0.--3. 10.  "                     STATUS    ,Generated Exception Type" "Reserved,Alignment,Debug,Access/section,Instruction,Translation/section,Access/page,Translation/page,Nontranslation/synchronous external,Domain/section,Reserved,Domain/page,L1/external,Permission/section,L2/external,Permission/page,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Asynchronous external,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
group.long c15:0x0006++0x00
 line.long 0x00 "DFAR,Data Fault Address Register"
  hexmask.long 0x00 0.--31. 1. " DFA     ,Data Fault Address"
group.long c15:0x0105++0x00
 line.long 0x00 "IFSR,Instruction Fault Status Register"
  bitfld.long 0x00 12. " SD      ,External Abort Qualifier" "DECERR,SLVERR"
  bitfld.long 0x00 0.--3. 10. "                  STATUS    ,Generated Exception Type" "Reserved,Alignment,Debug,Access/section,Instruction,Translation/section,Access/page,Translation/page,Nontranslation/synchronous external,Domain/section,Reserved,Domain/page,L1/external,Permission/section,L2/external,Permission/page,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Asynchronous external,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
group.long c15:0x0206++0x00
 line.long 0x00 "IFAR,Instruction Fault Address Register"
  hexmask.long 0x00 0.--31. 1. " IFA     ,Instruction Fault Address"
group.long c15:0x0015++0x00
 line.long 0x00 "DAFSR,Data Auxiliary Fault Status Register"
  hexmask.long 0x00 0.--31. 1. " DAFS    ,Data Auxiliary Fault Status"
group.long c15:0x0115++0x00
 line.long 0x00 "IAFSR,Instruction Auxiliary Fault Status Register"
  hexmask.long 0x00 0.--31. 1. " IAFS    ,Instruction Auxiliary Fault Status" 
 textline " "
 
group.long c15:0xa++0x0
  line.long 0x0 "TLBLR,TLB Lockdown Register"
  bitfld.long 0x0 28.--29. " VICTIM  ,Victim Value Increments after Each Tabel Walk" "0,1,2,3"
  bitfld.long 0x0 0. "                       P         ,Lockdown by Victim or Set Associative Region of TLB" "Associative,Lockdown"
  
group.long c15:0x525f++0x0
 line.long 0x00 "MTLBVAR,Main TLB VA Register"
  hexmask.long 0x00 12.--31. 1. " VPN     ,Virtual Page Number"
  bitfld.long 0x00 10. "                NS        ,Non-Secure bit" "Not secured,Secured"
  textline "                      "
  hexmask.long.word 0x00 0.--9. 1. " PROCESS ,Memory space identifier"
group.long c15:0x526f++0x0
 line.long 0x00 "MTLBPAR,Main TLB PA Register"
  hexmask.long 0x00 12.--31. 1. " PPN     ,Physical Page Number"
  bitfld.long 0x00 6.--7. "                SZ        ,Region Size" "16MB,4KB,64KB,1MB"
  textline "                      "
  bitfld.long 0x00 1.--3. " AP      ,Access permission" "All access,Supervisor access only,Supervisor R/W access,Full,Reserved,Supervisor read only,Supervisor/Usr read only,Supervisor/Usr read only"
  bitfld.long 0x00 0. "V         ,Value bit" "0,1"
group.long c15:0x527f++0x0
 line.long 0x00 "MTLBAR,Main TLB Attribute Register"
  bitfld.long 0x00 11. " NS      ,Non-secure description" "Not secured,Secured"
  bitfld.long 0x00 7.--10. "             DOMAIN    ,Domain number of the TLB entry" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
  textline "                      "
  bitfld.long 0x00 6. " XN      ,Execute Never attribute" "0,1"
  bitfld.long 0x00 3.--5. "                       TEX       ,Region type Encoding" "0,1,2,3,4,5,6,7"
  textline "                      "
  bitfld.long 0x00 1.--2. " CB      ,Region type Encoding" "0,1,2,3"
  bitfld.long 0x00 0. "                       S         ,Shared attribute" "0,1"
group.long c15:0x0047++0x00
 line.long 0x00 "PAR,PA Register"
  hexmask.long 0x00 12.--31. 0x1000 " PA      ,Physical Adress"
  bitfld.long 0x00 9. "                NS        ,Non-secure" "Not secured,Secured"
  textline "                      "
  bitfld.long 0x00 7. " SH      ,Shareable attribute" "Non-shareable,Shareable"
  bitfld.long 0x00 4.--6. "           Inner     ,Signals region inner attributes" "Noncacheable,Strongly-ordered,Reserved,Device,Reserved,Write-back allocate,Write-through,Write-back"
  textline "                      "
  bitfld.long 0x00 2.--3. " Outer   ,Signals region outer attributes for normal memory type" "Noncacheable,Write-back allocate,Write-through,Write-back"
  bitfld.long 0x00 1. "     SS        ,Supersection Enable bit" "Disabled,Enabled"
  textline "                      "
  bitfld.long 0x00 0. " F       ,Translation Successful" "Successful,No successful"
 textline " "

group.long c15:0x002A++0x0
 line.long 0x00 "PRRR,Primary Region Remap Register"
  bitfld.long 0x00 19. " NS1     ,Shareable Attribute Remap when S=1 for Normal Regions" "Remapped,Not remapped"
  bitfld.long 0x00 18. "            NS0       ,Shareable Attribute Remap when S=0 for Normal Regions" "Not remapped,Remapped"
  textline "                      "
  bitfld.long 0x00 17. " DS1     ,Shareable Attribute Remap when S=1 for Device regions" "Remapped,Not remapped"
  bitfld.long 0x00 16. "            DS0       ,Shareable Attribute Remap when S=0 for Device regions" "Not remapped,Remapped"
  textline "                      "
  bitfld.long 0x00 14.--15. " TR7     ,{TEX[0] C B} = b111 Remap" "Strongly ordered,Device,Normal,UNP"
  bitfld.long 0x00 12.--13. "        TR6       ,{TEX[0] C B} = b110 Remap" "Strongly ordered,Device,Normal,UNP"
  textline "                      "
  bitfld.long 0x00 10.--11. " TR5     ,{TEX[0] C B} = b101 Remap" "Strongly ordered,Device,Normal,UNP"
  bitfld.long 0x00 8.--9. "        TR4       ,{TEX[0] C B} = b100 Remap" "Strongly ordered,Device,Normal,UNP"
  textline "                      "
  bitfld.long 0x00 6.--7. " TR3     ,{TEX[0] C B} = b011 Remap" "Strongly ordered,Device,Normal,UNP"
  bitfld.long 0x00 4.--5. "        TR2       ,{TEX[0] C B} = b010 Remap" "Strongly ordered,Device,Normal,UNP"
  textline "                      "
  bitfld.long 0x00 2.--3. " TR1     ,{TEX[0] C B} = b001 Remap" "Strongly ordered,Device,Normal,UNP"
  bitfld.long 0x00 0.--1. "        TR0       ,{TEX[0] C B} = b000 Remap" "Strongly ordered,Device,Normal,UNP"
group.long c15:0x012A++0x0
 line.long 0x00 "NMRR,Normal Memory Remap Register"
  bitfld.long 0x00 30.--31. " OR7     ,Outer Attribute for {TEX[0] C B} = b111 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 28.--29. "  OR6       ,Outer Attribute for {TEX[0] C B} = b110 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 26.--27. " OR5     ,Outer Attribute for {TEX[0] C B} = b101 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 24.--25. "  OR4       ,Outer Attribute for {TEX[0] C B} = b100 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 22.--23. " OR3     ,Outer Attribute for {TEX[0] C B} = b011 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 20.--21. "  OR2       ,Outer Attribute for {TEX[0] C B} = b010 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 18.--19. " OR1     ,Outer Attribute for {TEX[0] C B} = b001 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 16.--17. "  OR0       ,Outer Attribute for {TEX[0] C B} = b000 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 14.--15. " IR7     ,Inner attribute for {TEX[0] C B} = b111 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 12.--13. "  IR6       ,Inner attribute for {TEX[0] C B} = b110 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 10.--11. " IR5     ,Inner attribute for {TEX[0] C B} = b101 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 8.--9. "  IR4       ,Inner attribute for {TEX[0] C B} = b100 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 6.--7. " IR3     ,Inner attribute for {TEX[0] C B} = b011 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 4.--5. "  IR2       ,Inner attribute for {TEX[0] C B} = b010 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  textline "                      "
  bitfld.long 0x00 2.--3. " IR1     ,Inner attribute for {TEX[0] C B} = b001 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
  bitfld.long 0x00 0.--1. "  IR0       ,Inner attribute for {TEX[0] C B} = b000 Remap" "Noncachable,Write-back allocate,Write-through,Write-back no allocate"
 textline " "

rgroup.long c15:0x000d++0x00
 line.long 0x00 "FCSEIDR,FCSE PID Register"
  hexmask.long 0x00 0.--31. 1. " FCSEPID ,Process for Fast Context Switch Identification and Specification"
group.long c15:0x10d++0x0
 line.long 0x0 "CONTEXTIDR,Context ID Register"
  hexmask.long.tbyte 0x0 8.--31. 1 " PROCID  ,Process ID"
  hexmask.long.byte 0x0 0.--7. 1 "                  ASID      ,Application Space ID"
group.long c15:0x020d++0x00
 line.long 0x00 "URWTPIDR,User Read/Write Thread and Process ID Register"
  hexmask.long 0x00 0.--31. 1. " URWTPID ,User Read/Write Thread and Process ID"
group.long c15:0x030d++0x00
 line.long 0x00 "UROTPIDR,User Read-Only Thread and Process ID Register"
  hexmask.long 0x00 0.--31. 1. " UROTPID ,User Read-Only Thread and Process ID"
group.long c15:0x040d++0x00
 line.long 0x00 "POTPIDR,Privileged Only Thread and Process ID Register"
  hexmask.long 0x00 0.--31. 1. " POTPID  ,Privileged Only Thread and Process ID"
tree.end

width 0xC
tree "Cache Control and Configuration"
rgroup.long c15:0x1100++0x0
 line.long 0x0 "CLIDR,Cache Level ID Register"
  bitfld.long 0x00 27.--29. " LOU     ,Level of Unification" "Level 1,Level 2,Level 3,Level 4,Level 5,Level 6,Level 7,Level 8"
  bitfld.long 0x00 24.--26. "                    LOC    ,Level of Coherency" "Level 1,Level 2,Level 3,Level 4,Level 5,Level 6,Level 7,Level 8"
  textline "                     "
  bitfld.long 0x00 21.--23. " CType8  ,Cache type for levels 8" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  bitfld.long 0x00 18.--20. "               CType7 ,Cache type for levels 7" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  textline "                     "
  bitfld.long 0x00 15.--17. " CType6  ,Cache type for levels 6" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  bitfld.long 0x00 12.--14. "               CType5 ,Cache type for levels 5" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  textline "                     "
  bitfld.long 0x00 9.--11. " CType4  ,Cache type for levels 4" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  bitfld.long 0x00 6.--8. "               CType3 ,Cache type for levels 3" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  textline "                     "
  bitfld.long 0x00 3.--5. " CType2  ,Cache type for levels 2" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
  bitfld.long 0x00 0.--2. "               CType1 ,Cache type for levels 1" "No cache,I-cache,D-cache,Separate I/D,Unified,Reserved,Reserved,Reserved"
rgroup.long c15:0x1700++0x0
 line.long 0x0 "AIDR,Auxiliary ID Register"
  hexmask.long 0x00 0.--31. 1. " AID     ,Auxiliary ID"
rgroup.long c15:0x1000++0x0
 line.long 0x0 "CCSIDR,Current Cache Size ID Register"
   bitfld.long 0x00 31. " WT      ,Write-Through" "Not Supported,Supported"
  bitfld.long 0x00 30. "              WB     ,Write-Back" "Not Supported,Supported"
  textline "                     "
  bitfld.long 0x00 29. " RA      ,Read-Allocate" "Not Supported,Supported"
  bitfld.long 0x00 28. "              WA     ,Write-Allocate" "Not Supported,Supported"
  textline "                     "
  hexmask.long.word 0x00 13.--27. 1.  " SETS    ,Number of Sets"
  hexmask.long.word 0x00 3.--12. 1.  "                       ASSOC  ,Associativity"
  textline "                     "
  bitfld.long 0x00 0.--2. " LSIZE   ,Line Size" "4 words,8 words,16 words,32 words,64 words,128 words,256 words,512 words"
group.long c15:0x2000++0x0
 line.long 0x0 "CSSELR,Cache Size Selection Register"
  bitfld.long 0x00 1.--3. " LEVEL   ,Level" "Level 1,Level 2,Level 3,Level 4,Level 5,Level 6,Level 7,Level 8"
  bitfld.long 0x00 0. "                    IND    ,Instruction/Not Data" "Data,Instruction"
tree.end

width 0x8

tree "L2 Preload Engine"
 rgroup c15:0x000b++0x00
  line.long 0x00 "PLEIDR,PLE Identification Register 0"
   bitfld.long 0x00 0. " CH0P ,Channel 0 Present" "Not present,Present"
 rgroup c15:0x020b++0x00
  line.long 0x00 "PLESR,PLE Status Register"
   bitfld.long 0x00 0. " CH0R ,Channel 0 Run" "Not running,Running"
 rgroup c15:0x040b++0x00
  line.long 0x00 "PLEFSR,PLE FIFO Status Register"
 group c15:0x001b++0x00
  line.long 0x00 "PLEUAR,PLE User Accessibility Register"
   bitfld.long 0x00 0. " U0  ,User Mode Process Access Registers for Channel 0 Permission" "Not permitted,Permitted"
 group c15:0x011b++0x00
  line.long 0x00 "PLEPCR,PLE Parameters Control Register"
tree.end

width 12.
tree "System Performance Monitor"
group.long c15:0xC9++0x0
 line.long 0x0 "PMCR,Performance Monitor Control Register"
  hexmask.long.byte 0x00 24.--31. 1. " IMP  ,Implementer code"
  hexmask.long.byte 0x00 16.--23. 1. "           IDCODE ,Identification code"
  bitfld.long 0x00 11.--15. "           N  ,Number of counters implemented" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
  bitfld.long 0x00 5. "           DP ,Disable CCNT when prohibited" "Enabled,Disabled"
  textline "                     "
  bitfld.long 0x00 4. " X    ,Export Enabled" "Disabled,Enabled"
  bitfld.long 0x00 3. "     D      ,Clock Divider" "Every cycle,64th cycle"
  bitfld.long 0x00 2. "  C  ,Clock Counter Reset" "No action,Reset"
  bitfld.long 0x00 1. "    P  ,Performance Counter Reset" "No action,Reset"
  textline "                     "
  bitfld.long 0x00 0. " E    ,Counters Enable" "Disabled,Enabled"
group.long c15:0x1C9++0x0
 line.long 0x0 "PMCNTENSET,Count Enable Set Register"
  bitfld.long 0x00 31. " C    ,CCNT Enabled" "Disabled,Enabled"
  bitfld.long 0x00  5. "     P5     ,PMN5 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  4. "     P4 ,PMN5 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  3. "     P3 ,PMN3 Enabled" "Disabled,Enabled"
  textline "                     "
  bitfld.long 0x00  2. " P2   ,PMN2 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  1. "     P1     ,PMN1 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  0. "     P0 ,PMN0 Enabled" "Disabled,Enabled"
group.long c15:0x2C9++0x0
 line.long 0x0 "PMCNTENCLR,Count Enable Clear Register"
  bitfld.long 0x00 31. " C    ,CCNT Enabled" "Disabled,Enabled"
  bitfld.long 0x00  5. "     P5     ,PMN5 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  4. "     P4 ,PMN5 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  3. "     P3 ,PMN3 Enabled" "Disabled,Enabled"
  textline "                     "
  bitfld.long 0x00  2. " P2   ,PMN2 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  1. "     P1     ,PMN1 Enabled" "Disabled,Enabled"
  bitfld.long 0x00  0. "     P0 ,PMN0 Enabled" "Disabled,Enabled"
group.long c15:0x3C9++0x0
 line.long 0x0 "PMOVSR,Overflow Flag Status Register"
  eventfld.long 0x00 31. " C    ,CCNT overflowed" "No overflow,Overflow"
  eventfld.long 0x00  5. "  P5     ,PMN5 overflow" "No overflow,Overflow"
  eventfld.long 0x00  4. "  P4 ,PMN5 overflow" "No overflow,Overflow"
  eventfld.long 0x00  3. "  P3 ,PMN3 overflow" "No overflow,Overflow"
  textline "                     "
  eventfld.long 0x00  2. " P2   ,PMN2 overflow" "No overflow,Overflow"
  eventfld.long 0x00  1. "  P1     ,PMN1 overflow" "No overflow,Overflow"
  eventfld.long 0x00  0. "  P0 ,PMN0 overflow" "No overflow,Overflow"
wgroup.long c15:0x4C9++0x0
 line.long 0x0 "PMSWINC,Software Increment Register"
  eventfld.long 0x00  5. " P5   ,Increment  PMN2" "No action,Increment"
  eventfld.long 0x00  4. "    P4     ,Increment  PMN1" "No action,Increment"
  eventfld.long 0x00  3. "    P3 ,Increment  PMN3" "No action,Increment"
  eventfld.long 0x00  2. "    P2 ,Increment  PMN2" "No action,Increment"
  textline "                     "
  eventfld.long 0x00  1. " P1   ,Increment  PMN1" "No action,Increment"
  eventfld.long 0x00  0. "    P0     ,Increment  PMN0" "No action,Increment"
group.long c15:0x5C9++0x0
 line.long 0x0 "PMSELR,Performance Counter Selection Register"
  bitfld.long 0x00 0.--5. " SEL  ,Selection value" "CNT0,CNT1,CNT2,CNT3,CNT4,CNT5,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
group.long c15:0xD9++0x0
 line.long 0x00 "PMCCNTR,Cycle Count Register"
  hexmask.long 0x00 0.--31. 1. " CCNT ,Cycle Count"
group.long c15:0x01d9++0x00
 line.long 0x00 "PMXEVTYPER,Event Selection Register"
  hexmask.long.byte 0x00 0.--7. 1. " SEL  ,Event Selection"
group.long c15:0x02d9++0x00
 line.long 0x00 "PMCNT,Performance Monitor Count Register"
  hexmask.long 0x00 0.--31. 1. " PMC  ,Performance Monitor Count"
group.long c15:0xE9++0x0
 line.long 0x0 "PMUSERENR,User Enable Register"
  bitfld.long 0x00  0. " EN   ,User Mode Enable" "Disabled,Enabled"
group.long c15:0x1E9++0x0
 line.long 0x0 "PMINTENSET,Interrupt Enable Set Register"
  bitfld.long 0x00 31. " C    ,CCNT Overflow Interrupt Enable" "Disabled,Enabled"
  bitfld.long 0x00  5. "     P5     ,PMCNT5 Overflow Interrupt Enable" "Disabled,Enabled"
  bitfld.long 0x00  4. "     P4 ,PMCNT4 Overflow Interrupt Enable" "Disabled,Enabled"
  bitfld.long 0x00  3. "     P3 ,PMCNT3 Overflow Interrupt Enable" "Disabled,Enabled"
  textline "                     "
  bitfld.long 0x00  2. " P2   ,PMCNT2 Overflow Interrupt Enable" "Disabled,Enabled"
  bitfld.long 0x00  1. "     P1     ,PMCNT1 Overflow Interrupt Enable" "Disabled,Enabled"
  bitfld.long 0x00  0. "     P0 ,PMCNT0 Overflow Interrupt Enable" "Disabled,Enabled"
group.long c15:0x2E9++0x0
 line.long 0x0 "PMINTENCLR,Interrupt Enable Clear Register"
  eventfld.long 0x00 31. " C    ,CCNT Overflow Interrupt Enable" "Disabled,Enabled"
  eventfld.long 0x00  5. "     P5     ,PMCNT5 Overflow Interrupt Enable" "Disabled,Enabled"
  eventfld.long 0x00  4. "     P4 ,PMCNT4 Overflow Interrupt Enable" "Disabled,Enabled"
  eventfld.long 0x00  3. "     P3 ,PMCNT3 Overflow Interrupt Enable" "Disabled,Enabled"
  textline "                     "
  eventfld.long 0x00  2. " P2   ,PMCNT2 Overflow Interrupt Enable" "Disabled,Enabled"
  eventfld.long 0x00  1. "     P1     ,PMCNT1 Overflow Interrupt Enable" "Disabled,Enabled"
  eventfld.long 0x00  0. "     P0 ,PMCNT0 Overflow Interrupt Enable" "Disabled,Enabled"
tree.end
width 0xb
width 8.

tree "Debug Registers"
 width 11.
 tree "Processor Identifier Registers"
    rgroup c14:0x340--0x340
     line.long 0x00 "CPUID,Main ID Register"
       hexmask.long.byte 0x0 24.--31. 0x1 " IMPL       ,Implementer code"
       hexmask.long.byte 0x0 20.--23. 0x1 "             SPECREV    ,Variant number"
       textline "                    "
       hexmask.long.byte 0x0 16.--19. 0x1 " ARCH       , Architecture"
       hexmask.long.word 0x0 4.--15. 0x1 "             PARTNUM    ,Part Number"
       textline "                    "
       hexmask.long.byte 0x0 0.--3. 0x1 " REV        ,Layout Revision"
    rgroup c14:0x341--0x341
     line.long 0x00 "CACHETYPE,Cache Type Register"
     bitfld.long 0x0 29.--31. " FORMAT     ,Format" "Not ARMv7,Not ARMv7,Not ARMv7,Not ARMv7,ARMv7,Not ARMv7,Not ARMv7,Not ARMv7"
     bitfld.long 0x0 24.--27. "      CWG        ,Cache Writeback Granule" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
     textline "                    "
     bitfld.long 0x0 20.--23. " ERG        ,Exclusives Reservation Granule" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
     bitfld.long 0x00 16.--19. "             DMinLine   ,Words of Smallest Line Length in L1 or L2 Data Cache Number" "Reserved,Reserved,Reserved,Reserved,16x32-bit words,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 14.--15. " L1_Ipolicy ,VIPT Instruction Cache Support" "Reserved,Reserved,Supported,Reserved"
     bitfld.long 0x00 0.--3. "      IMinLine   ,Words of Smallest Line Length in L1 or L2 Instruction Cache Number" "Reserved,Reserved,Reserved,Reserved,16x32-bit words,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    rgroup c14:0x343--0x343
     line.long 0x00 "TLBTYPE,TLB Type Register"
      hexmask.long.byte 0x0 16.--23. 0x1 " ILsize     ,Specifies the number of instruction TLB lockable entries"
      hexmask.long.byte 0x0 8.--15. 0x1 "             DLsize     ,Specifies the number of unified or data TLB lockable entries"
       textline "                    "
      bitfld.long 0x0 1. " TLB_size   ,TLB Size" "64,128"
      bitfld.long 0x0 0. "            U          ,Unified or separate instruction TLBs" "Unified,Separate"
    rgroup c14:0x348--0x348
     line.long 0x00 "ID_PFR0,Processor Feature Register 0"
     bitfld.long 0x00 12.--15. " State3     ,Thumb-2 Execution Environment (Thumb-2EE) Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "      State2     ,Java Extension Interface Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " State1     ,Thumb Encoding Supported by the Processor Type" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      State0     ,ARM Instruction Set Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    rgroup c14:0x349--0x349
     line.long 0x00 "ID_PFR1,Processor Feature Register 1"
     bitfld.long 0x00 8.--11. " MPM        ,Microcontroller Programmer's Model Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 4.--7. "  SE         ,Security Extensions Architecture v1 Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 0.--3. " PM         ,Standard ARMv4 Programmer's Model Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    rgroup c14:0x34a--0x34a
     line.long 0x00 "ID_DFR0,Debug Feature Register 0"
     bitfld.long 0x00 20.--23. " MDM_MM     ,Microcontroller Debug Model Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "  TDM_MM     ,Trace Debug Model (Memory-Mapped) Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " TDM_CB     ,Coprocessor-Based Trace Debug Model Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "  CDM_MM     ,Memory-Mapped Debug Model Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " SDM_CB     ,Secure Debug Model (Coprocessor) Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      CDM_CB     ,Coprocessor Debug Model Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    rgroup c14:0x34b--0x34b
     line.long 0x00 "ID_AFR0,Auxiliary Feature Register 0"
     hexmask.long 0x00 0.--31. 1. " AF         ,Auxiliary Feature"
    rgroup c14:0x34c--0x34c
     line.long 0x00 "ID_MMFR0,Processor Feature Register 0"
     bitfld.long 0x00 24.--27. " FCSE       ,Fast Context Switch Memory Mappings Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 20.--23. "  ACR        ,Auxiliary Control Register Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 16.--19. " TCM        ,TCM and Associated DMA Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 12.--15. "  OSS        ,Outer Shareable Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 8.--11. " CC_CPUA    ,Cache Coherency Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 4.--7. "      PMSA       ,Physical Memory System Architecture (PMSA) Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 0.--3. " VMSA       ,Virtual Memory System Architecture (VMSA) Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"   
    rgroup c14:0x34d--0x34d
     line.long 0x00 "ID_MMFR1,Processor Feature Register 1"
     bitfld.long 0x00 28.--31. " BTB        ,Branch Predictor" "Reserved,Reserved,Required,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 24.--27. "       L1TCO      ,Test and Clean Operations on Data Cache/Harvard/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 20.--23. " L1UCMO     ,L1 Cache/All Maintenance Operations/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "  L1HCMO     ,L1 Cache/All Maintenance Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " L1UCLMOSW  ,L1 Cache Line Maintenance Operations by Set and Way/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "  L1HCLMOSW  ,L1 Cache Line Maintenance Operations by Set and Way/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " L1UCLMOMVA ,L1 Cache Line Maintenance Operations by VA/Unified Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "  L1HCLMOMVA ,L1 Cache Line Maintenance Operations by VA/Harvard Architecture" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved" 
    rgroup c14:0x34e--0x34e
     line.long 0x00 "ID_MMFR2,Processor Feature Register 2"
     bitfld.long 0x00 28.--31. " HAF        ,Hardware Access Flag Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 24.--27. "  WFI        ,Wait for Interrupt Stalling Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 20.--23. " MBF        ,Memory Barrier Operations Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "      UTLBMO     ,TLB Maintenance Operations/Unified Architecture Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " HTLBMO     ,TLB Maintenance Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "  HL1CMRO    ,Cache Maintenance Range Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " HL1BPCRO   ,Background Prefetch Cache Range Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "  HL1FPCRO   ,Foreground Prefetch Cache Range Operations/Harvard Architecture Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    rgroup c14:0x34f--0x34f
     line.long 0x00 "ID_MMFR3,Processor Feature Register 3"
     bitfld.long 0x00 28.--31. " SS         ,Supersection support" "Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 20.--23. "      CW         ,Coherent walk" "Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " MB         ,Invalidate broadcast Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "      BPM        ,Invalidate Branch predictor Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " HCMOSW     ,Invalidate Cache by Set and Way/Clean by Set and Way/Invalidate and Clean by Set and Way Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      HCMOMVA    ,Invalidate Cache MVA Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"    
    rgroup c14:0x350--0x350
     line.long 0x00 "ID_ISAR0,ISA Feature Register 0"
     bitfld.long 0x00 24.--27. " DIVI       ,Divide Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 20.--23. "  DEBI       ,Debug Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 16.--19. " CI         ,Coprocessor Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 12.--15. "  CBI        ,Combined Compare and Branch Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 8.--11. " BI         ,Bitfield Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 4.--7. "      BCI        ,Bit Counting Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 0.--3. " SI         ,Swap Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"   
    rgroup c14:0x351--0x351
     line.long 0x00 "ID_ISAR1,ISA Feature Register 1"
     bitfld.long 0x00 28.--31. " JI         ,Jazelle Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 24.--27. "      INTI       ,Interwork Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 20.--23. " IMMI       ,Immediate Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "      ITEI       ,If Then Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " EXTI       ,Extend Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "      E2I        ,Exception 2 Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " E1I        ,Exception 1 Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      ENDI       ,Endian Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"   
    rgroup c14:0x352--0x352
     line.long 0x00 "ID_ISAR2,ISA Feature Register 2"
     bitfld.long 0x00 28.--31. " RI         ,Reversal Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 24.--27. "      PSRI       ,PSR Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 20.--23. " UMI        ,Advanced Unsigned Multiply Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "      SMI        ,Advanced Signed Multiply Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " MI         ,Multiply Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "      II         ,Multi-Access Interruptible Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " MHI        ,Memory Hint Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      LSI        ,Load and Store Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
    rgroup c14:0x353--0x353
     line.long 0x00 "ID_ISAR3,ISA Feature Register 3"
     bitfld.long 0x00 28.--31. " T2E        ,Thumb-2 Extensions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 24.--27. "      NOPI       ,True NOP Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 20.--23. " TCI        ,Thumb Copy Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "      TBI        ,Table Branch Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " SPI        ,Synchronization Primitive Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "      SVCI       ,SVC Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " SIMDI      ,Single Instruction Multiple Data (SIMD) Instructions Support" "Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      SI         ,Saturate Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"    
    rgroup c14:0x354--0x354
     line.long 0x00 "ID_ISAR4,ISA Feature Register 4"
     bitfld.long 0x00 28.--31. " SWP_frac   ,SWAP_frac" "Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 24.--27. "      PSR_M_I    ,PSR_M Instructions Support" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 20.--23. " SPRI       ,Synchronization Primitive instructions" "Not supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 16.--19. "  BI         ,Barrier Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 12.--15. " SMCI       ,SMC Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 8.--11. "      WBI        ,Write-Back Instructions Support" "Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     textline "                    "
     bitfld.long 0x00 4.--7. " WSI        ,With-Shift Instructions Support" "Reserved,Reserved,Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
     bitfld.long 0x00 0.--3. "      UI         ,Unprivileged Instructions Support" "Reserved,Reserved,Supported,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"     
    rgroup c14:0x355--0x355
     line.long 0x00 "ID_ISAR5,ISA Feature Register 5 (Reserrved)"
 tree.end

tree "Coresight Management Registers"
 width 0xC

 textline "                     "

 group c14:0x03bd++0x00
  line.long 0x00 "ITCTRL_IOC,Integration Internal Output Control Register"
   bitfld.long 0x00 5. " I_DBGTRIGGER    ,Internal DBGTRIGGER" "0,1"
   bitfld.long 0x00 4. "                I_DBGRESTARTED  ,Internal DBGRESTARTED" "0,1"
     textline "                     "
   bitfld.long 0x00 3. " I_nPMUIRQ       ,Internal nPMUIRQ" "0,1"
   bitfld.long 0x00 2. "                InternalCOMMTX  ,Internal COMMTX" "0,1"
     textline "                     "
   bitfld.long 0x00 1. " I_COMMRX        ,Internal COMMRX" "0,1"
   bitfld.long 0x00 0. "                I_DBGACK        ,Internal DBGACK" "0,1"
 group c14:0x03be++0x00
  line.long 0x00 "ITCTRL_EOC,Integration External Output Control Register"
   bitfld.long 0x00 7. " nDMAEXTERRIQ    ,External nDMAEXTERRIRQ" "0,1"
   bitfld.long 0x00 6. "                nDMASIRQ        ,External nDMASIRQ" "0,1"
   textline "                     "
   bitfld.long 0x00 5. " nDMAIRQ         ,External nDMAIRQ" "0,1"
   bitfld.long 0x00 4. "                nPMUIRQ         ,External nPMUIRQ" "0,1"
   textline "                     "
   bitfld.long 0x00 3. " STANDBYWFI      ,External STANDBYWFI" "0,1"
   bitfld.long 0x00 2. "                COMMTX          ,External COMMTX" "0,1"
   textline "                     "
   bitfld.long 0x00 1. " COMMRX          ,External COMMRX" "0,1"
   bitfld.long 0x00 0. "                DBGACK          ,External DBGACK" "0,1"
 rgroup c14:0x03bf++0x00
  line.long 0x00 "ITCTRL_IS,Integration Input Status Register"
   bitfld.long 0x00 11. " CTI_DBGRESTART  ,CTI Debug Restart" "0,1"
   bitfld.long 0x00 10. "                CTI_EDBGRQ      ,CTI Debug Request" "0,1"
   textline "                     "
   bitfld.long 0x00 9. " CTI_PMUEXTIN[1] ,CTI PMUEXTIN[1] Signal" "0,1"
   bitfld.long 0x00 8. "                CTI_PMUEXTIN[0] ,CTI PMUEXTIN[0] Signal" "0,1"
   textline "                     "
   bitfld.long 0x00 2. " nFIQ            ,nFIQ Input" "0,1"
   bitfld.long 0x00 1. "                nIRQ            ,nIRQ Input" "0,1"
   textline "                     "
   bitfld.long 0x00 0. " EDBGRQ          ,EDBGRQ Input" "0,1"
 group c14:0x3c0--0x3c0
  line.long 0x0 "ITCTRL,Integration Mode Control Register"
   bitfld.long 0x0 0. " IME             ,Integration Mode Enable" "Disabled,Enabled"
 group c14:0x3e8--0x3e8
  line.long 0x0 "CLAIMSET,Claim Tag Set Register"
   bitfld.long 0x0 7. " CT7             ,Claim Tag 7" "No Effect,Set"
   bitfld.long 0x0 6. "        CT6             ,Claim Tag 6" "No Effect,Set"
   textline "                     "
   bitfld.long 0x0 5. " CT5             ,Claim Tag 5" "No Effect,Set"
   bitfld.long 0x0 4. "        CT4             ,Claim Tag 4" "No Effect,Set"
   textline "                     "
   bitfld.long 0x0 3. " CT3             ,Claim Tag 3" "No Effect,Set"
   bitfld.long 0x0 2. "        CT2             ,Claim Tag 2" "No Effect,Set"
   textline "                     "
   bitfld.long 0x0 1. " CT1             ,Claim Tag 1" "No Effect,Set"
   bitfld.long 0x0 0. "        CT0             ,Claim Tag 0" "No Effect,Set"
 group c14:0x3e9--0x3e9
  line.long 0x0 "CLAIMCLR,Claim Tag Clear Register"
   bitfld.long 0x0 7. " CT7             ,Claim Tag 7" "No Effect,Cleared"
   bitfld.long 0x0 6. "        CT6             ,Claim Tag 6" "No Effect,Cleared"
   textline "                     "
   bitfld.long 0x0 5. " CT5             ,Claim Tag 5" "No Effect,Cleared"
   bitfld.long 0x0 4. "        CT4             ,Claim Tag 4" "No Effect,Cleared"
   textline "                     "
   bitfld.long 0x0 3. " CT3             ,Claim Tag 3" "No Effect,Cleared"
   bitfld.long 0x0 2. "        CT2             ,Claim Tag 2" "No Effect,Cleared"
   textline "                     "
   bitfld.long 0x0 1. " CT1             ,Claim Tag 1" "No Effect,Cleared"
   bitfld.long 0x0 0. "        CT0             ,Claim Tag 0" "No Effect,Cleared"
 wgroup c14:0x3ec--0x3ec
  line.long 0x0 "LAR,Lock Access Register"
   hexmask.long.long 0x0 0.--31. 1 " LACK            ,Lock Access Control Key"
 rgroup c14:0x3ed--0x3ed 
  line.long 0x0 "LSR,Lock Status Register"
   bitfld.long 0x0 2. " 32ACND          ,32-bit Access Needed" "Needed,Not needed"
   bitfld.long 0x0 1. "       WLCK            ,Writes Lock" "Permitted,Ignored"
   textline "                     "
   bitfld.long 0x0 0. " LI              ,Lock Implementation" "Lock ignored,Unlock required"
width 0xc
 rgroup c14:0x3ee--0x3ee
  line.long 0x0 "AUTHSTATUS,Authentication Status Register"
   bitfld.long 0x0 7. " SNIDFI  ,Secure Non-invasive Debug Features Implemented" "Not Implemented,Implemented"
   bitfld.long 0x0 6. "  SNIDE  ,Secure Non-invasive Debug Enable" "Disabled,Enabled"
   textline "                     "
   bitfld.long 0x0 5. " SIDFI   ,Secure Invasive Debug Feauter Implemented" "Not Implemented,Implemented"
   bitfld.long 0x0 4. "  SIDE   ,Secure Invasive Debug Enable" "Disabled,Enabled"
   textline "                     "
   bitfld.long 0x0 3. " NSNIDFI ,Non-secure Non-invasive Debug Feature Implemented" "Not Implemented,Implemented"
   bitfld.long 0x0 2. "  NSNIDE ,Non-secure Non-invasive Debug Enable" "Disabled,Enabled"
   textline "                     "
   bitfld.long 0x0 1. " NSIDFI  ,Non-secure Invasive Debug Implemented" "Not Implemented,Implemented"
   bitfld.long 0x0 0. "  NSIDE  ,Non-secure Invasive Debug Enable" "Disabled,Enabled"
width 0xc
 hgroup c14:0x3f2--0x3f2
  hide.long 0x0 "DEVID,Device Identifier (RESERVED)"
 rgroup c14:0x3f3--0x3f3
  line.long 0x0 "DEVTYPE,Device Type"
   hexmask.long.byte 0x0 4.--7. 1 " STPC   ,Sub Type: Processor Core"
   hexmask.long.byte 0x0 0.--3. 1 "     MCDL   ,Main Class: Debug Logic"

   rgroup c14:0x3f8--0x3f8
    line.long 0x0 "PID0,Peripherial ID0"
     hexmask.long.byte 0x0 0.--7. 1 " PN     ,Part Number [7:0]"
   rgroup c14:0x3f9--0x3f9  
    line.long 0x0 "PID1,Peripherial ID1"
     hexmask.long.byte 0x0 4.--7. 1 " JEP106 ,JEP106 Identity Code [3:0]"
     hexmask.long.byte 0x0 0.--3. 1 "     PN     ,Part Number [11:8]"
   rgroup c14:0x3fa--0x3fa
    line.long 0x0 "PID2,Peripherial ID2"
     hexmask.long.byte 0x0 4.--7. 1 " REV    ,Revision"
     hexmask.long.byte 0x0 0.--2. 1 "     JEP106 ,JEP106 Identity Code [6:4]"
   rgroup c14:0x3fb--0x3fb
    line.long 0x0 "PID3,Peripherial ID3"
     hexmask.long.byte 0x0 4.--7. 1 " REVA   ,RevAnd"
     hexmask.long.byte 0x0 0.--3. 1 "     CMOD   ,Customer Modified"
   rgroup c14:0x3f4--0x3f4
    line.long 0x0 "PID4,Peripherial ID4"
     bitfld.long 0x0 4.--7. " 4KBC   ,Number of 4KB Blocks Occupied" "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
     bitfld.long 0x0 0.--3. "  JEP106 ,JEP106 Continuation Code" "0000,0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111"
   rgroup c14:0x3fc--0x3fc
    line.long 0x0 "COMPONENTID0,Component ID0"
     hexmask.long.byte 0x0 0.--7. 1 " PRBL   ,Preamble"
   rgroup c14:0x3fd--0x3fd
    line.long 0x0 "COMPONENTID1,Component ID1"
     hexmask.long.byte 0x0 4.--7. 1 " CCLASS ,Component Class (CoreSight Component)"
     hexmask.long.byte 0x0 0.--3. 1 "     PRBL   ,Preamble"
   rgroup c14:0x3fe--0x3fe
    line.long 0x0 "COMPONENTID2,Component ID2"
     hexmask.long.byte 0x0 0.--7. 1 " PRBL   ,Preamble"
   rgroup c14:0x3ff--0x3ff
    line.long 0x0 "COMPONENTID3,Component ID3"
     hexmask.long.byte 0x0 0.--7. 1 " PRBL   ,Preamble"
tree.end

textline "                     "
width 0x7

rgroup c14:0x000--0x000
 line.long 0x0 "DIDR,Debug ID Register"
  bitfld.long 0x0 28.--31. " WRP      ,Number of Watchpoint Register Pairs" "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16"
  bitfld.long 0x0 24.--27. "               BRP      ,Number of Breakpoint Register Pairs" "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16"
  bitfld.long 0x0 20.--23. "         Context ,Number of BRPs with Context ID Comparison Capability" "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16"
 textline "                "
  bitfld.long 0x0 16.--19. " Version  ,Debug Architecture Version" "Reserved,ARMv6,ARMv6.1,ARMv7,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
 textline "                "
  bitfld.long 0x0 13. " PCSAMPLE ,PC Sample register implemented" "Not implemented,Implemented"
  bitfld.long 0x0 12. "  Security ,Security Extensions implemented" "Not implemented,Implemented"
 textline "                "
  bitfld.long 0x0 4.--7. " Variant  ,Implementation-defined Variant Number" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
  bitfld.long 0x0 0.--3. "               Revision ,Implementation-defined Revision Number" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

width 0x7
group c14:0x22--0x22
 line.long 0x0 "DSCR,Debug Status and Control Register"
  bitfld.long 0x0 30. " DTRRXfull   ,The DTRRX Full Flag" "Empty,Full"
  bitfld.long 0x0 29. "                 DTRTXfull   ,The DTRTX Full Flag" "Empty,Full"
 textline "                "
 bitfld.long 0x00 27. " DTRRXfull_l ,The DTRRX Full Flag 1" "Empty,Full"
 bitfld.long 0x00 26. "                 DTRTXfull_l ,The DTRTX Full Flag 1" "Empty,Full"
 textline "                "
  bitfld.long 0x0 25. " SPA         ,Sticky Pipeline Advance" "No effect,Instruction retired"
  bitfld.long 0x0 24. "   IC          ,Instruction Complete" "Executing,Not executing"
 textline "                "
  bitfld.long 0x0 20.--21. " DTR         ,DTR Access Mode" "Non-blocking,Stall,Fast,Reserved"
  bitfld.long 0x0 19. "          NSWS        ,Imprecise Data Aborts discarded" "Not discarded,Discarded"
 textline "                "
 bitfld.long 0x0 18. " NS          ,Non-secure World Status" "Secured,Not secured"
  bitfld.long 0x0 17. "           nSPNIDEN    ,Secure Non-invasive Debug Disabled" "Enabled,Disabled"
 textline "                "
  bitfld.long 0x0 16. " nSPIDEN     ,Secure Invasive Debug Disabled" "Enabled,Disabled"
  bitfld.long 0x0 15. "              MONITOR     ,Monitor Debug-mode enable" "Disabled,Enabled"
   textline "                "
  bitfld.long 0x0 14. " HDEn        ,Halting Debug-mode enable" "Disabled,Enabled"
  bitfld.long 0x0 13. "              EXECUTE     ,Execute instruction enable" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 12. " COMMS       ,User mode access to Comms Channel disable" "Enabled,Disabled"
  bitfld.long 0x0 11. "              IntDis      ,Disable Interrupts" "Enabled,Disabled"
 textline "                "
  bitfld.long 0x0 10. " DbgAck      ,Force Debug Acknowledge" "Not forced,Forced"
  bitfld.long 0x0 8. "            uExt        ,Sticky Undefined Exception" "No exception,Exception"
 textline "                "
  bitfld.long 0x0 7. " IABORT      ,Sticky Imprecise Abort" "Not aborted,Aborted"
  bitfld.long 0x0 6. "           PABORT      ,Sticky Precise Abort" "Not aborted,Aborted"
 textline "                "
  bitfld.long 0x0 2.--5. " MOE         ,Method of Debug Entry" "Debug Entry,Breakpoint,Imprecise Watchpoint,BKPT instruction,External debug,Vector catch,Reserved,Reserved,OS Unlock,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved,Reserved"
  bitfld.long 0x0 1. "  RESTARTED   ,Core Restarted" "Debug not exited,Debug exited"
 textline "                "
  bitfld.long 0x0 0. " HALTED      ,Core Halted" "Normal state,Debug state"
width 0x7
if (((data.long(c14:0x00))&0x01000)==0x00000)
group c14:0x007--0x007
 line.long 0x0 "VCR,Vector Catch Register"
  bitfld.long 0x0 7. " FIQ     ,Vector Catch Enable FIQ" "Disabled,Enabled"
  bitfld.long 0x0 6. "  IRQ     ,Vector Catch Enable IRQ" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 4. " DABORT  ,Vector Catch Enable Data Abort" "Disabled,Enabled"
  bitfld.long 0x0 3. "  PABORT  ,Vector Catch Enable Prefetch Abort" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 2. " SWI     ,Vector Catch Enable SWI" "Disabled,Enabled"
  bitfld.long 0x0 1. "  UNDEF   ,Vector Catch Enable Undefined Instruction" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 0. " RESET   ,Vector Catch Enable Reset" "Disabled,Enabled"
else
group c14:0x007--0x007
 line.long 0x0 "VCR,Vector Catch Register"
  bitfld.long 0x0 31. " FIQN    ,Vector Catch Enable FIQ (Non-secure)" "Disabled,Enabled"
  bitfld.long 0x0 30. "  IRQN    ,Vector Catch Enable IRQ (Non-secure)" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 28. " DABORTN ,Vector Catch Enable Data Abort (Non-secure)" "Disabled,Enabled"
  bitfld.long 0x0 27. "  PABORTN ,Vector Catch Enable Prefetch abort (Non-secure)" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 26. " SWIN    ,Vector Catch Enable SWI (Non-secure)" "Disabled,Enabled"
  bitfld.long 0x0 25. "  UNDEFS  ,Vector Catch Enable Undefined (Non-secure)" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 15. " FIQS    ,Vector Catch Enable FIQ (Secure)" "Disabled,Enabled"
  bitfld.long 0x0 14. "  IRQS    ,Vector Catch Enable IRQ (Secure)" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 12. " DABORTS ,Vector Catch Enable Data Abort (Secure)" "Disabled,Enabled"
 bitfld.long 0x00 11. "  PABORTS ,Vector Catch Enable Prefetch abort (Secure)" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 10. " SMI     ,Vector Catch Enable SMI (Secure)" "Disabled,Enabled"
  bitfld.long 0x0 7. "  FIQ     ,Vector Catch Enable FIQ" "Disabled,Enabled"
  textline "                "
  bitfld.long 0x0 6. " IRQ     ,Vector Catch Enable IRQ" "Disabled,Enabled"
  bitfld.long 0x0 4. "  DABORT0 ,Vector Catch Enable Data Abort" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 3. " PABORT  ,Vector Catch Enable Prefetch Abort" "Disabled,Enabled"
  bitfld.long 0x0 2. "  SWI     ,Vector Catch Enable SWI" "Disabled,Enabled"
 textline "                "
  bitfld.long 0x0 1. " UNDEF   ,Vector Catch Enable Undefined Instruction" "Disabled,Enabled"
  bitfld.long 0x0 0. "  RESET   ,Vector Catch Enable Reset" "Disabled,Enabled"
endif

;rgroup c14:0x1++0x1
; line.long 0x0 "DRAR,Debug ROM Address Register"
;  hexmask.long 0x0 12.--31. 0x1000 " DBROMPA ,Debug bus ROM physical address"
;  bitfld.long 0x0 0.--1. "  VB      ,Valid bits" "Not valid,Reserved,Reserved,Valid"
; line.long 0x4 "DSAR,Debug Self Address Offset Register"
;  hexmask.long 0x4 12.--31. 0x1000 " DBSAOV  ,Debug bus self-address offset value"
;  bitfld.long 0x4 0.--1. "  VB      ,Valid bits" "Not valid,Reserved,Reserved,Valid"
;hgroup c14:0x50++0x0
; hide.long 0x0 "DTR,Data Transfer Register"
;  in
width 0x7
hgroup c14:0x020--0x020
 hide.long 0x0 "DTRRX,Target -> Host Data Transfer Register"
  in
group c14:0x023--0x023
 line.long 0x0 "DTRTX,Host -> Target Data Transfer Register"
 hexmask.long 0x00 0.--31. 1 " HTD   ,Host -> target data"
group c14:0x09++0x00
 line.long 0x00 "ECR,Event Catch Register"
  bitfld.long 0x00 0. " OSUC  ,OS Unlock Catch" "Disabled,Enabled"
group c14:0x0a++0x00
 line.long 0x00 "DSCCR,Debug State Cache Control Register"
  bitfld.long 0x00 2. " NWT   ,Not Write-Through" "Forced,Normal"
  bitfld.long 0x00 0. "            DUCL ,Data and Unified Cache Linefill" "Disabled,Normal"
wgroup c14:0x21++0x00
 line.long 0x00 "ITR,Instruction Transfer Register"
  hexmask.long 0x00 0.--31. 1. " Data  ,ARM Instruction for the Processor in Debug State Execute"
wgroup c14:0x24++0x00
 line.long 0x00 "DRCR,Debug Run Control Register"
  bitfld.long 0x00 3. " CSPA  ,Clear Sticky Pipeline Advance" "Not cleared,Cleared"
  bitfld.long 0x00 2. "       CSE  ,Clear Sticky Exceptions" "Not cleared,Cleared"
   textline "                "
  bitfld.long 0x00 1. " RR    ,Restart Request" "Not requested,Requested"
  bitfld.long 0x00 0. "     HR   ,Halt Request" "Not requested,Requested"
wgroup c14:0xc0++0x00
 line.long 0x00 "OSLAR,Operating System Lock Access Register"
  hexmask.long 0x00 0.--31. 1. " OSLA  ,OS Lock Access"
rgroup c14:0xc1++0x00
 line.long 0x00 "OSLSR,Operating System Lock Status Register"
  bitfld.long 0x00 2. " 32_BA ,32-Bit Access" "Not required,Required"
  bitfld.long 0x00 1. "      LB   ,Locked Bit" "Not locked,Locked"
  bitfld.long 0x00 0. "     LIB ,Lock Implemented Bit" "Not implemented,Implemented"
group c14:0xc2++0x00
 line.long 0x00 "OSSRR,Operating System Save and Restore Register"
  hexmask.long 0x00 0.--31. 1. " OSSR  ,OS Save and Restore"
group c14:0xc4++0x00
 line.long 0x00 "PRCR,Device Power-Down and Reset Control Register"
  bitfld.long 0x00 0. " NPD   ,No Power-Down" "DBGNOPWRDWN low,DBGNOPWRDWN high"
hgroup c14:0xc5++0x00
 hide.long 0x00 "PRSR,Device Power-Down and Reset Status Register"
  in
tree.end

width 6.
tree "Breakpoint Registers"
 group c14:0x40++0x00
  line.long 0x00 "BVR0,Breakpoint Value Register 0"
   hexmask.long 0x00 0.--31. 1. " BV0 ,Breakpoint Value 0"
 group c14:0x50++0x00
  line.long 0x00 "BCR0,Breakpoint Control Register 0"
   bitfld.long 0x00 20.--22. " M   ,BVR Meaning" "IVA match,Linked IVA match,Reserved,Reserved,IVA mismatch,Linked IVA mismatch,Reserved,Reserved"
   bitfld.long 0x00 16.--19. "     LBRP ,Linked BRP Number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x00 14.--15. "     SWAC ,Secure World Access Control" "Both,Nonsecure,Secure,Reserved"
   textline "               "
   bitfld.long 0x0 8. " BAS ,Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
    bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
    bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
   bitfld.long 0x00 1.--2. "        S  ,Supervisor Access Control" "User/system/supervisor,Privileged,User,Any"
   bitfld.long 0x00 0. "  B    ,Breakpoint Enable" "Disabled,Enabled"
 group c14:0x41++0x00
  line.long 0x00 "BVR1,Breakpoint Value Register 1"
   hexmask.long 0x00 0.--31. 1. " BV1 ,Breakpoint Value 1"
 group c14:0x51++0x00
  line.long 0x00 "BCR1,Breakpoint Control Register 1"
   bitfld.long 0x00 20.--22. " M   ,BVR Meaning" "IVA match,Linked IVA match,Reserved,Reserved,IVA mismatch,Linked IVA mismatch,Reserved,Reserved"
   bitfld.long 0x00 16.--19. "     LBRP ,Linked BRP Number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x00 14.--15. "     SWAC ,Secure World Access Control" "Both,Nonsecure,Secure,Reserved"
   textline "               "
   bitfld.long 0x0 8. " BAS ,Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
    bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
    bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
   bitfld.long 0x00 1.--2. "        S  ,Supervisor Access Control" "User/system/supervisor,Privileged,User,Any"
   bitfld.long 0x00 0. "  B    ,Breakpoint Enable" "Disabled,Enabled"
 group c14:0x42++0x00
  line.long 0x00 "BVR2,Breakpoint Value Register 2"
   hexmask.long 0x00 0.--31. 1. " BV2 ,Breakpoint Value 2"
 group c14:0x52++0x00
  line.long 0x00 "BCR2,Breakpoint Control Register 2"
   bitfld.long 0x00 20.--22. " M   ,BVR Meaning" "IVA match,Linked IVA match,Reserved,Reserved,IVA mismatch,Linked IVA mismatch,Reserved,Reserved"
   bitfld.long 0x00 16.--19. "     LBRP ,Linked BRP Number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x00 14.--15. "     SWAC ,Secure World Access Control" "Both,Nonsecure,Secure,Reserved"
   textline "               "
   bitfld.long 0x0 8. " BAS ,Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
    bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
    bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
   bitfld.long 0x00 1.--2. "        S  ,Supervisor Access Control" "User/system/supervisor,Privileged,User,Any"
   bitfld.long 0x00 0. "  B    ,Breakpoint Enable" "Disabled,Enabled"
 group c14:0x43++0x00
  line.long 0x00 "BVR3,Breakpoint Value Register 3"
   hexmask.long 0x00 0.--31. 1. " BV3 ,Breakpoint Value 3"
 group c14:0x53++0x00
  line.long 0x00 "BCR3,Breakpoint Control Register 3"
   bitfld.long 0x00 20.--22. " M   ,BVR Meaning" "IVA match,Linked IVA match,Reserved,Reserved,IVA mismatch,Linked IVA mismatch,Reserved,Reserved"
   bitfld.long 0x00 16.--19. "     LBRP ,Linked BRP Number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x00 14.--15. "     SWAC ,Secure World Access Control" "Both,Nonsecure,Secure,Reserved"
   textline "               "
   bitfld.long 0x0 8. " BAS ,Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
    bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
    bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
   bitfld.long 0x00 1.--2. "        S  ,Supervisor Access Control" "User/system/supervisor,Privileged,User,Any"
   bitfld.long 0x00 0. "  B    ,Breakpoint Enable" "Disabled,Enabled"
 group c14:0x44++0x00
  line.long 0x00 "BVR4,Breakpoint Value Register 4"
   hexmask.long 0x00 0.--31. 1. " BV4 ,Breakpoint Value 4"
 group c14:0x54++0x00
  line.long 0x00 "BCR4,Breakpoint Control Register 4"
   bitfld.long 0x00 20.--22. " M   ,BVR Meaning" "IVA match,Linked IVA match,Unlinked ID,Linked ID,IVA mismatch,Linked IVA mismatch,Reserved,Reserved"
   bitfld.long 0x00 16.--19. "     LBRP ,Linked BRP Number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x00 14.--15. "     SWAC ,Secure World Access Control" "Both,Nonsecure,Secure,Reserved"
   textline "               "
   bitfld.long 0x0 8. " BAS ,Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
    bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
    bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
   bitfld.long 0x00 1.--2. "        S  ,Supervisor Access Control" "User/system/supervisor,Privileged,User,Any"
   bitfld.long 0x00 0. "  B    ,Breakpoint Enable" "Disabled,Enabled"
 group c14:0x45++0x00
  line.long 0x00 "BVR5,Breakpoint Value Register 5"
   hexmask.long 0x00 0.--31. 1. " BV5 ,Breakpoint Value 5"
 group c14:0x55++0x00
  line.long 0x00 "BCR5,Breakpoint Control Register 5"
   bitfld.long 0x00 20.--22. " M   ,BVR Meaning" "IVA match,Linked IVA match,Unlinked ID,Linked ID,IVA mismatch,Linked IVA mismatch,Reserved,Reserved"
   bitfld.long 0x00 16.--19. "     LBRP ,Linked BRP Number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x00 14.--15. "     SWAC ,Secure World Access Control" "Both,Nonsecure,Secure,Reserved"
   textline "               "
   bitfld.long 0x0 8. " BAS ,Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
    bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
    bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
   bitfld.long 0x00 1.--2. "        S  ,Supervisor Access Control" "User/system/supervisor,Privileged,User,Any"
   bitfld.long 0x00 0. "  B    ,Breakpoint Enable" "Disabled,Enabled"
tree.end

width 6.
tree "Watchpoint Control Registers"
 group c14:0x60++0x00
  line.long 0x00 "WVR0,Watchpoint Value Register 0"
   hexmask.long 0x00 2.--31. 0x04 " WA0   ,Watchpoint Address 0"
 group c14:0x70--0x70
  line.long 0x0 "WCR0,Watchpoint Control Register 0"
   bitfld.long 0x0 24.--28. " WAM   ,Watchpoint address mask" "Not masked,Reserved,Reserved,0x7,0xF,0x1F,0x3F,0x7F,0xFF,0x1FF,0x3FF,0x7FF,0xFFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF,0x1FFFF,0x3FFFF,0x7FFFF,0xFFFFF,0x1FFFFF,0x3FFFFF,0x7FFFFF,0xFFFFFF,0x1FFFFFF,0x3FFFFFF,0x7FFFFFF,0xFFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF"
   bitfld.long 0x0 20. "  EL   ,Enable Linking" "Disabled,Enabled"
    textline "               "
   bitfld.long 0x0 16.--19. " LBN   ,Linked BRP number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x0 14.--15. "       SWAC ,Secure world access control" "Non-secure & Secure,Non-secure,Secure,Reserved"
    textline "               "
   bitfld.long 0x0 12. " BAS   ,Byte 7 address select" "0,1"
   bitfld.long 0x0 11. ",Byte 6 address select" "0,1"
   bitfld.long 0x0 10. ",Byte 5 address select" "0,1"
   bitfld.long 0x0 9. ",Byte 4 address select" "0,1"
   bitfld.long 0x0 8. ",Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
   bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
   bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
  textline "               "
   bitfld.long 0x0 3.--4. " RD/WR ,Load/Store access control" "Reserved,Load,Store,Any"
   bitfld.long 0x0 1.--2. "    PAC  ,Privileged access control" "Reserved,Privileged,USR,Any"
    textline "               "
   bitfld.long 0x0 0. " WE    ,Watchpoint enable" "Disabled,Enabled"
 group c14:0x61++0x00
  line.long 0x00 "WVR1,Watchpoint Value Register 1"
   hexmask.long 0x00 2.--31. 0x04 " WA1   ,Watchpoint Address 1"
 group c14:0x71--0x71
  line.long 0x0 "WCR1,Watchpoint Control Register 1"
     bitfld.long 0x0 24.--28. " WAM   ,Watchpoint address mask" "Not masked,Reserved,Reserved,0x7,0xF,0x1F,0x3F,0x7F,0xFF,0x1FF,0x3FF,0x7FF,0xFFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF,0x1FFFF,0x3FFFF,0x7FFFF,0xFFFFF,0x1FFFFF,0x3FFFFF,0x7FFFFF,0xFFFFFF,0x1FFFFFF,0x3FFFFFF,0x7FFFFFF,0xFFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF"
   bitfld.long 0x0 20. "  EL   ,Enable Linking" "Disabled,Enabled"
    textline "               "
   bitfld.long 0x0 16.--19. " LBN   ,Linked BRP number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x0 14.--15. "       SWAC ,Secure world access control" "Non-secure & Secure,Non-secure,Secure,Reserved"
    textline "               "
   bitfld.long 0x0 12. " BAS   ,Byte 7 address select" "0,1"
   bitfld.long 0x0 11. ",Byte 6 address select" "0,1"
   bitfld.long 0x0 10. ",Byte 5 address select" "0,1"
   bitfld.long 0x0 9. ",Byte 4 address select" "0,1"
   bitfld.long 0x0 8. ",Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
   bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
   bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
  textline "               "
   bitfld.long 0x0 3.--4. " RD/WR ,Load/Store access control" "Reserved,Load,Store,Any"
   bitfld.long 0x0 1.--2. "    PAC  ,Privileged access control" "Reserved,Privileged,USR,Any"
    textline "               "
   bitfld.long 0x0 0. " WE    ,Watchpoint enable" "Disabled,Enabled"
group c14:0x62++0x00
  line.long 0x00 "WVR2,Watchpoint Value Register 2"
   hexmask.long 0x00 2.--31. 0x04 " WA2   ,Watchpoint Address 2"
 group c14:0x72--0x72
  line.long 0x0 "WCR2,Watchpoint Control Register 2"
   bitfld.long 0x0 24.--28. " WAM   ,Watchpoint address mask" "Not masked,Reserved,Reserved,0x7,0xF,0x1F,0x3F,0x7F,0xFF,0x1FF,0x3FF,0x7FF,0xFFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF,0x1FFFF,0x3FFFF,0x7FFFF,0xFFFFF,0x1FFFFF,0x3FFFFF,0x7FFFFF,0xFFFFFF,0x1FFFFFF,0x3FFFFFF,0x7FFFFFF,0xFFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF"
   bitfld.long 0x0 20. "  EL   ,Enable Linking" "Disabled,Enabled"
    textline "               "
   bitfld.long 0x0 16.--19. " LBN   ,Linked BRP number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x0 14.--15. "       SWAC ,Secure world access control" "Non-secure & Secure,Non-secure,Secure,Reserved"
    textline "               "
   bitfld.long 0x0 12. " BAS   ,Byte 7 address select" "0,1"
   bitfld.long 0x0 11. ",Byte 6 address select" "0,1"
   bitfld.long 0x0 10. ",Byte 5 address select" "0,1"
   bitfld.long 0x0 9. ",Byte 4 address select" "0,1"
   bitfld.long 0x0 8. ",Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
   bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
   bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
  textline "               "
   bitfld.long 0x0 3.--4. " RD/WR ,Load/Store access control" "Reserved,Load,Store,Any"
   bitfld.long 0x0 1.--2. "    PAC  ,Privileged access control" "Reserved,Privileged,USR,Any"
    textline "               "
   bitfld.long 0x0 0. " WE    ,Watchpoint enable" "Disabled,Enabled"
group c14:0x63++0x00
  line.long 0x00 "WVR3,Watchpoint Value Register 3"
   hexmask.long 0x00 2.--31. 0x04 " WA3   ,Watchpoint Address 3"
 group c14:0x73--0x73
  line.long 0x0 "WCR3,Watchpoint Control Register 3"
   bitfld.long 0x0 24.--28. " WAM   ,Watchpoint address mask" "Not masked,Reserved,Reserved,0x7,0xF,0x1F,0x3F,0x7F,0xFF,0x1FF,0x3FF,0x7FF,0xFFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF,0x1FFFF,0x3FFFF,0x7FFFF,0xFFFFF,0x1FFFFF,0x3FFFFF,0x7FFFFF,0xFFFFFF,0x1FFFFFF,0x3FFFFFF,0x7FFFFFF,0xFFFFFFF,0x1FFFFFFF,0x3FFFFFFF,0x7FFFFFFF"
   bitfld.long 0x0 20. "  EL   ,Enable Linking" "Disabled,Enabled"
    textline "               "
   bitfld.long 0x0 16.--19. " LBN   ,Linked BRP number" "BRP,BRP1,BRP2,BRP3,BRP4,BRP5,BRP6,BRP7,BRP8,BRP9,BRP10,BRP11,BRP12,BRP13,BRP14,BRP15"
   bitfld.long 0x0 14.--15. "       SWAC ,Secure world access control" "Non-secure & Secure,Non-secure,Secure,Reserved"
    textline "               "
   bitfld.long 0x0 12. " BAS   ,Byte 7 address select" "0,1"
   bitfld.long 0x0 11. ",Byte 6 address select" "0,1"
   bitfld.long 0x0 10. ",Byte 5 address select" "0,1"
   bitfld.long 0x0 9. ",Byte 4 address select" "0,1"
   bitfld.long 0x0 8. ",Byte 3 address select" "0,1"
   bitfld.long 0x0 7. ",Byte 2 address select" "0,1"
   bitfld.long 0x0 6. ",Byte 1 address select" "0,1"
   bitfld.long 0x0 5. ",Byte 0 address select" "0,1"
  textline "               "
   bitfld.long 0x0 3.--4. " RD/WR ,Load/Store access control" "Reserved,Load,Store,Any"
   bitfld.long 0x0 1.--2. "    PAC  ,Privileged access control" "Reserved,Privileged,USR,Any"
    textline "               "
   bitfld.long 0x0 0. " WE    ,Watchpoint enable" "Disabled,Enabled"
 group c14:0x006--0x006
  line.long 0x0 "WFAR,Watchpoint Fault Address Register"
  hexmask.long.long 0x00 1.--31. 0x02 " WFAR  ,Address of the watchpointed instruction"
tree.end
width 0xb
tree.end

;--------------------------------------------------------------------------------
; AIPSTZ
;--------------------------------------------------------------------------------
tree.open "AIPSTZ"
    tree "AIPSTZ1"
        base ad:0x02000000

width 4.
group.long 0x0++0x3
    line.long 0x00 "MPR,Master Priviledge Registers"
        hexmask.long.byte 0x00 16.--20. 1. " MPROT3 ,Master 3 Priviledge, Buffer, Read, Write Control."
        textline "   "
        hexmask.long.byte 0x00 20.--24. 1. " MPROT2 ,Master 2 Priviledge, Buffer, Read, Write Control"
        textline "   "
        hexmask.long.byte 0x00 24.--28. 1. " MPROT1 ,Master 1 Priviledge, Buffer, Read, Write Control"
        textline "   "
        hexmask.long.byte 0x00 28.--32. 1. " MPROT0 ,Master 0 Priviledge, Buffer, Read, Write Control"
width 6.
group.long 0x40++0x3
    line.long 0x00 "OPACR,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC7 ,Off-platform Peripheral Access Control 7"
        textline "     "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC6 ,Off-platform Peripheral Access Control 6"
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC5 ,Off-platform Peripheral Access Control 5"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC4 ,Off-platform Peripheral Access Control 4"
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC3 ,Off-platform Peripheral Access Control 3"
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC2 ,Off-platform Peripheral Access Control 2"
        textline "     "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC1 ,Off-platform Peripheral Access Control 1"
        textline "     "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC0 ,Off-platform Peripheral Access Control 0"
width 7.
group.long 0x44++0x3
    line.long 0x00 "OPACR1,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC15 ,Off-platform Peripheral Access Control 15"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC14 ,Off-platform Peripheral Access Control 14"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC13 ,Off-platform Peripheral Access Control 13"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC12 ,Off-platform Peripheral Access Control 12"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC11 ,Off-platform Peripheral Access Control 11"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC10 ,Off-platform Peripheral Access Control 10"
        textline "      "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC9 ,Off-platform Peripheral Access Control 9"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC8 ,Off-platform Peripheral Access Control 8"
width 7.
group.long 0x48++0x3
    line.long 0x00 "OPACR2,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC23 ,Off-platform Peripheral Access Control 23"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC22 ,Off-platform Peripheral Access Control 22"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC21 ,Off-platform Peripheral Access Control 21"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC20 ,Off-platform Peripheral Access Control 20"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC19 ,Off-platform Peripheral Access Control 19"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC18 ,Off-platform Peripheral Access Control 18"
        textline "      "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC17 ,Off-platform Peripheral Access Control 17"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC16 ,Off-platform Peripheral Access Control 16"
width 7.
group.long 0x4c++0x3
    line.long 0x00 "OPACR3,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC31 ,Off-platform Peripheral Access Control 31"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC30 ,Off-platform Peripheral Access Control 30"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC29 ,Off-platform Peripheral Access Control 29"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC28 ,Off-platform Peripheral Access Control 28"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC27 ,Off-platform Peripheral Access Control 27"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC26 ,Off-platform Peripheral Access Control 26"
        textline "      "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC25 ,Off-platform Peripheral Access Control 25"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC24 ,Off-platform Peripheral Access Control 24"
width 7.
group.long 0x50++0x3
    line.long 0x00 "OPACR4,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 24.--28. 1. " OPAC33 ,Off-platform Peripheral Access Control 33"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC32 ,Off-platform Peripheral Access Control 32"


    tree.end
    tree "AIPSTZ2"
        base ad:0x02100000

width 4.
group.long 0x0++0x3
    line.long 0x00 "MPR,Master Priviledge Registers"
        hexmask.long.byte 0x00 16.--20. 1. " MPROT3 ,Master 3 Priviledge, Buffer, Read, Write Control."
        textline "   "
        hexmask.long.byte 0x00 20.--24. 1. " MPROT2 ,Master 2 Priviledge, Buffer, Read, Write Control"
        textline "   "
        hexmask.long.byte 0x00 24.--28. 1. " MPROT1 ,Master 1 Priviledge, Buffer, Read, Write Control"
        textline "   "
        hexmask.long.byte 0x00 28.--32. 1. " MPROT0 ,Master 0 Priviledge, Buffer, Read, Write Control"
width 6.
group.long 0x40++0x3
    line.long 0x00 "OPACR,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC7 ,Off-platform Peripheral Access Control 7"
        textline "     "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC6 ,Off-platform Peripheral Access Control 6"
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC5 ,Off-platform Peripheral Access Control 5"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC4 ,Off-platform Peripheral Access Control 4"
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC3 ,Off-platform Peripheral Access Control 3"
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC2 ,Off-platform Peripheral Access Control 2"
        textline "     "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC1 ,Off-platform Peripheral Access Control 1"
        textline "     "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC0 ,Off-platform Peripheral Access Control 0"
width 7.
group.long 0x44++0x3
    line.long 0x00 "OPACR1,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC15 ,Off-platform Peripheral Access Control 15"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC14 ,Off-platform Peripheral Access Control 14"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC13 ,Off-platform Peripheral Access Control 13"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC12 ,Off-platform Peripheral Access Control 12"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC11 ,Off-platform Peripheral Access Control 11"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC10 ,Off-platform Peripheral Access Control 10"
        textline "      "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC9 ,Off-platform Peripheral Access Control 9"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC8 ,Off-platform Peripheral Access Control 8"
width 7.
group.long 0x48++0x3
    line.long 0x00 "OPACR2,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC23 ,Off-platform Peripheral Access Control 23"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC22 ,Off-platform Peripheral Access Control 22"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC21 ,Off-platform Peripheral Access Control 21"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC20 ,Off-platform Peripheral Access Control 20"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC19 ,Off-platform Peripheral Access Control 19"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC18 ,Off-platform Peripheral Access Control 18"
        textline "      "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC17 ,Off-platform Peripheral Access Control 17"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC16 ,Off-platform Peripheral Access Control 16"
width 7.
group.long 0x4c++0x3
    line.long 0x00 "OPACR3,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 0.--4. 1. " OPAC31 ,Off-platform Peripheral Access Control 31"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " OPAC30 ,Off-platform Peripheral Access Control 30"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " OPAC29 ,Off-platform Peripheral Access Control 29"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " OPAC28 ,Off-platform Peripheral Access Control 28"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " OPAC27 ,Off-platform Peripheral Access Control 27"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " OPAC26 ,Off-platform Peripheral Access Control 26"
        textline "      "
        hexmask.long.byte 0x00 24.--28. 1. " OPAC25 ,Off-platform Peripheral Access Control 25"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC24 ,Off-platform Peripheral Access Control 24"
width 7.
group.long 0x50++0x3
    line.long 0x00 "OPACR4,Off-Platform Peripheral Access Control Registers"
        hexmask.long.byte 0x00 24.--28. 1. " OPAC33 ,Off-platform Peripheral Access Control 33"
        textline "      "
        hexmask.long.byte 0x00 28.--32. 1. " OPAC32 ,Off-platform Peripheral Access Control 32"


    tree.end

tree.end



;--------------------------------------------------------------------------------
; ARMGLOBALTIMER
;--------------------------------------------------------------------------------
tree "ARMGLOBALTIMER"
    base ad:0x00a00000

width 9.
group.long 0x200++0x3
    line.long 0x00 "COUNTER0,Global Timer Counter Registers"
        hexmask.long.long 0x00 0.--32. 1. " VALUE ,32-bits of the counter value."
width 9.
group.long 0x204++0x3
    line.long 0x00 "COUNTER1,Global Timer Counter Registers"
        hexmask.long.long 0x00 0.--32. 1. " VALUE ,32-bits of the counter value."
width 8.
group.long 0x208++0x3
    line.long 0x00 "CONTROL,Global Timer Control Register"
        bitfld.long 0x00 0. " TIMER_ENABLE ,Timer enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " COMP_ENABLE ,This bit is banked per Cortex-A9 processor." "0,1"
        textline "       "
        bitfld.long 0x00 2. " IRQ_ENABLE ,This bit is banked per Cortex-A9 processor." "0,1"
        textline "       "
        bitfld.long 0x00 3. " AUTO_INCREMENT ,This bit is banked per Cortex-A9 processor." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " PRESCALER ,The prescaler modifies the clock period for the decrementing event for the Counter Register."
width 10.
group.long 0x20c++0x3
    line.long 0x00 "IRQSTATUS,Global Timer Interrupt Status Register"
        bitfld.long 0x00 0. " EVENT_FLAG ,The event flag is a sticky bit that is automatically set when the Counter Register reaches the Comparator Register value." "0,1"
width 12.
group.long 0x210++0x3
    line.long 0x00 "COMPARATOR0,Global Timer Comparator Value Registers"
        hexmask.long.long 0x00 0.--32. 1. " VALUE ,32-bits of the comparator value."
width 12.
group.long 0x214++0x3
    line.long 0x00 "COMPARATOR1,Global Timer Comparator Value Registers"
        hexmask.long.long 0x00 0.--32. 1. " VALUE ,32-bits of the comparator value."
width 14.
group.long 0x218++0x3
    line.long 0x00 "AUTOINCREMENT,Global Timer Auto-increment Register"
        hexmask.long.long 0x00 0.--32. 1. " VALUE ,32-bit auto-increment value."


tree.end



;--------------------------------------------------------------------------------
; ASRC
;--------------------------------------------------------------------------------
tree "ASRC"
    base ad:0x02034000

width 7.
group.long 0x0++0x3
    line.long 0x00 "ASRCTR,ASRC Control Register"
        bitfld.long 0x00 0. " ASRCEN ,ASRC Enable Enable the operation of ASRC." "0,1"
        textline "      "
        bitfld.long 0x00 1. " ASREA ,ASRC Enable A Enable the operation of the conversion A of ASRC." "0,1"
        textline "      "
        bitfld.long 0x00 2. " ASREB ,ASRC Enable B Enable the operation of the conversion B of ASRC." "0,1"
        textline "      "
        bitfld.long 0x00 3. " ASREC ,ASRC Enable C Enable the operation of the conversion C of ASRC." "0,1"
        textline "      "
        bitfld.long 0x00 4. " SRST ,Software Reset This bit is self-clear bit." "0,1"
        textline "      "
        bitfld.long 0x00 13. " IDRA ,Use Ideal Ratio for Pair A When USRA=0, this bit has no usage." "0,1"
        textline "      "
        bitfld.long 0x00 14. " USRA ,Use Ratio for Pair A Use ratio as the input to ASRC." "0,1"
        textline "      "
        bitfld.long 0x00 15. " IDRB ,Use Ideal Ratio for Pair B When USRB=0, this bit has no usage." "0,1"
        textline "      "
        bitfld.long 0x00 16. " USRB ,Use Ratio for Pair B Use ratio as the input to ASRC." "0,1"
        textline "      "
        bitfld.long 0x00 17. " IDRC ,Use Ideal Ratio for Pair C When USRC=0, this bit has no usage." "0,1"
        textline "      "
        bitfld.long 0x00 18. " USRC ,Use Ratio for Pair C Use ratio as the input to ASRC." "0,1"
        textline "      "
        bitfld.long 0x00 20. " ATSA ,ASRC Pair A Automatic Selection For Processing Options When this bit is 1, pair A will automatic update its pre-processing and post-processing options (ASRCFG: PREMODA, ASRCFG:POSTMODA see ASRC Misc Control Register 1 for Pair C ) based on the frequencies it detected." "0,1"
        textline "      "
        bitfld.long 0x00 21. " ATSB ,ASRC Pair B Automatic Selection For Processing Options When this bit is 1, pair B will automatic update its pre-processing and post-processing options (ASRCFG: PREMODB, ASRCFG:POSTMODB see ASRC Misc Control Register 1 for Pair C ) based on the frequencies it detected." "0,1"
        textline "      "
        bitfld.long 0x00 22. " ATSC ,ASRC Pair C Automatic Selection For Processing Options When this bit is 1, pair C will automatic update its pre-processing and post-processing options (ASRCFG: PREMODC, ASRCFG:POSTMODC see ASRC Misc Control Register 1 for Pair C ) based on the frequencies it detected." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
group.long 0x4++0x3
    line.long 0x00 "ASRIER,ASRC Interrupt Enable Register"
        bitfld.long 0x00 0. " ADIEA ,Data Input A Interrupt Enable Enables the data input A Interrupt." "0,1"
        textline "      "
        bitfld.long 0x00 1. " ADIEB ,Data Input B Interrupt Enable Enables the data input B interrupt." "0,1"
        textline "      "
        bitfld.long 0x00 2. " ADIEC ,Data Input C Interrupt Enable Enables the data input C interrupt." "0,1"
        textline "      "
        bitfld.long 0x00 3. " ADOEA ,Data Output A Interrupt Enable Enables the data output A interrupt." "0,1"
        textline "      "
        bitfld.long 0x00 4. " ADOEB ,Data Output B Interrupt Enable Enables the data output B interrupt." "0,1"
        textline "      "
        bitfld.long 0x00 5. " ADOEC ,Data Output C Interrupt Enable Enables the data output C interrupt." "0,1"
        textline "      "
        bitfld.long 0x00 6. " AOLIE ,Overload Interrupt Enable Enables the overload interrupt." "0,1"
        textline "      "
        bitfld.long 0x00 7. " AFPWE ,FP in Wait State Interrupt Enable Enables the FP in wait state interrupt." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
group.long 0xc++0x3
    line.long 0x00 "ASRCNCR,ASRC Channel Number Configuration Register"
        hexmask.long.byte 0x00 0.--4. 1. " ANCA ,Number of A Channels"
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " ANCB ,Number of B Channels"
        textline "       "
        hexmask.long.byte 0x00 8.--12. 1. " ANCC ,Number of C Channels ANCC+ANCB+ANCA<=10."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
group.long 0x10++0x3
    line.long 0x00 "ASRCFG,ASRC Filter Configuration Status Register"
        hexmask.long.byte 0x00 6.--8. 1. " PREMODA ,Pre-Processing Configuration for Conversion Pair A These bits will be read/write by user if ASRCTR:ATSA=0, and can also be automatically updated by the ASRC internal logic if ASRCTR:ATSA=1 (see ASRC Misc Control Register 1 for Pair C )."
        textline "      "
        hexmask.long.byte 0x00 8.--10. 1. " POSTMODA ,Post-Processing Configuration for Conversion Pair A These bits will be read/write by user if ASRCTR:ATSA=0, and can also be automatically updated by the ASRC internal logic if ASRCTR:ATSA=1 (see ASRC Misc Control Register 1 for Pair C )."
        textline "      "
        hexmask.long.byte 0x00 10.--12. 1. " PREMODB ,Pre-Processing Configuration for Conversion Pair B These bits will be read/write by user if ASRCTR:ATSB=0, and can also be automatically updated by the ASRC internal logic if ASRCTR:ATSB=1 (see ASRC Misc Control Register 1 for Pair C )."
        textline "      "
        hexmask.long.byte 0x00 12.--14. 1. " POSTMODB ,Post-Processing Configuration for Conversion Pair B These bits will be read/write by user if ASRCTR:ATSB=0, and can also be automatically updated by the ASRC internal logic if ASRCTR:ATSB=1 (see ASRC Misc Control Register 1 for Pair C )."
        textline "      "
        hexmask.long.byte 0x00 14.--16. 1. " PREMODC ,Pre-Processing Configuration for Conversion Pair C These bits will be read/write by user if ASRCTR:ATSC=0, and can also be automatically updated by the ASRC internal logic if ASRCTR:ATSC=1 (see ASRC Misc Control Register 1 for Pair C )."
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " POSTMODC ,Post-Processing Configuration for Conversion Pair C These bits will be read/write by user if ASRCTR:ATSC=0, and can also be automatically updated by the ASRC internal logic if ASRCTR:ATSC=1 (see ASRC Misc Control Register 1 for Pair C )."
        textline "      "
        bitfld.long 0x00 18. " NDPRA ,Not Use Default Parameters for RAM-stored Parameters For Conversion Pair A" "0,1"
        textline "      "
        bitfld.long 0x00 19. " NDPRB ,Not Use Default Parameters for RAM-stored Parameters For Conversion Pair B" "0,1"
        textline "      "
        bitfld.long 0x00 20. " NDPRC ,Not Use Default Parameters for RAM-stored Parameters For Conversion Pair C" "0,1"
        textline "      "
        bitfld.long 0x00 21. " INIRQA ,Initialization for Conversion Pair A is served When this bit is 1, it means the initialization for conversion pair A is served." "0,1"
        textline "      "
        bitfld.long 0x00 22. " INIRQB ,Initialization for Conversion Pair B is served When this bit is 1, it means the initialization for conversion pair B is served." "0,1"
        textline "      "
        bitfld.long 0x00 23. " INIRQC ,Initialization for Conversion Pair C is served When this bit is 1, it means the initialization for conversion pair C is served." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
group.long 0x14++0x3
    line.long 0x00 "ASRCSR,ASRC Clock Source Register"
        hexmask.long.byte 0x00 0.--4. 1. " AICSA ,Input Clock Source A"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " AICSB ,Input Clock Source B"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " AICSC ,Input Clock Source C"
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " AOCSA ,Output Clock Source A"
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " AOCSB ,Output Clock Source B"
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " AOCSC ,Output Clock Source C"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
group.long 0x18++0x3
    line.long 0x00 "ASRCDR1,ASRC Clock Divider Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " AICPA ,Input Clock Prescaler A Specify the prescaling factor of the input prescaler A."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " AICDA ,Input Clock Divider A Specify the divide ratio of the input clock divider A."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " AICPB ,Input Clock Prescaler B Specify the prescaling factor of the input prescaler B."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " AICDB ,Input Clock Divider B Specify the divide ratio of the input clock divider B."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " AOCPA ,Output Clock Prescaler A Specify the prescaling factor of the output prescaler A."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " AOCDA ,Output Clock Divider A Specify the divide ratio of the output clock divider A."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " AOCPB ,Output Clock Prescaler B Specify the prescaling factor of the output prescaler B."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " AOCDB ,Output Clock Divider B Specify the divide ratio of the output clock divider B."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
group.long 0x1c++0x3
    line.long 0x00 "ASRCDR2,ASRC Clock Divider Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " AICPC ,Input Clock Prescaler C Specify the prescaling factor of the input prescaler C."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " AICDC ,Input Clock Divider C Specify the divide ratio of the input clock divider C."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " AOCPC ,Output Clock Prescaler C Specify the prescaling factor of the output prescaler C."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " AOCDC ,Output Clock Divider C Specify the divide ratio of the output clock divider C."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
rgroup.long 0x20++0x3
    line.long 0x00 "ASRSTR,ASRC Status Register"
        bitfld.long 0x00 0. " AIDEA ,Number of data in Input Data Buffer A is less than threshold When set, this bit indicates that number of data still available in ASRDIRA is less than threshold and the processor can write data to ASRDIRA." "0,1"
        textline "      "
        bitfld.long 0x00 1. " AIDEB ,Number of data in Input Data Buffer B is less than threshold When set, this bit indicates that number of data still available in ASRDIRB is less than threshold and the processor can write data to ASRDIRB." "0,1"
        textline "      "
        bitfld.long 0x00 2. " AIDEC ,Number of data in Input Data Buffer C is less than threshold When set, this bit indicates that number of data still available in ASRDIRC is less than threshold and the processor can write data to ASRDIRC." "0,1"
        textline "      "
        bitfld.long 0x00 3. " AODFA ,Number of data in Output Data Buffer A is greater than threshold When set, this bit indicates that number of data already existing in ASRDORA is greater than threshold and the processor can read data from ASRDORA." "0,1"
        textline "      "
        bitfld.long 0x00 4. " AODFB ,Number of data in Output Data Buffer B is greater than threshold When set, this bit indicates that number of data already existing in ASRDORB is greater than threshold and the processor can read data from ASRDORB." "0,1"
        textline "      "
        bitfld.long 0x00 5. " AODFC ,Number of data in Output Data Buffer C is greater than threshold When set, this bit indicates that number of data already existing in ASRDORC is greater than threshold and the processor can read data from ASRDORC." "0,1"
        textline "      "
        bitfld.long 0x00 6. " AOLE ,Overload Error Flag When set, this bit indicates that the task rate is too high for the ASRC to handle." "0,1"
        textline "      "
        bitfld.long 0x00 7. " FPWT ,FP is in wait states This bit is for debug only." "0,1"
        textline "      "
        bitfld.long 0x00 8. " AIDUA ,Input Data Buffer A has underflowed When set, this bit indicates that input data buffer A has underflowed." "0,1"
        textline "      "
        bitfld.long 0x00 9. " AIDUB ,Input Data Buffer B has underflowed When set, this bit indicates that input data buffer B has underflowed." "0,1"
        textline "      "
        bitfld.long 0x00 10. " AIDUC ,Input Data Buffer C has underflowed When set, this bit indicates that input data buffer C has underflowed." "0,1"
        textline "      "
        bitfld.long 0x00 11. " AODOA ,Output Data Buffer A has overflowed When set, this bit indicates that output data buffer A has overflowed." "0,1"
        textline "      "
        bitfld.long 0x00 12. " AODOB ,Output Data Buffer B has overflowed When set, this bit indicates that output data buffer B has overflowed." "0,1"
        textline "      "
        bitfld.long 0x00 13. " AODOC ,Output Data Buffer C has overflowed When set, this bit indicates that output data buffer C has overflowed." "0,1"
        textline "      "
        bitfld.long 0x00 14. " AIOLA ,Pair A Input Task Overload When set, this bit indicates that pair A input task is oveloaded." "0,1"
        textline "      "
        bitfld.long 0x00 15. " AIOLB ,Pair B Input Task Overload When set, this bit indicates that pair B input task is oveloaded." "0,1"
        textline "      "
        bitfld.long 0x00 16. " AIOLC ,Pair C Input Task Overload When set, this bit indicates that pair C input task is oveloaded." "0,1"
        textline "      "
        bitfld.long 0x00 17. " AOOLA ,Pair A Output Task Overload When set, this bit indicates that pair A output task is oveloaded." "0,1"
        textline "      "
        bitfld.long 0x00 18. " AOOLB ,Pair B Output Task Overload When set, this bit indicates that pair B output task is oveloaded." "0,1"
        textline "      "
        bitfld.long 0x00 19. " AOOLC ,Pair C Output Task Overload When set, this bit indicates that pair C output task is oveloaded." "0,1"
        textline "      "
        bitfld.long 0x00 20. " ATQOL ,Task Queue FIFO overload When set, this bit indicates that task queue FIFO logic is oveloaded." "0,1"
        textline "      "
        bitfld.long 0x00 21. " DSLCNT ,DSL Counter Input to FIFO ready When set, this bit indicates that new DSL counter information is stored in the internal ASRC FIFO." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
group.long 0x40++0x3
    line.long 0x00 "ASRPMN1,ASRC Parameter Register n"
        hexmask.long.long 0x00 0.--24. 1. " PARAMETER_VALUE ,See recommended values table."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
group.long 0x44++0x3
    line.long 0x00 "ASRPMN2,ASRC Parameter Register n"
        hexmask.long.long 0x00 0.--24. 1. " PARAMETER_VALUE ,See recommended values table."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
group.long 0x48++0x3
    line.long 0x00 "ASRPMN3,ASRC Parameter Register n"
        hexmask.long.long 0x00 0.--24. 1. " PARAMETER_VALUE ,See recommended values table."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
group.long 0x4c++0x3
    line.long 0x00 "ASRPMN4,ASRC Parameter Register n"
        hexmask.long.long 0x00 0.--24. 1. " PARAMETER_VALUE ,See recommended values table."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
group.long 0x50++0x3
    line.long 0x00 "ASRPMN5,ASRC Parameter Register n"
        hexmask.long.long 0x00 0.--24. 1. " PARAMETER_VALUE ,See recommended values table."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
group.long 0x54++0x3
    line.long 0x00 "ASRTFR1,ASRC ASRC Task Queue FIFO Register 1"
        hexmask.long.byte 0x00 6.--13. 1. " TF_BASE ,Base address for task queue FIFO."
        textline "       "
        hexmask.long.byte 0x00 13.--20. 1. " TF_FILL ,Current number of entries in task queue FIFO."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
group.long 0x5c++0x3
    line.long 0x00 "ASRCCR,ASRC Channel Counter Register"
        hexmask.long.byte 0x00 0.--4. 1. " ACIA ,The channel counter for Pair A's input FIFO These bits stand for the current channel being accessed through shared peripheral bus for Pair A's input FIFO's usage."
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " ACIB ,The channel counter for Pair B's input FIFO These bits stand for the current channel being accessed through shared peripheral bus for Pair B's input FIFO's usage."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " ACIC ,The channel counter for Pair C's input FIFO These bits stand for the current channel being accessed through shared peripheral bus for Pair C's input FIFO's usage."
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " ACOA ,The channel counter for Pair A's output FIFO These bits stand for the current channel being accessed through shared peripheral bus for Pair A's output FIFO's usage."
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " ACOB ,The channel counter for Pair B's output FIFO These bits stand for the current channel being accessed through shared peripheral bus for Pair B's output FIFO's usage."
        textline "      "
        hexmask.long.byte 0x00 20.--24. 1. " ACOC ,The channel counter for Pair C's output FIFO These bits stand for the current channel being accessed through shared peripheral bus for Pair C's output FIFO's usage."
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
wgroup.long 0x60++0x3
    line.long 0x00 "ASRDIA,ASRC Data Input Register for Pair x"
        hexmask.long.long 0x00 0.--24. 1. " DATA ,Audio data input"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
rgroup.long 0x64++0x3
    line.long 0x00 "ASRDOA,ASRC Data Output Register for Pair x"
        hexmask.long.long 0x00 0.--24. 1. " DATA ,Audio data output"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
wgroup.long 0x68++0x3
    line.long 0x00 "ASRDIB,ASRC Data Input Register for Pair x"
        hexmask.long.long 0x00 0.--24. 1. " DATA ,Audio data input"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
rgroup.long 0x6c++0x3
    line.long 0x00 "ASRDOB,ASRC Data Output Register for Pair x"
        hexmask.long.long 0x00 0.--24. 1. " DATA ,Audio data output"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
wgroup.long 0x70++0x3
    line.long 0x00 "ASRDIC,ASRC Data Input Register for Pair x"
        hexmask.long.long 0x00 0.--24. 1. " DATA ,Audio data input"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
rgroup.long 0x74++0x3
    line.long 0x00 "ASRDOC,ASRC Data Output Register for Pair x"
        hexmask.long.long 0x00 0.--24. 1. " DATA ,Audio data output"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 9.
group.long 0x80++0x3
    line.long 0x00 "ASRIDRHA,ASRC Ideal Ratio for Pair A-High Part"
        hexmask.long.byte 0x00 0.--8. 1. " IDRATIOA ,IDRATIOA[31:24]."
        textline "        "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 9.
group.long 0x84++0x3
    line.long 0x00 "ASRIDRLA,ASRC Ideal Ratio for Pair A -Low Part"
        hexmask.long.long 0x00 0.--24. 1. " IDRATIOA ,IDRATIOA[23:0]."
        textline "        "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 9.
group.long 0x88++0x3
    line.long 0x00 "ASRIDRHB,ASRC Ideal Ratio for Pair B-High Part"
        hexmask.long.byte 0x00 0.--8. 1. " IDRATIOB ,IDRATIOB[31:24]."
        textline "        "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 9.
group.long 0x8c++0x3
    line.long 0x00 "ASRIDRLB,ASRC Ideal Ratio for Pair B-Low Part"
        hexmask.long.long 0x00 0.--24. 1. " IDRATIOB ,IDRATIOB[23:0]."
        textline "        "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 9.
group.long 0x90++0x3
    line.long 0x00 "ASRIDRHC,ASRC Ideal Ratio for Pair C-High Part"
        hexmask.long.byte 0x00 0.--8. 1. " IDRATIOC ,IDRATIOC[31:24]."
        textline "        "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 9.
group.long 0x94++0x3
    line.long 0x00 "ASRIDRLC,ASRC Ideal Ratio for Pair C-Low Part"
        hexmask.long.long 0x00 0.--24. 1. " IDRATIOC ,IDRATIOC[23:0]."
        textline "        "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
group.long 0x98++0x3
    line.long 0x00 "ASR76K,ASRC 76kHz Period in terms of ASRC processing clock"
        hexmask.long.long 0x00 0.--17. 1. " ASR76K ,Value for the period of the 76kHz sampling clock."
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
group.long 0x9c++0x3
    line.long 0x00 "ASR56K,ASRC 56kHz Period in terms of ASRC processing clock"
        hexmask.long.long 0x00 0.--17. 1. " ASR56K ,Value for the period of the 56kHz sampling clock"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
group.long 0xa0++0x3
    line.long 0x00 "ASRMCRA,ASRC Misc Control Register for Pair A"
        hexmask.long.byte 0x00 0.--6. 1. " INFIFO_THRESHOLDA ,The threshold for Pair A's input FIFO per channel These bits stand for the threshold for Pair A's input FIFO per channel."
        textline "       "
        bitfld.long 0x00 10. " RSYNOFA ,Re-sync Output FIFO Channel Counter If bit set, force ASRCCR:ACOA=0." "0,1"
        textline "       "
        bitfld.long 0x00 11. " RSYNIFA ,Re-sync Input FIFO Channel Counter If bit set, force ASRCCR:ACIA=0." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--18. 1. " OUTFIFO_THRESHOLDA ,The threshold for Pair A's output FIFO per channel These bits stand for the threshold for Pair A's output FIFO per channel."
        textline "       "
        bitfld.long 0x00 20. " BYPASSPOLYA ,Bypass Polyphase Filtering for Pair A This bit will determine whether the polyphase filtering part of Pair A conversion will be bypassed." "0,1"
        textline "       "
        bitfld.long 0x00 21. " BUFSTALLA ,Stall Pair A conversion in case of Buffer Near Empty/Full Condition This bit will determine whether the near empty/full FIFO condition will stall the rate conversion for pair A." "0,1"
        textline "       "
        bitfld.long 0x00 22. " EXTTHRSHA ,Use external thresholds for FIFO control of Pair A This bit will determine whether the FIFO thresholds externally defined in this register is used to control ASRC internal FIFO logic for pair A." "0,1"
        textline "       "
        bitfld.long 0x00 23. " ZEROBUFA ,Initialize buf of Pair A when pair A is enabled." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
rgroup.long 0xa4++0x3
    line.long 0x00 "ASRFSTA,ASRC FIFO Status Register for Pair A"
        hexmask.long.byte 0x00 0.--7. 1. " INFIFO_FILLA ,The fillings for Pair A's input FIFO per channel These bits stand for the fillings for Pair A's input FIFO per channel."
        textline "       "
        bitfld.long 0x00 11. " IAEA ,Input FIFO is near Empty for Pair A This bit is to indicate whether the input FIFO of Pair A is near empty." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--19. 1. " OUTFIFO_FILLA ,The fillings for Pair A's output FIFO per channel These bits stand for the fillings for Pair A's output FIFO per channel."
        textline "       "
        bitfld.long 0x00 23. " OAFA ,Output FIFO is near Full for Pair A This bit is to indicate whether the output FIFO of Pair A is near full." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
group.long 0xa8++0x3
    line.long 0x00 "ASRMCRB,ASRC Misc Control Register for Pair B"
        hexmask.long.byte 0x00 0.--6. 1. " INFIFO_THRESHOLDB ,The threshold for Pair B's input FIFO per channel These bits stand for the threshold for Pair B's input FIFO per channel."
        textline "       "
        bitfld.long 0x00 10. " RSYNOFB ,Re-sync Output FIFO Channel Counter If bit set, force ASRCCR:ACOB=0." "0,1"
        textline "       "
        bitfld.long 0x00 11. " RSYNIFB ,Re-sync Input FIFO Channel Counter If bit set, force ASRCCR:ACIB=0." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--18. 1. " OUTFIFO_THRESHOLDB ,The threshold for Pair B's output FIFO per channel These bits stand for the threshold for Pair B's output FIFO per channel."
        textline "       "
        bitfld.long 0x00 20. " BYPASSPOLYB ,Bypass Polyphase Filtering for Pair B This bit will determine whether the polyphase filtering part of Pair B conversion will be bypassed." "0,1"
        textline "       "
        bitfld.long 0x00 21. " BUFSTALLB ,Stall Pair B conversion in case of Buffer Near Empty/Full Condition This bit will determine whether the near empty/full FIFO condition will stall the rate conversion for pair B." "0,1"
        textline "       "
        bitfld.long 0x00 22. " EXTTHRSHB ,Use external thresholds for FIFO control of Pair B This bit will determine whether the FIFO thresholds externally defined in this register is used to control ASRC internal FIFO logic for pair B." "0,1"
        textline "       "
        bitfld.long 0x00 23. " ZEROBUFB ,Initialize buf of Pair B when pair B is enabled This bit is used to control whether the buffer is to be zeroized when pair B is enabled." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
rgroup.long 0xac++0x3
    line.long 0x00 "ASRFSTB,ASRC FIFO Status Register for Pair B"
        hexmask.long.byte 0x00 0.--7. 1. " INFIFO_FILLB ,The fillings for Pair B's input FIFO per channel These bits stand for the fillings for Pair B's input FIFO per channel."
        textline "       "
        bitfld.long 0x00 11. " IAEB ,Input FIFO is near Empty for Pair B This bit is to indicate whether the input FIFO of Pair B is near empty." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--19. 1. " OUTFIFO_FILLB ,The fillings for Pair B's output FIFO per channel These bits stand for the fillings for Pair B's output FIFO per channel."
        textline "       "
        bitfld.long 0x00 23. " OAFB ,Output FIFO is near Full for Pair B This bit is to indicate whether the output FIFO of Pair B is near full." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
group.long 0xb0++0x3
    line.long 0x00 "ASRMCRC,ASRC Misc Control Register for Pair C"
        hexmask.long.byte 0x00 0.--6. 1. " INFIFO_THRESHOLDC ,The threshold for Pair C's input FIFO per channel These bits stand for the threshold for Pair C's input FIFO per channel."
        textline "       "
        bitfld.long 0x00 10. " RSYNOFC ,Re-sync Output FIFO Channel Counter If bit set, force ASRCCR:ACOC=0." "0,1"
        textline "       "
        bitfld.long 0x00 11. " RSYNIFC ,Re-sync Input FIFO Channel Counter If bit set, force ASRCCR:ACIC=0." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--18. 1. " OUTFIFO_THRESHOLDC ,The threshold for Pair C's output FIFO per channel These bits stand for the threshold for Pair C's output FIFO per channel."
        textline "       "
        bitfld.long 0x00 20. " BYPASSPOLYC ,Bypass Polyphase Filtering for Pair C This bit will determine whether the polyphase filtering part of Pair C conversion will be bypassed." "0,1"
        textline "       "
        bitfld.long 0x00 21. " BUFSTALLC ,Stall Pair C conversion in case of Buffer Near Empty/Full Condition This bit will determine whether the near empty/full FIFO condition will stall the rate conversion for pair C." "0,1"
        textline "       "
        bitfld.long 0x00 22. " EXTTHRSHC ,Use external thresholds for FIFO control of Pair C This bit will determine whether the FIFO thresholds externally defined in this register is used to control ASRC internal FIFO logic for pair C." "0,1"
        textline "       "
        bitfld.long 0x00 23. " ZEROBUFC ,Initialize buf of Pair C when pair C is enabled This bit is used to control whether the buffer is to be zeroized when pair C is enabled." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 8.
rgroup.long 0xb4++0x3
    line.long 0x00 "ASRFSTC,ASRC FIFO Status Register for Pair C"
        hexmask.long.byte 0x00 0.--7. 1. " INFIFO_FILLC ,The fillings for Pair C's input FIFO per channel These bits stand for the fillings for Pair C's input FIFO per channel."
        textline "       "
        bitfld.long 0x00 11. " IAEC ,Input FIFO is near Empty for Pair C This bit is to indicate whether the input FIFO of Pair C is near empty." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--19. 1. " OUTFIFO_FILLC ,The fillings for Pair C's output FIFO per channel These bits stand for the fillings for Pair C's output FIFO per channel."
        textline "       "
        bitfld.long 0x00 23. " OAFC ,Output FIFO is near Full for Pair C This bit is to indicate whether the output FIFO of Pair C is near full." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 9.
group.long 0xc0++0x3
    line.long 0x00 "ASRMCR1A,ASRC Misc Control Register 1 for Pair X"
        bitfld.long 0x00 0. " OW16 ,Bit Width Option of the output FIFO This bit will determine the bit width option of the output FIFO." "0,1"
        textline "        "
        bitfld.long 0x00 1. " OSGN ,Sign Extension Option of the output FIFO This bit will determine the sign extension option of the output FIFO." "0,1"
        textline "        "
        bitfld.long 0x00 2. " OMSB ,Data Alignment of the output FIFO This bit will determine the data alignment of the output FIFO." "0,1"
        textline "        "
        bitfld.long 0x00 8. " IMSB ,Data Alignment of the input FIFO This bit will determine the data alignment of the input FIFO." "0,1"
        textline "        "
        hexmask.long.byte 0x00 9.--12. 1. " IWD ,Data Width of the input FIFO These three bits will determine the bitwidth for the audio data into ASRC All other settings not shown are reserved."
        textline "        "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 9.
group.long 0xc4++0x3
    line.long 0x00 "ASRMCR1B,ASRC Misc Control Register 1 for Pair X"
        bitfld.long 0x00 0. " OW16 ,Bit Width Option of the output FIFO This bit will determine the bit width option of the output FIFO." "0,1"
        textline "        "
        bitfld.long 0x00 1. " OSGN ,Sign Extension Option of the output FIFO This bit will determine the sign extension option of the output FIFO." "0,1"
        textline "        "
        bitfld.long 0x00 2. " OMSB ,Data Alignment of the output FIFO This bit will determine the data alignment of the output FIFO." "0,1"
        textline "        "
        bitfld.long 0x00 8. " IMSB ,Data Alignment of the input FIFO This bit will determine the data alignment of the input FIFO." "0,1"
        textline "        "
        hexmask.long.byte 0x00 9.--12. 1. " IWD ,Data Width of the input FIFO These three bits will determine the bitwidth for the audio data into ASRC All other settings not shown are reserved."
        textline "        "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 9.
group.long 0xc8++0x3
    line.long 0x00 "ASRMCR1C,ASRC Misc Control Register 1 for Pair X"
        bitfld.long 0x00 0. " OW16 ,Bit Width Option of the output FIFO This bit will determine the bit width option of the output FIFO." "0,1"
        textline "        "
        bitfld.long 0x00 1. " OSGN ,Sign Extension Option of the output FIFO This bit will determine the sign extension option of the output FIFO." "0,1"
        textline "        "
        bitfld.long 0x00 2. " OMSB ,Data Alignment of the output FIFO This bit will determine the data alignment of the output FIFO." "0,1"
        textline "        "
        bitfld.long 0x00 8. " IMSB ,Data Alignment of the input FIFO This bit will determine the data alignment of the input FIFO." "0,1"
        textline "        "
        hexmask.long.byte 0x00 9.--12. 1. " IWD ,Data Width of the input FIFO These three bits will determine the bitwidth for the audio data into ASRC All other settings not shown are reserved."
        textline "        "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"


tree.end



;--------------------------------------------------------------------------------
; AUDMUX
;--------------------------------------------------------------------------------
tree "AUDMUX"
    base ad:0x021d8000

width 6.
group.long 0x0++0x3
    line.long 0x00 "PTCR1,Port Timing Control Register 1"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0x4++0x3
    line.long 0x00 "PDCR1,Port Data Control Register 1"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."
width 6.
group.long 0x8++0x3
    line.long 0x00 "PTCR2,Port Timing Control Register 2"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0xc++0x3
    line.long 0x00 "PDCR2,Port Data Control Register 2"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."
width 6.
group.long 0x10++0x3
    line.long 0x00 "PTCR3,Port Timing Control Register 3"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0x14++0x3
    line.long 0x00 "PDCR3,Port Data Control Register 3"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."
width 6.
group.long 0x18++0x3
    line.long 0x00 "PTCR4,Port Timing Control Register 4"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0x1c++0x3
    line.long 0x00 "PDCR4,Port Data Control Register 4"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."
width 6.
group.long 0x20++0x3
    line.long 0x00 "PTCR5,Port Timing Control Register 5"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0x24++0x3
    line.long 0x00 "PDCR5,Port Data Control Register 5"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."
width 6.
group.long 0x28++0x3
    line.long 0x00 "PTCR6,Port Timing Control Register 6"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0x2c++0x3
    line.long 0x00 "PDCR6,Port Data Control Register 6"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."
width 6.
group.long 0x30++0x3
    line.long 0x00 "PTCR7,Port Timing Control Register 7"
        bitfld.long 0x00 11. " SYN ,Synchronous/Asynchronous Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RCSEL ,Receive Clock Select."
        textline "     "
        bitfld.long 0x00 16. " RCLKDIR ,Receive Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " RFSEL ,Receive Frame Sync Select."
        textline "     "
        bitfld.long 0x00 21. " RFS_DIR ,Receive Frame Sync Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 22.--26. 1. " TCSEL ,Transmit Clock Select."
        textline "     "
        bitfld.long 0x00 26. " TCLKDIR ,Transmit Clock Direction Control." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--31. 1. " TFSEL ,Transmit Frame Sync Select."
        textline "     "
        bitfld.long 0x00 31. " TFS_DIR ,Transmit Frame Sync Direction Control." "0,1"
width 6.
group.long 0x34++0x3
    line.long 0x00 "PDCR7,Port Data Control Register 7"
        hexmask.long.byte 0x00 0.--8. 1. " INMMASK ,Internal Network Mode Mask."
        textline "     "
        bitfld.long 0x00 8. " MODE ,Mode Select." "0,1"
        textline "     "
        bitfld.long 0x00 12. " TXRXEN ,Transmit/Receive Switch Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 13.--16. 1. " RXDSEL ,Receive Data Select."


tree.end



;--------------------------------------------------------------------------------
; CCM
;--------------------------------------------------------------------------------
tree "CCM"
    base ad:0x020c4000

width 4.
group.long 0x0++0x3
    line.long 0x00 "CCR,CCM Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " OSCNT ,Oscillator ready counter value."
        textline "   "
        bitfld.long 0x00 12. " COSC_EN ,On chip oscillator enable bit - this bit value is reflected on the output cosc_en." "0,1"
        textline "   "
        hexmask.long.byte 0x00 16.--19. 1. " WB_COUNT ,Well Bias counter."
        textline "   "
        hexmask.long.byte 0x00 21.--27. 1. " REG_BYPASS_COUNT ,Counter for analog_reg_bypass signal assertion after standby voltage request by pmic_vstby_req."
        textline "   "
        bitfld.long 0x00 27. " RBC_EN ,Enable for REG_BYPASS_COUNTER." "0,1"
width 5.
group.long 0x4++0x3
    line.long 0x00 "CCDR,CCM Control Divider Register"
        bitfld.long 0x00 16. " MMDC_CH1_MASK ,During divider ratio mmdc_ch1_axi_podf change or sync mux periph2_clk_sel change (but not jtag) or SRC request during warm reset, mask handshake with mmdc_ch1 module." "0,1"
        textline "    "
        bitfld.long 0x00 17. " MMDC_CH0_MASK ,During divider ratio mmdc_ch0_axi_podf change or sync mux periph_clk_sel change (but not jtag) or SRC request during warm reset, mask handshake with mmdc_ch0 module." "0,1"
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "CSR,CCM Status Register"
        bitfld.long 0x00 0. " REF_EN_B ,Status of the value of CCM_REF_EN_B output of ccm" "0,1"
        textline "   "
        bitfld.long 0x00 5. " COSC_READY ,Status indication of on board oscillator." "0,1"
width 5.
group.long 0xc++0x3
    line.long 0x00 "CCSR,CCM Clock Swither Register"
        bitfld.long 0x00 0. " PLL3_SW_CLK_SEL ,Selects source to generate pll3_sw_clk." "0,1"
        textline "    "
        bitfld.long 0x00 1. " PLL2_SW_CLK_SEL ,Selects source to generate pll2_sw_clk." "0,1"
        textline "    "
        bitfld.long 0x00 2. " PLL1_SW_CLK_SEL ,Selects source to generate pll1_sw_clk." "0,1"
        textline "    "
        bitfld.long 0x00 8. " STEP_SEL ,Selects the option to be chosen for the step frequency when shifting ARM frequency." "0,1"
        textline "    "
        bitfld.long 0x00 9. " PDF_396M_DIS_MASK ,Mask of 396M PFD auto-disable." "0,1"
        textline "    "
        bitfld.long 0x00 10. " PDF_307M_DIS_MASK ,Mask of 307M PFD auto-disable." "0,1"
        textline "    "
        bitfld.long 0x00 11. " PDF_528M_DIS_MASK ,Mask of 528M PFD auto-disable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " PDF_508M_DIS_MASK ,Mask of 508M PFD auto-disable." "0,1"
        textline "    "
        bitfld.long 0x00 15. " PDF_540M_DIS_MASK ,Mask of 540M PFD auto-disable." "0,1"
width 6.
group.long 0x10++0x3
    line.long 0x00 "CACRR,CCM Arm Clock Root Register"
        hexmask.long.byte 0x00 0.--3. 1. " ARM_PODF ,Divider for ARM clock root."
width 6.
group.long 0x14++0x3
    line.long 0x00 "CBCDR,CCM Bus Clock Divider Register"
        hexmask.long.byte 0x00 0.--3. 1. " PERIPH2_CLK2_PODF ,Divider for periph2_clk2 podf."
        textline "     "
        hexmask.long.byte 0x00 3.--6. 1. " MMDC_CH1_AXI_PODF ,Divider for mmdc_ch1_axi podf."
        textline "     "
        bitfld.long 0x00 6. " AXI_SEL ,AXI clock source select" "0,1"
        textline "     "
        bitfld.long 0x00 7. " AXI_ALT_SEL ,AXI alternative clock select" "0,1"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " IPG_PODF ,Divider for ipg podf."
        textline "     "
        hexmask.long.byte 0x00 10.--13. 1. " AHB_PODF ,Divider for ahb podf."
        textline "     "
        hexmask.long.byte 0x00 16.--19. 1. " AXI_PODF ,Divider for axi podf."
        textline "     "
        hexmask.long.byte 0x00 19.--22. 1. " MMDC_CH0_AXI_PODF ,Divider for mmdc_ch0_axi podf."
        textline "     "
        bitfld.long 0x00 25. " PERIPH_CLK_SEL ,Selector for peripheral main clock (source of mmdc_ch0_axi_clk_root)." "0,1"
        textline "     "
        bitfld.long 0x00 26. " PERIPH2_CLK_SEL ,Selector for peripheral2 main clock (source of mmdc_ch1_axi_clk_root )." "0,1"
        textline "     "
        hexmask.long.byte 0x00 27.--30. 1. " PERIPH_CLK2_PODF ,Divider for periph2 clock podf."
width 6.
group.long 0x18++0x3
    line.long 0x00 "CBCMR,CCM Bus Clock Multiplexer Register"
        hexmask.long.byte 0x00 4.--6. 1. " GPU3D_CORE_CLK_SEL ,Selector for gpu3d_core clock multiplexer"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " GPU2D_CORE_SEL ,Selector for gpu2d_core clock multiplexer"
        textline "     "
        bitfld.long 0x00 10. " PCIE_AXI_CLK_SEL ,Selector for pcie_axi clock multiplexer" "0,1"
        textline "     "
        bitfld.long 0x00 11. " VDOAXI_CLK_SEL ,Selector for vdoaxi clock multiplexer" "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " PERIPH_CLK2_SEL ,Selector for peripheral clk2 clock multiplexer"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " VPU_AXI_CLK_SEL ,Selector for VPU axi clock multiplexer"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " GPU2D_CLK_SEL ,Selector for open vg clock multiplexer"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " PRE_PERIPH_CLK_SEL ,Selector for pre_periph clock multiplexer"
        textline "     "
        bitfld.long 0x00 20. " PERIPH2_CLK2_SEL ,Selector for periph2_clk2 clock multiplexer" "0,1"
        textline "     "
        hexmask.long.byte 0x00 21.--23. 1. " PRE_PERIPH2_CLK_SEL ,Selector for pre_periph2 clock multiplexer"
        textline "     "
        hexmask.long.byte 0x00 23.--26. 1. " MLB_SYS_CLK_PODF ,Divider for mlb_sys clock."
        textline "     "
        hexmask.long.byte 0x00 26.--29. 1. " GPU3D_CORE_PODF ,Divider for gpu3d_core_podf."
        textline "     "
        hexmask.long.byte 0x00 29.--32. 1. " GPU2D_CORE_PODF ,Divider for gpu2d_core clock."
width 7.
group.long 0x1c++0x3
    line.long 0x00 "CSCMR1,CCM Serial Clock Multiplexer Register 1"
        hexmask.long.byte 0x00 0.--6. 1. " PERCLK_PODF ,Divider for perclk podf."
        textline "      "
        hexmask.long.byte 0x00 10.--12. 1. " SSI1_CLK_SEL ,Selector for ssi1 clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 12.--14. 1. " SSI2_CLK_SEL ,Selector for ssi2 clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 14.--16. 1. " SSI3_CLK_SEL ,Selector for ssi3 clock multiplexer"
        textline "      "
        bitfld.long 0x00 16. " USDHC1_CLK_SEL ,Selector for usdhc1 clock multiplexer" "0,1"
        textline "      "
        bitfld.long 0x00 17. " USDHC2_CLK_SEL ,Selector for usdhc2 clock multiplexer" "0,1"
        textline "      "
        bitfld.long 0x00 18. " USDHC3_CLK_SEL ,Selector for usdhc3 clock multiplexer" "0,1"
        textline "      "
        bitfld.long 0x00 19. " USDHC4_CLK_SEL ,Selector for usdhc4 clock multiplexer" "0,1"
        textline "      "
        hexmask.long.byte 0x00 20.--23. 1. " ACLK_PODF ,Divider for aclk clock root."
        textline "      "
        hexmask.long.byte 0x00 23.--26. 1. " ACLK_EIM_SLOW_PODF ,Divider for aclk_eim_slow clock root."
        textline "      "
        hexmask.long.byte 0x00 27.--29. 1. " ACLK_SEL ,Selector for aclk root clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 29.--31. 1. " ACLK_EIM_SLOW_SEL ,Selector for aclk_eim_slow root clock multiplexer"
width 7.
group.long 0x20++0x3
    line.long 0x00 "CSCMR2,CCM Serial Clock Multiplexer Register 2"
        hexmask.long.byte 0x00 2.--8. 1. " CAN_CLK_PODF ,Divider for can clock podf."
        textline "      "
        bitfld.long 0x00 10. " LDB_DI0_IPU_DIV ,Control for divider of ldb clock for IPU di0" "0,1"
        textline "      "
        bitfld.long 0x00 11. " LDB_DI1_IPU_DIV ,Control for divider of ldb clock for IPU di1" "0,1"
        textline "      "
        hexmask.long.byte 0x00 19.--21. 1. " ESAI_CLK_SEL ,Selector for esai clock multiplexer"
width 7.
group.long 0x24++0x3
    line.long 0x00 "CSCDR1,CCM Serial Clock Divider Register 1"
        hexmask.long.byte 0x00 0.--6. 1. " UART_CLK_PODF ,Divider for uart clock podf."
        textline "      "
        hexmask.long.byte 0x00 11.--14. 1. " USDHC1_PODF ,Divider for usdhc1 clock podf."
        textline "      "
        hexmask.long.byte 0x00 16.--19. 1. " USDHC2_PODF ,Divider for usdhc2 clock."
        textline "      "
        hexmask.long.byte 0x00 19.--22. 1. " USDHC3_PODF ,Divider for usdhc3 clock podf."
        textline "      "
        hexmask.long.byte 0x00 22.--25. 1. " USDHC4_PODF ,Divider for esdhc4 clock pred."
        textline "      "
        hexmask.long.byte 0x00 25.--28. 1. " VPU_AXI_PODF ,Divider for vpu axi clock podf."
width 7.
group.long 0x28++0x3
    line.long 0x00 "CS1CDR,CCM SSI1 Clock Divider Register"
        hexmask.long.byte 0x00 0.--6. 1. " SSI1_CLK_PODF ,Divider for ssi1 clock podf."
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " SSI1_CLK_PRED ,Divider for ssi1 clock pred."
        textline "      "
        hexmask.long.byte 0x00 9.--12. 1. " ESAI_CLK_PRED ,Divider for esai clock pred."
        textline "      "
        hexmask.long.byte 0x00 16.--22. 1. " SSI3_CLK_PODF ,Divider for ssi3 clock podf."
        textline "      "
        hexmask.long.byte 0x00 22.--25. 1. " SSI3_CLK_PRED ,Divider for ssi3 clock pred."
        textline "      "
        hexmask.long.byte 0x00 25.--28. 1. " ESAI_CLK_PODF ,Divider for esai clock podf."
width 7.
group.long 0x2c++0x3
    line.long 0x00 "CS2CDR,CCM SSI2 Clock Divider Register"
        hexmask.long.byte 0x00 0.--6. 1. " SSI2_CLK_PODF ,Divider for ssi2 clock podf."
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " SSI2_CLK_PRED ,Divider for ssi2 clock pred."
        textline "      "
        hexmask.long.byte 0x00 9.--12. 1. " LDB_DI0_CLK_SEL ,Selector for ldb_di1 clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 12.--15. 1. " LDB_DI1_CLK_SEL ,Selector for ldb_di1 clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " ENFC_CLK_SEL ,Selector for enfc clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 18.--21. 1. " ENFC_CLK_PRED ,Divider for enfc clock pred divider."
        textline "      "
        hexmask.long.byte 0x00 21.--27. 1. " ENFC_CLK_PODF ,Divider for enfc clock divider."
width 6.
group.long 0x30++0x3
    line.long 0x00 "CDCDR,CCM D1 Clock Divider Register"
        hexmask.long.byte 0x00 7.--9. 1. " SPDIF1_CLK_SEL ,Selector for spdif1 clock multiplexer"
        textline "     "
        hexmask.long.byte 0x00 9.--12. 1. " SPDIF1_CLK_PODF ,Divider for spdif1 clock podf."
        textline "     "
        hexmask.long.byte 0x00 12.--15. 1. " SPDIF1_CLK_PRED ,Divider for spdif1 clock pred."
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " SPDIF0_CLK_SEL ,Selector for spdif0 clock multiplexer"
        textline "     "
        hexmask.long.byte 0x00 22.--25. 1. " SPDIF0_CLK_PODF ,Divider for spdif0 clock podf."
        textline "     "
        hexmask.long.byte 0x00 25.--28. 1. " SPDIF0_CLK_PRED ,Divider for spdif0 clock pred."
        textline "     "
        bitfld.long 0x00 28. " HSI_TX_CLK_SEL ,Selector for hsi_tx clock multiplexer" "0,1"
        textline "     "
        hexmask.long.byte 0x00 29.--32. 1. " HSI_TX_PODF ,Divider for hsi_tx clock podf."
width 8.
group.long 0x34++0x3
    line.long 0x00 "CHSCCDR,CCM HSC Clock Divider Register"
        hexmask.long.byte 0x00 0.--3. 1. " IPU1_DI0_CLK_SEL ,Selector for ipu1 di0 root clock multiplexer"
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " IPU1_DI0_PODF ,Divider for ipu1_di0 clock divider."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " IPU1_DI0_PRE_CLK_SEL ,Selector for ipu1 di0 root clock pre-multiplexer"
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " IPU1_DI1_CLK_SEL ,Selector for ipu1 di1 root clock multiplexer"
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " IPU1_DI1_PODF ,Divider for ipu1_di clock divider."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " IPU1_DI1_PRE_CLK_SEL ,Selector for ipu1 di1 root clock pre-multiplexer"
width 7.
group.long 0x38++0x3
    line.long 0x00 "CSCDR2,CCM Serial Clock Divider Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " LCDIF_PIX_CLK_SEL ,Selector for lcdif_pix root clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 3.--6. 1. " LCDIF_PIX_PODF ,Divider for lcdif_pix clock divider."
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " LCDIF_PIX_PRE_CLK_SEL ,Selector for lcdif_pix root clock pre-multiplexer"
        textline "      "
        hexmask.long.byte 0x00 9.--12. 1. " EPDC_PIX_CLK_SEL ,Selector for epdc_pix root clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 12.--15. 1. " EPDC_PIX_PODF ,Divider for epdc_pix clock divider."
        textline "      "
        hexmask.long.byte 0x00 15.--18. 1. " EPDC_PIX_PRE_CLK_SEL ,Selector for epdc_pix root clock pre-multiplexer"
        textline "      "
        hexmask.long.byte 0x00 19.--25. 1. " ECSPI_CLK_PODF ,Divider for ecspi clock podf."
width 7.
group.long 0x3c++0x3
    line.long 0x00 "CSCDR3,CCM Serial Clock Divider Register 3"
        hexmask.long.byte 0x00 9.--11. 1. " IPU1_HSP_CLK_SEL ,Selector for ipu1_hsp clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 11.--14. 1. " IPU1_HSP_PODF ,Divider for ipu1_hsp clock."
        textline "      "
        hexmask.long.byte 0x00 14.--16. 1. " EPDC_CLK_SEL ,Selector for epdc_axi, lcdif_axi, and pxp_axi clock multiplexer"
        textline "      "
        hexmask.long.byte 0x00 16.--19. 1. " EPDC_PODF ,Divider for epdc_axi, lcdif_axi, and pxp_axi clock."
width 5.
group.long 0x44++0x3
    line.long 0x00 "CWDR,CCM Wakeup Detector Register"
width 7.
rgroup.long 0x48++0x3
    line.long 0x00 "CDHIPR,CCM Divider Handshake In-Process Register"
        bitfld.long 0x00 0. " AXI_PODF_BUSY ,Busy indicator for axi_podf." "0,1"
        textline "      "
        bitfld.long 0x00 1. " AHB_PODF_BUSY ,Busy indicator for ahb_podf." "0,1"
        textline "      "
        bitfld.long 0x00 2. " MMDC_CH1_PODF_BUSY ,Busy indicator for mmdc_ch1_axi_podf." "0,1"
        textline "      "
        bitfld.long 0x00 3. " PERIPH2_CLK_SEL_BUSY ,Busy indicator for periph2_clk_sel mux control." "0,1"
        textline "      "
        bitfld.long 0x00 4. " MMDC_CH0_PODF_BUSY ,Busy indicator for mmdc_ch0_axi_podf." "0,1"
        textline "      "
        bitfld.long 0x00 5. " PERIPH_CLK_SEL_BUSY ,Busy indicator for periph_clk_sel mux control." "0,1"
        textline "      "
        bitfld.long 0x00 16. " ARM_PODF_BUSY ,Busy indicator for arm_podf." "0,1"
width 5.
group.long 0x50++0x3
    line.long 0x00 "CTOR,CCM Testing Observability Register"
        hexmask.long.byte 0x00 0.--4. 1. " OBS_SPARE_OUTPUT_2_SEL ,Selection of the signal to be generated on obs_output_2 (output of CCM) for observability on the pads."
        textline "    "
        hexmask.long.byte 0x00 4.--8. 1. " OBS_SPARE_OUTPUT_1_SEL ,Selection of the signal to be generated on obs_output_1 (output of CCM) for observability on the pads."
        textline "    "
        hexmask.long.byte 0x00 8.--13. 1. " OBS_SPARE_OUTPUT_0_SEL ,Selection of the signal to be generated on obs_output_0 (output of CCM) for observability on the pads."
        textline "    "
        bitfld.long 0x00 13. " OBS_EN ,observability enable bit." "0,1"
width 6.
group.long 0x54++0x3
    line.long 0x00 "CLPCR,CCM Low Power Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " LPM ,Setting the low power mode that system will enter on next assertion of dsm_request signal."
        textline "     "
        bitfld.long 0x00 2. " BYPASS_PMIC_VFUNCTIONAL_READY ,By asserting this bit CCM will bypass waiting for pmic_vfunctional_ready signal when coming out of STOP mode." "0,1"
        textline "     "
        bitfld.long 0x00 5. " ARM_CLK_DIS_ON_LPM ,Define if ARM clocks (arm_clk, soc_mxclk, soc_pclk, soc_dbg_pclk, vl_wrck) will be disabled on wait mode." "0,1"
        textline "     "
        bitfld.long 0x00 6. " SBYOS ,Standby clock oscillator bit." "0,1"
        textline "     "
        bitfld.long 0x00 7. " DIS_REF_OSC ,dis_ref_osc - in run mode, software can manually control closing of external reference oscillator clock, i.e." "0,1"
        textline "     "
        bitfld.long 0x00 8. " VSTBY ,Voltage standby request bit." "0,1"
        textline "     "
        hexmask.long.byte 0x00 9.--11. 1. " STBY_COUNT ,Standby counter definition."
        textline "     "
        bitfld.long 0x00 11. " COSC_PWRDOWN ,In run mode, software can manually control powering down of on chip oscillator, i.e." "0,1"
        textline "     "
        bitfld.long 0x00 16. " WB_PER_AT_LPM ,Enable periphery charge pump for well biasing at low power mode (stop or wait)" "0,1"
        textline "     "
        bitfld.long 0x00 19. " BYPASS_MMDC_CH0_LPM_HS ,Bypass handshake with mmdc_ch0 on next entrance to low power mode (wait or stop mode)." "0,1"
        textline "     "
        bitfld.long 0x00 21. " BYPASS_MMDC_CH1_LPM_HS ,Bypass handshake with mmdc_ch1 on next entrance to low power mode (wait or stop mode)." "0,1"
        textline "     "
        bitfld.long 0x00 22. " MASK_CORE0_WFI ,Mask WFI of core0 for entering low power mode Note: assertion of all bits[27:22] will generate low power mode request" "0,1"
        textline "     "
        bitfld.long 0x00 23. " MASK_CORE1_WFI ,Mask WFI of core1 for entering low power mode Note: assertion of all bits[27:22] will generate low power mode request" "0,1"
        textline "     "
        bitfld.long 0x00 26. " MASK_SCU_IDLE ,Mask SCU IDLE for entering low power mode Note: assertion of all bits[27:22] will generate low power mode request" "0,1"
        textline "     "
        bitfld.long 0x00 27. " MASK_L2CC_IDLE ,Mask L2CC IDLE for entering low power mode." "0,1"
width 5.
group.long 0x58++0x3
    line.long 0x00 "CISR,CCM Interrupt Status Register"
        bitfld.long 0x00 0. " LRF_PLL ,Interrupt ipi_int_2 generated due to lock of all enabled and not bypaseed pll's" "0,1"
        textline "    "
        bitfld.long 0x00 6. " COSC_READY ,Interrupt ipi_int_2 generated due to on board oscillator ready, i.e." "0,1"
        textline "    "
        bitfld.long 0x00 17. " AXI_PODF_LOADED ,Interrupt ipi_int_1 generated due to frequency change of axi_a_podf" "0,1"
        textline "    "
        bitfld.long 0x00 18. " AXI_B_PODF_LOADED ,Interrupt ipi_int_1 generated due to frequency change of axi_b_podf" "0,1"
        textline "    "
        bitfld.long 0x00 19. " PERIPH2_CLK_SEL_LOADED ,Interrupt ipi_int_1 generated due to frequency change of periph2_clk_sel" "0,1"
        textline "    "
        bitfld.long 0x00 20. " AHB_PODF_LOADED ,Interrupt ipi_int_1 generated due to frequency change of ahb_podf" "0,1"
        textline "    "
        bitfld.long 0x00 21. " MMDC_CH1_PODF_LOADED ,Interrupt ipi_int_1 generated due to frequency change of mmdc_ch0_podf_ loaded" "0,1"
        textline "    "
        bitfld.long 0x00 22. " PERIPH_CLK_SEL_LOADED ,Interrupt ipi_int_1 generated due to update of periph_clk_sel." "0,1"
        textline "    "
        bitfld.long 0x00 23. " MMDC_CH0_PODF_LOADED ,Interrupt ipi_int_1 generated due to update of mmdc_ch0_axi_podf." "0,1"
        textline "    "
        bitfld.long 0x00 26. " ARM_PODF_LOADED ,Interrupt ipi_int_1 generated due to frequency change of arm_podf." "0,1"
width 5.
group.long 0x5c++0x3
    line.long 0x00 "CIMR,CCM Interrupt Mask Register"
        bitfld.long 0x00 0. " MASK_LRF_PLL ,mask interrupt generation due to lrf of pll's" "0,1"
        textline "    "
        bitfld.long 0x00 6. " MASK_COSC_READY ,mask interrupt generation due to on board oscillator ready" "0,1"
        textline "    "
        bitfld.long 0x00 17. " MASK_AXI_PODF_LOADED ,mask interrupt generation due to frequency change of axi_podf" "0,1"
        textline "    "
        bitfld.long 0x00 18. " MASK_AXI_B_PODF_LOADED ,mask interrupt generation due to frequency change of axi_b_podf" "0,1"
        textline "    "
        bitfld.long 0x00 19. " MASK_PERIPH2_CLK_SEL_LOADED ,mask interrupt generation due to update of periph2_clk_sel." "0,1"
        textline "    "
        bitfld.long 0x00 20. " MASK_AHB_PODF_LOADED ,mask interrupt generation due to frequency change of ahb_podf" "0,1"
        textline "    "
        bitfld.long 0x00 21. " MASK_MMDC_CH1_PODF_LOADED ,mask interrupt generation due to update of mask_mmdc_ch1_podf" "0,1"
        textline "    "
        bitfld.long 0x00 22. " MASK_PERIPH_CLK_SEL_LOADED ,mask interrupt generation due to update of periph_clk_sel." "0,1"
        textline "    "
        bitfld.long 0x00 23. " MASK_MMDC_CH0_PODF_LOADED ,mask interrupt generation due to update of mask_mmdc_ch0_podf" "0,1"
        textline "    "
        bitfld.long 0x00 26. " ARM_PODF_LOADED ,mask interrupt generation due to frequency change of arm_podf" "0,1"
width 6.
group.long 0x60++0x3
    line.long 0x00 "CCOSR,CCM Clock Output Source Register"
        hexmask.long.byte 0x00 0.--4. 1. " CLKO1_SEL ,Selection of the clock to be generated on CCM_CLKO1"
        textline "     "
        hexmask.long.byte 0x00 4.--7. 1. " CLKO1_DIV ,Setting the divider of CCM_CLKO1"
        textline "     "
        bitfld.long 0x00 7. " CLKO1_EN ,Enable of CCM_CLKO1 clock" "0,1"
        textline "     "
        bitfld.long 0x00 8. " CLKO_SEL ,CCM_CLKO1 output to reflect CCM_CLKO1 or CCM_CLKO2 clocks" "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--21. 1. " CLKO2_SEL ,Selection of the clock to be generated on CCM_CLKO2"
        textline "     "
        hexmask.long.byte 0x00 21.--24. 1. " CLKO2_DIV ,Setting the divider of CCM_CLKO2"
        textline "     "
        bitfld.long 0x00 24. " CLKO2_EN ,Enable of CCM_CLKO2 clock" "0,1"
width 5.
group.long 0x64++0x3
    line.long 0x00 "CGPR,CCM General Purpose Register"
        bitfld.long 0x00 0. " PMIC_DELAY_SCALER ,Defines clock dividion of clock for stby_count (pmic delay counter)" "0,1"
        textline "    "
        bitfld.long 0x00 2. " MMDC_EXT_CLK_DIS ,Disable external clock driver of MMDC during STOP mode" "0,1"
        textline "    "
        bitfld.long 0x00 4. " EFUSE_PROG_SUPPLY_GATE ,Defines the value of the output signal cgpr_dout[4]." "0,1"
        textline "    "
        bitfld.long 0x00 16. " FPL ," "0,1"
width 6.
group.long 0x68++0x3
    line.long 0x00 "CCGR0,CCM Clock Gating Register 0"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,aips_tz1 clocks (aips_tz1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,aips_tz2 clocks (aips_tz2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,apbhdma hclk clock (apbhdma_hclk_enable)"
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,asrc clock (asrc_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,caam_secure_mem clock (caam_secure_mem_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,caam_wrapper_aclk clock (caam_wrapper_aclk_enable)"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,caam_wrapper_ipg clock (caam_wrapper_ipg_enable)"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,can1 clock (can1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,can1_serial clock (can1_serial_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,can2 clock (can2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,can2_serial clock (can2_serial_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,CPU debug clocks (arm_dbg_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,dcic 1 clocks (dcic1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,dcic2 clocks (dcic2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,dtcp clocks (dtcp_dtcp_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,Reserved"
width 6.
group.long 0x6c++0x3
    line.long 0x00 "CCGR1,CCM Clock Gating Register 1"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,ecspi1 clocks (ecspi1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,ecspi2 clocks (ecspi2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,ecspi3 clocks (ecspi3_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,ecspi4 clocks (ecspi4_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,ecspi5 clocks (ecspi5_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,clock (enet_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,epit1 clocks (epit1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,epit2 clocks (epit2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,esai clocks (esai_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,gpt bus clock (gpt_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,gpt serial clock (gpt_serial_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,gpu2d clock (gpu2d_clk_enable) GPU2D clock cannot be gated without gating OPENVG clock as well."
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,gpu3d clock (gpu3d_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,Reserved"
width 6.
group.long 0x70++0x3
    line.long 0x00 "CCGR2,CCM Clock Gating Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,hdmi_tx_iahbclk, hdmi_tx_ihclk clock (hdmi_tx_iahbclk_enable)"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,hdmi_tx_isfrclk clock (hdmi_tx_isfrclk_enable)"
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,i2c1_serial clock (i2c1_serial_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,i2c2_serial clock (i2c2_serial_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,i2c3_serial clock (i2c3_serial_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,OCOTP_CTRL clock (iim_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,iomux_ipt_clk_io clock (iomux_ipt_clk_io_enable)"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,ipmux1 clock (ipmux1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,ipmux2 clock (ipmux2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,ipmux3 clock (ipmux3_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,ipsync_ip2apb_tzasc1_ipg clocks (ipsync_ip2apb_tzasc1_ipg_master_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,ipsync_vdoa_ipg clocks (ipsync_ip2apb_tzasc2_ipg clocks)"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,ipsync_vdoa_ipg clocks (ipsync_vdoa_ipg_master_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,Reserved"
width 6.
group.long 0x74++0x3
    line.long 0x00 "CCGR3,CCM Clock Gating Register 3"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,ipu1_ipu clock (ipu1_ipu_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,ipu1_ipu_di0 clock (ipu1_ipu_di0_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,ipu1_ipu_di1 clock (ipu1_ipu_di1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,epdc/lcdif/pxp clock (epdc_axi_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,lcdif_pix clock (lcdif_pix_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,epdc_pix clock (epdc_pix_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,ldb_di0 clock (ldb_di0_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,ldb_di1 clock (ldb_di1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,mipi_core_cfg clock (mipi_core_cfg_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,mlb clock (mlb_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,mmdc_core_aclk_fast_core_p0 clock (mmdc_core_aclk_fast_core_p0_enable)"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,mmdc_core_aclk_fast_core_p1 clock (mmdc_core_aclk_fast_core_p1_enable)"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,mmdc_core_ipg_clk_p0 clock (mmdc_core_ipg_clk_p0_enable)"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,mmdc_core_ipg_clk_p1 clock (mmdc_core_ipg_clk_p1_enable)"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,ocram clock (ocram_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,openvgaxiclk clock (openvgaxiclk_clk_root_enable) OPENVG clock cannot be gated without gating GPU2D clock as well."
width 6.
group.long 0x78++0x3
    line.long 0x00 "CCGR4,CCM Clock Gating Register 4"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,125M clocks (125M_root_enable)"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,Reserved."
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,Reserved."
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,Reserved."
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,pl301_mx6qfast1_s133 clock (pl301_mx6qfast1_s133clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,pl301_mx6qper1_bch clocks (pl301_mx6qper1_bchclk_enable)"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,pl301_mx6qper2_mainclk_enable (pl301_mx6qper2_mainclk_enable)"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,pwm1 clocks (pwm1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,pwm2 clocks (pwm2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,pwm3 clocks (pwm3_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,pwm4 clocks (pwm4_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,rawnand_u_bch_input_apb clock (rawnand_u_bch_input_apb_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,rawnand_u_gpmi_bch_input_bch clock (rawnand_u_gpmi_bch_input_bch_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,rawnand_u_gpmi_bch_input_gpmi_io clock (rawnand_u_gpmi_bch_input_gpmi_io_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,rawnand_u_gpmi_input_apb clock rawnand_u_gpmi_input_apb_clk_enable)"
width 6.
group.long 0x7c++0x3
    line.long 0x00 "CCGR5,CCM Clock Gating Register 5"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,rom clock (rom_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,100M clock (100M_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,sdma clock (sdma_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,spba clock (spba_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,spdif clock (spdif_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,ssi1 clocks (ssi1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,ssi2 clocks (ssi2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,ssi3 clocks (ssi3_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,uart clock (uart_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,uart_serial clock (uart_serial_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,Reserved"
width 6.
group.long 0x80++0x3
    line.long 0x00 "CCGR6,CCM Clock Gating Register 6"
        hexmask.long.byte 0x00 0.--2. 1. " CG0 ,usboh3 clock (usboh3_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " CG1 ,usdhc1 clocks (usdhc1_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " CG2 ,usdhc2 clocks (usdhc2_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 6.--8. 1. " CG3 ,usdhc3 clocks (usdhc3_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 8.--10. 1. " CG4 ,usdhc4 clocks (usdhc4_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 10.--12. 1. " CG5 ,eim_slow clocks (eim_slow_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 12.--14. 1. " CG6 ,vdoaxiclk root clock (vdoaxiclk_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " CG7 ,vpu clocks (vpu_clk_enable)"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CG8 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " CG9 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 20.--22. 1. " CG10 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 22.--24. 1. " CG11 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " CG12 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " CG13 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " CG14 ,Reserved"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " CG15 ,Reserved"
width 6.
group.long 0x88++0x3
    line.long 0x00 "CMEOR,CCM Module Enable Overide Register"
        bitfld.long 0x00 4. " MOD_EN_OV_VDOA ,overide clock enable signal from vdoa - clock will not be gated based on vdoa signal." "0,1"
        textline "     "
        bitfld.long 0x00 5. " MOD_EN_OV_GPT ,overide clock enable signal from gpt - clock will not be gated based on gpt's signal 'ipg_enable_clk' ." "0,1"
        textline "     "
        bitfld.long 0x00 6. " MOD_EN_OV_EPIT ,overide clock enable signal from epit - clock will not be gated based on epit's signal 'ipg_enable_clk' ." "0,1"
        textline "     "
        bitfld.long 0x00 7. " MOD_EN_USDHC ,overide clock enable signal from usdhc." "0,1"
        textline "     "
        bitfld.long 0x00 8. " MOD_EN_OV_DAP ,overide clock enable signal from dap- clock will not be gated based on dap's signal 'dap_dbgen' ." "0,1"
        textline "     "
        bitfld.long 0x00 9. " MOD_EN_OV_VPU ,overide clock enable signal from vpu- clock will not be gated based on vpu's signal 'vpu_idle' ." "0,1"
        textline "     "
        bitfld.long 0x00 10. " MOD_EN_OV_GPU2D ,overide clock enable signal from gpu2d - clock will not be gated based on gpu2d's signal 'gpu2d_busy' ." "0,1"
        textline "     "
        bitfld.long 0x00 11. " MOD_EN_OV_GPU3D ,overide clock enable signal from gpu3d - clock will not be gated based on gpu3d's signal." "0,1"
        textline "     "
        bitfld.long 0x00 28. " MOD_EN_OV_CAN2_CPI ,overide clock enable signal from can2 - clock will not be gated based on can's signal 'enable_clk_cpi'." "0,1"
        textline "     "
        bitfld.long 0x00 30. " MOD_EN_OV_CAN1_CPI ,overide clock enable signal from can1 - clock will not be gated based on can's signal 'enable_clk_cpi'." "0,1"


tree.end



;--------------------------------------------------------------------------------
; CCM_ANALOG
;--------------------------------------------------------------------------------
tree "CCM_ANALOG"
    base ad:0x020c8000

width 8.
group.long 0x0++0x3
    line.long 0x00 "PLL_ARM,Analog ARM PLL control Register"
        hexmask.long.byte 0x00 0.--7. 1. " DIV_SELECT ,This field controls the pll loop divider."
        textline "       "
        bitfld.long 0x00 12. " POWERDOWN ,Powers down the PLL." "0,1"
        textline "       "
        bitfld.long 0x00 13. " ENABLE ,Enable the clock output." "0,1"
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "       "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "       "
        bitfld.long 0x00 17. " LVDS_SEL ,Analog Debug Bit" "0,1"
        textline "       "
        bitfld.long 0x00 18. " LVDS_24MHZ_SEL ,Analog Debug Bit" "0,1"
        textline "       "
        bitfld.long 0x00 19. " PLL_SEL ,Reserved" "0,1"
        textline "       "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked." "0,1"
width 9.
group.long 0x10++0x3
    line.long 0x00 "PLL_USB1,Analog USB1 480MHz PLL Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " DIV_SELECT ,This field controls the pll loop divider."
        textline "        "
        bitfld.long 0x00 6. " EN_USB_CLKS ,Powers the 9-phase PLL outputs for USBPHYn." "0,1"
        textline "        "
        bitfld.long 0x00 12. " POWER ,Powers up the PLL." "0,1"
        textline "        "
        bitfld.long 0x00 13. " ENABLE ,Enable the PLL clock output." "0,1"
        textline "        "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "        "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "        "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked." "0,1"
width 9.
group.long 0x20++0x3
    line.long 0x00 "PLL_USB2,Analog USB2 480MHz PLL Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " DIV_SELECT ,This field controls the pll loop divider."
        textline "        "
        bitfld.long 0x00 6. " EN_USB_CLKS ,0: 8-phase PLL outputs for USBPHY1 are powered down." "0,1"
        textline "        "
        bitfld.long 0x00 12. " POWER ,Powers up the PLL." "0,1"
        textline "        "
        bitfld.long 0x00 13. " ENABLE ,Enable the PLL clock output." "0,1"
        textline "        "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "        "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "        "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked." "0,1"
width 8.
group.long 0x30++0x3
    line.long 0x00 "PLL_SYS,Analog System PLL Control Register"
        bitfld.long 0x00 0. " DIV_SELECT ,This field controls the pll loop divider." "0,1"
        textline "       "
        bitfld.long 0x00 12. " POWERDOWN ,Powers down the PLL." "0,1"
        textline "       "
        bitfld.long 0x00 13. " ENABLE ,Enable PLL output" "0,1"
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "       "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "       "
        bitfld.long 0x00 18. " PFD_OFFSET_EN ,Enables an offset in the phase frequency detector." "0,1"
        textline "       "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked; 0 - PLL is not currently locked." "0,1"
width 11.
group.long 0x40++0x3
    line.long 0x00 "PLL_SYS_SS,528MHz System PLL Spread Spectrum Register."
        hexmask.long.word 0x00 0.--15. 1. " STEP ,frequency change step = step/B*24MHz."
        textline "          "
        bitfld.long 0x00 15. " ENABLE ,This bit enables the spread spectrum modulation." "0,1"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " STOP ,Frequency change = stop/B*24MHz."
width 12.
group.long 0x50++0x3
    line.long 0x00 "PLL_SYS_NUM,Numerator of 528MHz System PLL Fractional Loop Divider Register"
        hexmask.long.long 0x00 0.--30. 1. " A ,30 bit numerator (A) of fractional loop divider (signed integer)."
width 14.
group.long 0x60++0x3
    line.long 0x00 "PLL_SYS_DENOM,Denominator of 528MHz System PLL Fractional Loop Divider Register"
        hexmask.long.long 0x00 0.--30. 1. " B ,30 bit Denominator (B) of fractional loop divider (unsigned integer)."
width 10.
group.long 0x70++0x3
    line.long 0x00 "PLL_AUDIO,Analog Audio PLL control Register"
        hexmask.long.byte 0x00 0.--7. 1. " DIV_SELECT ,This field controls the pll loop divider."
        textline "         "
        bitfld.long 0x00 12. " POWERDOWN ,Powers down the PLL." "0,1"
        textline "         "
        bitfld.long 0x00 13. " ENABLE ,Enable PLL output" "0,1"
        textline "         "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "         "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "         "
        bitfld.long 0x00 18. " PFD_OFFSET_EN ,Enables an offset in the phase frequency detector." "0,1"
        textline "         "
        hexmask.long.byte 0x00 19.--21. 1. " POST_DIV_SELECT ,These bits implement a divider after the PLL, but before the enable and bypass mux."
        textline "         "
        bitfld.long 0x00 21. " SSC_EN ,Reserved Bit" "0,1"
        textline "         "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked." "0,1"
width 14.
group.long 0x80++0x3
    line.long 0x00 "PLL_AUDIO_NUM,Numerator of Audio PLL Fractional Loop Divider Register"
        hexmask.long.long 0x00 0.--30. 1. " A ,30 bit numerator of fractional loop divider."
width 16.
group.long 0x90++0x3
    line.long 0x00 "PLL_AUDIO_DENOM,Denominator of Audio PLL Fractional Loop Divider Register"
        hexmask.long.long 0x00 0.--30. 1. " B ,30 bit Denominator of fractional loop divider."
width 10.
group.long 0xa0++0x3
    line.long 0x00 "PLL_VIDEO,Analog Video PLL control Register"
        hexmask.long.byte 0x00 0.--7. 1. " DIV_SELECT ,This field controls the pll loop divider."
        textline "         "
        bitfld.long 0x00 12. " POWERDOWN ,Powers down the PLL." "0,1"
        textline "         "
        bitfld.long 0x00 13. " ENABLE ,Enalbe PLL output" "0,1"
        textline "         "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "         "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "         "
        bitfld.long 0x00 18. " PFD_OFFSET_EN ,Enables an offset in the phase frequency detector." "0,1"
        textline "         "
        hexmask.long.byte 0x00 19.--21. 1. " POST_DIV_SELECT ,These bits implement a divider after the PLL, but before the enable and bypass mux."
        textline "         "
        bitfld.long 0x00 21. " SSC_EN ,Revserved BIt" "0,1"
        textline "         "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked; 0 - PLL is not currently locked." "0,1"
width 14.
group.long 0xb0++0x3
    line.long 0x00 "PLL_VIDEO_NUM,Numerator of Video PLL Fractional Loop Divider Register"
        hexmask.long.long 0x00 0.--30. 1. " A ,30 bit numerator of fractional loop divider(Signed number), absolute value should be less than denominator"
width 16.
group.long 0xc0++0x3
    line.long 0x00 "PLL_VIDEO_DENOM,Denominator of Video PLL Fractional Loop Divider Register"
        hexmask.long.long 0x00 0.--30. 1. " B ,30 bit Denominator of fractional loop divider."
width 8.
group.long 0xd0++0x3
    line.long 0x00 "PLL_MLB,MLB PLL Control Register"
        bitfld.long 0x00 11. " HOLD_RING_OFF ,Analog debug bit." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " PHASE_SEL ,Analog debut bit."
        textline "       "
        bitfld.long 0x00 16. " BYPASS ,Bypass the PLL." "0,1"
        textline "       "
        hexmask.long.byte 0x00 17.--20. 1. " VDDA_DELAY_CFG ,Configure the phase delay of the MLB PLL by adjusting the delay line in Vddio power domain."
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " VDDD_DELAY_CFG ,Configure the phase delay of the MLB PLL by adjusting the delay line in core Vdd poser domain."
        textline "       "
        hexmask.long.byte 0x00 23.--26. 1. " RX_CLK_DELAY_CFG ,Configure the phase delay of the MLB PLL RX Clock."
        textline "       "
        hexmask.long.byte 0x00 26.--29. 1. " MLB_FLT_RES_CFG ,Configure the filter resistor for different divider ratio of MLB PLL."
        textline "       "
        bitfld.long 0x00 31. " LOCK ,Lock bit" "0,1"
width 9.
group.long 0xe0++0x3
    line.long 0x00 "PLL_ENET,Analog ENET PLL Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " DIV_SELECT ,Controls the frequency of the ethernet reference clock.00 - 25MHz; 01 - 50MHz; 10 - 100MHz (not 50% duty cycle); 11 - 125MHz;"
        textline "        "
        bitfld.long 0x00 12. " POWERDOWN ,Powers down the PLL." "0,1"
        textline "        "
        bitfld.long 0x00 13. " ENABLE ,Enable the ethernet clock output." "0,1"
        textline "        "
        hexmask.long.byte 0x00 14.--16. 1. " BYPASS_CLK_SRC ,Determines the bypass source."
        textline "        "
        bitfld.long 0x00 16. " BYPASS ,Bypass the pll." "0,1"
        textline "        "
        bitfld.long 0x00 18. " PFD_OFFSET_EN ,Enables an offset in the phase frequency detector." "0,1"
        textline "        "
        bitfld.long 0x00 19. " ENABLE_125M ,Enables an offset in the phase frequency detector." "0,1"
        textline "        "
        bitfld.long 0x00 20. " ENABLE_100M ,Enables an offset in the phase frequency detector." "0,1"
        textline "        "
        bitfld.long 0x00 31. " LOCK ,1 - PLL is currently locked; 0 - PLL is not currently locked." "0,1"
width 8.
group.long 0xf0++0x3
    line.long 0x00 "PFD_480,480MHz Clock (from PLL_USB2) Phase Fractional Divider Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " PFD0_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 6. " PFD0_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 7. " PFD0_CLKGATE ,If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--14. 1. " PFD1_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 14. " PFD1_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 15. " PFD1_CLKGATE ,IO Clock Gate." "0,1"
        textline "       "
        hexmask.long.byte 0x00 16.--22. 1. " PFD2_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 22. " PFD2_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 23. " PFD2_CLKGATE ,IO Clock Gate." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " PFD3_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 30. " PFD3_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 31. " PFD3_CLKGATE ,IO Clock Gate." "0,1"
width 8.
group.long 0x100++0x3
    line.long 0x00 "PFD_528,528MHz Clock (From PLL_SYS) Phase Fractional Divider Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " PFD0_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 6. " PFD0_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 7. " PFD0_CLKGATE ,If set to 1, the IO fractional divider clock (reference ref_pfd0) is off (power savings)." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--14. 1. " PFD1_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 14. " PFD1_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 15. " PFD1_CLKGATE ,IO Clock Gate." "0,1"
        textline "       "
        hexmask.long.byte 0x00 16.--22. 1. " PFD2_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 22. " PFD2_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 23. " PFD2_CLKGATE ,IO Clock Gate." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " PFD3_FRAC ,This field controls the fractional divide value."
        textline "       "
        bitfld.long 0x00 30. " PFD3_STABLE ,This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the fractional divider should become stable quickly enough that this field will never need to be used by either device driver or application code." "0,1"
        textline "       "
        bitfld.long 0x00 31. " PFD3_CLKGATE ,IO Clock Gate." "0,1"
width 6.
group.long 0x150++0x3
    line.long 0x00 "MISC0,Miscellaneous Control Register"
        bitfld.long 0x00 12. " STOP_MODE_CONFIG ,Configure the analog behavior in stop mode." "0,1"
width 6.
group.long 0x170++0x3
    line.long 0x00 "MISC2,Miscellaneous Control Register"
        bitfld.long 0x00 7. " PLL3_DISABLE ,Default value of ""0""." "0,1"
        textline "     "
        bitfld.long 0x00 15. " AUDIO_DIV_LSB ,LSB of Post-divider for Audio PLL." "0,1"
        textline "     "
        bitfld.long 0x00 23. " AUDIO_DIV_MSB ,MSB of Post-divider for Audio PLL." "0,1"
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " VIDEO_DIV ,Post-divider for video."


tree.end



;--------------------------------------------------------------------------------
; CSI2IPU
;--------------------------------------------------------------------------------
tree "CSI2IPU"
    base ad:0x021dc000

width 7.
group.long 0xf00++0x3
    line.long 0x00 "SW_RST,CSI 2 IPU Gasket Software Reset"
        bitfld.long 0x00 0. " SW_RST ,Software Reset" "0,1"
        textline "      "
        bitfld.long 0x00 1. " CLK_SEL ,Clock mode selection" "0,1"
        textline "      "
        bitfld.long 0x00 2. " YUV422_8BIT_FM ,YUV422 8-bit mode selection" "0,1"
        textline "      "
        bitfld.long 0x00 3. " RGB444_FM ,rgb444 mode selection" "0,1"


tree.end



;--------------------------------------------------------------------------------
; CSU
;--------------------------------------------------------------------------------
tree "CSU"
    base ad:0x021c0000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CSL0,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x4++0x3
    line.long 0x00 "CSL1,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x8++0x3
    line.long 0x00 "CSL2,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0xc++0x3
    line.long 0x00 "CSL3,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x10++0x3
    line.long 0x00 "CSL4,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x14++0x3
    line.long 0x00 "CSL5,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x18++0x3
    line.long 0x00 "CSL6,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x1c++0x3
    line.long 0x00 "CSL7,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x20++0x3
    line.long 0x00 "CSL8,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 5.
group.long 0x24++0x3
    line.long 0x00 "CSL9,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "    "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "    "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x28++0x3
    line.long 0x00 "CSL10,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x2c++0x3
    line.long 0x00 "CSL11,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x30++0x3
    line.long 0x00 "CSL12,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x34++0x3
    line.long 0x00 "CSL13,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x38++0x3
    line.long 0x00 "CSL14,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x3c++0x3
    line.long 0x00 "CSL15,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x40++0x3
    line.long 0x00 "CSL16,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x44++0x3
    line.long 0x00 "CSL17,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x48++0x3
    line.long 0x00 "CSL18,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x4c++0x3
    line.long 0x00 "CSL19,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x50++0x3
    line.long 0x00 "CSL20,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x54++0x3
    line.long 0x00 "CSL21,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x58++0x3
    line.long 0x00 "CSL22,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x5c++0x3
    line.long 0x00 "CSL23,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x60++0x3
    line.long 0x00 "CSL24,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x64++0x3
    line.long 0x00 "CSL25,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x68++0x3
    line.long 0x00 "CSL26,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x6c++0x3
    line.long 0x00 "CSL27,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x70++0x3
    line.long 0x00 "CSL28,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x74++0x3
    line.long 0x00 "CSL29,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x78++0x3
    line.long 0x00 "CSL30,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x7c++0x3
    line.long 0x00 "CSL31,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x80++0x3
    line.long 0x00 "CSL32,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x84++0x3
    line.long 0x00 "CSL33,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x88++0x3
    line.long 0x00 "CSL34,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x8c++0x3
    line.long 0x00 "CSL35,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x90++0x3
    line.long 0x00 "CSL36,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x94++0x3
    line.long 0x00 "CSL37,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x98++0x3
    line.long 0x00 "CSL38,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 6.
group.long 0x9c++0x3
    line.long 0x00 "CSL39,Config security level register"
        bitfld.long 0x00 0. " SUR_S2 ,Secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 1. " SSR_S2 ,Secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 2. " NUR_S2 ,Non-secure user read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 3. " NSR_S2 ,Non-secure supervisor read access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SUW_S2 ,Secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 5. " SSW_S2 ,Secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 6. " NUW_S2 ,Non-secure user write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 7. " NSW_S2 ,Non-secure supervisor write access control for the second slave" "0,1"
        textline "     "
        bitfld.long 0x00 8. " LOCK_S2 ,Lock bit corresponding to the second slave." "0,1"
        textline "     "
        bitfld.long 0x00 16. " SUR_S1 ,Secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 17. " SSR_S1 ,Secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 18. " NUR_S1 ,Non-secure user read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 19. " NSR_S1 ,Non-secure supervisor read access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 20. " SUW_S1 ,Secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 21. " SSW_S1 ,Secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 22. " NUW_S1 ,Non-secure user write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 23. " NSW_S1 ,Non-secure supervisor write access control for the first slave" "0,1"
        textline "     "
        bitfld.long 0x00 24. " LOCK_S1 ,Lock bit corresponding to the first slave." "0,1"
width 4.
group.long 0x200++0x3
    line.long 0x00 "HP0,HP0 register"
        bitfld.long 0x00 0. " HP_PCIE ,Indicates the Privilege/User Mode for PCIE" "0,1"
        textline "   "
        bitfld.long 0x00 1. " L_PCIE ,Lock bit set by TZ software for HP_PCIE." "0,1"
        textline "   "
        bitfld.long 0x00 2. " HP_SATA ,Indicates the Privilege/User Mode for SATA This bit field is Reserved for i.MX6SDL" "0,1"
        textline "   "
        bitfld.long 0x00 3. " L_SATA ,Lock bit set by TZ software for HP_SATA." "0,1"
        textline "   "
        bitfld.long 0x00 4. " HP_SDMA ,Indicates the Privilege/User Mode for SDMA." "0,1"
        textline "   "
        bitfld.long 0x00 5. " L_SDMA ,Lock bit set by TZ software for HP_SDMA." "0,1"
        textline "   "
        bitfld.long 0x00 6. " HP_PU ,Indicates the Privilege/User Mode for GPU3D, GPU2D, VPU, IPU1, EPDC, PXP, LCDIF and VDOA." "0,1"
        textline "   "
        bitfld.long 0x00 7. " L_PU ,Lock bit set by TZ software for HP_PU." "0,1"
        textline "   "
        bitfld.long 0x00 8. " HP_USB ,Indicates the Privilege/User Mode for USB." "0,1"
        textline "   "
        bitfld.long 0x00 9. " L_USB ,Lock bit set by TZ software for HP_USB." "0,1"
        textline "   "
        bitfld.long 0x00 10. " HP_TEST ,Indicates the Privilege/User Mode for IOMUX Test Port." "0,1"
        textline "   "
        bitfld.long 0x00 11. " L_TEST ,Lock bit set by TZ software for HP_TEST." "0,1"
        textline "   "
        bitfld.long 0x00 12. " HP_MLB ,Indicate the mode Privilege/User Mode for MLB." "0,1"
        textline "   "
        bitfld.long 0x00 13. " L_MLB ,Lock bit set by TZ software for HP_MLB." "0,1"
        textline "   "
        bitfld.long 0x00 14. " HP_CAAM ,Indicates the Privilege/User Mode for CAAM" "0,1"
        textline "   "
        bitfld.long 0x00 15. " L_CAAM ,Lock bit set by TZ software for HP_CAAM." "0,1"
        textline "   "
        bitfld.long 0x00 16. " HP_RAWNAND ,Indicates the Privilege/User Mode for RawNAND" "0,1"
        textline "   "
        bitfld.long 0x00 17. " L_RAWNAND ,Lock bit set by TZ software for HP_RAWNAND." "0,1"
        textline "   "
        bitfld.long 0x00 18. " HP_APBHDMA ,Indicates the Privilege/User Mode for APBHDMA" "0,1"
        textline "   "
        bitfld.long 0x00 19. " L_ABPHDMA ,Lock bit set by TZ software for HP_APBHDMA." "0,1"
        textline "   "
        bitfld.long 0x00 20. " HP_ENET ,Indicates the Privilege/User Mode for ENET" "0,1"
        textline "   "
        bitfld.long 0x00 21. " L_ENET ,Lock bit set by TZ software for HP_ENET." "0,1"
        textline "   "
        bitfld.long 0x00 22. " HP_DAP ,Indicates the Privilege/User Mode for DAP" "0,1"
        textline "   "
        bitfld.long 0x00 23. " L_DAP ,Lock bit set by TZ software for HP_DAP." "0,1"
        textline "   "
        bitfld.long 0x00 24. " HP_USDHC1 ,Indicates the Privilege/User Mode for USDHC1" "0,1"
        textline "   "
        bitfld.long 0x00 25. " L_USDHC1 ,Lock bit set by TZ software for HP_USDHC1." "0,1"
        textline "   "
        bitfld.long 0x00 26. " HP_USDHC2 ,Indicates the Privilege/User Mode for USDHC2" "0,1"
        textline "   "
        bitfld.long 0x00 27. " L_USDHC2 ,Lock bit set by TZ software for HP_USDHC2." "0,1"
        textline "   "
        bitfld.long 0x00 28. " HP_USDHC3 ,Indicates the Privilege/User Mode for USDHC3" "0,1"
        textline "   "
        bitfld.long 0x00 29. " L_USDHC3 ,Lock bit set by TZ software for HP_USDHC3." "0,1"
        textline "   "
        bitfld.long 0x00 30. " HP_USDHC4 ,Indicates the Privilege/User Mode for USDHC4." "0,1"
        textline "   "
        bitfld.long 0x00 31. " L_USDHC4 ,Lock bit set by TZ software for HP_USDHC4." "0,1"
width 4.
group.long 0x204++0x3
    line.long 0x00 "HP1,HP1 register"
        bitfld.long 0x00 0. " HP_HDMI_HSI ,Indicates the Privilege/User Mode for HDMI Tx and HSI." "0,1"
        textline "   "
        bitfld.long 0x00 1. " L_HDMI_HSI ,Lock bit set by TZ software for HP_HDMI_HSI." "0,1"
width 3.
group.long 0x218++0x3
    line.long 0x00 "SA,Secure access register"
        bitfld.long 0x00 0. " NSA_CP15 ,Indicate the Type (Secured/Non-Secured) Access to ARM CP15 register." "0,1"
        textline "  "
        bitfld.long 0x00 1. " L_CP15 ,Lock bit set by TZ software for NSA_CP15." "0,1"
        textline "  "
        bitfld.long 0x00 2. " NSA_SATA ,Indicates the type of access (Secured/Non-Secured) for SATA This bit field is Reserved for i.MX6SDL" "0,1"
        textline "  "
        bitfld.long 0x00 3. " L_SATA ,Lock bit set by TZ software for NSA_SATA." "0,1"
        textline "  "
        bitfld.long 0x00 4. " NSA_SDMA ,Indicate the Type (Secured/Non-Secured) Access for SDMA." "0,1"
        textline "  "
        bitfld.long 0x00 5. " L_SDMA ,Lock bit set by TZ software for NSA_SDMA." "0,1"
        textline "  "
        bitfld.long 0x00 6. " NSA_PU ,Indicate the Type (Secured/Non-Secured) Access for GPU3D, VDOA, GPU2D, IPU1, EPDC, PXP, LCDIF and VPU." "0,1"
        textline "  "
        bitfld.long 0x00 7. " L_PU ,Lock bit set by TZ software for NSA_PU." "0,1"
        textline "  "
        bitfld.long 0x00 8. " NSA_USB_MLB ,Indicate the Type (Secured/Non-Secured) Access for USB and MLB." "0,1"
        textline "  "
        bitfld.long 0x00 9. " L_USB_MLB ,Lock bit set by TZ software for NSA_USB_MLB." "0,1"
        textline "  "
        bitfld.long 0x00 10. " NSA_PCIE_TEST ,Indicate the Type (Secured/Non-Secured) Access for PCIe and IOMUX Test Port." "0,1"
        textline "  "
        bitfld.long 0x00 11. " L_PCIE_TEST ,Lock bit set by TZ software for NSA_PCIE_TEST." "0,1"
        textline "  "
        bitfld.long 0x00 14. " NSA_RAWNAND_APBHDMA ,Indicate the Type (Secured/Non-Secured) Access for RawNAND and apbhdmat." "0,1"
        textline "  "
        bitfld.long 0x00 15. " L_RAWNAND_APBHDMA ,Lock bit set by TZ software for NSA_RAWNAND_APBHDMA." "0,1"
        textline "  "
        bitfld.long 0x00 16. " NSA_ENET ,Indicate the Type (Secured/Non-Secured) Access for ENET." "0,1"
        textline "  "
        bitfld.long 0x00 17. " L_ENET ,Lock bit set by TZ software for NSA_ENET." "0,1"
        textline "  "
        bitfld.long 0x00 18. " NSA_DAP ,Access Policy indicator bits" "0,1"
        textline "  "
        bitfld.long 0x00 19. " L_DAP ,Lock bit set by TZ software for NSA_DAP." "0,1"
        textline "  "
        bitfld.long 0x00 20. " NSA_USDHC1 ,Indicate the Type (Secured/Non-Secured) Access for USDHC1." "0,1"
        textline "  "
        bitfld.long 0x00 21. " L_USDHC1 ,Lock bit set by TZ software for NSA_USDHC1." "0,1"
        textline "  "
        bitfld.long 0x00 22. " NSA_USDHC2 ,Indicate the Type (Secured/Non-Secured) Access for USDHC2." "0,1"
        textline "  "
        bitfld.long 0x00 23. " L_USDHC2 ,Lock bit set by TZ software for NSA_USDHC2." "0,1"
        textline "  "
        bitfld.long 0x00 24. " NSA_USDHC3 ,Indicate the Type (Secured/Non-Secured) Access for USDHC3." "0,1"
        textline "  "
        bitfld.long 0x00 25. " L_USDHC3 ,Lock bit set by TZ software for NSA_USDHC3." "0,1"
        textline "  "
        bitfld.long 0x00 26. " NSA_USDHC4 ,Indicate the Type (Secured/Non-Secured) Access for USDHC4." "0,1"
        textline "  "
        bitfld.long 0x00 27. " L_USDHC4 ,Lock bit set by TZ software for NSA_USDHC14." "0,1"
        textline "  "
        bitfld.long 0x00 28. " NSA_HDMI_HSI ,Indicate the Type (Secured/Non-Secured) Access for HDMI Tx and HSI." "0,1"
        textline "  "
        bitfld.long 0x00 29. " L_HDMI_HSI ,Lock bit set by TZ software for NSA_HDMI_HSI." "0,1"
width 11.
group.long 0x358++0x3
    line.long 0x00 "HPCONTROL0,HPCONTROL0 register"
        bitfld.long 0x00 0. " HPC_PCIE ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of PCIE." "0,1"
        textline "          "
        bitfld.long 0x00 1. " L_PCIE ,Lock bit set by TZ software for HPC_PCIE." "0,1"
        textline "          "
        bitfld.long 0x00 2. " HPC_SATA ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of SATA." "0,1"
        textline "          "
        bitfld.long 0x00 3. " L_SATA ,Lock bit set by TZ software for HPC_SATA." "0,1"
        textline "          "
        bitfld.long 0x00 4. " HPC_SDMA ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of SDMA." "0,1"
        textline "          "
        bitfld.long 0x00 5. " L_SDMA ,Lock bit set by TZ software for HPC_SDMA." "0,1"
        textline "          "
        bitfld.long 0x00 6. " HPC_PU ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of GPU3D, GPU2D, VPU, IPU1, EPDC, PXP, LCDIF and VDOA." "0,1"
        textline "          "
        bitfld.long 0x00 7. " L_PU ,Lock bit set by TZ software for HPC_PU." "0,1"
        textline "          "
        bitfld.long 0x00 8. " HPC_USB ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of USB." "0,1"
        textline "          "
        bitfld.long 0x00 9. " L_USB ,Lock bit set by TZ software for HPC_USB." "0,1"
        textline "          "
        bitfld.long 0x00 10. " HPC_TEST ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of IOMUX Test Port." "0,1"
        textline "          "
        bitfld.long 0x00 11. " L_TEST ,Lock bit set by TZ software for HPC_TEST." "0,1"
        textline "          "
        bitfld.long 0x00 12. " HPC_MLB ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of MLB." "0,1"
        textline "          "
        bitfld.long 0x00 13. " L_MLB ,Lock bit set by TZ software for HPC_MLB." "0,1"
        textline "          "
        bitfld.long 0x00 14. " HPC_CAAM ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of CAAM." "0,1"
        textline "          "
        bitfld.long 0x00 15. " L_CAAM ,Lock bit set by TZ software for HPC_CAAM." "0,1"
        textline "          "
        bitfld.long 0x00 16. " HPC_RAWNAND ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of RawNAND." "0,1"
        textline "          "
        bitfld.long 0x00 17. " L_RAWNAND ,Lock bit set by TZ software for HPC_RAWNAND." "0,1"
        textline "          "
        bitfld.long 0x00 18. " HPC_APBHDMA ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of apbhdma." "0,1"
        textline "          "
        bitfld.long 0x00 19. " L_ABPHDMA ,Lock bit set by TZ software for HPC_APBHDMA." "0,1"
        textline "          "
        bitfld.long 0x00 20. " HPC_ENET ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of ENET." "0,1"
        textline "          "
        bitfld.long 0x00 21. " L_ENET ,Lock bit set by TZ software for HPC_ENET." "0,1"
        textline "          "
        bitfld.long 0x00 22. " HPC_DAP ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of DAP." "0,1"
        textline "          "
        bitfld.long 0x00 23. " L_DAP ,Lock bit set by TZ software for HPC_DAP." "0,1"
        textline "          "
        bitfld.long 0x00 24. " HPC_USDHC1 ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of USDHC1." "0,1"
        textline "          "
        bitfld.long 0x00 25. " L_USDHC1 ,Lock bit set by TZ software for HPC_USDHC1." "0,1"
        textline "          "
        bitfld.long 0x00 26. " HPC_USDHC2 ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of USDHC2." "0,1"
        textline "          "
        bitfld.long 0x00 27. " L_USDHC2 ,Lock bit set by TZ software for HPC_USDHC2." "0,1"
        textline "          "
        bitfld.long 0x00 28. " HPC_USDHC3 ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of USDHC3." "0,1"
        textline "          "
        bitfld.long 0x00 29. " L_USDHC3 ,Lock bit set by TZ software for HPC_USDHC3." "0,1"
        textline "          "
        bitfld.long 0x00 30. " HPC_USDHC4 ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of USDHC4." "0,1"
        textline "          "
        bitfld.long 0x00 31. " L_USDHC4 ,Lock bit set by TZ software for HPC_USDHC4." "0,1"
width 11.
group.long 0x35c++0x3
    line.long 0x00 "HPCONTROL1,HPCONTROL1 register"
        bitfld.long 0x00 0. " HPC_HDMI_HSI ,Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of HDMI Tx and HSI." "0,1"
        textline "          "
        bitfld.long 0x00 1. " L_HDMI_HSI ,Lock bit set by TZ software for HPC_HDMI_HSI." "0,1"


tree.end



;--------------------------------------------------------------------------------
; DCIC
;--------------------------------------------------------------------------------
tree.open "DCIC"
    tree "DCIC1"
        base ad:0x020e4000

width 6.
group.long 0x0++0x3
    line.long 0x00 "DCICC,DCIC Control Register"
        bitfld.long 0x00 0. " IC_EN ,Integrity Check enable." "0,1"
        textline "     "
        bitfld.long 0x00 4. " DE_POL ,DATA_EN_IN signal polarity." "0,1"
        textline "     "
        bitfld.long 0x00 5. " HSYNC_POL ,HSYNC_IN signal polarity." "0,1"
        textline "     "
        bitfld.long 0x00 6. " VSYNC_POL ,VSYNC_IN signal polarity." "0,1"
        textline "     "
        bitfld.long 0x00 7. " CLK_POL ,DISP_CLK signal polarity." "0,1"
width 7.
group.long 0x4++0x3
    line.long 0x00 "DCICIC,DCIC Interrupt Control Register"
        bitfld.long 0x00 0. " EI_MASK ,Error Interrupt mask." "0,1"
        textline "      "
        bitfld.long 0x00 1. " FI_MASK ,Functional Interrupt mask." "0,1"
        textline "      "
        bitfld.long 0x00 3. " FREEZE_MASK ,Disable change of interrupt masks." "0,1"
        textline "      "
        bitfld.long 0x00 16. " EXT_SIG_EN ,External controller mismatch indication signal." "0,1"
width 6.
group.long 0x8++0x3
    line.long 0x00 "DCICS,DCIC Status Register"
        hexmask.long.word 0x00 0.--16. 1. " ROI_MATCH_STAT ,Each set bit of this field indicates there was a mismatch at appropriate ROIs signature during the last frame."
        textline "     "
        bitfld.long 0x00 16. " EI_STAT ,Error Interrupt status." "0,1"
        textline "     "
        bitfld.long 0x00 17. " FI_STAT ,Functional Interrupt status." "0,1"
width 7.
group.long 0x10++0x3
    line.long 0x00 "DCICRC,DCIC ROI Config Register m"
        hexmask.long.word 0x00 0.--13. 1. " START_OFFSET_X ,Column number of ROIs upper-left corner (X coordinate) Range: 0 to 2^ 13 -1"
        textline "      "
        hexmask.long.word 0x00 16.--28. 1. " START_OFFSET_Y ,Row number of ROIs upper-left corner (Y coordinate) Range: 0 to 2^ 12 -1"
        textline "      "
        bitfld.long 0x00 30. " ROI_FREEZE ,When set, the only parameter of ROI #m that can be changed is reference signature." "0,1"
        textline "      "
        bitfld.long 0x00 31. " ROI_EN ,ROI #m tracking enable" "0,1"
width 7.
group.long 0x14++0x3
    line.long 0x00 "DCICRS,DCIC ROI Size Register m"
        hexmask.long.word 0x00 0.--13. 1. " END_OFFSET_X ,Column number of ROIs lower-right corner (X coordinate) Range: 1 to 2^ 13 -1"
        textline "      "
        hexmask.long.word 0x00 16.--28. 1. " END_OFFSET_Y ,Row number of ROIs lower-right corner (Y coordinate) Range: 1 to 2^ 12 -1"
width 8.
group.long 0x18++0x3
    line.long 0x00 "DCICRRS,DCIC ROI Reference Signature Register m"
        hexmask.long.long 0x00 0.--32. 1. " REFERENCE_SIGNATURE ,32-bit expected signature (CRC calculation result) for ROI #m"
width 8.
rgroup.long 0x1c++0x3
    line.long 0x00 "DCICRCS,DCIC ROI Calculated Signature m"
        hexmask.long.long 0x00 0.--32. 1. " CALCULATED_SIGNATURE ,32-bit actual signature (CRC calculation result) for ROI #m during the last frame."


    tree.end
    tree "DCIC2"
        base ad:0x020e8000

width 6.
group.long 0x0++0x3
    line.long 0x00 "DCICC,DCIC Control Register"
        bitfld.long 0x00 0. " IC_EN ,Integrity Check enable." "0,1"
        textline "     "
        bitfld.long 0x00 4. " DE_POL ,DATA_EN_IN signal polarity." "0,1"
        textline "     "
        bitfld.long 0x00 5. " HSYNC_POL ,HSYNC_IN signal polarity." "0,1"
        textline "     "
        bitfld.long 0x00 6. " VSYNC_POL ,VSYNC_IN signal polarity." "0,1"
        textline "     "
        bitfld.long 0x00 7. " CLK_POL ,DISP_CLK signal polarity." "0,1"
width 7.
group.long 0x4++0x3
    line.long 0x00 "DCICIC,DCIC Interrupt Control Register"
        bitfld.long 0x00 0. " EI_MASK ,Error Interrupt mask." "0,1"
        textline "      "
        bitfld.long 0x00 1. " FI_MASK ,Functional Interrupt mask." "0,1"
        textline "      "
        bitfld.long 0x00 3. " FREEZE_MASK ,Disable change of interrupt masks." "0,1"
        textline "      "
        bitfld.long 0x00 16. " EXT_SIG_EN ,External controller mismatch indication signal." "0,1"
width 6.
group.long 0x8++0x3
    line.long 0x00 "DCICS,DCIC Status Register"
        hexmask.long.word 0x00 0.--16. 1. " ROI_MATCH_STAT ,Each set bit of this field indicates there was a mismatch at appropriate ROIs signature during the last frame."
        textline "     "
        bitfld.long 0x00 16. " EI_STAT ,Error Interrupt status." "0,1"
        textline "     "
        bitfld.long 0x00 17. " FI_STAT ,Functional Interrupt status." "0,1"
width 7.
group.long 0x10++0x3
    line.long 0x00 "DCICRC,DCIC ROI Config Register m"
        hexmask.long.word 0x00 0.--13. 1. " START_OFFSET_X ,Column number of ROIs upper-left corner (X coordinate) Range: 0 to 2^ 13 -1"
        textline "      "
        hexmask.long.word 0x00 16.--28. 1. " START_OFFSET_Y ,Row number of ROIs upper-left corner (Y coordinate) Range: 0 to 2^ 12 -1"
        textline "      "
        bitfld.long 0x00 30. " ROI_FREEZE ,When set, the only parameter of ROI #m that can be changed is reference signature." "0,1"
        textline "      "
        bitfld.long 0x00 31. " ROI_EN ,ROI #m tracking enable" "0,1"
width 7.
group.long 0x14++0x3
    line.long 0x00 "DCICRS,DCIC ROI Size Register m"
        hexmask.long.word 0x00 0.--13. 1. " END_OFFSET_X ,Column number of ROIs lower-right corner (X coordinate) Range: 1 to 2^ 13 -1"
        textline "      "
        hexmask.long.word 0x00 16.--28. 1. " END_OFFSET_Y ,Row number of ROIs lower-right corner (Y coordinate) Range: 1 to 2^ 12 -1"
width 8.
group.long 0x18++0x3
    line.long 0x00 "DCICRRS,DCIC ROI Reference Signature Register m"
        hexmask.long.long 0x00 0.--32. 1. " REFERENCE_SIGNATURE ,32-bit expected signature (CRC calculation result) for ROI #m"
width 8.
rgroup.long 0x1c++0x3
    line.long 0x00 "DCICRCS,DCIC ROI Calculated Signature m"
        hexmask.long.long 0x00 0.--32. 1. " CALCULATED_SIGNATURE ,32-bit actual signature (CRC calculation result) for ROI #m during the last frame."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; DVFSC
;--------------------------------------------------------------------------------
tree "DVFSC"
    base ad:0x020dc180

width 5.
group.long 0x0++0x3
    line.long 0x00 "THRS,DVFS Thresholds"
        hexmask.long.byte 0x00 0.--6. 1. " PNCTHR ,Panic threshold for load tracking"
        textline "    "
        hexmask.long.byte 0x00 16.--22. 1. " DWTHR ,Down threshold for load tracking"
        textline "    "
        hexmask.long.byte 0x00 22.--28. 1. " UPTHR ,Upper threshold for load tracking"
width 5.
group.long 0x4++0x3
    line.long 0x00 "COUN,DVFS Counters thresholds"
        hexmask.long.byte 0x00 0.--8. 1. " UPCNT ,UP counter threshold value"
        textline "    "
        hexmask.long.byte 0x00 16.--24. 1. " DN_CNT ,Down counter threshold value"
width 5.
group.long 0x8++0x3
    line.long 0x00 "SIG1,DVFS general purpose bits weight"
        hexmask.long.byte 0x00 2.--5. 1. " WSW6 ,General purpose load tracking signal weight dvfs_w_sig[6]"
        textline "    "
        hexmask.long.byte 0x00 5.--8. 1. " WSW7 ,General purpose load tracking signal weight dvfs_w_sig[7]"
        textline "    "
        hexmask.long.byte 0x00 8.--11. 1. " WSW8 ,General purpose load tracking signal weight dvfs_w_sig[8]"
        textline "    "
        hexmask.long.byte 0x00 11.--14. 1. " WSW9 ,General purpose load tracking signal weight dvfs_w_sig[9]"
        textline "    "
        hexmask.long.byte 0x00 14.--17. 1. " WSW10 ,General purpose load tracking signal weight dvfs_w_sig[10]"
        textline "    "
        hexmask.long.byte 0x00 17.--20. 1. " WSW11 ,General purpose load tracking signal weight dvfs_w_sig[11]"
        textline "    "
        hexmask.long.byte 0x00 20.--23. 1. " WSW12 ,General purpose load tracking signal weight dvfs_w_sig[12]"
        textline "    "
        hexmask.long.byte 0x00 23.--26. 1. " WSW13 ,General purpose load tracking signal weight dvfs_w_sig[13]"
        textline "    "
        hexmask.long.byte 0x00 26.--29. 1. " WSW14 ,General purpose load tracking signal weight dvfs_w_sig[14]"
        textline "    "
        hexmask.long.byte 0x00 29.--32. 1. " WSW15 ,General purpose load tracking signal weight dvfs_w_sig[15]"
width 9.
group.long 0xc++0x3
    line.long 0x00 "DVFSSIG0,DVFS general purpose bits weight"
        hexmask.long.byte 0x00 0.--6. 1. " WSW0 ,General purpose load tracking signal weight dvfs_w_sig[0]."
        textline "        "
        hexmask.long.byte 0x00 6.--12. 1. " WSW1 ,General purpose load tracking signal weight dvfs_w_sig[1]."
        textline "        "
        hexmask.long.byte 0x00 20.--23. 1. " WSW2 ,General purpose load tracking signal weight dvfs_w_sig[2]"
        textline "        "
        hexmask.long.byte 0x00 23.--26. 1. " WSW3 ,General purpose load tracking signal weight dvfs_w_sig[3]"
        textline "        "
        hexmask.long.byte 0x00 26.--29. 1. " WSW4 ,General purpose load tracking signal weight dvfs_w_sig[4]"
        textline "        "
        hexmask.long.byte 0x00 29.--32. 1. " WSW5 ,General purpose load tracking signal weight dvfs_w_sig[5]"
width 9.
group.long 0x10++0x3
    line.long 0x00 "DVFSGPC0,DVFS general purpose bit 0 weight counter"
        hexmask.long.long 0x00 0.--17. 1. " GPBC0 ,GPBC0 - General Purpose bits Counter 0 During period of this counter the GeP bit 0 will be set and WSW0 will be added to the calculations."
        textline "        "
        bitfld.long 0x00 30. " C0ACT ,C0ACT - Counter 0 active indicator" "0,1"
        textline "        "
        bitfld.long 0x00 31. " C0STRT ,C0STRT - Counter 0 start Setting of this bit will initialize down counting of the GPC0 value." "0,1"
width 9.
group.long 0x14++0x3
    line.long 0x00 "DVFSGPC1,DVFS general purpose bit 1 weight counter"
        hexmask.long.long 0x00 0.--17. 1. " GPBC1 ,GPBC1 - General Purpose bits Counter 1 During period of this counter the GeP bit 1 will be set and WSW1 will be added to the calculations."
        textline "        "
        bitfld.long 0x00 30. " C1ACT ,C1ACT - Counter 1 active indicator" "0,1"
        textline "        "
        bitfld.long 0x00 31. " C1STRT ,C1STRT - Counter 1start Setting of this bit will initialize down counting of the GPC1 value." "0,1"
width 9.
group.long 0x18++0x3
    line.long 0x00 "DVFSGPBT,DVFS general purpose bits enables"
        bitfld.long 0x00 0. " GPB0 ,General purpose bit 0." "0,1"
        textline "        "
        bitfld.long 0x00 1. " GPB1 ,General purpose bit 1." "0,1"
        textline "        "
        bitfld.long 0x00 2. " GPB2 ,General purpose bit 2." "0,1"
        textline "        "
        bitfld.long 0x00 3. " GPB3 ,General purpose bit 3." "0,1"
        textline "        "
        bitfld.long 0x00 4. " GPB4 ,General purpose bit 4." "0,1"
        textline "        "
        bitfld.long 0x00 5. " GPB5 ,General purpose bit 5." "0,1"
        textline "        "
        bitfld.long 0x00 6. " GPB6 ,General purpose bit 6." "0,1"
        textline "        "
        bitfld.long 0x00 7. " GPB7 ,General purpose bit 7." "0,1"
        textline "        "
        bitfld.long 0x00 8. " GPB8 ,General purpose bit 8." "0,1"
        textline "        "
        bitfld.long 0x00 9. " GPB9 ,General purpose bit 9." "0,1"
        textline "        "
        bitfld.long 0x00 10. " GPB10 ,General purpose bit 10." "0,1"
        textline "        "
        bitfld.long 0x00 11. " GPB11 ,General purpose bit 11." "0,1"
        textline "        "
        bitfld.long 0x00 12. " GPB12 ,General purpose bit 12." "0,1"
        textline "        "
        bitfld.long 0x00 13. " GPB13 ,General purpose bit 13." "0,1"
        textline "        "
        bitfld.long 0x00 14. " GPB14 ,General purpose bit 14." "0,1"
        textline "        "
        bitfld.long 0x00 15. " GPB15 ,General purpose bit 15." "0,1"
width 9.
group.long 0x1c++0x3
    line.long 0x00 "DVFSEMAC,DVFS EMAC settings"
        hexmask.long.word 0x00 0.--9. 1. " EMAC ,EMAC - EMA control value"
        textline "        "
        bitfld.long 0x00 9. " DVFEN0 ,DVFS tracking for core0 enable." "0,1"
        textline "        "
        bitfld.long 0x00 10. " DVFEN1 ,DVFS tracking for core1 enable." "0,1"
        textline "        "
        hexmask.long.byte 0x00 16.--18. 1. " FSVAI0 ,DVFS Frequency adjustment status of core 0."
        textline "        "
        hexmask.long.byte 0x00 18.--20. 1. " FSVAI1 ,DVFS Frequency adjustment status of core 1."
        textline "        "
        bitfld.long 0x00 24. " WFIM0 ,DVFS Wait for Interrupt of core 0 mask bit" "0,1"
        textline "        "
        bitfld.long 0x00 25. " WFIM1 ,DVFS Wait for Interrupt of core 1 mask bit" "0,1"
width 5.
group.long 0x20++0x3
    line.long 0x00 "CNTR,DVFS Control"
        hexmask.long.byte 0x00 3.--5. 1. " LTBRSR ,LTBRSR - Load Tracking Buffer Register Source:"
        textline "    "
        bitfld.long 0x00 5. " LTBRSH ,LTBRSH - Load Tracking Buffer Register Shift:" "0,1"
        textline "    "
        hexmask.long.byte 0x00 6.--9. 1. " PFUS ,PFUS - Periodic Frequency Update Status"
        textline "    "
        bitfld.long 0x00 9. " PFUE ,PFUE - Period Frequency Update Enable" "0,1"
        textline "    "
        hexmask.long.byte 0x00 11.--17. 1. " DIV_RATIO ,DIV_RATIO - Divider value."
        textline "    "
        bitfld.long 0x00 17. " MINF ,Minimum frequency reached." "0,1"
        textline "    "
        bitfld.long 0x00 18. " MAXF ,Maximum frequency reached." "0,1"
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " FSVAI ,FSVAI DVFS Frequency adjustment interrupt."
        textline "    "
        bitfld.long 0x00 22. " FSVAIM ,DVFS Frequency adjustment interrupt mask." "0,1"
        textline "    "
        bitfld.long 0x00 23. " PIRQS ,PIRQS - Pattern IRQ Source * write '1' to clear." "0,1"
        textline "    "
        bitfld.long 0x00 24. " DVFIS ,DVFS Interrupt select." "0,1"
        textline "    "
        bitfld.long 0x00 25. " LBFL0 ,Load buffer 0 - full status bit." "0,1"
        textline "    "
        bitfld.long 0x00 26. " LBFL1 ,Load buffer 1 - full status bit." "0,1"
        textline "    "
        bitfld.long 0x00 27. " LBMI ,Load buffer full mask interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 28. " DVFEV ,Always give a DVFS event." "0,1"
        textline "    "
        hexmask.long.byte 0x00 29.--32. 1. " DIV3CK ,DIV3CK - div_3_clk division ratio inside the DVFS module."
width 11.
rgroup.long 0x24++0x3
    line.long 0x00 "DVFSLTR0_0,DVFS Load Tracking Register 0, portion 0"
        hexmask.long.byte 0x00 0.--4. 1. " LTS0_0 ,core 0 Load Tracking Sample 0"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " LTS0_1 ,core 0 Load Tracking Sample 1"
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " LTS0_2 ,core 0 Load Tracking Sample 2"
        textline "          "
        hexmask.long.byte 0x00 12.--16. 1. " LTS0_3 ,core 0 Load Tracking Sample 3"
        textline "          "
        hexmask.long.byte 0x00 16.--20. 1. " LTS0_4 ,core 0 Load Tracking Sample 4"
        textline "          "
        hexmask.long.byte 0x00 20.--24. 1. " LTS0_5 ,core 0 Load Tracking Sample 5"
        textline "          "
        hexmask.long.byte 0x00 24.--28. 1. " LTS0_6 ,core 0 Load Tracking Sample 6"
        textline "          "
        hexmask.long.byte 0x00 28.--32. 1. " LTS0_7 ,core 0 Load Tracking Sample 7"
width 11.
rgroup.long 0x28++0x3
    line.long 0x00 "DVFSLTR0_1,DVFS Load Tracking Register 0, portion 1"
        hexmask.long.byte 0x00 0.--4. 1. " LTS0_8 ,core 0 Load Tracking Sample 8"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " LTS0_9 ,core 0 Load Tracking Sample 9"
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " LTS0_10 ,core 0 Load Tracking Sample 10"
        textline "          "
        hexmask.long.byte 0x00 12.--16. 1. " LTS0_11 ,core 0 Load Tracking Sample 11"
        textline "          "
        hexmask.long.byte 0x00 16.--20. 1. " LTS0_12 ,core 0 Load Tracking Sample 12"
        textline "          "
        hexmask.long.byte 0x00 20.--24. 1. " LTS0_13 ,core 0 Load Tracking Sample 13"
        textline "          "
        hexmask.long.byte 0x00 24.--28. 1. " LTS0_14 ,core 0 Load Tracking Sample 14"
        textline "          "
        hexmask.long.byte 0x00 28.--32. 1. " LTS0_15 ,core 0 Load Tracking Sample 15"
width 11.
rgroup.long 0x2c++0x3
    line.long 0x00 "DVFSLTR1_0,DVFS Load Tracking Register 1, portion 0"
        hexmask.long.byte 0x00 0.--4. 1. " LTS1_0 ,core 0 Load Tracking Sample 0"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " LTS1_1 ,core 0 Load Tracking Sample 1"
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " LTS1_2 ,core 0 Load Tracking Sample 2"
        textline "          "
        hexmask.long.byte 0x00 12.--16. 1. " LTS1_3 ,core 0 Load Tracking Sample 3"
        textline "          "
        hexmask.long.byte 0x00 16.--20. 1. " LTS1_4 ,core 0 Load Tracking Sample 4"
        textline "          "
        hexmask.long.byte 0x00 20.--24. 1. " LTS1_5 ,core 0 Load Tracking Sample 5"
        textline "          "
        hexmask.long.byte 0x00 24.--28. 1. " LTS1_6 ,core 0 Load Tracking Sample 6"
        textline "          "
        hexmask.long.byte 0x00 28.--32. 1. " LTS1_7 ,core 0 Load Tracking Sample 7"
width 11.
rgroup.long 0x30++0x3
    line.long 0x00 "DVFSLTR1_1,DVFS Load Tracking Register 3, portion 1"
        hexmask.long.byte 0x00 0.--4. 1. " LTS1_8 ,core 0 Load Tracking Sample 8"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " LTS1_9 ,core 0 Load Tracking Sample 9"
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " LTS1_10 ,core 0 Load Tracking Sample 10"
        textline "          "
        hexmask.long.byte 0x00 12.--16. 1. " LTS1_11 ,core 0 Load Tracking Sample 11"
        textline "          "
        hexmask.long.byte 0x00 16.--20. 1. " LTS1_12 ,core 0 Load Tracking Sample 12"
        textline "          "
        hexmask.long.byte 0x00 20.--24. 1. " LTS1_13 ,core 0 Load Tracking Sample 13"
        textline "          "
        hexmask.long.byte 0x00 24.--28. 1. " LTS1_14 ,core 0 Load Tracking Sample 14"
        textline "          "
        hexmask.long.byte 0x00 28.--32. 1. " LTS1_15 ,core 0 Load Tracking Sample 15"
width 8.
group.long 0x34++0x3
    line.long 0x00 "DVFSPT0,DVFS pattern 0 length"
        hexmask.long.long 0x00 0.--17. 1. " FPTN0 ,FPTN0 - Frequency pattern 0 counter During period of this counter the frequency will be reduced from the EMA-detected level."
        textline "       "
        bitfld.long 0x00 17. " PT0A ,PT0A - Pattern 0 currently active (read-only)" "0,1"
width 8.
group.long 0x38++0x3
    line.long 0x00 "DVFSPT1,DVFS pattern 1 length"
        hexmask.long.long 0x00 0.--17. 1. " FPTN1 ,FPTN1 - Frequency pattern 1 counter During period of this counter the frequency will be set to the EMA-detected level."
        textline "       "
        bitfld.long 0x00 17. " PT1A ,PT1A - Pattern 1 currently active (read-only)" "0,1"
width 8.
group.long 0x3c++0x3
    line.long 0x00 "DVFSPT2,DVFS pattern 2 length"
        hexmask.long.long 0x00 0.--17. 1. " FPTN2 ,FPTN2 - Frequency pattern 2 counter During period of this counter the frequency will be increased to higher, than detected by the EMA-detected level."
        textline "       "
        bitfld.long 0x00 17. " PT2A ,PT2A - Pattern 2 currently active (read-only)" "0,1"
        textline "       "
        hexmask.long.byte 0x00 26.--32. 1. " P2THR ,P2THR - Pattern 2 Threshold Threshold of current DVFS load (after EMA), for generating interrupts with PFUS indicators 110, 111."
width 8.
group.long 0x40++0x3
    line.long 0x00 "DVFSPT3,DVFS pattern 3 length"
        hexmask.long.long 0x00 0.--17. 1. " FPTN3 ,FPTN3 - Frequency pattern 3 counter During period of this counter the frequency will be set to the EMA-detected level."
        textline "       "
        bitfld.long 0x00 17. " PT3A ,PT3A - Pattern 3 currently active (read-only)" "0,1"


tree.end



;--------------------------------------------------------------------------------
; ECSPI
;--------------------------------------------------------------------------------
tree.open "ECSPI"
    tree "ECSPI1"
        base ad:0x02008000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "RXDATA,Receive Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_RXDATA ,Receive Data."
width 7.
wgroup.long 0x4++0x3
    line.long 0x00 "TXDATA,Transmit Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_TXDATA ,Transmit Data."
width 7.
group.long 0x8++0x3
    line.long 0x00 "CONREG,Control Register"
        bitfld.long 0x00 0. " EN ,SPI Block Enable Control." "0,1"
        textline "      "
        bitfld.long 0x00 1. " HT ,Hardware Trigger Enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " XCH ,SPI Exchange Bit." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SMC ,Start Mode Control." "0,1"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " CHANNEL_MODE ,SPI CHANNEL MODE selects the mode for each SPI channel."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " POST_DIVIDER ,SPI Post Divider."
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " PRE_DIVIDER ,SPI Pre Divider."
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " DRCTL ,SPI Data Ready Control."
        textline "      "
        hexmask.long.byte 0x00 18.--20. 1. " CHANNEL_SELECT ,SPI CHANNEL SELECT bits."
        textline "      "
        hexmask.long.word 0x00 20.--32. 1. " BURST_LENGTH ,Burst Length."
width 10.
group.long 0xc++0x3
    line.long 0x00 "CONFIGREG,Config Register"
        hexmask.long.byte 0x00 0.--4. 1. " SCLK_PHA ,SPI Clock/Data Phase Control."
        textline "         "
        hexmask.long.byte 0x00 4.--8. 1. " SCLK_POL ,SPI Clock Polarity Control."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " SS_CTL ,SPI SS Wave Form Select."
        textline "         "
        hexmask.long.byte 0x00 12.--16. 1. " SS_POL ,SPI SS Polarity Select."
        textline "         "
        hexmask.long.byte 0x00 16.--20. 1. " DATA_CTL ,DATA CTL."
        textline "         "
        hexmask.long.byte 0x00 20.--24. 1. " SCLK_CTL ,SCLK CTL."
        textline "         "
        hexmask.long.byte 0x00 24.--29. 1. " HT_LENGTH ,HT LENGTH."
width 7.
group.long 0x10++0x3
    line.long 0x00 "INTREG,Interrupt Control Register"
        bitfld.long 0x00 0. " TEEN ,TXFIFO Empty Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 1. " TDREN ,TXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " TFEN ,TXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 3. " RREN ,RXFIFO Ready Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 4. " RDREN ,RXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 5. " RFEN ,RXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 6. " ROEN ,RXFIFO Overflow Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 7. " TCEN ,Transfer Completed Interrupt enable." "0,1"
width 7.
group.long 0x14++0x3
    line.long 0x00 "DMAREG,DMA Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " TX_THRESHOLD ,TX THRESHOLD."
        textline "      "
        bitfld.long 0x00 7. " TEDEN ,TXFIFO Empty DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--22. 1. " RX_THRESHOLD ,RX THRESHOLD."
        textline "      "
        bitfld.long 0x00 23. " RXDEN ,RXFIFO DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--30. 1. " RX_DMA_LENGTH ,RX DMA LENGTH."
        textline "      "
        bitfld.long 0x00 31. " RXTDEN ,RXFIFO TAIL DMA Request Enable." "0,1"
width 8.
group.long 0x18++0x3
    line.long 0x00 "STATREG,Status Register"
        bitfld.long 0x00 0. " TE ,TXFIFO Empty." "0,1"
        textline "       "
        bitfld.long 0x00 1. " TDR ,TXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 2. " TF ,TXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 3. " RR ,RXFIFO Ready." "0,1"
        textline "       "
        bitfld.long 0x00 4. " RDR ,RXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RF ,RXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 6. " RO ,RXFIFO Overflow." "0,1"
        textline "       "
        bitfld.long 0x00 7. " TC ,Transfer Completed Status bit." "0,1"
width 10.
group.long 0x1c++0x3
    line.long 0x00 "PERIODREG,Sample Period Control Register"
        hexmask.long.word 0x00 0.--15. 1. " SAMPLE_PERIOD ,Sample Period Control."
        textline "         "
        bitfld.long 0x00 15. " CSRC ,Clock Source Control." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--22. 1. " CSD_CTL ,Chip Select Delay Control bits."
width 8.
group.long 0x20++0x3
    line.long 0x00 "TESTREG,Test Control Register"
        hexmask.long.byte 0x00 0.--7. 1. " TXCNT ,TXFIFO Counter."
        textline "       "
        hexmask.long.byte 0x00 8.--15. 1. " RXCNT ,RXFIFO Counter."
        textline "       "
        bitfld.long 0x00 31. " LBC ,Loop Back Control." "0,1"
width 8.
wgroup.long 0x40++0x3
    line.long 0x00 "MSGDATA,Message Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_MSGDATA ,ECSPI_MSGDATA holds the top word of MSG Data FIFO."


    tree.end
    tree "ECSPI2"
        base ad:0x0200c000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "RXDATA,Receive Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_RXDATA ,Receive Data."
width 7.
wgroup.long 0x4++0x3
    line.long 0x00 "TXDATA,Transmit Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_TXDATA ,Transmit Data."
width 7.
group.long 0x8++0x3
    line.long 0x00 "CONREG,Control Register"
        bitfld.long 0x00 0. " EN ,SPI Block Enable Control." "0,1"
        textline "      "
        bitfld.long 0x00 1. " HT ,Hardware Trigger Enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " XCH ,SPI Exchange Bit." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SMC ,Start Mode Control." "0,1"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " CHANNEL_MODE ,SPI CHANNEL MODE selects the mode for each SPI channel."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " POST_DIVIDER ,SPI Post Divider."
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " PRE_DIVIDER ,SPI Pre Divider."
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " DRCTL ,SPI Data Ready Control."
        textline "      "
        hexmask.long.byte 0x00 18.--20. 1. " CHANNEL_SELECT ,SPI CHANNEL SELECT bits."
        textline "      "
        hexmask.long.word 0x00 20.--32. 1. " BURST_LENGTH ,Burst Length."
width 10.
group.long 0xc++0x3
    line.long 0x00 "CONFIGREG,Config Register"
        hexmask.long.byte 0x00 0.--4. 1. " SCLK_PHA ,SPI Clock/Data Phase Control."
        textline "         "
        hexmask.long.byte 0x00 4.--8. 1. " SCLK_POL ,SPI Clock Polarity Control."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " SS_CTL ,SPI SS Wave Form Select."
        textline "         "
        hexmask.long.byte 0x00 12.--16. 1. " SS_POL ,SPI SS Polarity Select."
        textline "         "
        hexmask.long.byte 0x00 16.--20. 1. " DATA_CTL ,DATA CTL."
        textline "         "
        hexmask.long.byte 0x00 20.--24. 1. " SCLK_CTL ,SCLK CTL."
        textline "         "
        hexmask.long.byte 0x00 24.--29. 1. " HT_LENGTH ,HT LENGTH."
width 7.
group.long 0x10++0x3
    line.long 0x00 "INTREG,Interrupt Control Register"
        bitfld.long 0x00 0. " TEEN ,TXFIFO Empty Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 1. " TDREN ,TXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " TFEN ,TXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 3. " RREN ,RXFIFO Ready Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 4. " RDREN ,RXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 5. " RFEN ,RXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 6. " ROEN ,RXFIFO Overflow Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 7. " TCEN ,Transfer Completed Interrupt enable." "0,1"
width 7.
group.long 0x14++0x3
    line.long 0x00 "DMAREG,DMA Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " TX_THRESHOLD ,TX THRESHOLD."
        textline "      "
        bitfld.long 0x00 7. " TEDEN ,TXFIFO Empty DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--22. 1. " RX_THRESHOLD ,RX THRESHOLD."
        textline "      "
        bitfld.long 0x00 23. " RXDEN ,RXFIFO DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--30. 1. " RX_DMA_LENGTH ,RX DMA LENGTH."
        textline "      "
        bitfld.long 0x00 31. " RXTDEN ,RXFIFO TAIL DMA Request Enable." "0,1"
width 8.
group.long 0x18++0x3
    line.long 0x00 "STATREG,Status Register"
        bitfld.long 0x00 0. " TE ,TXFIFO Empty." "0,1"
        textline "       "
        bitfld.long 0x00 1. " TDR ,TXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 2. " TF ,TXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 3. " RR ,RXFIFO Ready." "0,1"
        textline "       "
        bitfld.long 0x00 4. " RDR ,RXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RF ,RXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 6. " RO ,RXFIFO Overflow." "0,1"
        textline "       "
        bitfld.long 0x00 7. " TC ,Transfer Completed Status bit." "0,1"
width 10.
group.long 0x1c++0x3
    line.long 0x00 "PERIODREG,Sample Period Control Register"
        hexmask.long.word 0x00 0.--15. 1. " SAMPLE_PERIOD ,Sample Period Control."
        textline "         "
        bitfld.long 0x00 15. " CSRC ,Clock Source Control." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--22. 1. " CSD_CTL ,Chip Select Delay Control bits."
width 8.
group.long 0x20++0x3
    line.long 0x00 "TESTREG,Test Control Register"
        hexmask.long.byte 0x00 0.--7. 1. " TXCNT ,TXFIFO Counter."
        textline "       "
        hexmask.long.byte 0x00 8.--15. 1. " RXCNT ,RXFIFO Counter."
        textline "       "
        bitfld.long 0x00 31. " LBC ,Loop Back Control." "0,1"
width 8.
wgroup.long 0x40++0x3
    line.long 0x00 "MSGDATA,Message Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_MSGDATA ,ECSPI_MSGDATA holds the top word of MSG Data FIFO."


    tree.end
    tree "ECSPI3"
        base ad:0x02010000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "RXDATA,Receive Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_RXDATA ,Receive Data."
width 7.
wgroup.long 0x4++0x3
    line.long 0x00 "TXDATA,Transmit Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_TXDATA ,Transmit Data."
width 7.
group.long 0x8++0x3
    line.long 0x00 "CONREG,Control Register"
        bitfld.long 0x00 0. " EN ,SPI Block Enable Control." "0,1"
        textline "      "
        bitfld.long 0x00 1. " HT ,Hardware Trigger Enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " XCH ,SPI Exchange Bit." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SMC ,Start Mode Control." "0,1"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " CHANNEL_MODE ,SPI CHANNEL MODE selects the mode for each SPI channel."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " POST_DIVIDER ,SPI Post Divider."
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " PRE_DIVIDER ,SPI Pre Divider."
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " DRCTL ,SPI Data Ready Control."
        textline "      "
        hexmask.long.byte 0x00 18.--20. 1. " CHANNEL_SELECT ,SPI CHANNEL SELECT bits."
        textline "      "
        hexmask.long.word 0x00 20.--32. 1. " BURST_LENGTH ,Burst Length."
width 10.
group.long 0xc++0x3
    line.long 0x00 "CONFIGREG,Config Register"
        hexmask.long.byte 0x00 0.--4. 1. " SCLK_PHA ,SPI Clock/Data Phase Control."
        textline "         "
        hexmask.long.byte 0x00 4.--8. 1. " SCLK_POL ,SPI Clock Polarity Control."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " SS_CTL ,SPI SS Wave Form Select."
        textline "         "
        hexmask.long.byte 0x00 12.--16. 1. " SS_POL ,SPI SS Polarity Select."
        textline "         "
        hexmask.long.byte 0x00 16.--20. 1. " DATA_CTL ,DATA CTL."
        textline "         "
        hexmask.long.byte 0x00 20.--24. 1. " SCLK_CTL ,SCLK CTL."
        textline "         "
        hexmask.long.byte 0x00 24.--29. 1. " HT_LENGTH ,HT LENGTH."
width 7.
group.long 0x10++0x3
    line.long 0x00 "INTREG,Interrupt Control Register"
        bitfld.long 0x00 0. " TEEN ,TXFIFO Empty Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 1. " TDREN ,TXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " TFEN ,TXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 3. " RREN ,RXFIFO Ready Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 4. " RDREN ,RXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 5. " RFEN ,RXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 6. " ROEN ,RXFIFO Overflow Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 7. " TCEN ,Transfer Completed Interrupt enable." "0,1"
width 7.
group.long 0x14++0x3
    line.long 0x00 "DMAREG,DMA Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " TX_THRESHOLD ,TX THRESHOLD."
        textline "      "
        bitfld.long 0x00 7. " TEDEN ,TXFIFO Empty DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--22. 1. " RX_THRESHOLD ,RX THRESHOLD."
        textline "      "
        bitfld.long 0x00 23. " RXDEN ,RXFIFO DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--30. 1. " RX_DMA_LENGTH ,RX DMA LENGTH."
        textline "      "
        bitfld.long 0x00 31. " RXTDEN ,RXFIFO TAIL DMA Request Enable." "0,1"
width 8.
group.long 0x18++0x3
    line.long 0x00 "STATREG,Status Register"
        bitfld.long 0x00 0. " TE ,TXFIFO Empty." "0,1"
        textline "       "
        bitfld.long 0x00 1. " TDR ,TXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 2. " TF ,TXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 3. " RR ,RXFIFO Ready." "0,1"
        textline "       "
        bitfld.long 0x00 4. " RDR ,RXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RF ,RXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 6. " RO ,RXFIFO Overflow." "0,1"
        textline "       "
        bitfld.long 0x00 7. " TC ,Transfer Completed Status bit." "0,1"
width 10.
group.long 0x1c++0x3
    line.long 0x00 "PERIODREG,Sample Period Control Register"
        hexmask.long.word 0x00 0.--15. 1. " SAMPLE_PERIOD ,Sample Period Control."
        textline "         "
        bitfld.long 0x00 15. " CSRC ,Clock Source Control." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--22. 1. " CSD_CTL ,Chip Select Delay Control bits."
width 8.
group.long 0x20++0x3
    line.long 0x00 "TESTREG,Test Control Register"
        hexmask.long.byte 0x00 0.--7. 1. " TXCNT ,TXFIFO Counter."
        textline "       "
        hexmask.long.byte 0x00 8.--15. 1. " RXCNT ,RXFIFO Counter."
        textline "       "
        bitfld.long 0x00 31. " LBC ,Loop Back Control." "0,1"
width 8.
wgroup.long 0x40++0x3
    line.long 0x00 "MSGDATA,Message Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_MSGDATA ,ECSPI_MSGDATA holds the top word of MSG Data FIFO."


    tree.end
    tree "ECSPI4"
        base ad:0x02014000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "RXDATA,Receive Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_RXDATA ,Receive Data."
width 7.
wgroup.long 0x4++0x3
    line.long 0x00 "TXDATA,Transmit Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_TXDATA ,Transmit Data."
width 7.
group.long 0x8++0x3
    line.long 0x00 "CONREG,Control Register"
        bitfld.long 0x00 0. " EN ,SPI Block Enable Control." "0,1"
        textline "      "
        bitfld.long 0x00 1. " HT ,Hardware Trigger Enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " XCH ,SPI Exchange Bit." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SMC ,Start Mode Control." "0,1"
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " CHANNEL_MODE ,SPI CHANNEL MODE selects the mode for each SPI channel."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " POST_DIVIDER ,SPI Post Divider."
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " PRE_DIVIDER ,SPI Pre Divider."
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " DRCTL ,SPI Data Ready Control."
        textline "      "
        hexmask.long.byte 0x00 18.--20. 1. " CHANNEL_SELECT ,SPI CHANNEL SELECT bits."
        textline "      "
        hexmask.long.word 0x00 20.--32. 1. " BURST_LENGTH ,Burst Length."
width 10.
group.long 0xc++0x3
    line.long 0x00 "CONFIGREG,Config Register"
        hexmask.long.byte 0x00 0.--4. 1. " SCLK_PHA ,SPI Clock/Data Phase Control."
        textline "         "
        hexmask.long.byte 0x00 4.--8. 1. " SCLK_POL ,SPI Clock Polarity Control."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " SS_CTL ,SPI SS Wave Form Select."
        textline "         "
        hexmask.long.byte 0x00 12.--16. 1. " SS_POL ,SPI SS Polarity Select."
        textline "         "
        hexmask.long.byte 0x00 16.--20. 1. " DATA_CTL ,DATA CTL."
        textline "         "
        hexmask.long.byte 0x00 20.--24. 1. " SCLK_CTL ,SCLK CTL."
        textline "         "
        hexmask.long.byte 0x00 24.--29. 1. " HT_LENGTH ,HT LENGTH."
width 7.
group.long 0x10++0x3
    line.long 0x00 "INTREG,Interrupt Control Register"
        bitfld.long 0x00 0. " TEEN ,TXFIFO Empty Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 1. " TDREN ,TXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 2. " TFEN ,TXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 3. " RREN ,RXFIFO Ready Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 4. " RDREN ,RXFIFO Data Request Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 5. " RFEN ,RXFIFO Full Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 6. " ROEN ,RXFIFO Overflow Interrupt enable." "0,1"
        textline "      "
        bitfld.long 0x00 7. " TCEN ,Transfer Completed Interrupt enable." "0,1"
width 7.
group.long 0x14++0x3
    line.long 0x00 "DMAREG,DMA Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " TX_THRESHOLD ,TX THRESHOLD."
        textline "      "
        bitfld.long 0x00 7. " TEDEN ,TXFIFO Empty DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--22. 1. " RX_THRESHOLD ,RX THRESHOLD."
        textline "      "
        bitfld.long 0x00 23. " RXDEN ,RXFIFO DMA Request Enable." "0,1"
        textline "      "
        hexmask.long.byte 0x00 24.--30. 1. " RX_DMA_LENGTH ,RX DMA LENGTH."
        textline "      "
        bitfld.long 0x00 31. " RXTDEN ,RXFIFO TAIL DMA Request Enable." "0,1"
width 8.
group.long 0x18++0x3
    line.long 0x00 "STATREG,Status Register"
        bitfld.long 0x00 0. " TE ,TXFIFO Empty." "0,1"
        textline "       "
        bitfld.long 0x00 1. " TDR ,TXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 2. " TF ,TXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 3. " RR ,RXFIFO Ready." "0,1"
        textline "       "
        bitfld.long 0x00 4. " RDR ,RXFIFO Data Request." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RF ,RXFIFO Full." "0,1"
        textline "       "
        bitfld.long 0x00 6. " RO ,RXFIFO Overflow." "0,1"
        textline "       "
        bitfld.long 0x00 7. " TC ,Transfer Completed Status bit." "0,1"
width 10.
group.long 0x1c++0x3
    line.long 0x00 "PERIODREG,Sample Period Control Register"
        hexmask.long.word 0x00 0.--15. 1. " SAMPLE_PERIOD ,Sample Period Control."
        textline "         "
        bitfld.long 0x00 15. " CSRC ,Clock Source Control." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--22. 1. " CSD_CTL ,Chip Select Delay Control bits."
width 8.
group.long 0x20++0x3
    line.long 0x00 "TESTREG,Test Control Register"
        hexmask.long.byte 0x00 0.--7. 1. " TXCNT ,TXFIFO Counter."
        textline "       "
        hexmask.long.byte 0x00 8.--15. 1. " RXCNT ,RXFIFO Counter."
        textline "       "
        bitfld.long 0x00 31. " LBC ,Loop Back Control." "0,1"
width 8.
wgroup.long 0x40++0x3
    line.long 0x00 "MSGDATA,Message Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ECSPI_MSGDATA ,ECSPI_MSGDATA holds the top word of MSG Data FIFO."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; EIM
;--------------------------------------------------------------------------------
tree "EIM"
    base ad:0x021b8000

width 8.
group.long 0x0++0x3
    line.long 0x00 "CS0GCR1,Chip Select n General Configuration Register 1"
        bitfld.long 0x00 0. " CSEN ,CS Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SWR ,Synchronous Write Data." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SRD ,Synchronous Read Data." "0,1"
        textline "       "
        bitfld.long 0x00 3. " MUM ,Multiplexed Mode." "0,1"
        textline "       "
        bitfld.long 0x00 4. " WFL ,Write Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RFL ,Read Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 6. " CRE ,Configuration Register Enable." "0,1"
        textline "       "
        bitfld.long 0x00 7. " CREP ,Configuration Register Enable Polarity." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BL ,Burst Length."
        textline "       "
        bitfld.long 0x00 11. " WC ,Write Continuous." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " BCD ,Burst Clock Divisor."
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BCS ,Burst Clock Start."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " DSZ ,Data Port Size."
        textline "       "
        bitfld.long 0x00 19. " SP ,Supervisor Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " CSREC ,CS Recovery."
        textline "       "
        bitfld.long 0x00 23. " AUS ,Address UnShifted." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " GBC ,Gap Between Chip Selects."
        textline "       "
        bitfld.long 0x00 27. " WP ,Write Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " PSZ ,Page Size."
width 8.
group.long 0x4++0x3
    line.long 0x00 "CS0GCR2,Chip Select n General Configuration Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " ADH ,Address hold time - This bit field determine the address hold time after ADV negation when mum = 1 (muxed mode)."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " DAPS ,Data Acknowledge Poling Start."
        textline "       "
        bitfld.long 0x00 8. " DAE ,Data Acknowledge Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " DAP ,Data Acknowledge Polarity." "0,1"
        textline "       "
        bitfld.long 0x00 12. " MUX16_BYP_GRANT ,Muxed 16 bypass grant." "0,1"
width 8.
group.long 0x8++0x3
    line.long 0x00 "CS0RCR1,Chip Select n Read Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " RCSN ,Read CS Negation."
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RCSA ,Read CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " OEN ,OE Negation."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " OEA ,OE Assertion."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " RADVN ,ADV Negation."
        textline "       "
        bitfld.long 0x00 19. " RAL ,Read ADV Low." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " RADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " RWSC ,Read Wait State Control."
width 8.
group.long 0xc++0x3
    line.long 0x00 "CS0RCR2,Chip Select n Read Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " RBEN ,Read BE Negation."
        textline "       "
        bitfld.long 0x00 3. " RBE ,Read BE enable." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RBEA ,Read BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " RL ,Read Latency."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " PAT ,Page Access Time."
        textline "       "
        bitfld.long 0x00 15. " APR ,Asynchronous Page Read." "0,1"
width 8.
group.long 0x10++0x3
    line.long 0x00 "CS0WCR1,Chip Select n Write Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " WCSN ,Write CS Negation."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " WCSA ,Write CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " WEN ,WE Negation."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " WEA ,WE Assertion."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " WBEN ,BE[3:0] Negation."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " WBEA ,BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " WADVN ,ADV Negation."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " WADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " WWSC ,Write Wait State Control."
        textline "       "
        bitfld.long 0x00 30. " WBED ,Write Byte Enable Disable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " WAL ,Write ADV Low." "0,1"
width 8.
group.long 0x14++0x3
    line.long 0x00 "CS0WCR2,Chip Select n Write Configuration Register 2"
        bitfld.long 0x00 0. " WBCDD ,Write Burst Clock Divisor Decrement." "0,1"
width 8.
group.long 0x18++0x3
    line.long 0x00 "CS1GCR1,Chip Select n General Configuration Register 1"
        bitfld.long 0x00 0. " CSEN ,CS Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SWR ,Synchronous Write Data." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SRD ,Synchronous Read Data." "0,1"
        textline "       "
        bitfld.long 0x00 3. " MUM ,Multiplexed Mode." "0,1"
        textline "       "
        bitfld.long 0x00 4. " WFL ,Write Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RFL ,Read Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 6. " CRE ,Configuration Register Enable." "0,1"
        textline "       "
        bitfld.long 0x00 7. " CREP ,Configuration Register Enable Polarity." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BL ,Burst Length."
        textline "       "
        bitfld.long 0x00 11. " WC ,Write Continuous." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " BCD ,Burst Clock Divisor."
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BCS ,Burst Clock Start."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " DSZ ,Data Port Size."
        textline "       "
        bitfld.long 0x00 19. " SP ,Supervisor Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " CSREC ,CS Recovery."
        textline "       "
        bitfld.long 0x00 23. " AUS ,Address UnShifted." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " GBC ,Gap Between Chip Selects."
        textline "       "
        bitfld.long 0x00 27. " WP ,Write Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " PSZ ,Page Size."
width 8.
group.long 0x1c++0x3
    line.long 0x00 "CS1GCR2,Chip Select n General Configuration Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " ADH ,Address hold time - This bit field determine the address hold time after ADV negation when mum = 1 (muxed mode)."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " DAPS ,Data Acknowledge Poling Start."
        textline "       "
        bitfld.long 0x00 8. " DAE ,Data Acknowledge Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " DAP ,Data Acknowledge Polarity." "0,1"
        textline "       "
        bitfld.long 0x00 12. " MUX16_BYP_GRANT ,Muxed 16 bypass grant." "0,1"
width 8.
group.long 0x20++0x3
    line.long 0x00 "CS1RCR1,Chip Select n Read Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " RCSN ,Read CS Negation."
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RCSA ,Read CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " OEN ,OE Negation."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " OEA ,OE Assertion."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " RADVN ,ADV Negation."
        textline "       "
        bitfld.long 0x00 19. " RAL ,Read ADV Low." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " RADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " RWSC ,Read Wait State Control."
width 8.
group.long 0x24++0x3
    line.long 0x00 "CS1RCR2,Chip Select n Read Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " RBEN ,Read BE Negation."
        textline "       "
        bitfld.long 0x00 3. " RBE ,Read BE enable." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RBEA ,Read BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " RL ,Read Latency."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " PAT ,Page Access Time."
        textline "       "
        bitfld.long 0x00 15. " APR ,Asynchronous Page Read." "0,1"
width 8.
group.long 0x28++0x3
    line.long 0x00 "CS1WCR1,Chip Select n Write Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " WCSN ,Write CS Negation."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " WCSA ,Write CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " WEN ,WE Negation."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " WEA ,WE Assertion."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " WBEN ,BE[3:0] Negation."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " WBEA ,BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " WADVN ,ADV Negation."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " WADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " WWSC ,Write Wait State Control."
        textline "       "
        bitfld.long 0x00 30. " WBED ,Write Byte Enable Disable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " WAL ,Write ADV Low." "0,1"
width 8.
group.long 0x2c++0x3
    line.long 0x00 "CS1WCR2,Chip Select n Write Configuration Register 2"
        bitfld.long 0x00 0. " WBCDD ,Write Burst Clock Divisor Decrement." "0,1"
width 8.
group.long 0x30++0x3
    line.long 0x00 "CS2GCR1,Chip Select n General Configuration Register 1"
        bitfld.long 0x00 0. " CSEN ,CS Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SWR ,Synchronous Write Data." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SRD ,Synchronous Read Data." "0,1"
        textline "       "
        bitfld.long 0x00 3. " MUM ,Multiplexed Mode." "0,1"
        textline "       "
        bitfld.long 0x00 4. " WFL ,Write Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RFL ,Read Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 6. " CRE ,Configuration Register Enable." "0,1"
        textline "       "
        bitfld.long 0x00 7. " CREP ,Configuration Register Enable Polarity." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BL ,Burst Length."
        textline "       "
        bitfld.long 0x00 11. " WC ,Write Continuous." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " BCD ,Burst Clock Divisor."
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BCS ,Burst Clock Start."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " DSZ ,Data Port Size."
        textline "       "
        bitfld.long 0x00 19. " SP ,Supervisor Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " CSREC ,CS Recovery."
        textline "       "
        bitfld.long 0x00 23. " AUS ,Address UnShifted." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " GBC ,Gap Between Chip Selects."
        textline "       "
        bitfld.long 0x00 27. " WP ,Write Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " PSZ ,Page Size."
width 8.
group.long 0x34++0x3
    line.long 0x00 "CS2GCR2,Chip Select n General Configuration Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " ADH ,Address hold time - This bit field determine the address hold time after ADV negation when mum = 1 (muxed mode)."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " DAPS ,Data Acknowledge Poling Start."
        textline "       "
        bitfld.long 0x00 8. " DAE ,Data Acknowledge Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " DAP ,Data Acknowledge Polarity." "0,1"
        textline "       "
        bitfld.long 0x00 12. " MUX16_BYP_GRANT ,Muxed 16 bypass grant." "0,1"
width 8.
group.long 0x38++0x3
    line.long 0x00 "CS2RCR1,Chip Select n Read Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " RCSN ,Read CS Negation."
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RCSA ,Read CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " OEN ,OE Negation."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " OEA ,OE Assertion."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " RADVN ,ADV Negation."
        textline "       "
        bitfld.long 0x00 19. " RAL ,Read ADV Low." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " RADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " RWSC ,Read Wait State Control."
width 8.
group.long 0x3c++0x3
    line.long 0x00 "CS2RCR2,Chip Select n Read Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " RBEN ,Read BE Negation."
        textline "       "
        bitfld.long 0x00 3. " RBE ,Read BE enable." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RBEA ,Read BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " RL ,Read Latency."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " PAT ,Page Access Time."
        textline "       "
        bitfld.long 0x00 15. " APR ,Asynchronous Page Read." "0,1"
width 8.
group.long 0x40++0x3
    line.long 0x00 "CS2WCR1,Chip Select n Write Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " WCSN ,Write CS Negation."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " WCSA ,Write CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " WEN ,WE Negation."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " WEA ,WE Assertion."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " WBEN ,BE[3:0] Negation."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " WBEA ,BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " WADVN ,ADV Negation."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " WADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " WWSC ,Write Wait State Control."
        textline "       "
        bitfld.long 0x00 30. " WBED ,Write Byte Enable Disable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " WAL ,Write ADV Low." "0,1"
width 8.
group.long 0x44++0x3
    line.long 0x00 "CS2WCR2,Chip Select n Write Configuration Register 2"
        bitfld.long 0x00 0. " WBCDD ,Write Burst Clock Divisor Decrement." "0,1"
width 8.
group.long 0x48++0x3
    line.long 0x00 "CS3GCR1,Chip Select n General Configuration Register 1"
        bitfld.long 0x00 0. " CSEN ,CS Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SWR ,Synchronous Write Data." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SRD ,Synchronous Read Data." "0,1"
        textline "       "
        bitfld.long 0x00 3. " MUM ,Multiplexed Mode." "0,1"
        textline "       "
        bitfld.long 0x00 4. " WFL ,Write Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RFL ,Read Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 6. " CRE ,Configuration Register Enable." "0,1"
        textline "       "
        bitfld.long 0x00 7. " CREP ,Configuration Register Enable Polarity." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BL ,Burst Length."
        textline "       "
        bitfld.long 0x00 11. " WC ,Write Continuous." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " BCD ,Burst Clock Divisor."
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BCS ,Burst Clock Start."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " DSZ ,Data Port Size."
        textline "       "
        bitfld.long 0x00 19. " SP ,Supervisor Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " CSREC ,CS Recovery."
        textline "       "
        bitfld.long 0x00 23. " AUS ,Address UnShifted." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " GBC ,Gap Between Chip Selects."
        textline "       "
        bitfld.long 0x00 27. " WP ,Write Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " PSZ ,Page Size."
width 8.
group.long 0x4c++0x3
    line.long 0x00 "CS3GCR2,Chip Select n General Configuration Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " ADH ,Address hold time - This bit field determine the address hold time after ADV negation when mum = 1 (muxed mode)."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " DAPS ,Data Acknowledge Poling Start."
        textline "       "
        bitfld.long 0x00 8. " DAE ,Data Acknowledge Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " DAP ,Data Acknowledge Polarity." "0,1"
        textline "       "
        bitfld.long 0x00 12. " MUX16_BYP_GRANT ,Muxed 16 bypass grant." "0,1"
width 8.
group.long 0x50++0x3
    line.long 0x00 "CS3RCR1,Chip Select n Read Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " RCSN ,Read CS Negation."
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RCSA ,Read CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " OEN ,OE Negation."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " OEA ,OE Assertion."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " RADVN ,ADV Negation."
        textline "       "
        bitfld.long 0x00 19. " RAL ,Read ADV Low." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " RADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " RWSC ,Read Wait State Control."
width 8.
group.long 0x54++0x3
    line.long 0x00 "CS3RCR2,Chip Select n Read Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " RBEN ,Read BE Negation."
        textline "       "
        bitfld.long 0x00 3. " RBE ,Read BE enable." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RBEA ,Read BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " RL ,Read Latency."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " PAT ,Page Access Time."
        textline "       "
        bitfld.long 0x00 15. " APR ,Asynchronous Page Read." "0,1"
width 8.
group.long 0x58++0x3
    line.long 0x00 "CS3WCR1,Chip Select n Write Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " WCSN ,Write CS Negation."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " WCSA ,Write CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " WEN ,WE Negation."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " WEA ,WE Assertion."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " WBEN ,BE[3:0] Negation."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " WBEA ,BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " WADVN ,ADV Negation."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " WADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " WWSC ,Write Wait State Control."
        textline "       "
        bitfld.long 0x00 30. " WBED ,Write Byte Enable Disable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " WAL ,Write ADV Low." "0,1"
width 8.
group.long 0x5c++0x3
    line.long 0x00 "CS3WCR2,Chip Select n Write Configuration Register 2"
        bitfld.long 0x00 0. " WBCDD ,Write Burst Clock Divisor Decrement." "0,1"
width 8.
group.long 0x60++0x3
    line.long 0x00 "CS4GCR1,Chip Select n General Configuration Register 1"
        bitfld.long 0x00 0. " CSEN ,CS Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SWR ,Synchronous Write Data." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SRD ,Synchronous Read Data." "0,1"
        textline "       "
        bitfld.long 0x00 3. " MUM ,Multiplexed Mode." "0,1"
        textline "       "
        bitfld.long 0x00 4. " WFL ,Write Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RFL ,Read Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 6. " CRE ,Configuration Register Enable." "0,1"
        textline "       "
        bitfld.long 0x00 7. " CREP ,Configuration Register Enable Polarity." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BL ,Burst Length."
        textline "       "
        bitfld.long 0x00 11. " WC ,Write Continuous." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " BCD ,Burst Clock Divisor."
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BCS ,Burst Clock Start."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " DSZ ,Data Port Size."
        textline "       "
        bitfld.long 0x00 19. " SP ,Supervisor Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " CSREC ,CS Recovery."
        textline "       "
        bitfld.long 0x00 23. " AUS ,Address UnShifted." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " GBC ,Gap Between Chip Selects."
        textline "       "
        bitfld.long 0x00 27. " WP ,Write Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " PSZ ,Page Size."
width 8.
group.long 0x64++0x3
    line.long 0x00 "CS4GCR2,Chip Select n General Configuration Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " ADH ,Address hold time - This bit field determine the address hold time after ADV negation when mum = 1 (muxed mode)."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " DAPS ,Data Acknowledge Poling Start."
        textline "       "
        bitfld.long 0x00 8. " DAE ,Data Acknowledge Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " DAP ,Data Acknowledge Polarity." "0,1"
        textline "       "
        bitfld.long 0x00 12. " MUX16_BYP_GRANT ,Muxed 16 bypass grant." "0,1"
width 8.
group.long 0x68++0x3
    line.long 0x00 "CS4RCR1,Chip Select n Read Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " RCSN ,Read CS Negation."
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RCSA ,Read CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " OEN ,OE Negation."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " OEA ,OE Assertion."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " RADVN ,ADV Negation."
        textline "       "
        bitfld.long 0x00 19. " RAL ,Read ADV Low." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " RADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " RWSC ,Read Wait State Control."
width 8.
group.long 0x6c++0x3
    line.long 0x00 "CS4RCR2,Chip Select n Read Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " RBEN ,Read BE Negation."
        textline "       "
        bitfld.long 0x00 3. " RBE ,Read BE enable." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RBEA ,Read BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " RL ,Read Latency."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " PAT ,Page Access Time."
        textline "       "
        bitfld.long 0x00 15. " APR ,Asynchronous Page Read." "0,1"
width 8.
group.long 0x70++0x3
    line.long 0x00 "CS4WCR1,Chip Select n Write Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " WCSN ,Write CS Negation."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " WCSA ,Write CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " WEN ,WE Negation."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " WEA ,WE Assertion."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " WBEN ,BE[3:0] Negation."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " WBEA ,BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " WADVN ,ADV Negation."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " WADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " WWSC ,Write Wait State Control."
        textline "       "
        bitfld.long 0x00 30. " WBED ,Write Byte Enable Disable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " WAL ,Write ADV Low." "0,1"
width 8.
group.long 0x74++0x3
    line.long 0x00 "CS4WCR2,Chip Select n Write Configuration Register 2"
        bitfld.long 0x00 0. " WBCDD ,Write Burst Clock Divisor Decrement." "0,1"
width 8.
group.long 0x78++0x3
    line.long 0x00 "CS5GCR1,Chip Select n General Configuration Register 1"
        bitfld.long 0x00 0. " CSEN ,CS Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SWR ,Synchronous Write Data." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SRD ,Synchronous Read Data." "0,1"
        textline "       "
        bitfld.long 0x00 3. " MUM ,Multiplexed Mode." "0,1"
        textline "       "
        bitfld.long 0x00 4. " WFL ,Write Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RFL ,Read Fix Latency." "0,1"
        textline "       "
        bitfld.long 0x00 6. " CRE ,Configuration Register Enable." "0,1"
        textline "       "
        bitfld.long 0x00 7. " CREP ,Configuration Register Enable Polarity." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BL ,Burst Length."
        textline "       "
        bitfld.long 0x00 11. " WC ,Write Continuous." "0,1"
        textline "       "
        hexmask.long.byte 0x00 12.--14. 1. " BCD ,Burst Clock Divisor."
        textline "       "
        hexmask.long.byte 0x00 14.--16. 1. " BCS ,Burst Clock Start."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " DSZ ,Data Port Size."
        textline "       "
        bitfld.long 0x00 19. " SP ,Supervisor Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " CSREC ,CS Recovery."
        textline "       "
        bitfld.long 0x00 23. " AUS ,Address UnShifted." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " GBC ,Gap Between Chip Selects."
        textline "       "
        bitfld.long 0x00 27. " WP ,Write Protect." "0,1"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " PSZ ,Page Size."
width 8.
group.long 0x7c++0x3
    line.long 0x00 "CS5GCR2,Chip Select n General Configuration Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " ADH ,Address hold time - This bit field determine the address hold time after ADV negation when mum = 1 (muxed mode)."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " DAPS ,Data Acknowledge Poling Start."
        textline "       "
        bitfld.long 0x00 8. " DAE ,Data Acknowledge Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " DAP ,Data Acknowledge Polarity." "0,1"
        textline "       "
        bitfld.long 0x00 12. " MUX16_BYP_GRANT ,Muxed 16 bypass grant." "0,1"
width 8.
group.long 0x80++0x3
    line.long 0x00 "CS5RCR1,Chip Select n Read Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " RCSN ,Read CS Negation."
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RCSA ,Read CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " OEN ,OE Negation."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " OEA ,OE Assertion."
        textline "       "
        hexmask.long.byte 0x00 16.--19. 1. " RADVN ,ADV Negation."
        textline "       "
        bitfld.long 0x00 19. " RAL ,Read ADV Low." "0,1"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " RADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " RWSC ,Read Wait State Control."
width 8.
group.long 0x84++0x3
    line.long 0x00 "CS5RCR2,Chip Select n Read Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " RBEN ,Read BE Negation."
        textline "       "
        bitfld.long 0x00 3. " RBE ,Read BE enable." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " RBEA ,Read BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " RL ,Read Latency."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " PAT ,Page Access Time."
        textline "       "
        bitfld.long 0x00 15. " APR ,Asynchronous Page Read." "0,1"
width 8.
group.long 0x88++0x3
    line.long 0x00 "CS5WCR1,Chip Select n Write Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " WCSN ,Write CS Negation."
        textline "       "
        hexmask.long.byte 0x00 3.--6. 1. " WCSA ,Write CS Assertion."
        textline "       "
        hexmask.long.byte 0x00 6.--9. 1. " WEN ,WE Negation."
        textline "       "
        hexmask.long.byte 0x00 9.--12. 1. " WEA ,WE Assertion."
        textline "       "
        hexmask.long.byte 0x00 12.--15. 1. " WBEN ,BE[3:0] Negation."
        textline "       "
        hexmask.long.byte 0x00 15.--18. 1. " WBEA ,BE Assertion."
        textline "       "
        hexmask.long.byte 0x00 18.--21. 1. " WADVN ,ADV Negation."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " WADVA ,ADV Assertion."
        textline "       "
        hexmask.long.byte 0x00 24.--30. 1. " WWSC ,Write Wait State Control."
        textline "       "
        bitfld.long 0x00 30. " WBED ,Write Byte Enable Disable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " WAL ,Write ADV Low." "0,1"
width 8.
group.long 0x8c++0x3
    line.long 0x00 "CS5WCR2,Chip Select n Write Configuration Register 2"
        bitfld.long 0x00 0. " WBCDD ,Write Burst Clock Divisor Decrement." "0,1"
width 4.
group.long 0x90++0x3
    line.long 0x00 "WCR,EIM Configuration Register"
        bitfld.long 0x00 0. " BCM ,Burst Clock Mode." "0,1"
        textline "   "
        hexmask.long.byte 0x00 1.--3. 1. " GBCD ,General Burst Clock Divisor."
        textline "   "
        bitfld.long 0x00 3. " CONT_BCLK_SEL ,When this bit is set BCLK pin output continuous clock." "0,1"
        textline "   "
        bitfld.long 0x00 4. " INTEN ,Interrupt Enable." "0,1"
        textline "   "
        bitfld.long 0x00 5. " INTPOL ,Interrupt Polarity." "0,1"
        textline "   "
        bitfld.long 0x00 8. " WDOG_EN ,Memory WDog enable." "0,1"
        textline "   "
        hexmask.long.byte 0x00 9.--11. 1. " WDOG_LIMIT ,Memory Watch Dog (WDog) cycle limit."
        textline "   "
        bitfld.long 0x00 11. " FRUN_ACLK_EN ," "0,1"
width 4.
group.long 0x94++0x3
    line.long 0x00 "DCR,DLL Control Register"
        bitfld.long 0x00 0. " DLL_CTRL_ENABLE ,Set this bit to 1 to enable the DLL and delay chain; otherwise; set to 0 to bypasses DLL." "0,1"
        textline "   "
        bitfld.long 0x00 1. " DLL_CTRL_RESET ,Setting this bit to 1 force a reset on DLL." "0,1"
        textline "   "
        bitfld.long 0x00 2. " DLL_CTRL_SLV_FORCE_UPD ,Setting this bit to 1, forces the slave delay line to update to the DLL calibrated value immediately." "0,1"
        textline "   "
        bitfld.long 0x00 3. " DLL_CTRL_SLV_OFFSET_DEC ,Decrease(or increase) the value defined by DLL_CTRL_SLV_OFFSET when calculating DLL_STS_SLV_SEL" "0,1"
        textline "   "
        hexmask.long.byte 0x00 4.--7. 1. " DLL_CTRL_SLV_OFFSET ,OFFSET value for DLL_CTRL_SLV_SEL"
        textline "   "
        bitfld.long 0x00 7. " DLL_CTRL_GATE_UPDATE ,Set this bit to 1 to force DLL not update from now on." "0,1"
        textline "   "
        bitfld.long 0x00 8. " DLL_CTRL_SLV_OVERRIDE ,Set this bit to 1 to Enable manual override for slave delay chain using SLV_OVERRIDE_VAL; to set 0 to disable manual override." "0,1"
        textline "   "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_CTRL_SLV_OVERRIDE_VAL ,When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical taps manually."
        textline "   "
        hexmask.long.byte 0x00 16.--23. 1. " DLL_CTRL_REF_INITIAL_VAL ,This field is used to select the initial value of reference chain before DLL enabled."
        textline "   "
        hexmask.long.byte 0x00 23.--28. 1. " DLL_CTRL_SLV_UPDATE_INT ,If default 0 is used, it means 256 cycles of ref_clock."
        textline "   "
        hexmask.long.byte 0x00 28.--32. 1. " DLL_CTRL_REF_UPDATE_INT ,DLL control loop update interval."
width 4.
rgroup.long 0x98++0x3
    line.long 0x00 "DSR,DLL Status Register"
        bitfld.long 0x00 0. " DLL_STS_SLV_LOCK ,Slave delay-line lock status." "0,1"
        textline "   "
        bitfld.long 0x00 1. " DLL_STS_REF_LOCK ,Reference DLL lock status." "0,1"
        textline "   "
        hexmask.long.byte 0x00 2.--9. 1. " DLL_STS_SLV_SEL ,Slave delay line select status."
        textline "   "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_STS_REF_SEL ,Reference delay line select taps."
width 5.
group.long 0x9c++0x3
    line.long 0x00 "WIAR,EIM IP Access Register"
        bitfld.long 0x00 0. " IPS_REQ ,IPS request." "0,1"
        textline "    "
        bitfld.long 0x00 1. " IPS_ACK ,IPS ACK." "0,1"
        textline "    "
        bitfld.long 0x00 2. " INT ,Interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 3. " ERRST ,READY After Reset." "0,1"
        textline "    "
        bitfld.long 0x00 4. " ACLK_EN ,ACLK enable." "0,1"
width 4.
group.long 0xa0++0x3
    line.long 0x00 "EAR,Error Address Register"
        hexmask.long.long 0x00 0.--32. 1. " ERROR_ADDR ,Error Address."


tree.end



;--------------------------------------------------------------------------------
; ENET
;--------------------------------------------------------------------------------
tree "ENET"
    base ad:0x02188000

width 4.
group.long 0x4++0x3
    line.long 0x00 "EIR,Interrupt Event Register"
        bitfld.long 0x00 15. " TS_TIMER ,The adjustable timer reached the period event." "0,1"
        textline "   "
        bitfld.long 0x00 16. " TS_AVAIL ,Indicates that the timestamp of the last transmitted timing frame is available in the ATSTMP register." "0,1"
        textline "   "
        bitfld.long 0x00 17. " WAKEUP ,Read-only status bit to indicate that a magic packet has been detected." "0,1"
        textline "   "
        bitfld.long 0x00 18. " PLR ,Indicates a frame was received with a payload length error." "0,1"
        textline "   "
        bitfld.long 0x00 19. " UN ,Indicates the transmit FIFO became empty before the complete frame was transmitted." "0,1"
        textline "   "
        bitfld.long 0x00 20. " RL ,Indicates a collision occurred on each of 16 successive attempts to transmit the frame." "0,1"
        textline "   "
        bitfld.long 0x00 21. " LC ,Indicates a collision occurred beyond the collision window (slot time) in half-duplex mode." "0,1"
        textline "   "
        bitfld.long 0x00 22. " EBERR ,Indicates a system bus error occurred when a uDMA transaction is underway." "0,1"
        textline "   "
        bitfld.long 0x00 23. " MII ,Indicates that the MII has completed the data transfer requested." "0,1"
        textline "   "
        bitfld.long 0x00 24. " RXB ,Indicates a receive buffer descriptor is not the last in the frame has been updated." "0,1"
        textline "   "
        bitfld.long 0x00 25. " RXF ,Indicates a frame has been received and the last corresponding buffer descriptor has been updated." "0,1"
        textline "   "
        bitfld.long 0x00 26. " TXB ,Indicates a transmit buffer descriptor has been updated." "0,1"
        textline "   "
        bitfld.long 0x00 27. " TXF ,Indicates a frame has been transmitted and the last corresponding buffer descriptor has been updated." "0,1"
        textline "   "
        bitfld.long 0x00 28. " GRA ,This interrupt is asserted after the transmitter is put into a pause state after completion of the frame currently being transmitted." "0,1"
        textline "   "
        bitfld.long 0x00 29. " BABT ,Indicates the transmitted frame length exceeds RCR[MAX_FL] bytes." "0,1"
        textline "   "
        bitfld.long 0x00 30. " BABR ,Indicates a frame was received with length in excess of RCR[MAX_FL] bytes." "0,1"
width 5.
group.long 0x8++0x3
    line.long 0x00 "EIMR,Interrupt Mask Register"
        bitfld.long 0x00 15. " TS_TIMER ,Corresponds to interrupt source TS_TIMER defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 16. " TS_AVAIL ,Corresponds to interrupt source TS_AVAIL defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 17. " WAKEUP ,Corresponds to interrupt source WAKEUP defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 18. " PLR ,Corresponds to interrupt source PLR defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 19. " UN ,Corresponds to interrupt source UN defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 20. " RL ,Corresponds to interrupt source RL defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 21. " LC ,Corresponds to interrupt source LC defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 22. " EBERR ,Corresponds to interrupt source EBERR defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 23. " MII ,Corresponds to interrupt source MII defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RXB ,Corresponds to interrupt source RXB defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 25. " RXF ,Corresponds to interrupt source RXF defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 26. " TXB ,Corresponds to interrupt source TXB defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 27. " TXF ,Corresponds to interrupt source TXF defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 28. " GRA ,Corresponds to interrupt source GRA defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 29. " BABT ,Corresponds to interrupt source BABT defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 30. " BABR ,Corresponds to interrupt source BABR defined by the EIR register and determines whether an interrupt condition can generate an interrupt." "0,1"
width 5.
group.long 0x10++0x3
    line.long 0x00 "RDAR,Receive Descriptor Active Register"
        bitfld.long 0x00 24. " RDAR ,Always set to 1 when this register is written, regardless of the value written." "0,1"
width 5.
group.long 0x14++0x3
    line.long 0x00 "TDAR,Transmit Descriptor Active Register"
        bitfld.long 0x00 24. " TDAR ,Always set to 1 when this register is written, regardless of the value written." "0,1"
width 4.
group.long 0x24++0x3
    line.long 0x00 "ECR,Ethernet Control Register"
        bitfld.long 0x00 0. " RESET ,When this field is set, it clears the ETHEREN field." "0,1"
        textline "   "
        bitfld.long 0x00 1. " ETHEREN ,Enables/disables the Ethernet MAC." "0,1"
        textline "   "
        bitfld.long 0x00 2. " MAGICEN ,Enables/disables magic packet detection." "0,1"
        textline "   "
        bitfld.long 0x00 3. " SLEEP ," "0,1"
        textline "   "
        bitfld.long 0x00 4. " EN1588 ,Enables enhanced functionality of the MAC." "0,1"
        textline "   "
        bitfld.long 0x00 6. " DBGEN ,Enables the MAC to enter hardware freeze mode when the device enters debug mode." "0,1"
        textline "   "
        bitfld.long 0x00 7. " STOPEN ,Controls device behavior in doze mode." "0,1"
width 5.
group.long 0x40++0x3
    line.long 0x00 "MMFR,MII Management Frame Register"
        hexmask.long.word 0x00 0.--16. 1. " DATA ,This is the field for data to be written to or read from the PHY register."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " TA ,This field must be programmed to 10 to generate a valid MII management frame."
        textline "    "
        hexmask.long.byte 0x00 18.--23. 1. " RA ,Specifies one of up to 32 registers within the specified PHY device."
        textline "    "
        hexmask.long.byte 0x00 23.--28. 1. " PA ,Specifies one of up to 32 attached PHY devices."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " OP ,Determines the frame operation."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ST ,These fields must be programmed to 01 for a valid MII management frame."
width 5.
group.long 0x44++0x3
    line.long 0x00 "MSCR,MII Speed Control Register"
        hexmask.long.byte 0x00 1.--7. 1. " MII_SPEED ,Controls the frequency of the MII management interface clock (MDC) relative to the internal module clock."
        textline "    "
        bitfld.long 0x00 7. " DIS_PRE ,Enables/disables prepending a preamble to the MII management frame." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--11. 1. " HOLDTIME ,IEEE802.3 clause 22 defines a minimum of 10 ns for the holdtime on the MDIO output."
width 5.
group.long 0x64++0x3
    line.long 0x00 "MIBC,MIB Control Register"
        bitfld.long 0x00 29. " MIB_CLEAR ,If set, all statistics counters are reset to 0." "0,1"
        textline "    "
        bitfld.long 0x00 30. " MIB_IDLE ,If this status field is set, the MIB block is not currently updating any MIB counters." "0,1"
        textline "    "
        bitfld.long 0x00 31. " MIB_DIS ,If this control field is set, the MIB logic halts and does not update any MIB counters." "0,1"
width 4.
group.long 0x84++0x3
    line.long 0x00 "RCR,Receive Control Register"
        bitfld.long 0x00 0. " LOOP ,This is an MII internal loopback, therefore MII_MODE must be written to 1 and RMII_MODE must be written to 0." "0,1"
        textline "   "
        bitfld.long 0x00 1. " DRT ," "0,1"
        textline "   "
        bitfld.long 0x00 2. " MII_MODE ,This field must always be set." "0,1"
        textline "   "
        bitfld.long 0x00 3. " PROM ,All frames are accepted regardless of address matching." "0,1"
        textline "   "
        bitfld.long 0x00 4. " BC_REJ ,If set, frames with destination address (DA) equal to 0xFFFF_FFFF_FFFF are rejected unless the PROM field is set." "0,1"
        textline "   "
        bitfld.long 0x00 5. " FCE ,If set, the receiver detects PAUSE frames." "0,1"
        textline "   "
        bitfld.long 0x00 8. " RMII_MODE ,Specifies whether the MAC is configured for MII mode or RMII operation ." "0,1"
        textline "   "
        bitfld.long 0x00 9. " RMII_10T ,Enables 10-Mbps mode of the RMII ." "0,1"
        textline "   "
        bitfld.long 0x00 12. " PADEN ,Specifies whether the MAC removes padding from received frames." "0,1"
        textline "   "
        bitfld.long 0x00 13. " PAUFWD ,Specifies whether pause frames are terminated or forwarded." "0,1"
        textline "   "
        bitfld.long 0x00 14. " CRCFWD ,Specifies whether the CRC field of received frames is transmitted or stripped." "0,1"
        textline "   "
        bitfld.long 0x00 15. " CFEN ,Enables/disables the MAC control frame." "0,1"
        textline "   "
        hexmask.long.word 0x00 16.--30. 1. " MAX_FL ,Resets to decimal 1518."
        textline "   "
        bitfld.long 0x00 30. " NLC ,Enables/disables a payload length check." "0,1"
        textline "   "
        bitfld.long 0x00 31. " GRS ,Read-only status indicating that the MAC receive datapath is stopped." "0,1"
width 4.
group.long 0xc4++0x3
    line.long 0x00 "TCR,Transmit Control Register"
        bitfld.long 0x00 0. " GTS ,When this field is set, MAC stops transmission after any frame currently transmitted is complete and EIR[GRA] is set." "0,1"
        textline "   "
        bitfld.long 0x00 2. " FDEN ,If this field is set, frames transmit independent of carrier sense and collision inputs." "0,1"
        textline "   "
        bitfld.long 0x00 3. " TFC_PAUSE ,Pauses frame transmission." "0,1"
        textline "   "
        bitfld.long 0x00 4. " RFC_PAUSE ,This status field is set when a full-duplex flow control pause frame is received and the transmitter pauses for the duration defined in this pause frame." "0,1"
        textline "   "
        hexmask.long.byte 0x00 5.--8. 1. " ADDSEL ,If ADDINS is set, indicates the MAC address that overwrites the source MAC address."
        textline "   "
        bitfld.long 0x00 8. " ADDINS ," "0,1"
        textline "   "
        bitfld.long 0x00 9. " CRCFWD ," "0,1"
width 5.
group.long 0xe4++0x3
    line.long 0x00 "PALR,Physical Address Lower Register"
        hexmask.long.long 0x00 0.--32. 1. " PADDR1 ,Bytes 0 (bits 31:24), 1 (bits 23:16), 2 (bits 15:8), and 3 (bits 7:0) of the 6-byte individual address are used for exact match and the source address field in PAUSE frames."
width 5.
group.long 0xe8++0x3
    line.long 0x00 "PAUR,Physical Address Upper Register"
        hexmask.long.word 0x00 0.--16. 1. " TYPE ,These fields have a constant value of 0x8808."
        textline "    "
        hexmask.long.word 0x00 16.--32. 1. " PADDR2 ,Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual address used for exact match, and the source address field in PAUSE frames."
width 4.
group.long 0xec++0x3
    line.long 0x00 "OPD,Opcode/Pause Duration Register"
        hexmask.long.word 0x00 0.--16. 1. " PAUSE_DUR ,Pause duration field used in PAUSE frames."
        textline "   "
        hexmask.long.word 0x00 16.--32. 1. " OPCODE ,These fields have a constant value of 0x0001."
width 5.
group.long 0x118++0x3
    line.long 0x00 "IAUR,Descriptor Individual Upper Address Register"
        hexmask.long.long 0x00 0.--32. 1. " IADDR1 ,Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address."
width 5.
group.long 0x11c++0x3
    line.long 0x00 "IALR,Descriptor Individual Lower Address Register"
        hexmask.long.long 0x00 0.--32. 1. " IADDR2 ,Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a unicast address."
width 5.
group.long 0x120++0x3
    line.long 0x00 "GAUR,Descriptor Group Upper Address Register"
        hexmask.long.long 0x00 0.--32. 1. " GADDR1 ,Contains the upper 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address."
width 5.
group.long 0x124++0x3
    line.long 0x00 "GALR,Descriptor Group Lower Address Register"
        hexmask.long.long 0x00 0.--32. 1. " GADDR2 ,Contains the lower 32 bits of the 64-bit hash table used in the address recognition process for receive frames with a multicast address."
width 5.
group.long 0x144++0x3
    line.long 0x00 "TFWR,Transmit FIFO Watermark Register"
        hexmask.long.byte 0x00 0.--6. 1. " TFWR ,If STRFWD is cleared, this field indicates the number of bytes written to the transmit FIFO before transmission of a frame begins."
        textline "    "
        bitfld.long 0x00 8. " STRFWD ," "0,1"
width 5.
group.long 0x180++0x3
    line.long 0x00 "RDSR,Receive Descriptor Ring Start Register"
        hexmask.long.long 0x00 3.--32. 1. " R_DES_START ,Pointer to the beginning of the receive buffer descriptor queue."
width 5.
group.long 0x184++0x3
    line.long 0x00 "TDSR,Transmit Buffer Descriptor Ring Start Register"
        hexmask.long.long 0x00 3.--32. 1. " X_DES_START ,Pointer to the beginning of the transmit buffer descriptor queue."
width 5.
group.long 0x188++0x3
    line.long 0x00 "MRBR,Maximum Receive Buffer Size Register"
        hexmask.long.word 0x00 4.--14. 1. " R_BUF_SIZE ,Receive buffer size in bytes."
width 5.
group.long 0x190++0x3
    line.long 0x00 "RSFL,Receive FIFO Section Full Threshold"
width 5.
group.long 0x194++0x3
    line.long 0x00 "RSEM,Receive FIFO Section Empty Threshold"
width 5.
group.long 0x198++0x3
    line.long 0x00 "RAEM,Receive FIFO Almost Empty Threshold"
width 5.
group.long 0x19c++0x3
    line.long 0x00 "RAFL,Receive FIFO Almost Full Threshold"
width 5.
group.long 0x1a0++0x3
    line.long 0x00 "TSEM,Transmit FIFO Section Empty Threshold"
width 5.
group.long 0x1a4++0x3
    line.long 0x00 "TAEM,Transmit FIFO Almost Empty Threshold"
width 5.
group.long 0x1a8++0x3
    line.long 0x00 "TAFL,Transmit FIFO Almost Full Threshold"
width 5.
group.long 0x1ac++0x3
    line.long 0x00 "TIPG,Transmit Inter-Packet Gap"
        hexmask.long.byte 0x00 0.--5. 1. " IPG ,Indicates the IPG, in bytes, between transmitted frames."
width 5.
group.long 0x1b0++0x3
    line.long 0x00 "FTRL,Frame Truncation Length"
        hexmask.long.word 0x00 0.--14. 1. " TRUNC_FL ,Indicates the value a receive frame is truncated, if it is greater than this value."
width 5.
group.long 0x1c0++0x3
    line.long 0x00 "TACC,Transmit Accelerator Function Configuration"
        bitfld.long 0x00 0. " SHIFT16 ," "0,1"
        textline "    "
        bitfld.long 0x00 3. " IPCHK ,Enables insertion of IP header checksum." "0,1"
        textline "    "
        bitfld.long 0x00 4. " PROCHK ,Enables insertion of protocol checksum." "0,1"
width 5.
group.long 0x1c4++0x3
    line.long 0x00 "RACC,Receive Accelerator Function Configuration"
        bitfld.long 0x00 0. " PADREM ," "0,1"
        textline "    "
        bitfld.long 0x00 1. " IPDIS ," "0,1"
        textline "    "
        bitfld.long 0x00 2. " PRODIS ," "0,1"
        textline "    "
        bitfld.long 0x00 6. " LINEDIS ," "0,1"
        textline "    "
        bitfld.long 0x00 7. " SHIFT16 ,When this field is set, the actual frame data starts at bit 16 of the first word read from the RX FIFO aligning the Ethernet payload on a 32-bit boundary." "0,1"
width 5.
group.long 0x400++0x3
    line.long 0x00 "ATCR,Timer Control Register"
        bitfld.long 0x00 0. " EN ," "0,1"
        textline "    "
        bitfld.long 0x00 2. " OFFEN ," "0,1"
        textline "    "
        bitfld.long 0x00 3. " OFFRST ," "0,1"
        textline "    "
        bitfld.long 0x00 4. " PEREN ," "0,1"
        textline "    "
        bitfld.long 0x00 7. " PINPER ,Enables event signal output assertion on period event." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RESTART ,Resets the timer to zero." "0,1"
        textline "    "
        bitfld.long 0x00 11. " CAPTURE ," "0,1"
        textline "    "
        bitfld.long 0x00 13. " SLAVE ," "0,1"
width 5.
group.long 0x404++0x3
    line.long 0x00 "ATVR,Timer Value Register"
        hexmask.long.long 0x00 0.--32. 1. " ATIME ,A write sets the timer."
width 6.
group.long 0x408++0x3
    line.long 0x00 "ATOFF,Timer Offset Register"
        hexmask.long.long 0x00 0.--32. 1. " OFFSET ,Offset value for one-shot event generation."
width 6.
group.long 0x40c++0x3
    line.long 0x00 "ATPER,Timer Period Register"
        hexmask.long.long 0x00 0.--32. 1. " PERIOD ,Value for generating periodic events."
width 6.
group.long 0x410++0x3
    line.long 0x00 "ATCOR,Timer Correction Register"
        hexmask.long.long 0x00 0.--31. 1. " COR ,Defines after how many timer clock cycles (ts_clk) the correction counter should be reset and trigger a correction increment on the timer."
width 6.
group.long 0x414++0x3
    line.long 0x00 "ATINC,Time-Stamping Clock Period Register"
        hexmask.long.byte 0x00 0.--7. 1. " INC ,The timer increments by this amount each clock cycle."
        textline "     "
        hexmask.long.byte 0x00 8.--15. 1. " INC_CORR ,This value is added every time the correction timer expires (every clock cycle given in ATCOR)."
width 7.
rgroup.long 0x418++0x3
    line.long 0x00 "ATSTMP,Timestamp of Last Transmitted Frame"
        hexmask.long.long 0x00 0.--32. 1. " TIMESTAMP ,Timestamp of the last frame transmitted by the core that had TxBD[TS] set ."


tree.end



;--------------------------------------------------------------------------------
; EPDC
;--------------------------------------------------------------------------------
tree "EPDC"
    base ad:0x020f4000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CTRL,EPDC Control Register"
        bitfld.long 0x00 0. " BURST_LEN_8 ,0- EPDC display fifo logic will issue AXI bursts of length 16." "0,1"
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " LUT_DATA_SWIZZLE ,Specifies how to swap the bytes for the LUT data before store to LUTRAM."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " UPD_DATA_SWIZZLE ,Specifies how to swap the bytes for the UPD data before the WB construction."
        textline "    "
        bitfld.long 0x00 8. " SRAM_POWERDOWN ,Enable Power-down of embedded SRAM memories" "0,1"
        textline "    "
        bitfld.long 0x00 30. " CLKGATE ,This bit must be set to zero for normal operation." "0,1"
        textline "    "
        bitfld.long 0x00 31. " SFTRST ,Set this bit to zero to enable normal EPDC operation." "0,1"
width 7.
group.long 0x20++0x3
    line.long 0x00 "WVADDR,EPDC Waveform Address Pointer"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Start address of waveform tables."
width 8.
group.long 0x30++0x3
    line.long 0x00 "WB_ADDR,EPDC Working Buffer Address"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address for EPDC working buffer."
width 4.
group.long 0x40++0x3
    line.long 0x00 "RES,EPDC Screen Resolution"
        hexmask.long.word 0x00 0.--13. 1. " HORIZONTAL ,Horizontal Resolution (in pixels)"
        textline "   "
        hexmask.long.word 0x00 16.--29. 1. " VERTICAL ,Vertical Resoltion (in pixels)"
width 7.
group.long 0x50++0x3
    line.long 0x00 "FORMAT,EPDC Format Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " TFT_PIXEL_FORMAT ,EPDC TFT Pixel Format."
        textline "      "
        hexmask.long.byte 0x00 8.--11. 1. " BUF_PIXEL_FORMAT ,EPDC Input Buffer Pixel format."
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " DEFAULT_TFT_PIXEL ,Default TFT pixel value."
        textline "      "
        bitfld.long 0x00 24. " BUF_PIXEL_SCALE ,Selects method of conversion from 8-bit input" "0,1"
width 9.
group.long 0xa0++0x3
    line.long 0x00 "FIFOCTRL,EPDC FIFO control register"
        hexmask.long.byte 0x00 0.--8. 1. " FIFO_L_LEVEL ,Lower level value of FIFO watermark."
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " FIFO_H_LEVEL ,Upper level value of FIFO watermark."
        textline "        "
        hexmask.long.byte 0x00 16.--24. 1. " FIFO_INIT_LEVEL ,This register sets the watermark for the pixel-fifo."
        textline "        "
        bitfld.long 0x00 31. " ENABLE_PRIORITY ,Enable watermark-based priority elevation mechanism." "0,1"
width 9.
group.long 0x100++0x3
    line.long 0x00 "UPD_ADDR,EPDC Update Region Address"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address for incoming region update."
width 11.
group.long 0x110++0x3
    line.long 0x00 "UPD_STRIDE,EPDC Update Region Stride"
        hexmask.long.long 0x00 0.--32. 1. " STRIDE ,line stride for incoming region update"
width 9.
group.long 0x120++0x3
    line.long 0x00 "UPD_CORD,EPDC Update Command Co-ordinate"
        hexmask.long.word 0x00 0.--13. 1. " XCORD ,X co-ordinate for incoming region update"
        textline "        "
        hexmask.long.word 0x00 16.--29. 1. " YCORD ,Y co-ordinate for incoming region update"
width 9.
group.long 0x140++0x3
    line.long 0x00 "UPD_SIZE,EPDC Update Command Size"
        hexmask.long.word 0x00 0.--13. 1. " WIDTH ,Width (in pixels)"
        textline "        "
        hexmask.long.word 0x00 16.--29. 1. " HEIGHT ,Height (in pixels)"
width 9.
group.long 0x160++0x3
    line.long 0x00 "UPD_CTRL,EPDC Update Command Control"
        bitfld.long 0x00 0. " UPDATE_MODE ,Update Mode" "0,1"
        textline "        "
        bitfld.long 0x00 1. " DRY_RUN ,Enable Dry Run mode(set to 1)." "0,1"
        textline "        "
        bitfld.long 0x00 2. " AUTOWV ,enable automatical waveform mode selection" "0,1"
        textline "        "
        bitfld.long 0x00 3. " AUTOWV_PAUSE ," "0,1"
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " WAVEFORM_MODE ,Waveform Mode 0-255"
        textline "        "
        hexmask.long.byte 0x00 16.--22. 1. " LUT_SEL ,LUT select 0-63"
        textline "        "
        bitfld.long 0x00 31. " USE_FIXED ,Use fixed pixel values (requires programming of HW_EPDC_UPD_FIXED)" "0,1"
width 10.
group.long 0x180++0x3
    line.long 0x00 "UPD_FIXED,EPDC Update Fixed Pixel Control"
        hexmask.long.byte 0x00 0.--8. 1. " FIXCP ,CP value if fixecp_en is set to 1."
        textline "         "
        hexmask.long.byte 0x00 8.--16. 1. " FIXNP ,NP value if fixenp_en is set to 1."
        textline "         "
        bitfld.long 0x00 30. " FIXCP_EN ,If set to 1, current updated region has the CP value defined by FIXCP" "0,1"
        textline "         "
        bitfld.long 0x00 31. " FIXNP_EN ,If set to 1, current updated region has the NP value defined by FIXNP" "0,1"
width 5.
group.long 0x1a0++0x3
    line.long 0x00 "TEMP,EPDC Temperature Register"
        hexmask.long.long 0x00 0.--32. 1. " TEMPERATURE ,Temperature Value."
width 11.
group.long 0x1c0++0x3
    line.long 0x00 "AUTOWV_LUT,Waveform Mode Lookup Table Control Register."
        hexmask.long.byte 0x00 0.--8. 1. " ADDR ,ADDR"
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " DATA ,DATA"
width 9.
group.long 0x200++0x3
    line.long 0x00 "TCE_CTRL,EPDC Timing Control Engine Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " PIXELS_PER_SDCLK ,Number of TFT pixels per SDCLK period."
        textline "        "
        bitfld.long 0x00 2. " SDDO_WIDTH ,Selects either 8 or 16 bit SDDO bus format" "0,1"
        textline "        "
        bitfld.long 0x00 3. " DUAL_SCAN ,Enables dual scan-mode." "0,1"
        textline "        "
        bitfld.long 0x00 4. " SCAN_DIR_0 ,Determines scan direction for each half of the TFT panel" "0,1"
        textline "        "
        bitfld.long 0x00 5. " SCAN_DIR_1 ,Determines scan direction for each half of the TFT panel" "0,1"
        textline "        "
        bitfld.long 0x00 6. " LVDS_MODE ,If set, the upper 8-bit of the SDDO bus are used for LVDS differential signalling." "0,1"
        textline "        "
        bitfld.long 0x00 7. " LVDS_MODE_CE ,If set (together with LVDS_MODE=1), SDCE[9:5] shall be driven as the differential inverse of SDCE[4:0]." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DDR_MODE ,If set, SDDO data is driven on both positive and negative edges of SDCLK." "0,1"
        textline "        "
        bitfld.long 0x00 9. " VCOM_MODE ,This field determines the method used to drive the VCOM signal." "0,1"
        textline "        "
        hexmask.long.byte 0x00 10.--12. 1. " VCOM_VAL ,When VCOM_MODE = MANUAL, this value is used to manually set the VCOM value for the VCOM[1:0] pins"
        textline "        "
        hexmask.long.word 0x00 16.--25. 1. " VSCAN_HOLDOFF ,This period (expressed in vertical lines), sets the portion of the vertical blanking available for new LUTs to be activated."
width 10.
group.long 0x220++0x3
    line.long 0x00 "TCE_SDCFG,EPDC Timing Control Engine Source-Driver Config Register"
        hexmask.long.word 0x00 0.--13. 1. " PIXELS_PER_CE ,Number of pixels (outputs) per source-driver IC."
        textline "         "
        bitfld.long 0x00 13. " SDDO_INVERT ,Setting this bit to 1 reverses the polarity of each SDDO bit so 0xAAAA in 16-bit mode for example becomes 0x5555." "0,1"
        textline "         "
        hexmask.long.byte 0x00 14.--16. 1. " SDDO_REFORMAT ,This register defines the various re-formatting options to enable more flexibility in the source-driver interface:"
        textline "         "
        hexmask.long.byte 0x00 16.--20. 1. " NUM_CE ,Number of source driver IC chip-enables."
        textline "         "
        bitfld.long 0x00 20. " SDSHR ,Value for source-driver shift direction output port" "0,1"
        textline "         "
        bitfld.long 0x00 21. " SDCLK_HOLD ,Setting this bit to 1 holds the SDCLK low during LINE_BEGIN" "0,1"
width 10.
group.long 0x240++0x3
    line.long 0x00 "TCE_GDCFG,EPDC Timing Control Engine Gate-Driver Config Register"
        bitfld.long 0x00 0. " GDSP_MODE ,Selects method for driving GDSP pulse." "0,1"
        textline "         "
        bitfld.long 0x00 1. " GDOE_MODE ,Selects method for driving GDOE signal." "0,1"
        textline "         "
        bitfld.long 0x00 4. " GDRL ,Value for gate-driver right/left shift output port" "0,1"
        textline "         "
        hexmask.long.word 0x00 16.--32. 1. " PERIOD_VSCAN ,when vscan state is splited, this reg defines the counter period"
width 11.
group.long 0x260++0x3
    line.long 0x00 "TCE_HSCAN1,EPDC Timing Control Engine Horizontal Timing Register 1"
        hexmask.long.word 0x00 0.--12. 1. " LINE_SYNC ,Number of PIXCLK cycles for line sync duration."
        textline "          "
        hexmask.long.word 0x00 16.--28. 1. " LINE_SYNC_WIDTH ,Number of PIXCLK cycles for the SDLE active time."
width 11.
group.long 0x280++0x3
    line.long 0x00 "TCE_HSCAN2,EPDC Timing Control Engine Horizontal Timing Register 2"
        hexmask.long.word 0x00 0.--12. 1. " LINE_BEGIN ,Number of PIXCLK cycles for line begin duration."
        textline "          "
        hexmask.long.word 0x00 16.--28. 1. " LINE_END ,Number of PIXCLK cycles for line end duration."
width 10.
group.long 0x2a0++0x3
    line.long 0x00 "TCE_VSCAN,EPDC Timing Control Engine Vertical Timing Register"
        hexmask.long.byte 0x00 0.--8. 1. " FRAME_SYNC ,Number of lines for frame sync duration."
        textline "         "
        hexmask.long.byte 0x00 8.--16. 1. " FRAME_BEGIN ,Number of lines for frame begin duration."
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " FRAME_END ,Number of lines for frame end duration."
width 7.
group.long 0x2c0++0x3
    line.long 0x00 "TCE_OE,EPDC Timing Control Engine OE timing control Register"
        hexmask.long.byte 0x00 0.--8. 1. " SDOEZ_DLY ,Number of PIXCLK cycles from SDLE falling edge to SDOEZ rising (Must be greater than 0)"
        textline "      "
        hexmask.long.byte 0x00 8.--16. 1. " SDOEZ_WIDTH ,Number of PIXCLK cycles from SDOEZ high to SDOEZ falling (Must be greater than 0)"
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " SDOED_DLY ,Number of PIXCLK cycles from SDOEZ low to SDOED rising (Must be greater than 0)"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " SDOED_WIDTH ,Number of PIXCLK cycles from SDOED high to SDOED falling (Must be greater than 0)"
width 13.
group.long 0x2e0++0x3
    line.long 0x00 "TCE_POLARITY,EPDC Timing Control Engine Driver Polarity Register"
        bitfld.long 0x00 0. " SDCE_POL ,0 = Active Low, 1 = Active High." "0,1"
        textline "            "
        bitfld.long 0x00 1. " SDLE_POL ,0 = Active Low, 1 = Active High." "0,1"
        textline "            "
        bitfld.long 0x00 2. " SDOE_POL ,0 = Active Low, 1 = Active High." "0,1"
        textline "            "
        bitfld.long 0x00 3. " GDOE_POL ,0 = Active Low, 1 = Active High." "0,1"
        textline "            "
        bitfld.long 0x00 4. " GDSP_POL ,0 = Active Low, 1 = Active High." "0,1"
width 12.
group.long 0x300++0x3
    line.long 0x00 "TCE_TIMING1,EPDC Timing Control Engine Timing Register 1"
        hexmask.long.byte 0x00 0.--2. 1. " SDCLK_SHIFT ,This register can be used to implement additional timing setup/hold adjustment of source driver signals by adjusting the SDCLK up to 4 cycles"
        textline "           "
        bitfld.long 0x00 3. " SDCLK_INVERT ,Invert phase of SDCLK" "0,1"
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " SDLE_SHIFT ,This register can be used to implement additional timing setup/hold adjustment of source driver signals by adjusting the SDCLK up to 3 PIXCLK cycles"
width 12.
group.long 0x310++0x3
    line.long 0x00 "TCE_TIMING2,EPDC Timing Control Engine Timing Register 2"
        hexmask.long.word 0x00 0.--16. 1. " GDSP_OFFSET ,This register allows the user to shift the GDSP pulse by N PIXCLKs where N=1 to 65535."
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " GDCLK_HP ,This register controls the GDCLK high-pulse width."
width 12.
group.long 0x320++0x3
    line.long 0x00 "TCE_TIMING3,EPDC Timing Control Engine Timing Register 3"
        hexmask.long.word 0x00 0.--16. 1. " GDCLK_OFFSET ,This register allows the user to shift the GDCLK from the line time by N PIXCLK cycles."
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " GDOE_OFFSET ,When using GDOE_MODE=1, this register sets the delay from GDCLK to the GDOE in terms of N PIXCLK cycles"
width 13.
group.long 0x380++0x3
    line.long 0x00 "PIGEON_CTRL0,EPDC Pigeon Mode Control Register 0"
        hexmask.long.word 0x00 0.--12. 1. " FD_PERIOD ,period of line counter during FD phase"
        textline "            "
        hexmask.long.word 0x00 16.--28. 1. " LD_PERIOD ,period of pclk counter during LD phase"
width 13.
group.long 0x390++0x3
    line.long 0x00 "PIGEON_CTRL1,EPDC Pigeon Mode Control Register 1"
        hexmask.long.word 0x00 0.--12. 1. " FRAME_CNT_PERIOD ,period of frame counter"
        textline "            "
        hexmask.long.word 0x00 16.--28. 1. " FRAME_CNT_CYCLES ,max cycles of frame counter"
width 10.
group.long 0x3c0++0x3
    line.long 0x00 "IRQ_MASK1,EPDC IRQ Mask Register for LUT 0~31"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_CMPLT_IRQ_EN ,LUT0~31 Complete Interrupt Enable"
width 10.
group.long 0x3d0++0x3
    line.long 0x00 "IRQ_MASK2,EPDC IRQ Mask Register for LUT 32~63"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_CMPLT_IRQ_EN ,LUT32~64 Complete Interrupt Enable"
width 5.
group.long 0x3e0++0x3
    line.long 0x00 "IRQ1,EPDC Interrupt Register for LUT 0~31"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_CMPLT_IRQ ,LUT 0~31 Complete Interrupt"
width 5.
group.long 0x3f0++0x3
    line.long 0x00 "IRQ2,EPDC Interrupt Registerr for LUT 32~63"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_CMPLT_IRQ ,LUT 32~64 Complete Interrupt"
width 9.
group.long 0x400++0x3
    line.long 0x00 "IRQ_MASK,EPDC IRQ Mask Register"
        bitfld.long 0x00 16. " WB_CMPLT_IRQ_EN ,Enable WB complete interrupt" "0,1"
        textline "        "
        bitfld.long 0x00 17. " COL_IRQ_EN ,Enable collision detection interrupts for all LUTs" "0,1"
        textline "        "
        bitfld.long 0x00 18. " TCE_UNDERRUN_IRQ_EN ,Enable pixel FIFO under-run condition detection." "0,1"
        textline "        "
        bitfld.long 0x00 19. " FRAME_END_IRQ_EN ,If this bit is set, EPDC will assert the current frame end interrupt." "0,1"
        textline "        "
        bitfld.long 0x00 20. " BUS_ERROR_IRQ_EN ,Enable AXI BUS ERROR interrupt detection." "0,1"
        textline "        "
        bitfld.long 0x00 21. " TCE_IDLE_IRQ_EN ,Enable TCE Idle interrupt detection." "0,1"
        textline "        "
        bitfld.long 0x00 22. " UPD_DONE_IRQ_EN ,Enable UPD complete interrupt" "0,1"
        textline "        "
        bitfld.long 0x00 23. " PWR_IRQ_EN ,Enable power interrupt" "0,1"
width 4.
group.long 0x420++0x3
    line.long 0x00 "IRQ,EPDC Interrupt Register"
        bitfld.long 0x00 16. " WB_CMPLT_IRQ ,Working buffer process complete Interrupt" "0,1"
        textline "   "
        bitfld.long 0x00 17. " LUT_COL_IRQ ,Collision detection interrupt." "0,1"
        textline "   "
        bitfld.long 0x00 18. " TCE_UNDERRUN_IRQ ,Interrupt to indicate that a pixel FIFO under-run has occured." "0,1"
        textline "   "
        bitfld.long 0x00 19. " FRAME_END_IRQ ,Interrupt to indicate EPDC has completed the current frame and is in the vertical blanking period." "0,1"
        textline "   "
        bitfld.long 0x00 20. " BUS_ERROR_IRQ ,Interrupt to indicate AXI BUS error occurs." "0,1"
        textline "   "
        bitfld.long 0x00 21. " TCE_IDLE_IRQ ,Interrupt to indicate that the TCE has completed TFT frame scans and is in an idle state." "0,1"
        textline "   "
        bitfld.long 0x00 22. " UPD_DONE_IRQ ,Working buffer process complete Interrupt" "0,1"
        textline "   "
        bitfld.long 0x00 23. " PWR_IRQ ,Power Interrupt" "0,1"
width 13.
group.long 0x440++0x3
    line.long 0x00 "STATUS_LUTS1,EPDC Status Register - LUTs"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_STS ,LUT 0~31 Status : 1=ACTIVE, 0=IDLE"
width 13.
group.long 0x450++0x3
    line.long 0x00 "STATUS_LUTS2,EPDC Status Register - LUTs"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_STS ,LUT 32~63 Status : 1=ACTIVE, 0=IDLE"
width 15.
group.long 0x460++0x3
    line.long 0x00 "STATUS_NEXTLUT,EPDC Status Register - Next Available LUT"
        hexmask.long.byte 0x00 0.--6. 1. " NEXT_LUT ,Next available LUT value"
        textline "              "
        bitfld.long 0x00 8. " NEXT_LUT_VALID ,This bitfield can be used to check against a LUTs full condition" "0,1"
width 12.
group.long 0x480++0x3
    line.long 0x00 "STATUS_COL1,EPDC LUT Collision Status"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_COL_STS ,LUTn Collision Status"
width 12.
group.long 0x490++0x3
    line.long 0x00 "STATUS_COL2,EPDC LUT Collision Status"
        hexmask.long.long 0x00 0.--32. 1. " LUTN_COL_STS ,LUTn Collision Status"
width 7.
group.long 0x4a0++0x3
    line.long 0x00 "STATUS,EPDC General Status Register"
        bitfld.long 0x00 0. " WB_BUSY ,Working buffer process is busy cannot accept new update requests." "0,1"
        textline "      "
        bitfld.long 0x00 1. " LUTS_BUSY ,Provides a summary status of LUTs." "0,1"
        textline "      "
        bitfld.long 0x00 2. " LUTS_UNDERRUN ,Provides a summary status of LUT fill." "0,1"
        textline "      "
        hexmask.long.byte 0x00 8.--13. 1. " HISTOGRAM_NP ,Indicates which histogram matched the processed bitmap(NP)."
        textline "      "
        hexmask.long.byte 0x00 16.--21. 1. " HISTOGRAM_CP ,Indicates which histogram matched the existing bitmap(CP)."
width 13.
group.long 0x4c0++0x3
    line.long 0x00 "UPD_COL_CORD,EPDC Collision Region Co-ordinate"
        hexmask.long.word 0x00 0.--13. 1. " XCORD ,X co-ordinate for collision region of the latest completed update"
        textline "            "
        hexmask.long.word 0x00 16.--29. 1. " YCORD ,Y co-ordinate for collision region of the latest completed update"
width 13.
group.long 0x4e0++0x3
    line.long 0x00 "UPD_COL_SIZE,EPDC Collision Region Size"
        hexmask.long.word 0x00 0.--13. 1. " WIDTH ,Width (in pixels)"
        textline "            "
        hexmask.long.word 0x00 16.--29. 1. " HEIGHT ,Height (in pixels)"
width 12.
group.long 0x600++0x3
    line.long 0x00 "HIST1_PARAM,1-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,value for 1-level histogram"
width 12.
group.long 0x610++0x3
    line.long 0x00 "HIST2_PARAM,2-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,Black value for 2-level histogram"
        textline "           "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,White value for 2-level histogram"
width 12.
group.long 0x620++0x3
    line.long 0x00 "HIST4_PARAM,4-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,GRAY0 (Black) value for 4-level histogram"
        textline "           "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,GRAY1 value for 4-level histogram"
        textline "           "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE2 ,GRAY2 value for 4-level histogram"
        textline "           "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE3 ,GRAY3 (White) value for 4-level histogram"
width 13.
group.long 0x630++0x3
    line.long 0x00 "HIST8_PARAM0,8-level Histogram Parameter 0 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,GRAY0 (Black) value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,GRAY1 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE2 ,GRAY2 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE3 ,GRAY3 value for 8-level histogram"
width 13.
group.long 0x640++0x3
    line.long 0x00 "HIST8_PARAM1,8-level Histogram Parameter 1 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE4 ,GRAY4 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE5 ,GRAY5 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE6 ,GRAY6 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE7 ,GRAY7 (White) value for 8-level histogram"
width 14.
group.long 0x650++0x3
    line.long 0x00 "HIST16_PARAM0,16-level Histogram Parameter 0 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,GRAY0 (Black) value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,GRAY1 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE2 ,GRAY2 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE3 ,GRAY3 value for 16-level histogram"
width 14.
group.long 0x660++0x3
    line.long 0x00 "HIST16_PARAM1,16-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE4 ,GRAY4 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE5 ,GRAY5 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE6 ,GRAY6 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE7 ,GRAY7 value for 16-level histogram"
width 14.
group.long 0x670++0x3
    line.long 0x00 "HIST16_PARAM2,16-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE8 ,GRAY8 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE9 ,GRAY9 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE10 ,GRAY10 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE11 ,GRAY11 value for 16-level histogram"
width 14.
group.long 0x680++0x3
    line.long 0x00 "HIST16_PARAM3,16-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE12 ,GRAY12 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE13 ,GRAY13 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE14 ,GRAY14 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE15 ,GRAY15 (White) value for 16-level histogram"
width 5.
group.long 0x700++0x3
    line.long 0x00 "GPIO,EPDC General Purpose I/O Debug register"
        hexmask.long.byte 0x00 0.--2. 1. " BDR ,Controls ipp_epdc_bdr[1:0] output"
        textline "    "
        hexmask.long.byte 0x00 2.--6. 1. " PWRCTRL ,Controls ipp_epdc_pwrctrl[3:0] output"
        textline "    "
        bitfld.long 0x00 6. " PWRCOM ,Controls ipp_epdc_pwrcom output" "0,1"
        textline "    "
        bitfld.long 0x00 7. " PWRWAKE ,Controls ipp_epdc_pwrwake output" "0,1"
        textline "    "
        bitfld.long 0x00 8. " PWRSTAT ,reflect ipp_epdc_pwrstat input" "0,1"
width 8.
group.long 0x7f0++0x3
    line.long 0x00 "VERSION,EPDC Version Register"
        hexmask.long.word 0x00 0.--16. 1. " STEP ,Fixed read-only value reflecting the stepping of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of the RTL version."
width 11.
group.long 0x800++0x3
    line.long 0x00 "PIGEON_0_0,Panel Interface Signal Generator Register 0_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x810++0x3
    line.long 0x00 "PIGEON_0_1,Panel Interface Signal Generator Register 0_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x820++0x3
    line.long 0x00 "PIGEON_0_2,Panel Interface Signal Generator Register 0_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x840++0x3
    line.long 0x00 "PIGEON_1_0,Panel Interface Signal Generator Register 1_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x850++0x3
    line.long 0x00 "PIGEON_1_1,Panel Interface Signal Generator Register 1_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x860++0x3
    line.long 0x00 "PIGEON_1_2,Panel Interface Signal Generator Register 1_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x880++0x3
    line.long 0x00 "PIGEON_2_0,Panel Interface Signal Generator Register 2_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x890++0x3
    line.long 0x00 "PIGEON_2_1,Panel Interface Signal Generator Register 2_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x8a0++0x3
    line.long 0x00 "PIGEON_2_2,Panel Interface Signal Generator Register 2_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x8c0++0x3
    line.long 0x00 "PIGEON_3_0,Panel Interface Signal Generator Register 3_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x8d0++0x3
    line.long 0x00 "PIGEON_3_1,Panel Interface Signal Generator Register 3_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x8e0++0x3
    line.long 0x00 "PIGEON_3_2,Panel Interface Signal Generator Register 3_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x900++0x3
    line.long 0x00 "PIGEON_4_0,Panel Interface Signal Generator Register 4_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x910++0x3
    line.long 0x00 "PIGEON_4_1,Panel Interface Signal Generator Register 4_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x920++0x3
    line.long 0x00 "PIGEON_4_2,Panel Interface Signal Generator Register 4_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x940++0x3
    line.long 0x00 "PIGEON_5_0,Panel Interface Signal Generator Register 5_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x950++0x3
    line.long 0x00 "PIGEON_5_1,Panel Interface Signal Generator Register 5_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x960++0x3
    line.long 0x00 "PIGEON_5_2,Panel Interface Signal Generator Register 5_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x980++0x3
    line.long 0x00 "PIGEON_6_0,Panel Interface Signal Generator Register 6_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x990++0x3
    line.long 0x00 "PIGEON_6_1,Panel Interface Signal Generator Register 6_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x9a0++0x3
    line.long 0x00 "PIGEON_6_2,Panel Interface Signal Generator Register 6_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0x9c0++0x3
    line.long 0x00 "PIGEON_7_0,Panel Interface Signal Generator Register 7_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0x9d0++0x3
    line.long 0x00 "PIGEON_7_1,Panel Interface Signal Generator Register 7_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0x9e0++0x3
    line.long 0x00 "PIGEON_7_2,Panel Interface Signal Generator Register 7_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0xa00++0x3
    line.long 0x00 "PIGEON_8_0,Panel Interface Signal Generator Register 8_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0xa10++0x3
    line.long 0x00 "PIGEON_8_1,Panel Interface Signal Generator Register 8_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0xa20++0x3
    line.long 0x00 "PIGEON_8_2,Panel Interface Signal Generator Register 8_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 11.
group.long 0xa40++0x3
    line.long 0x00 "PIGEON_9_0,Panel Interface Signal Generator Register 9_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "          "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "          "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 11.
group.long 0xa50++0x3
    line.long 0x00 "PIGEON_9_1,Panel Interface Signal Generator Register 9_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "          "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 11.
group.long 0xa60++0x3
    line.long 0x00 "PIGEON_9_2,Panel Interface Signal Generator Register 9_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "          "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xa80++0x3
    line.long 0x00 "PIGEON_10_0,Panel Interface Signal Generator Register 10_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xa90++0x3
    line.long 0x00 "PIGEON_10_1,Panel Interface Signal Generator Register 10_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xaa0++0x3
    line.long 0x00 "PIGEON_10_2,Panel Interface Signal Generator Register 10_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xac0++0x3
    line.long 0x00 "PIGEON_11_0,Panel Interface Signal Generator Register 11_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xad0++0x3
    line.long 0x00 "PIGEON_11_1,Panel Interface Signal Generator Register 11_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xae0++0x3
    line.long 0x00 "PIGEON_11_2,Panel Interface Signal Generator Register 11_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xb00++0x3
    line.long 0x00 "PIGEON_12_0,Panel Interface Signal Generator Register 12_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xb10++0x3
    line.long 0x00 "PIGEON_12_1,Panel Interface Signal Generator Register 12_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xb20++0x3
    line.long 0x00 "PIGEON_12_2,Panel Interface Signal Generator Register 12_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xb40++0x3
    line.long 0x00 "PIGEON_13_0,Panel Interface Signal Generator Register 13_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xb50++0x3
    line.long 0x00 "PIGEON_13_1,Panel Interface Signal Generator Register 13_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xb60++0x3
    line.long 0x00 "PIGEON_13_2,Panel Interface Signal Generator Register 13_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xb80++0x3
    line.long 0x00 "PIGEON_14_0,Panel Interface Signal Generator Register 14_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xb90++0x3
    line.long 0x00 "PIGEON_14_1,Panel Interface Signal Generator Register 14_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xba0++0x3
    line.long 0x00 "PIGEON_14_2,Panel Interface Signal Generator Register 14_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xbc0++0x3
    line.long 0x00 "PIGEON_15_0,Panel Interface Signal Generator Register 15_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xbd0++0x3
    line.long 0x00 "PIGEON_15_1,Panel Interface Signal Generator Register 15_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xbe0++0x3
    line.long 0x00 "PIGEON_15_2,Panel Interface Signal Generator Register 15_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"
width 12.
group.long 0xc00++0x3
    line.long 0x00 "PIGEON_16_0,Panel Interface Signal Generator Register 16_0"
        bitfld.long 0x00 0. " EN ,enable pigeon mode on this signal" "0,1"
        textline "           "
        bitfld.long 0x00 1. " POL ,polarity of signal output" "0,1"
        textline "           "
        hexmask.long.byte 0x00 2.--4. 1. " INC_SEL ,event to incrment local counter"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " OFFSET ,offset on pclk unit."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " MASK_CNT_SEL ,select global counters as mask condition, use together with MASK_CNT"
        textline "           "
        hexmask.long.word 0x00 12.--24. 1. " MASK_CNT ,When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " STATE_MASK ,state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking"
width 12.
group.long 0xc10++0x3
    line.long 0x00 "PIGEON_16_1,Panel Interface Signal Generator Register 16_1"
        hexmask.long.word 0x00 0.--16. 1. " SET_CNT ,assert signal output when counter match this value"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " CLR_CNT ,deassert signal output when counter match this value"
width 12.
group.long 0xc20++0x3
    line.long 0x00 "PIGEON_16_2,Panel Interface Signal Generator Register 16_1"
        hexmask.long.byte 0x00 0.--4. 1. " SIG_LOGIC ,logic operation with another signal sigout : final output signal of this generator mask : final mask of this generator this_sig : intermediate signal of this generator before logic operation other_masks : intermediate mask result of this generator before logic operation sig_another : signal selected other generators"
        textline "           "
        hexmask.long.byte 0x00 4.--9. 1. " SIG_ANOTHER ,select another signal for logic operation or as mask or counter tick event"


tree.end



;--------------------------------------------------------------------------------
; EPIT
;--------------------------------------------------------------------------------
tree.open "EPIT"
    tree "EPIT1"
        base ad:0x020d0000

width 3.
group.long 0x0++0x3
    line.long 0x00 "CR,Control register"
        bitfld.long 0x00 0. " EN ,This bit enables the EPIT." "0,1"
        textline "  "
        bitfld.long 0x00 1. " ENMOD ,EPIT enable mode." "0,1"
        textline "  "
        bitfld.long 0x00 2. " OCIEN ,Output compare interrupt enable." "0,1"
        textline "  "
        bitfld.long 0x00 3. " RLD ,Counter reload control." "0,1"
        textline "  "
        hexmask.long.word 0x00 4.--16. 1. " PRESCALAR ,Counter clock prescaler value."
        textline "  "
        bitfld.long 0x00 16. " SWR ,Software reset." "0,1"
        textline "  "
        bitfld.long 0x00 17. " IOVW ,EPIT counter overwrite enable." "0,1"
        textline "  "
        bitfld.long 0x00 18. " DBGEN ,This bit is used to keep the EPIT functional in debug mode." "0,1"
        textline "  "
        bitfld.long 0x00 19. " WAITEN ,This read/write control bit enables the operation of the EPIT during wait mode." "0,1"
        textline "  "
        bitfld.long 0x00 21. " STOPEN ,EPIT stop mode enable." "0,1"
        textline "  "
        hexmask.long.byte 0x00 22.--24. 1. " OM ,EPIT output mode.This bit field determines the mode of EPIT output on the output pin."
        textline "  "
        hexmask.long.byte 0x00 24.--26. 1. " CLKSRC ,Select clock source These bits determine which clock input is to be selected for running the counter."
width 3.
group.long 0x4++0x3
    line.long 0x00 "SR,Status register"
        bitfld.long 0x00 0. " OCIF ,Output compare interrupt flag." "0,1"
width 3.
group.long 0x8++0x3
    line.long 0x00 "LR,Load register"
        hexmask.long.long 0x00 0.--32. 1. " LOAD ,Load value."
width 5.
group.long 0xc++0x3
    line.long 0x00 "CMPR,Compare register"
        hexmask.long.long 0x00 0.--32. 1. " COMPARE ,Compare Value."
width 4.
rgroup.long 0x10++0x3
    line.long 0x00 "CNR,Counter register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Counter value."


    tree.end
    tree "EPIT2"
        base ad:0x020d4000

width 3.
group.long 0x0++0x3
    line.long 0x00 "CR,Control register"
        bitfld.long 0x00 0. " EN ,This bit enables the EPIT." "0,1"
        textline "  "
        bitfld.long 0x00 1. " ENMOD ,EPIT enable mode." "0,1"
        textline "  "
        bitfld.long 0x00 2. " OCIEN ,Output compare interrupt enable." "0,1"
        textline "  "
        bitfld.long 0x00 3. " RLD ,Counter reload control." "0,1"
        textline "  "
        hexmask.long.word 0x00 4.--16. 1. " PRESCALAR ,Counter clock prescaler value."
        textline "  "
        bitfld.long 0x00 16. " SWR ,Software reset." "0,1"
        textline "  "
        bitfld.long 0x00 17. " IOVW ,EPIT counter overwrite enable." "0,1"
        textline "  "
        bitfld.long 0x00 18. " DBGEN ,This bit is used to keep the EPIT functional in debug mode." "0,1"
        textline "  "
        bitfld.long 0x00 19. " WAITEN ,This read/write control bit enables the operation of the EPIT during wait mode." "0,1"
        textline "  "
        bitfld.long 0x00 21. " STOPEN ,EPIT stop mode enable." "0,1"
        textline "  "
        hexmask.long.byte 0x00 22.--24. 1. " OM ,EPIT output mode.This bit field determines the mode of EPIT output on the output pin."
        textline "  "
        hexmask.long.byte 0x00 24.--26. 1. " CLKSRC ,Select clock source These bits determine which clock input is to be selected for running the counter."
width 3.
group.long 0x4++0x3
    line.long 0x00 "SR,Status register"
        bitfld.long 0x00 0. " OCIF ,Output compare interrupt flag." "0,1"
width 3.
group.long 0x8++0x3
    line.long 0x00 "LR,Load register"
        hexmask.long.long 0x00 0.--32. 1. " LOAD ,Load value."
width 5.
group.long 0xc++0x3
    line.long 0x00 "CMPR,Compare register"
        hexmask.long.long 0x00 0.--32. 1. " COMPARE ,Compare Value."
width 4.
rgroup.long 0x10++0x3
    line.long 0x00 "CNR,Counter register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Counter value."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; ESAI
;--------------------------------------------------------------------------------
tree "ESAI"
    base ad:0x02024000

width 5.
wgroup.long 0x0++0x3
    line.long 0x00 "ETDR,ESAI Transmit Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ETDR ,ESAI Transmit Data Register."
width 5.
rgroup.long 0x4++0x3
    line.long 0x00 "ERDR,ESAI Receive Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ERDR ,ESAI Receive Data Register."
width 4.
group.long 0x8++0x3
    line.long 0x00 "ECR,ESAI Control Register"
        bitfld.long 0x00 0. " ESAIEN ,ESAI Enable." "0,1"
        textline "   "
        bitfld.long 0x00 1. " ERST ,ESAI Reset." "0,1"
        textline "   "
        bitfld.long 0x00 16. " ERO ,EXTAL Receiver Out." "0,1"
        textline "   "
        bitfld.long 0x00 17. " ERI ,EXTAL Receiver In." "0,1"
        textline "   "
        bitfld.long 0x00 18. " ETO ,EXTAL Transmitter Out." "0,1"
        textline "   "
        bitfld.long 0x00 19. " ETI ,EXTAL Transmitter In." "0,1"
width 4.
rgroup.long 0xc++0x3
    line.long 0x00 "ESR,ESAI Status Register"
        bitfld.long 0x00 0. " RD ,Receive Data." "0,1"
        textline "   "
        bitfld.long 0x00 1. " RED ,Receive Even Data." "0,1"
        textline "   "
        bitfld.long 0x00 2. " RDE ,Receive Data Exception." "0,1"
        textline "   "
        bitfld.long 0x00 3. " RLS ,Receive Last Slot." "0,1"
        textline "   "
        bitfld.long 0x00 4. " TD ,Transmit Data." "0,1"
        textline "   "
        bitfld.long 0x00 5. " TED ,Transmit Even Data." "0,1"
        textline "   "
        bitfld.long 0x00 6. " TDE ,Transmit Data Exception." "0,1"
        textline "   "
        bitfld.long 0x00 7. " TLS ,Transmit Last Slot." "0,1"
        textline "   "
        bitfld.long 0x00 8. " TFE ,Transmit FIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 9. " RFF ,Receive FIFO Full." "0,1"
        textline "   "
        bitfld.long 0x00 10. " TINIT ,Transmit Initialization." "0,1"
width 5.
group.long 0x10++0x3
    line.long 0x00 "TFCR,Transmit FIFO Configuration Register"
        bitfld.long 0x00 0. " TFE ,Transmit FIFO Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFR ,Transmit FIFO Reset." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TE0 ,Transmitter #0 FIFO Enable." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TE1 ,Transmitter #1 FIFO Enable." "0,1"
        textline "    "
        bitfld.long 0x00 4. " TE2 ,Transmitter #2 FIFO Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TE3 ,Transmitter #3 FIFO Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TE4 ,Transmitter #4 FIFO Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TE5 ,Transmitter #5 FIFO Enable." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " TFWM ,Transmit FIFO Watermark."
        textline "    "
        hexmask.long.byte 0x00 16.--19. 1. " TWA ,Transmit Word Alignment."
        textline "    "
        bitfld.long 0x00 19. " TIEN ,Transmitter Initialization Enable." "0,1"
width 5.
rgroup.long 0x14++0x3
    line.long 0x00 "TFSR,Transmit FIFO Status Register"
        hexmask.long.byte 0x00 0.--8. 1. " TFCNT ,Transmit FIFO Counter."
        textline "    "
        hexmask.long.byte 0x00 8.--11. 1. " NTFI ,Next Transmitter FIFO In."
        textline "    "
        hexmask.long.byte 0x00 12.--15. 1. " NTFO ,Next Transmitter FIFO Out."
width 5.
group.long 0x18++0x3
    line.long 0x00 "RFCR,Receive FIFO Configuration Register"
        bitfld.long 0x00 0. " RFE ,Receive FIFO Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RFR ,Receive FIFO Reset." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RE0 ,Receiver #0 FIFO Enable." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RE1 ,Receiver #1 FIFO Enable." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RE2 ,Receiver #2 FIFO Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RE3 ,Receiver #3 FIFO Enable." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " RFWM ,Receive FIFO Watermark."
        textline "    "
        hexmask.long.byte 0x00 16.--19. 1. " RWA ,Receive Word Alignment."
        textline "    "
        bitfld.long 0x00 19. " REXT ,Receive Extension." "0,1"
width 5.
rgroup.long 0x1c++0x3
    line.long 0x00 "RFSR,Receive FIFO Status Register"
        hexmask.long.byte 0x00 0.--8. 1. " RFCNT ,Receive FIFO Counter."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " NRFO ,Next Receiver FIFO Out."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " NRFI ,Next Receiver FIFO In."
width 4.
wgroup.long 0x80++0x3
    line.long 0x00 "TX0,Transmit Data Register n"
        hexmask.long.long 0x00 0.--24. 1. " TXN ,Stores the data to be transmitted and is automatically transferred to the transmit shift registers."
width 4.
wgroup.long 0x84++0x3
    line.long 0x00 "TX1,Transmit Data Register n"
        hexmask.long.long 0x00 0.--24. 1. " TXN ,Stores the data to be transmitted and is automatically transferred to the transmit shift registers."
width 4.
wgroup.long 0x88++0x3
    line.long 0x00 "TX2,Transmit Data Register n"
        hexmask.long.long 0x00 0.--24. 1. " TXN ,Stores the data to be transmitted and is automatically transferred to the transmit shift registers."
width 4.
wgroup.long 0x8c++0x3
    line.long 0x00 "TX3,Transmit Data Register n"
        hexmask.long.long 0x00 0.--24. 1. " TXN ,Stores the data to be transmitted and is automatically transferred to the transmit shift registers."
width 4.
wgroup.long 0x90++0x3
    line.long 0x00 "TX4,Transmit Data Register n"
        hexmask.long.long 0x00 0.--24. 1. " TXN ,Stores the data to be transmitted and is automatically transferred to the transmit shift registers."
width 4.
wgroup.long 0x94++0x3
    line.long 0x00 "TX5,Transmit Data Register n"
        hexmask.long.long 0x00 0.--24. 1. " TXN ,Stores the data to be transmitted and is automatically transferred to the transmit shift registers."
width 4.
wgroup.long 0x98++0x3
    line.long 0x00 "TSR,ESAI Transmit Slot Register"
        hexmask.long.long 0x00 0.--24. 1. " TSR ,The write-only Transmit Slot Register (ESAI_TSR) is effectively a null data register that is used when the data is not to be transmitted in the available transmit time slot."
width 4.
rgroup.long 0xa0++0x3
    line.long 0x00 "RX0,Receive Data Register n"
        hexmask.long.long 0x00 0.--24. 1. " RXN ,Accept data from the receive shift registers when they become full See"
width 4.
rgroup.long 0xa4++0x3
    line.long 0x00 "RX1,Receive Data Register n"
        hexmask.long.long 0x00 0.--24. 1. " RXN ,Accept data from the receive shift registers when they become full See"
width 4.
rgroup.long 0xa8++0x3
    line.long 0x00 "RX2,Receive Data Register n"
        hexmask.long.long 0x00 0.--24. 1. " RXN ,Accept data from the receive shift registers when they become full See"
width 4.
rgroup.long 0xac++0x3
    line.long 0x00 "RX3,Receive Data Register n"
        hexmask.long.long 0x00 0.--24. 1. " RXN ,Accept data from the receive shift registers when they become full See"
width 6.
rgroup.long 0xcc++0x3
    line.long 0x00 "SAISR,Serial Audio Interface Status Register"
        bitfld.long 0x00 0. " IF0 ,ESAI_SAISR Serial Input Flag 0." "0,1"
        textline "     "
        bitfld.long 0x00 1. " IF1 ,ESAI_SAISR Serial Inout Flag 1." "0,1"
        textline "     "
        bitfld.long 0x00 2. " IF2 ,ESAI_SAISR Serial Input Flag 2." "0,1"
        textline "     "
        bitfld.long 0x00 6. " RFS ,ESAI_SAISR Receive Frame Sync Flag." "0,1"
        textline "     "
        bitfld.long 0x00 7. " ROE ,ESAI_SAISR Receive Overrun Error Flag." "0,1"
        textline "     "
        bitfld.long 0x00 8. " RDF ,ESAI_SAISR Receive Data Register Full." "0,1"
        textline "     "
        bitfld.long 0x00 9. " REDF ,ESAI_SAISR Receive Even-Data Register Full." "0,1"
        textline "     "
        bitfld.long 0x00 10. " RODF ,ESAI_SAISR Receive Odd-Data Register Full." "0,1"
        textline "     "
        bitfld.long 0x00 13. " TFS ,ESAI_SAISR Transmit Frame Sync Flag." "0,1"
        textline "     "
        bitfld.long 0x00 14. " TUE ,ESAI_SAISR Transmit Underrun Error Flag." "0,1"
        textline "     "
        bitfld.long 0x00 15. " TDE ,ESAI_SAISR Transmit Data Register Empty." "0,1"
        textline "     "
        bitfld.long 0x00 16. " TEDE ,ESAI_SAISR Transmit Even-DataRegister Empty." "0,1"
        textline "     "
        bitfld.long 0x00 17. " TODFE ,ESAI_SAISR Transmit Odd-Data Register Empty." "0,1"
width 6.
group.long 0xd0++0x3
    line.long 0x00 "SAICR,Serial Audio Interface Control Register"
        bitfld.long 0x00 0. " OF0 ,ESAI_SAICR Serial Output Flag 0." "0,1"
        textline "     "
        bitfld.long 0x00 1. " OF1 ,ESAI_SAICR Serial Output Flag 1." "0,1"
        textline "     "
        bitfld.long 0x00 2. " OF2 ,ESAI_SAICR Serial Output Flag 2." "0,1"
        textline "     "
        bitfld.long 0x00 6. " SYN ,ESAI_SAICR Synchronous Mode Selection." "0,1"
        textline "     "
        bitfld.long 0x00 7. " TEBE ,ESAI_SAICR Transmit External Buffer Enable." "0,1"
        textline "     "
        bitfld.long 0x00 8. " ALC ,ESAI_SAICR Alignment Control." "0,1"
width 4.
group.long 0xd4++0x3
    line.long 0x00 "TCR,Transmit Control Register"
        bitfld.long 0x00 0. " TE0 ,ESAI_TCR ESAI Transmit 0 Enable." "0,1"
        textline "   "
        bitfld.long 0x00 1. " TE1 ,ESAI_TCR ESAI Transmit 1 Enable." "0,1"
        textline "   "
        bitfld.long 0x00 2. " TE2 ,ESAI_TCR ESAI Transmit 2 Enable." "0,1"
        textline "   "
        bitfld.long 0x00 3. " TE3 ,ESAI_TCR ESAI Transmit 3 Enable." "0,1"
        textline "   "
        bitfld.long 0x00 4. " TE4 ,ESAI_TCR ESAI Transmit 4 Enable." "0,1"
        textline "   "
        bitfld.long 0x00 5. " TE5 ,ESAI_TCR ESAI Transmit 5 Enable." "0,1"
        textline "   "
        bitfld.long 0x00 6. " TSHFD ,ESAI_TCR Transmit Shift Direction." "0,1"
        textline "   "
        bitfld.long 0x00 7. " TWA ,ESAI_TCR Transmit Word Alignment Control." "0,1"
        textline "   "
        hexmask.long.byte 0x00 8.--10. 1. " TMOD ,ESAI_TCR Transmit Network Mode Control (TMOD1-TMOD0)."
        textline "   "
        hexmask.long.byte 0x00 10.--15. 1. " TSWS ,ESAI_TCR Tx Slot and Word Length Select (TSWS4-TSWS0)."
        textline "   "
        bitfld.long 0x00 15. " TFSL ,ESAI_TCR Transmit Frame Sync Length." "0,1"
        textline "   "
        bitfld.long 0x00 16. " TFSR ,ESAI_TCR Transmit Frame Sync Relative Timing." "0,1"
        textline "   "
        bitfld.long 0x00 17. " PADC ,ESAI_TCR Transmit Zero Padding Control." "0,1"
        textline "   "
        bitfld.long 0x00 19. " TPR ,ESAI_TCR Transmit Section Personal Reset." "0,1"
        textline "   "
        bitfld.long 0x00 20. " TEIE ,ESAI_TCR Transmit Exception Interrupt Enable." "0,1"
        textline "   "
        bitfld.long 0x00 21. " TEDIE ,ESAI_TCR Transmit Even Slot Data Interrupt Enable." "0,1"
        textline "   "
        bitfld.long 0x00 22. " TIE ,ESAI_TCR Transmit Interrupt Enable." "0,1"
        textline "   "
        bitfld.long 0x00 23. " TLIE ,ESAI_TCR Transmit Last Slot Interrupt Enable." "0,1"
width 5.
group.long 0xd8++0x3
    line.long 0x00 "TCCR,Transmit Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " TPM ,ESAI_TCCR Transmit Prescale Modulus Select."
        textline "    "
        bitfld.long 0x00 8. " TPSR ,ESAI_TCCR Transmit Prescaler Range." "0,1"
        textline "    "
        hexmask.long.byte 0x00 9.--14. 1. " TDC ,ESAI_TCCR Tx Frame Rate Divider Control."
        textline "    "
        hexmask.long.byte 0x00 14.--18. 1. " TFP ,ESAI_TCCR Tx High Frequency Clock Divider."
        textline "    "
        bitfld.long 0x00 18. " TCKP ,ESAI_TCCR Transmit Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 19. " TFSP ,ESAI_TCCR Transmit Frame Sync Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 20. " THCKP ,ESAI_TCCR Transmit High Frequency Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 21. " TCKD ,ESAI_TCCR Transmit Clock Source Direction." "0,1"
        textline "    "
        bitfld.long 0x00 22. " TFSD ,ESAI_TCCR Transmit Frame Sync Signal Direction." "0,1"
        textline "    "
        bitfld.long 0x00 23. " THCKD ,ESAI_TCCR Transmit High Frequency Clock Direction." "0,1"
width 4.
group.long 0xdc++0x3
    line.long 0x00 "RCR,Receive Control Register"
        bitfld.long 0x00 0. " RE0 ,ESAI_RCR ESAI Receiver 0 Enable." "0,1"
        textline "   "
        bitfld.long 0x00 1. " RE1 ,ESAI_RCR ESAI Receiver 1 Enable." "0,1"
        textline "   "
        bitfld.long 0x00 2. " RE2 ,ESAI_RCR ESAI Receiver 2 Enable." "0,1"
        textline "   "
        bitfld.long 0x00 3. " RE3 ,ESAI_RCR ESAI Receiver 3 Enable." "0,1"
        textline "   "
        bitfld.long 0x00 6. " RSHFD ,ESAI_RCR Receiver Shift Direction." "0,1"
        textline "   "
        bitfld.long 0x00 7. " RWA ,ESAI_RCR Receiver Word Alignment Control." "0,1"
        textline "   "
        hexmask.long.byte 0x00 8.--10. 1. " RMOD ,ESAI_RCR Receiver Network Mode Control."
        textline "   "
        hexmask.long.byte 0x00 10.--15. 1. " RSWS ,ESAI_RCR Receiver Slot and Word Select."
        textline "   "
        bitfld.long 0x00 15. " RFSL ,ESAI_RCR Receiver Frame Sync Length." "0,1"
        textline "   "
        bitfld.long 0x00 16. " RFSR ,ESAI_RCR Receiver Frame Sync Relative Timing." "0,1"
        textline "   "
        bitfld.long 0x00 19. " RPR ,ESAI_RCR Receiver Section Personal Reset." "0,1"
        textline "   "
        bitfld.long 0x00 20. " REIE ,ESAI_RCR Receive Exception Interrupt Enable." "0,1"
        textline "   "
        bitfld.long 0x00 21. " REDIE ,ESAI_RCR Receive Even Slot Data Interrupt Enable." "0,1"
        textline "   "
        bitfld.long 0x00 22. " RIE ,ESAI_RCR Receive Interrupt Enable." "0,1"
        textline "   "
        bitfld.long 0x00 23. " RLIE ,ESAI_RCR Receive Last Slot Interrupt Enable." "0,1"
width 5.
group.long 0xe0++0x3
    line.long 0x00 "RCCR,Receive Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " RPM ,ESAI_RCCR Receiver Prescale Modulus Select."
        textline "    "
        bitfld.long 0x00 8. " RPSR ,ESAI_RCCR Receiver Prescaler Range." "0,1"
        textline "    "
        hexmask.long.byte 0x00 9.--14. 1. " RDC ,ESAI_RCCR Rx Frame Rate Divider Control."
        textline "    "
        hexmask.long.byte 0x00 14.--18. 1. " RFP ,ESAI_RCCR Rx High Frequency Clock Divider."
        textline "    "
        bitfld.long 0x00 18. " RCKP ,The Receiver Clock Polarity (RCKP) bit controls on which bit clock edge data and frame sync are clocked out and latched in." "0,1"
        textline "    "
        bitfld.long 0x00 19. " RFSP ,ESAI_RCCR Receiver Frame Sync Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 20. " RHCKP ,ESAI_RCCR Receiver High Frequency Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 21. " RCKD ,ESAI_RCCR Receiver Clock Source Direction." "0,1"
        textline "    "
        bitfld.long 0x00 22. " RFSD ,ESAI_RCCR Receiver Frame Sync Signal Direction." "0,1"
        textline "    "
        bitfld.long 0x00 23. " RHCKD ,ESAI_RCCR Receiver High Frequency Clock Direction." "0,1"
width 5.
group.long 0xe4++0x3
    line.long 0x00 "TSMA,Transmit Slot Mask Register A"
        hexmask.long.word 0x00 0.--16. 1. " TS ,When bit number N in ESAI_TSMA is cleared, all the transmit data pins of the enabled transmitters are tri-stated during transmit time slot number N."
width 5.
group.long 0xe8++0x3
    line.long 0x00 "TSMB,Transmit Slot Mask Register B"
        hexmask.long.word 0x00 0.--16. 1. " TS ,When bit number N in ESAI_TSMB is cleared, all the transmit data pins of the enabled transmitters are tri-stated during transmit time slot number N."
width 5.
group.long 0xec++0x3
    line.long 0x00 "RSMA,Receive Slot Mask Register A"
        hexmask.long.word 0x00 0.--16. 1. " RS ,When bit number N in the ESAI_RSMA register is cleared, the data from the enabled receivers input pins are shifted into their receive shift registers during slot number N."
width 5.
group.long 0xf0++0x3
    line.long 0x00 "RSMB,Receive Slot Mask Register B"
        hexmask.long.word 0x00 0.--16. 1. " RS ,When bit number N in the ESAI_RSMB register is cleared, the data from the enabled receivers input pins are shifted into their receive shift registers during slot number N."
width 5.
group.long 0xf8++0x3
    line.long 0x00 "PRRC,Port C Direction Register"
        hexmask.long.word 0x00 0.--12. 1. " PDC ,See ."
width 5.
group.long 0xfc++0x3
    line.long 0x00 "PCRC,Port C Control Register"
        hexmask.long.word 0x00 0.--12. 1. " PC ,See ."


tree.end



;--------------------------------------------------------------------------------
; FLEXCAN
;--------------------------------------------------------------------------------
tree.open "FLEXCAN"
    tree "FLEXCAN1"
        base ad:0x02090000

width 4.
group.long 0x0++0x3
    line.long 0x00 "MCR,Module Configuration Register"
        hexmask.long.byte 0x00 0.--6. 1. " MAXMB ,This 6-bit field defines the maximum number of message buffers that will take part in the matching and arbitration processes."
        textline "   "
        hexmask.long.byte 0x00 8.--10. 1. " IDAM ,This 2-bit field identifies the format of the elements of the Rx FIFO filter table, as shown below."
        textline "   "
        bitfld.long 0x00 12. " AEN ,This bit is supplied for backwards compatibility reasons." "0,1"
        textline "   "
        bitfld.long 0x00 13. " LPRIO_EN ,This bit is provided for backwards compatibility reasons." "0,1"
        textline "   "
        bitfld.long 0x00 16. " BCC ,This bit is provided to support Backwards Compatibility with previous FLEXCAN versions." "0,1"
        textline "   "
        bitfld.long 0x00 17. " SRX_DIS ,This bit defines whether FLEXCAN is allowed to receive frames transmitted by itself." "0,1"
        textline "   "
        bitfld.long 0x00 18. " DOZE ,This bit defines whether FLEXCAN is allowed to enter low power mode when Doze Mode is requested at ARM platform level." "0,1"
        textline "   "
        bitfld.long 0x00 19. " WAK_SRC ,This bit defines whether the integrated low-pass filter is applied to protect the Rx CAN input." "0,1"
        textline "   "
        bitfld.long 0x00 20. " LPM_ACK ,This read-only bit indicates that FLEXCAN is either in Disable Mode and Stop Mode." "0,1"
        textline "   "
        bitfld.long 0x00 21. " WRN_EN ,When asserted, this bit enables the generation of the TWRN_INT and RWRN_INT flags in the Error and Status Register." "0,1"
        textline "   "
        bitfld.long 0x00 22. " SLF_WAK ,This bit enables the Self Wake Up feature when FLEXCAN is in Stop Mode." "0,1"
        textline "   "
        bitfld.long 0x00 23. " SUPV ,This bit configures some of the FLEXCAN registers to be either in Supervisor or Unrestricted memory space." "0,1"
        textline "   "
        bitfld.long 0x00 24. " FRZ_ACK ,This read-only bit indicates that FLEXCAN is in Freeze Mode and its prescaler is stopped." "0,1"
        textline "   "
        bitfld.long 0x00 25. " SOFT_RST ,When this bit is asserted, FLEXCAN resets its internal state machines and some of the memory mapped registers." "0,1"
        textline "   "
        bitfld.long 0x00 26. " WAK_MSK ,This bit enables the Wake Up Interrupt generation." "0,1"
        textline "   "
        bitfld.long 0x00 27. " NOT_RDY ,This read-only bit indicates that FLEXCAN is either in Disable Mode, Stop Mode or Freeze Mode." "0,1"
        textline "   "
        bitfld.long 0x00 28. " HALT ,Assertion of this bit puts the FLEXCAN block into Freeze Mode." "0,1"
        textline "   "
        bitfld.long 0x00 29. " FEN ,This bit controls whether the FIFO feature is enabled or not." "0,1"
        textline "   "
        bitfld.long 0x00 30. " FRZ ,The FRZ bit specifies the FLEXCAN behavior when the HALT bit in the MCR Register is set or when Debug Mode is requested at ARM platform level." "0,1"
        textline "   "
        bitfld.long 0x00 31. " MDIS ,This bit controls whether FLEXCAN is enabled or not." "0,1"
width 5.
group.long 0x4++0x3
    line.long 0x00 "CTRL,Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " PROP_SEG ,This 3-bit field defines the length of the Propagation Segment in the bit time."
        textline "    "
        bitfld.long 0x00 3. " LOM ,This bit configures FLEXCAN to operate in Listen Only Mode." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LBUF ,This bit defines the ordering mechanism for Message Buffer transmission." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TSYN ,This bit enables a mechanism that resets the free-running timer each time a message is received in Message Buffer 0." "0,1"
        textline "    "
        bitfld.long 0x00 6. " BOFF_REC ,This bit defines how FLEXCAN recovers from Bus Off state." "0,1"
        textline "    "
        bitfld.long 0x00 7. " SMP ,This bit defines the sampling mode of CAN bits at the Rx input." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RWRN_MSK ,This bit provides a mask for the Rx Warning Interrupt associated with the RWRN_INT flag in the Error and Status Register." "0,1"
        textline "    "
        bitfld.long 0x00 11. " TWRN_MSK ,This bit provides a mask for the Tx Warning Interrupt associated with the TWRN_INT flag in the Error and Status Register." "0,1"
        textline "    "
        bitfld.long 0x00 12. " LPB ,This bit configures FLEXCAN to operate in Loop-Back Mode." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR_MSK ,This bit provides a mask for the Error Interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 15. " BOFF_MSK ,This bit provides a mask for the Bus Off Interrupt." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--19. 1. " PSEG2 ,This 3-bit field defines the length of Phase Buffer Segment 2 in the bit time."
        textline "    "
        hexmask.long.byte 0x00 19.--22. 1. " PSEG1 ,This 3-bit field defines the length of Phase Buffer Segment 1 in the bit time."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " RJW ,This 2-bit field defines the maximum number of time quanta One time quantum is equal to the Sclock period."
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " PRESDIV ,This 8-bit field defines the ratio between the CPI clock frequency and the Serial Clock (Sclock) frequency."
width 6.
group.long 0x8++0x3
    line.long 0x00 "TIMER,Free Running Timer"
        hexmask.long.word 0x00 0.--16. 1. " TIMER ,Timer value Contains the free-running counter value."
width 8.
group.long 0x10++0x3
    line.long 0x00 "RXGMASK,Rx Global Mask"
        hexmask.long.long 0x00 0.--32. 1. " MI31_MI0 ,For normal Rx message buffers, the mask bits affect the ID filter programmed on the message buffer."
width 9.
group.long 0x14++0x3
    line.long 0x00 "RX14MASK,Rx 14 Mask"
        hexmask.long.long 0x00 0.--32. 1. " MI31_MI0 ,Acceptance mask for the Identifier in Message Buffer 14"
width 9.
group.long 0x18++0x3
    line.long 0x00 "RX15MASK,Rx 15 Mask"
        hexmask.long.long 0x00 0.--32. 1. " MI31_MI0 ,Acceptance mask for the Identifier in Message Buffer 15"
width 4.
group.long 0x1c++0x3
    line.long 0x00 "ECR,Error Counter Register"
        hexmask.long.byte 0x00 0.--8. 1. " TX_ERR_COUNTER ,Transmit Error Counter"
        textline "   "
        hexmask.long.byte 0x00 8.--16. 1. " RX_ERR_COUNTER ,Receive Error Counter"
width 4.
group.long 0x20++0x3
    line.long 0x00 "ESR,Error and Status Register"
        bitfld.long 0x00 0. " WAK_INT ,When FLEXCAN is Stop Mode and a recessive to dominant transition is detected on the CAN bus and if the WAK_MSK bit in the MCR Register is set, an interrupt is generated to the ARM." "0,1"
        textline "   "
        bitfld.long 0x00 1. " ERR_INT ,This bit indicates that at least one of the Error Bits (bits 15-10) is set." "0,1"
        textline "   "
        bitfld.long 0x00 2. " BOFF_INT ,This bit is set when FLEXCAN enters Bus Off state." "0,1"
        textline "   "
        hexmask.long.byte 0x00 4.--6. 1. " FLT_CONF ,This 2-bit field indicates the Confinement State of the FLEXCAN block, as shown in below: If the LOM bit in the Control Register is asserted, the FLT_CONF field will indicate Error Passive."
        textline "   "
        bitfld.long 0x00 6. " TXRX ,This bit indicates if FLEXCAN is transmitting or receiving a message when the CAN bus is not in IDLE state." "0,1"
        textline "   "
        bitfld.long 0x00 7. " IDLE ,This bit indicates when CAN bus is in IDLE state." "0,1"
        textline "   "
        bitfld.long 0x00 8. " RX_WRN ,This bit indicates when repetitive errors are occurring during message reception." "0,1"
        textline "   "
        bitfld.long 0x00 9. " TX_WRN ,This bit indicates when repetitive errors are occurring during message transmission." "0,1"
        textline "   "
        bitfld.long 0x00 10. " STF_ERR ,This bit indicates that a Stuffing Error has been detected." "0,1"
        textline "   "
        bitfld.long 0x00 11. " FRM_ERR ,This bit indicates that a Form Error has been detected by the receiver node, that is, a fixed-form bit field contains at least one illegal bit." "0,1"
        textline "   "
        bitfld.long 0x00 12. " CRC_ERR ,This bit indicates that a CRC Error has been detected by the receiver node, that is, the calculated CRC is different from the received." "0,1"
        textline "   "
        bitfld.long 0x00 13. " ACK_ERR ,This bit indicates that an Acknowledge Error has been detected by the transmitter node, that is, a dominant bit has not been detected during the ACK SLOT." "0,1"
        textline "   "
        bitfld.long 0x00 14. " BIT0_ERR ,This bit indicates when an inconsistency occurs between the transmitted and the received bit in a message." "0,1"
        textline "   "
        bitfld.long 0x00 15. " BIT1_ERR ,This bit indicates when an inconsistency occurs between the transmitted and the received bit in a message." "0,1"
        textline "   "
        bitfld.long 0x00 16. " RWRN_INT ,If the WRN_EN bit in MCR is asserted, the RWRN_INT bit is set when the RX_WRN flag transitions from 0 to 1, meaning that the Rx error counters reached 96." "0,1"
        textline "   "
        bitfld.long 0x00 17. " TWRN_INT ,If the WRN_EN bit in MCR is asserted, the TWRN_INT bit is set when the TX_WRN flag transitions from 0 to 1, meaning that the Tx error counter reached 96." "0,1"
width 7.
group.long 0x24++0x3
    line.long 0x00 "IMASK2,Interrupt Masks 2 Register"
        hexmask.long.long 0x00 0.--32. 1. " BUF63M ,Each bit enables or disables the respective FLEXCAN Message Buffer (MB32 to MB63) Interrupt."
width 7.
group.long 0x28++0x3
    line.long 0x00 "IMASK1,Interrupt Masks 1 Register"
        hexmask.long.long 0x00 0.--32. 1. " BUF31M_BUF0M ,Each bit enables or disables the respective FLEXCAN Message Buffer (MB0 to MB31) Interrupt."
width 7.
group.long 0x2c++0x3
    line.long 0x00 "IFLAG2,Interrupt Flags 2 Register"
        hexmask.long.long 0x00 0.--32. 1. " BUF63I_BUF32I ,Each bit flags the respective FLEXCAN Message Buffer (MB32 to MB63) interrupt."
width 7.
group.long 0x30++0x3
    line.long 0x00 "IFLAG1,Interrupt Flags 1 Register"
        hexmask.long.byte 0x00 0.--5. 1. " BUF4I_BUF0I ,If the FIFO is not enabled, these bits flag the interrupts for MB0 to MB4."
        textline "      "
        bitfld.long 0x00 5. " BUF5I ,If the FIFO is not enabled, this bit flags the interrupt for MB5." "0,1"
        textline "      "
        bitfld.long 0x00 6. " BUF6I ,If the FIFO is not enabled, this bit flags the interrupt for MB6." "0,1"
        textline "      "
        bitfld.long 0x00 7. " BUF7I ,If the FIFO is not enabled, this bit flags the interrupt for MB7." "0,1"
        textline "      "
        hexmask.long.long 0x00 8.--32. 1. " BUF31I_BUF8I ,Each bit flags the respective FLEXCAN Message Buffer (MB8 to MB31) interrupt."
width 5.
group.long 0x34++0x3
    line.long 0x00 "GFWR,Glitch Filter Width Register"
        hexmask.long.byte 0x00 0.--8. 1. " GFWR ,It determines the Glitch Filter Width."
width 7.
group.long 0x880++0x3
    line.long 0x00 "RX0IMR,Rx Individual Mask Registers"
        hexmask.long.long 0x00 0.--32. 1. " MI31_MI0 ,For normal Rx message buffers, the mask bits affect the ID filter programmed on the message buffer."
width 8.
group.long 0x97c++0x3
    line.long 0x00 "RX63IMR,Rx Individual Mask Registers"
        hexmask.long.long 0x00 0.--32. 1. " MI31_MI0 ,For normal Rx message buffers, the mask bits affect the ID filter programmed on the message buffer."


    tree.end
    tree "FLEXCAN2"
        base ad:0x02094000

width 4.
group.long 0x0++0x3
    line.long 0x00 "MCR,Module Configuration Register"
        hexmask.long.byte 0x00 0.--6. 1. " MAXMB ,This 6-bit field defines the maximum number of message buffers that will take part in the matching and arbitration processes."
        textline "   "
        hexmask.long.byte 0x00 8.--10. 1. " IDAM ,This 2-bit field identifies the format of the elements of the Rx FIFO filter table, as shown below."
        textline "   "
        bitfld.long 0x00 12. " AEN ,This bit is supplied for backwards compatibility reasons." "0,1"
        textline "   "
        bitfld.long 0x00 13. " LPRIO_EN ,This bit is provided for backwards compatibility reasons." "0,1"
        textline "   "
        bitfld.long 0x00 16. " BCC ,This bit is provided to support Backwards Compatibility with previous FLEXCAN versions." "0,1"
        textline "   "
        bitfld.long 0x00 17. " SRX_DIS ,This bit defines whether FLEXCAN is allowed to receive frames transmitted by itself." "0,1"
        textline "   "
        bitfld.long 0x00 18. " DOZE ,This bit defines whether FLEXCAN is allowed to enter low power mode when Doze Mode is requested at ARM platform level." "0,1"
        textline "   "
        bitfld.long 0x00 19. " WAK_SRC ,This bit defines whether the integrated low-pass filter is applied to protect the Rx CAN input." "0,1"
        textline "   "
        bitfld.long 0x00 20. " LPM_ACK ,This read-only bit indicates that FLEXCAN is either in Disable Mode and Stop Mode." "0,1"
        textline "   "
        bitfld.long 0x00 21. " WRN_EN ,When asserted, this bit enables the generation of the TWRN_INT and RWRN_INT flags in the Error and Status Register." "0,1"
        textline "   "
        bitfld.long 0x00 22. " SLF_WAK ,This bit enables the Self Wake Up feature when FLEXCAN is in Stop Mode." "0,1"
        textline "   "
        bitfld.long 0x00 23. " SUPV ,This bit configures some of the FLEXCAN registers to be either in Supervisor or Unrestricted memory space." "0,1"
        textline "   "
        bitfld.long 0x00 24. " FRZ_ACK ,This read-only bit indicates that FLEXCAN is in Freeze Mode and its prescaler is stopped." "0,1"
        textline "   "
        bitfld.long 0x00 25. " SOFT_RST ,When this bit is asserted, FLEXCAN resets its internal state machines and some of the memory mapped registers." "0,1"
        textline "   "
        bitfld.long 0x00 26. " WAK_MSK ,This bit enables the Wake Up Interrupt generation." "0,1"
        textline "   "
        bitfld.long 0x00 27. " NOT_RDY ,This read-only bit indicates that FLEXCAN is either in Disable Mode, Stop Mode or Freeze Mode." "0,1"
        textline "   "
        bitfld.long 0x00 28. " HALT ,Assertion of this bit puts the FLEXCAN block into Freeze Mode." "0,1"
        textline "   "
        bitfld.long 0x00 29. " FEN ,This bit controls whether the FIFO feature is enabled or not." "0,1"
        textline "   "
        bitfld.long 0x00 30. " FRZ ,The FRZ bit specifies the FLEXCAN behavior when the HALT bit in the MCR Register is set or when Debug Mode is requested at ARM platform level." "0,1"
        textline "   "
        bitfld.long 0x00 31. " MDIS ,This bit controls whether FLEXCAN is enabled or not." "0,1"
width 5.
group.long 0x4++0x3
    line.long 0x00 "CTRL,Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " PROP_SEG ,This 3-bit field defines the length of the Propagation Segment in the bit time."
        textline "    "
        bitfld.long 0x00 3. " LOM ,This bit configures FLEXCAN to operate in Listen Only Mode." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LBUF ,This bit defines the ordering mechanism for Message Buffer transmission." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TSYN ,This bit enables a mechanism that resets the free-running timer each time a message is received in Message Buffer 0." "0,1"
        textline "    "
        bitfld.long 0x00 6. " BOFF_REC ,This bit defines how FLEXCAN recovers from Bus Off state." "0,1"
        textline "    "
        bitfld.long 0x00 7. " SMP ,This bit defines the sampling mode of CAN bits at the Rx input." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RWRN_MSK ,This bit provides a mask for the Rx Warning Interrupt associated with the RWRN_INT flag in the Error and Status Register." "0,1"
        textline "    "
        bitfld.long 0x00 11. " TWRN_MSK ,This bit provides a mask for the Tx Warning Interrupt associated with the TWRN_INT flag in the Error and Status Register." "0,1"
        textline "    "
        bitfld.long 0x00 12. " LPB ,This bit configures FLEXCAN to operate in Loop-Back Mode." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR_MSK ,This bit provides a mask for the Error Interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 15. " BOFF_MSK ,This bit provides a mask for the Bus Off Interrupt." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--19. 1. " PSEG2 ,This 3-bit field defines the length of Phase Buffer Segment 2 in the bit time."
        textline "    "
        hexmask.long.byte 0x00 19.--22. 1. " PSEG1 ,This 3-bit field defines the length of Phase Buffer Segment 1 in the bit time."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " RJW ,This 2-bit field defines the maximum number of time quanta One time quantum is equal to the Sclock period."
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " PRESDIV ,This 8-bit field defines the ratio between the CPI clock frequency and the Serial Clock (Sclock) frequency."
width 6.
group.long 0x8++0x3
    line.long 0x00 "TIMER,Free Running Timer"
        hexmask.long.word 0x00 0.--16. 1. " TIMER ,Timer value Contains the free-running counter value."
width 8.
group.long 0x10++0x3
    line.long 0x00 "RXGMASK,Rx Global Mask"
        hexmask.long.long 0x00 0.--32. 1. " MI31_MI0 ,For normal Rx message buffers, the mask bits affect the ID filter programmed on the message buffer."
width 9.
group.long 0x14++0x3
    line.long 0x00 "RX14MASK,Rx 14 Mask"
        hexmask.long.long 0x00 0.--32. 1. " MI31_MI0 ,Acceptance mask for the Identifier in Message Buffer 14"
width 9.
group.long 0x18++0x3
    line.long 0x00 "RX15MASK,Rx 15 Mask"
        hexmask.long.long 0x00 0.--32. 1. " MI31_MI0 ,Acceptance mask for the Identifier in Message Buffer 15"
width 4.
group.long 0x1c++0x3
    line.long 0x00 "ECR,Error Counter Register"
        hexmask.long.byte 0x00 0.--8. 1. " TX_ERR_COUNTER ,Transmit Error Counter"
        textline "   "
        hexmask.long.byte 0x00 8.--16. 1. " RX_ERR_COUNTER ,Receive Error Counter"
width 4.
group.long 0x20++0x3
    line.long 0x00 "ESR,Error and Status Register"
        bitfld.long 0x00 0. " WAK_INT ,When FLEXCAN is Stop Mode and a recessive to dominant transition is detected on the CAN bus and if the WAK_MSK bit in the MCR Register is set, an interrupt is generated to the ARM." "0,1"
        textline "   "
        bitfld.long 0x00 1. " ERR_INT ,This bit indicates that at least one of the Error Bits (bits 15-10) is set." "0,1"
        textline "   "
        bitfld.long 0x00 2. " BOFF_INT ,This bit is set when FLEXCAN enters Bus Off state." "0,1"
        textline "   "
        hexmask.long.byte 0x00 4.--6. 1. " FLT_CONF ,This 2-bit field indicates the Confinement State of the FLEXCAN block, as shown in below: If the LOM bit in the Control Register is asserted, the FLT_CONF field will indicate Error Passive."
        textline "   "
        bitfld.long 0x00 6. " TXRX ,This bit indicates if FLEXCAN is transmitting or receiving a message when the CAN bus is not in IDLE state." "0,1"
        textline "   "
        bitfld.long 0x00 7. " IDLE ,This bit indicates when CAN bus is in IDLE state." "0,1"
        textline "   "
        bitfld.long 0x00 8. " RX_WRN ,This bit indicates when repetitive errors are occurring during message reception." "0,1"
        textline "   "
        bitfld.long 0x00 9. " TX_WRN ,This bit indicates when repetitive errors are occurring during message transmission." "0,1"
        textline "   "
        bitfld.long 0x00 10. " STF_ERR ,This bit indicates that a Stuffing Error has been detected." "0,1"
        textline "   "
        bitfld.long 0x00 11. " FRM_ERR ,This bit indicates that a Form Error has been detected by the receiver node, that is, a fixed-form bit field contains at least one illegal bit." "0,1"
        textline "   "
        bitfld.long 0x00 12. " CRC_ERR ,This bit indicates that a CRC Error has been detected by the receiver node, that is, the calculated CRC is different from the received." "0,1"
        textline "   "
        bitfld.long 0x00 13. " ACK_ERR ,This bit indicates that an Acknowledge Error has been detected by the transmitter node, that is, a dominant bit has not been detected during the ACK SLOT." "0,1"
        textline "   "
        bitfld.long 0x00 14. " BIT0_ERR ,This bit indicates when an inconsistency occurs between the transmitted and the received bit in a message." "0,1"
        textline "   "
        bitfld.long 0x00 15. " BIT1_ERR ,This bit indicates when an inconsistency occurs between the transmitted and the received bit in a message." "0,1"
        textline "   "
        bitfld.long 0x00 16. " RWRN_INT ,If the WRN_EN bit in MCR is asserted, the RWRN_INT bit is set when the RX_WRN flag transitions from 0 to 1, meaning that the Rx error counters reached 96." "0,1"
        textline "   "
        bitfld.long 0x00 17. " TWRN_INT ,If the WRN_EN bit in MCR is asserted, the TWRN_INT bit is set when the TX_WRN flag transitions from 0 to 1, meaning that the Tx error counter reached 96." "0,1"
width 7.
group.long 0x24++0x3
    line.long 0x00 "IMASK2,Interrupt Masks 2 Register"
        hexmask.long.long 0x00 0.--32. 1. " BUF63M ,Each bit enables or disables the respective FLEXCAN Message Buffer (MB32 to MB63) Interrupt."
width 7.
group.long 0x28++0x3
    line.long 0x00 "IMASK1,Interrupt Masks 1 Register"
        hexmask.long.long 0x00 0.--32. 1. " BUF31M_BUF0M ,Each bit enables or disables the respective FLEXCAN Message Buffer (MB0 to MB31) Interrupt."
width 7.
group.long 0x2c++0x3
    line.long 0x00 "IFLAG2,Interrupt Flags 2 Register"
        hexmask.long.long 0x00 0.--32. 1. " BUF63I_BUF32I ,Each bit flags the respective FLEXCAN Message Buffer (MB32 to MB63) interrupt."
width 7.
group.long 0x30++0x3
    line.long 0x00 "IFLAG1,Interrupt Flags 1 Register"
        hexmask.long.byte 0x00 0.--5. 1. " BUF4I_BUF0I ,If the FIFO is not enabled, these bits flag the interrupts for MB0 to MB4."
        textline "      "
        bitfld.long 0x00 5. " BUF5I ,If the FIFO is not enabled, this bit flags the interrupt for MB5." "0,1"
        textline "      "
        bitfld.long 0x00 6. " BUF6I ,If the FIFO is not enabled, this bit flags the interrupt for MB6." "0,1"
        textline "      "
        bitfld.long 0x00 7. " BUF7I ,If the FIFO is not enabled, this bit flags the interrupt for MB7." "0,1"
        textline "      "
        hexmask.long.long 0x00 8.--32. 1. " BUF31I_BUF8I ,Each bit flags the respective FLEXCAN Message Buffer (MB8 to MB31) interrupt."
width 5.
group.long 0x34++0x3
    line.long 0x00 "GFWR,Glitch Filter Width Register"
        hexmask.long.byte 0x00 0.--8. 1. " GFWR ,It determines the Glitch Filter Width."
width 7.
group.long 0x880++0x3
    line.long 0x00 "RX0IMR,Rx Individual Mask Registers"
        hexmask.long.long 0x00 0.--32. 1. " MI31_MI0 ,For normal Rx message buffers, the mask bits affect the ID filter programmed on the message buffer."
width 8.
group.long 0x97c++0x3
    line.long 0x00 "RX63IMR,Rx Individual Mask Registers"
        hexmask.long.long 0x00 0.--32. 1. " MI31_MI0 ,For normal Rx message buffers, the mask bits affect the ID filter programmed on the message buffer."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; GPC
;--------------------------------------------------------------------------------
tree "GPC"
    base ad:0x020dc000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CNTR,GPC Interface control register"
        bitfld.long 0x00 0. " GPU_VPU_PDN_REQ ,GPU /VPU Power Down request." "0,1"
        textline "    "
        bitfld.long 0x00 1. " GPU_VPU_PUP_REQ ,GPU /VPU Power Up request." "0,1"
        textline "    "
        bitfld.long 0x00 16. " DVFS0CR ,DVFS0 (ARM) Change request (bit is read-only)" "0,1"
        textline "    "
        bitfld.long 0x00 21. " GPCIRQM ,GPC interrupt/event masking" "0,1"
width 4.
group.long 0x4++0x3
    line.long 0x00 "PGR,GPC Power Gating Register"
        hexmask.long.byte 0x00 29.--31. 1. " DRCIC ,Debug ref cir in mux control"
width 5.
group.long 0x8++0x3
    line.long 0x00 "IMR1,IRQ masking register 1"
        hexmask.long.long 0x00 0.--32. 1. " IMR1 ,IRQ[63:32] masking bits: 1-irq masked, 0-irq is not masked"
width 5.
group.long 0xc++0x3
    line.long 0x00 "IMR2,IRQ masking register 2"
        hexmask.long.long 0x00 0.--32. 1. " IMR2 ,IRQ[95:64] masking bits: 1-irq masked, 0-irq is not masked"
width 5.
group.long 0x10++0x3
    line.long 0x00 "IMR3,IRQ masking register 3"
        hexmask.long.long 0x00 0.--32. 1. " IMR3 ,IRQ[127:96] masking bits: 1-irq masked, 0-irq is not masked"
width 5.
group.long 0x14++0x3
    line.long 0x00 "IMR4,IRQ masking register 4"
        hexmask.long.long 0x00 0.--32. 1. " IMR4 ,IRQ[159:128] masking bits: 1-irq masked, 0-irq is not masked"
width 5.
rgroup.long 0x18++0x3
    line.long 0x00 "ISR1,IRQ status resister 1"
        hexmask.long.long 0x00 0.--32. 1. " ISR1 ,IRQ[63:32] status, read only"
width 5.
rgroup.long 0x1c++0x3
    line.long 0x00 "ISR2,IRQ status resister 2"
        hexmask.long.long 0x00 0.--32. 1. " ISR2 ,IRQ[95:64] status, read only"
width 5.
rgroup.long 0x20++0x3
    line.long 0x00 "ISR3,IRQ status resister 3"
        hexmask.long.long 0x00 0.--32. 1. " ISR3 ,IRQ[127:96] status, read only"
width 5.
rgroup.long 0x24++0x3
    line.long 0x00 "ISR4,IRQ status resister 4"
        hexmask.long.long 0x00 0.--32. 1. " ISR4 ,IRQ[159:128] status, read only"


tree.end



;--------------------------------------------------------------------------------
; GPIO
;--------------------------------------------------------------------------------
tree.open "GPIO"
    tree "GPIO1"
        base ad:0x0209c000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end
    tree "GPIO2"
        base ad:0x020a0000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end
    tree "GPIO3"
        base ad:0x020a4000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end
    tree "GPIO4"
        base ad:0x020a8000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end
    tree "GPIO5"
        base ad:0x020ac000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end
    tree "GPIO6"
        base ad:0x020b0000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end
    tree "GPIO7"
        base ad:0x020b4000

width 3.
group.long 0x0++0x3
    line.long 0x00 "DR,GPIO data register"
        hexmask.long.long 0x00 0.--32. 1. " DR ,Data bits."
width 5.
group.long 0x4++0x3
    line.long 0x00 "GDIR,GPIO direction register"
        hexmask.long.long 0x00 0.--32. 1. " GDIR ,GPIO direction bits."
width 4.
rgroup.long 0x8++0x3
    line.long 0x00 "PSR,GPIO pad status register"
        hexmask.long.long 0x00 0.--32. 1. " PSR ,GPIO pad status bits (status bits)."
width 5.
group.long 0xc++0x3
    line.long 0x00 "ICR1,GPIO interrupt configuration register1"
        hexmask.long.byte 0x00 0.--2. 1. " ICR0 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR1 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR2 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR3 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR4 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR5 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR6 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR7 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR8 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR9 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR10 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR11 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR12 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR13 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR14 ,Interrupt configuration 1 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR15 ,Interrupt configuration 1 fields."
width 5.
group.long 0x10++0x3
    line.long 0x00 "ICR2,GPIO interrupt configuration register2"
        hexmask.long.byte 0x00 0.--2. 1. " ICR16 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " ICR17 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ICR18 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ICR19 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ICR20 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICR21 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " ICR22 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " ICR23 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ICR24 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ICR25 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " ICR26 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " ICR27 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " ICR28 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " ICR29 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " ICR30 ,Interrupt configuration 2 fields."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " ICR31 ,Interrupt configuration 2 fields."
width 4.
group.long 0x14++0x3
    line.long 0x00 "IMR,GPIO interrupt mask register"
        hexmask.long.long 0x00 0.--32. 1. " IMR ,Interrupt Mask bits."
width 4.
group.long 0x18++0x3
    line.long 0x00 "ISR,GPIO interrupt status register"
        hexmask.long.long 0x00 0.--32. 1. " ISR ,Interrupt status bits - Bit n of this register is asserted (active high) when the active condition (as determined by the corresponding ICR bit) is detected on the GPIO input and is waiting for service."
width 9.
group.long 0x1c++0x3
    line.long 0x00 "EDGE_SEL,GPIO edge select register"
        hexmask.long.long 0x00 0.--32. 1. " GPIO_EDGE_SEL ,Edge select."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; GPT
;--------------------------------------------------------------------------------
tree "GPT"
    base ad:0x02098000

width 3.
group.long 0x0++0x3
    line.long 0x00 "CR,GPT Control Register"
        bitfld.long 0x00 0. " EN ,GPT Enable." "0,1"
        textline "  "
        bitfld.long 0x00 1. " ENMOD ,GPT Enable mode." "0,1"
        textline "  "
        bitfld.long 0x00 2. " DBGEN ,GPT debug mode enable." "0,1"
        textline "  "
        bitfld.long 0x00 3. " WAITEN ,GPT Wait Mode enable." "0,1"
        textline "  "
        bitfld.long 0x00 4. " DOZEEN ,GPT Doze Mode Enable." "0,1"
        textline "  "
        bitfld.long 0x00 5. " STOPEN ,GPT Stop Mode enable." "0,1"
        textline "  "
        hexmask.long.byte 0x00 6.--9. 1. " CLKSRC ,Clock Source select."
        textline "  "
        bitfld.long 0x00 9. " FRR ,Free-Run or Restart mode." "0,1"
        textline "  "
        bitfld.long 0x00 10. " _24MEN ,Enable 24MHz clock input from crystal." "0,1"
        textline "  "
        bitfld.long 0x00 15. " SWR ,Software reset." "0,1"
        textline "  "
        hexmask.long.byte 0x00 16.--18. 1. " IM1 ,See IM2"
        textline "  "
        hexmask.long.byte 0x00 18.--20. 1. " IM2 ,IM2 (bits 19-18, Input Capture Channel 2 operating mode) IM1 (bits 17-16, Input Capture Channel 1 operating mode) The IM n bit field determines the transition on the input pin (for Input capture channel n ), which will trigger a capture event."
        textline "  "
        hexmask.long.byte 0x00 20.--23. 1. " OM1 ,See OM3"
        textline "  "
        hexmask.long.byte 0x00 23.--26. 1. " OM2 ,See OM3"
        textline "  "
        hexmask.long.byte 0x00 26.--29. 1. " OM3 ,OM3 (bits 28-26) controls the Output Compare Channel 3 operating mode."
        textline "  "
        bitfld.long 0x00 29. " FO1 ,See F03" "0,1"
        textline "  "
        bitfld.long 0x00 30. " FO2 ,See F03" "0,1"
        textline "  "
        bitfld.long 0x00 31. " FO3 ,FO3 Force Output Compare Channel 3 FO2 Force Output Compare Channel 2 FO1 Force Output Compare Channel 1 The FO n bit causes the pin action programmed for the timer Output Compare n pin (according to the OM n bits in this register)." "0,1"
width 3.
group.long 0x4++0x3
    line.long 0x00 "PR,GPT Prescaler Register"
        hexmask.long.word 0x00 0.--12. 1. " PRESCALER ,Prescaler bits."
        textline "  "
        hexmask.long.byte 0x00 12.--16. 1. " PRESCALER24M ,Prescaler bits."
width 3.
group.long 0x8++0x3
    line.long 0x00 "SR,GPT Status Register"
        bitfld.long 0x00 0. " OF1 ,See OF3" "0,1"
        textline "  "
        bitfld.long 0x00 1. " OF2 ,See OF3" "0,1"
        textline "  "
        bitfld.long 0x00 2. " OF3 ,OF3 Output Compare 3 Flag OF2 Output Compare 2 Flag OF1 Output Compare 1 Flag The OF n bit indicates that a compare event has occurred on Output Compare channel n ." "0,1"
        textline "  "
        bitfld.long 0x00 3. " IF1 ,See IF2" "0,1"
        textline "  "
        bitfld.long 0x00 4. " IF2 ,IF2 Input capture 2 Flag IF1 Input capture 1 Flag The IF n bit indicates that a capture event has occurred on Input Capture channel n ." "0,1"
        textline "  "
        bitfld.long 0x00 5. " ROV ,Rollover Flag." "0,1"
width 3.
group.long 0xc++0x3
    line.long 0x00 "IR,GPT Interrupt Register"
        bitfld.long 0x00 0. " OF1IE ,See OF3IE" "0,1"
        textline "  "
        bitfld.long 0x00 1. " OF2IE ,See OF3IE" "0,1"
        textline "  "
        bitfld.long 0x00 2. " OF3IE ,OF3IE Output Compare 3 Interrupt Enable OF2IE Output Compare 2 Interrupt Enable OF1IE Output Compare 1 Interrupt Enable The OF n IE bit controls the Output Compare Channel n interrupt." "0,1"
        textline "  "
        bitfld.long 0x00 3. " IF1IE ,See IF2IE" "0,1"
        textline "  "
        bitfld.long 0x00 4. " IF2IE ,IF2IE Input capture 2 Interrupt Enable IF1IE Input capture 1 Interrupt Enable The IF n IE bit controls the IF n IE Input Capture n Interrupt Enable." "0,1"
        textline "  "
        bitfld.long 0x00 5. " ROVIE ,Rollover Interrupt Enable." "0,1"
width 5.
group.long 0x10++0x3
    line.long 0x00 "OCR1,GPT Output Compare Register 1"
        hexmask.long.long 0x00 0.--32. 1. " COMP ,Compare Value."
width 5.
group.long 0x14++0x3
    line.long 0x00 "OCR2,GPT Output Compare Register 2"
        hexmask.long.long 0x00 0.--32. 1. " COMP ,Compare Value."
width 5.
group.long 0x18++0x3
    line.long 0x00 "OCR3,GPT Output Compare Register 3"
        hexmask.long.long 0x00 0.--32. 1. " COMP ,Compare Value."
width 5.
rgroup.long 0x1c++0x3
    line.long 0x00 "ICR1,GPT Input Capture Register 1"
        hexmask.long.long 0x00 0.--32. 1. " CAPT ,Capture Value."
width 5.
rgroup.long 0x20++0x3
    line.long 0x00 "ICR2,GPT Input Capture Register 2"
        hexmask.long.long 0x00 0.--32. 1. " CAPT ,Capture Value."
width 4.
rgroup.long 0x24++0x3
    line.long 0x00 "CNT,GPT Counter Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Counter Value."


tree.end



;--------------------------------------------------------------------------------
; GPU2D
;--------------------------------------------------------------------------------
tree "GPU2D"
    base ad:0x00134000

width 17.
group.long 0x0++0x3
    line.long 0x00 "AQHICLOCKCONTROL,Clock Control Register"
        hexmask.long.byte 0x00 4.--8. 1. " MULTI_PIPE_USE_SINGLE_AXI ,Force all the transactions to go to one AXI."
        textline "                "
        hexmask.long.byte 0x00 8.--12. 1. " MULTI_PIPE_REG_SELECT ,Determines which HI/MC to use while reading registers."
        textline "                "
        bitfld.long 0x00 12. " ISOLATE_GPU ,Isolate GPU bit" "0,1"
        textline "                "
        bitfld.long 0x00 13. " IDLE_VG ,VG pipe is idle." "0,1"
        textline "                "
        bitfld.long 0x00 14. " IDLE2_D ,2D pipe is idle." "0,1"
        textline "                "
        bitfld.long 0x00 15. " IDLE3_D ,3D pipe is idle." "0,1"
        textline "                "
        bitfld.long 0x00 19. " SOFT_RESET ,Soft resets the IP." "0,1"
        textline "                "
        bitfld.long 0x00 20. " DISABLE_DEBUG_REGISTERS ,Disable debug registers." "0,1"
        textline "                "
        bitfld.long 0x00 21. " DISABLE_RAM_CLOCK_GATING ,Disables clock gating for rams." "0,1"
        textline "                "
        bitfld.long 0x00 22. " FSCALE_CMD_LOAD ,FSCALE Command Load bit" "0,1"
        textline "                "
        hexmask.long.byte 0x00 23.--30. 1. " FSCALE_VAL ,FSCALE Val"
        textline "                "
        bitfld.long 0x00 30. " CLK2D_DIS ,Disable 2D clock." "0,1"
        textline "                "
        bitfld.long 0x00 31. " CLK3D_DIS ,Disable 3D clock." "0,1"
width 9.
rgroup.long 0x4++0x3
    line.long 0x00 "AQHIIDLE,Idle Status Register"
        bitfld.long 0x00 0. " AXI_LP ,AXI is in low power mode." "0,1"
        textline "        "
        bitfld.long 0x00 20. " IDLE_TS ,TS is idle." "0,1"
        textline "        "
        bitfld.long 0x00 21. " IDLE_FP ,FP is idle." "0,1"
        textline "        "
        bitfld.long 0x00 22. " IDLE_IM ,IM is idle." "0,1"
        textline "        "
        bitfld.long 0x00 23. " IDLE_VG ,VG is idle." "0,1"
        textline "        "
        bitfld.long 0x00 24. " IDLE_TX ,TX is idle." "0,1"
        textline "        "
        bitfld.long 0x00 25. " IDLE_RA ,RA is idle." "0,1"
        textline "        "
        bitfld.long 0x00 26. " IDLE_SE ,SE is idle." "0,1"
        textline "        "
        bitfld.long 0x00 27. " IDLE_PA ,PA is idle." "0,1"
        textline "        "
        bitfld.long 0x00 28. " IDLE_SH ,SH is idle." "0,1"
        textline "        "
        bitfld.long 0x00 29. " IDLE_PE ,PE is idle." "0,1"
        textline "        "
        bitfld.long 0x00 30. " IDLE_DE ,DE is idle." "0,1"
        textline "        "
        bitfld.long 0x00 31. " IDLE_FE ,FE is idle." "0,1"
width 12.
group.long 0x8++0x3
    line.long 0x00 "AQAXICONFIG,AXI Configuration Register"
        hexmask.long.byte 0x00 16.--20. 1. " ARCACHE ,AR Cache"
        textline "           "
        hexmask.long.byte 0x00 20.--24. 1. " AWCACHE ,AW Cache"
        textline "           "
        hexmask.long.byte 0x00 24.--28. 1. " ARID ,AR ID"
        textline "           "
        hexmask.long.byte 0x00 28.--32. 1. " AWID ,AW ID"
width 12.
group.long 0xc++0x3
    line.long 0x00 "AQAXISTATUS,AXI Status Register"
        hexmask.long.byte 0x00 0.--4. 1. " WR_ERR_ID ,WR_ERR_ID bit"
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " RD_ERR_ID ,RD_ERR_ID bit"
        textline "           "
        bitfld.long 0x00 8. " DET_WR_ERR ,DET_WR_ERR bit" "0,1"
        textline "           "
        bitfld.long 0x00 9. " DET_RD_ERR ,DET_RD_ERR bit" "0,1"
width 18.
rgroup.long 0x10++0x3
    line.long 0x00 "AQINTRACKNOWLEDGE,Interrupt Acknowledge Register"
        hexmask.long.long 0x00 0.--32. 1. " INTR_VEC ,Interrupt VEC"
width 11.
group.long 0x14++0x3
    line.long 0x00 "AQINTRENBL,Interrupt Enable Register"
        hexmask.long.long 0x00 0.--32. 1. " INTR_ENBL_VEC ,Interrupt enable VEC"
width 8.
rgroup.long 0x18++0x3
    line.long 0x00 "AQIDENT,Identification Register"
        hexmask.long.byte 0x00 0.--8. 1. " CUSTOMER ,Customer value."
        textline "       "
        hexmask.long.byte 0x00 8.--12. 1. " TECHNOLOGY ,Technology value."
        textline "       "
        hexmask.long.byte 0x00 12.--16. 1. " REVISION ,Revision value."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " PRODUCT ,Product value."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " FAMILY ,Family value."
width 9.
rgroup.long 0x1c++0x3
    line.long 0x00 "FEATURES,Features Register"
        bitfld.long 0x00 0. " FE20_BIT_INDEX ,Supports 20 bit index." "0,1"
        textline "        "
        bitfld.long 0x00 1. " RS_YUV_TARGET ,Supports resolving into YUV target." "0,1"
        textline "        "
        bitfld.long 0x00 2. " BYTE_WRITE_3D ,3D PE has byte write capability." "0,1"
        textline "        "
        bitfld.long 0x00 3. " FE20 ,FE 2.0 is present." "0,1"
        textline "        "
        bitfld.long 0x00 4. " VGTS ,VG tessellator is present." "0,1"
        textline "        "
        bitfld.long 0x00 5. " PIPE_VG ,VG pipe is present." "0,1"
        textline "        "
        bitfld.long 0x00 6. " MEM32_BIT_SUPPORT ,32 bit memory address support." "0,1"
        textline "        "
        bitfld.long 0x00 7. " YUY2_RENDER_TARGET ,YUY2 support in PE and YUY2 to RGB conversion in resolve." "0,1"
        textline "        "
        bitfld.long 0x00 8. " HALF_TX_CACHE ,TX cache is half." "0,1"
        textline "        "
        bitfld.long 0x00 9. " HALF_PE_CACHE ,PE cache is half." "0,1"
        textline "        "
        bitfld.long 0x00 10. " YUY2_AVERAGING ,YUY2 averaging support in resolve." "0,1"
        textline "        "
        bitfld.long 0x00 11. " NO_SCALER ,IP does not have 2D scaler." "0,1"
        textline "        "
        bitfld.long 0x00 12. " BYTE_WRITE_2D ,Supports byte write in 2D." "0,1"
        textline "        "
        bitfld.long 0x00 13. " BUFFER_INTERLEAVING ,IP supports interleaving depth and color buffers." "0,1"
        textline "        "
        bitfld.long 0x00 14. " NO422_TEXTURE ,IP does not have 422 texture input format." "0,1"
        textline "        "
        bitfld.long 0x00 15. " NO_EZ ,IP does not have early-Z." "0,1"
        textline "        "
        bitfld.long 0x00 16. " MIN_AREA ,IP is configured to have minimum area." "0,1"
        textline "        "
        bitfld.long 0x00 17. " MODULE_CG ,Second level clock gating is available." "0,1"
        textline "        "
        bitfld.long 0x00 18. " YUV420_TILER ,YUV 4:2:0 tiler is available." "0,1"
        textline "        "
        bitfld.long 0x00 19. " HIGH_DYNAMIC_RANGE ,Shows if the IP has HDR support." "0,1"
        textline "        "
        bitfld.long 0x00 20. " FAST_SCALER ,Shows if the IP has HD scaler." "0,1"
        textline "        "
        bitfld.long 0x00 21. " ETC1_TEXTURE_COMPRESSION ,ETC1 texture compression." "0,1"
        textline "        "
        bitfld.long 0x00 22. " PIPE_2D ,Shows if there is 2D engine." "0,1"
        textline "        "
        bitfld.long 0x00 23. " DC ,Shows if there is a display controller in the IP." "0,1"
        textline "        "
        bitfld.long 0x00 24. " MSAA ,MSAA support." "0,1"
        textline "        "
        bitfld.long 0x00 25. " YUV420_FILTER ,YUV 4:2:0 support in filter blit." "0,1"
        textline "        "
        bitfld.long 0x00 26. " ZCOMPRESSION ,Depth and color compression." "0,1"
        textline "        "
        bitfld.long 0x00 27. " DEBUG_MODE ,Debug registers." "0,1"
        textline "        "
        bitfld.long 0x00 28. " DXT_TEXTURE_COMPRESSION ,DXT texture compression." "0,1"
        textline "        "
        bitfld.long 0x00 29. " PIPE_3D ,3D pipe." "0,1"
        textline "        "
        bitfld.long 0x00 30. " SPECIAL_ANTI_ALIASING ,Full-screen anti-aliasing." "0,1"
        textline "        "
        bitfld.long 0x00 31. " FAST_CLEAR ,Fast clear." "0,1"
width 7.
rgroup.long 0x20++0x3
    line.long 0x00 "CHIPID,Chip Identification Register"
        hexmask.long.long 0x00 0.--32. 1. " ID ,Id."
width 8.
rgroup.long 0x24++0x3
    line.long 0x00 "CHIPREV,Chip Revision Register"
        hexmask.long.long 0x00 0.--32. 1. " REV ,Revision."
width 9.
rgroup.long 0x28++0x3
    line.long 0x00 "CHIPDATE,Chip Release Date Register"
        hexmask.long.long 0x00 0.--32. 1. " DATE ,Date."
width 9.
rgroup.long 0x2c++0x3
    line.long 0x00 "CHIPTIME,Chip Release Time Register"
        hexmask.long.long 0x00 0.--32. 1. " TIME ,Time."
width 13.
rgroup.long 0x30++0x3
    line.long 0x00 "CHIPCUSTOMER,Chip Customer Register"
        hexmask.long.word 0x00 0.--16. 1. " GROUP ,Group."
        textline "            "
        hexmask.long.word 0x00 16.--32. 1. " COMPANY ,Company."
width 15.
rgroup.long 0x34++0x3
    line.long 0x00 "MINORFEATURES0,Minor Features Register 0"
        bitfld.long 0x00 0. " FLIP_Y ,Y flipping capability is added to resolve." "0,1"
        textline "              "
        bitfld.long 0x00 1. " DUAL_RETURN_BUS ,Dual Return Bus from HI to clients." "0,1"
        textline "              "
        bitfld.long 0x00 2. " ENDIANNESS_CONFIG ,Configurable endianness support." "0,1"
        textline "              "
        bitfld.long 0x00 3. " TEXTURE8_K ,Supports 8Kx8K textures." "0,1"
        textline "              "
        bitfld.long 0x00 4. " CORRECT_TEXTURE_CONVERTER ,Driver hack is not needed." "0,1"
        textline "              "
        bitfld.long 0x00 5. " SPECIAL_MSAA_LOD ,Special LOD calculation when MSAA is on." "0,1"
        textline "              "
        bitfld.long 0x00 6. " FAST_CLEAR_FLUSH ,Proper flush is done in fast clear cache." "0,1"
        textline "              "
        bitfld.long 0x00 7. " _2DPE20 ,2D PE 2.0 is present." "0,1"
        textline "              "
        bitfld.long 0x00 8. " CORRECT_AUTO_DISABLE ,Auto disable in FC is correct." "0,1"
        textline "              "
        bitfld.long 0x00 9. " RENDER_8K ,Supports 8K render target." "0,1"
        textline "              "
        bitfld.long 0x00 10. " TILE_STATUS_2BITS ,2 bits are used instead of 4 bits for tile status." "0,1"
        textline "              "
        bitfld.long 0x00 11. " SEPARATE_TILE_STATUS_WHEN_INTERLEAVED ,Use 2 separate tile status buffers in interleaved mode." "0,1"
        textline "              "
        bitfld.long 0x00 12. " SUPER_TILED_32X32 ,32x32 super tile is available." "0,1"
        textline "              "
        bitfld.long 0x00 13. " VG_20 ,Major updates to VG pipe (TS buffer tiling." "0,1"
        textline "              "
        bitfld.long 0x00 14. " TS_EXTENDED_COMMANDS ,New commands added to the tessellator." "0,1"
        textline "              "
        bitfld.long 0x00 15. " COMPRESSION_FIFO_FIXED ,If this bit is not set, the FIFO counter should be set to 50." "0,1"
        textline "              "
        bitfld.long 0x00 16. " EXTRA_SHADER_INSTRUCTIONS0 ,Floor, ceil, and sign instructions are available." "0,1"
        textline "              "
        bitfld.long 0x00 17. " VG_FILTER ,VG filter is available." "0,1"
        textline "              "
        bitfld.long 0x00 18. " VG_21 ,Minor updates to VG pipe (Event generation from VG, TS, PE)." "0,1"
        textline "              "
        bitfld.long 0x00 19. " SHADER_GETS_W ,W is sent to SH from RA." "0,1"
        textline "              "
        bitfld.long 0x00 20. " EXTRA_SHADER_INSTRUCTIONS1 ,Sqrt, sin, cos instructions are available." "0,1"
        textline "              "
        bitfld.long 0x00 21. " DEFAULT_REG0 ,Unavailable registers will return 0." "0,1"
        textline "              "
        bitfld.long 0x00 22. " MC_20 ,New style MC with separate paths for color and depth." "0,1"
        textline "              "
        bitfld.long 0x00 23. " SHADER_MSAA_SIDEBAND ,Put the MSAA data into sideband fifo." "0,1"
        textline "              "
        bitfld.long 0x00 24. " BUG_FIXES0 ,Bug fix bit 0" "0,1"
        textline "              "
        bitfld.long 0x00 25. " VAA ,VAA is available or not." "0,1"
        textline "              "
        bitfld.long 0x00 26. " BYPASS_IN_MSAA ,Shader supports bypass mode when MSAA is enabled." "0,1"
        textline "              "
        bitfld.long 0x00 27. " HIERARCHICAL_Z ,Hierarchiccal Z is supported." "0,1"
        textline "              "
        bitfld.long 0x00 28. " NEW_TEXTURE ,New texture unit is available." "0,1"
        textline "              "
        bitfld.long 0x00 29. " A8_TARGET_SUPPORT ,2D engine supports A8 target." "0,1"
        textline "              "
        bitfld.long 0x00 30. " CORRECT_STENCIL ,Correct stencil behavior in depth only." "0,1"
        textline "              "
        bitfld.long 0x00 31. " ENHANCE_VR ,Enhance VR and add a mode to walk 16 pixels in 16-bit mode in Vertical pass to improve $ hit rate when rotating 90/270." "0,1"
width 13.
group.long 0x38++0x3
    line.long 0x00 "CACHECONTROL,Cache Control Register"
        hexmask.long.long 0x00 0.--32. 1. " NOT_USED ,Reserved"
width 17.
wgroup.long 0x3c++0x3
    line.long 0x00 "RESETMEMCOUNTERS,Reset Mem Counters Register"
        hexmask.long.long 0x00 0.--32. 1. " RESET ,Reset"
width 11.
rgroup.long 0x40++0x3
    line.long 0x00 "TOTALREADS,Read Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 12.
rgroup.long 0x44++0x3
    line.long 0x00 "TOTALWRITES,Write Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 10.
rgroup.long 0x48++0x3
    line.long 0x00 "CHIPSPECS,Chip Specification Register"
        hexmask.long.byte 0x00 0.--4. 1. " VERTEX_OUTPUT_BUFFER_SIZE ,Log2 of vertex output buffer size."
        textline "         "
        hexmask.long.byte 0x00 4.--7. 1. " NUM_PIXEL_PIPES ,Number of pixel pipes."
        textline "         "
        hexmask.long.byte 0x00 7.--12. 1. " NUM_SHADER_CORES ,Number of shader cores."
        textline "         "
        hexmask.long.byte 0x00 15.--20. 1. " VERTEX_CACHE_SIZE ,Number of entries in the vertex shader cache."
        textline "         "
        hexmask.long.byte 0x00 20.--24. 1. " THREAD_COUNT ,Log2 of thread count."
        textline "         "
        hexmask.long.byte 0x00 24.--28. 1. " TEMP_REGISTERS ,Log2 of temporary registers."
        textline "         "
        hexmask.long.byte 0x00 28.--32. 1. " STREAMS ,Number of vertex streams."
width 17.
rgroup.long 0x4c++0x3
    line.long 0x00 "TOTALWRITEBURSTS,Write Data Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 15.
rgroup.long 0x50++0x3
    line.long 0x00 "TOTALWRITEREQS,Write REQ Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 16.
rgroup.long 0x54++0x3
    line.long 0x00 "TOTALWRITELASTS,Total WLAST Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 16.
rgroup.long 0x58++0x3
    line.long 0x00 "TOTALREADBURSTS,Total Read Data Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 14.
rgroup.long 0x5c++0x3
    line.long 0x00 "TOTALREADREQS,Total Read REQ Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 15.
rgroup.long 0x60++0x3
    line.long 0x00 "TOTALREADLASTS,Total RLAST Count Register"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 7.
group.long 0x64++0x3
    line.long 0x00 "GPOUT0,General Purpose Register 0"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 7.
group.long 0x68++0x3
    line.long 0x00 "GPOUT1,General Purpose Register 1"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 7.
group.long 0x6c++0x3
    line.long 0x00 "GPOUT2,General Purpose Register 2"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 11.
group.long 0x70++0x3
    line.long 0x00 "AXICONTROL,AXI Control Register"
        hexmask.long.long 0x00 0.--32. 1. " WR_FULL_BURST_MODE ,WR_FULL_BURST_MODE"
width 15.
rgroup.long 0x74++0x3
    line.long 0x00 "MINORFEATURES1,Minor Features Register 1"
        bitfld.long 0x00 26. " TEXTURE_STRIDE ,Texture has stride and memory addressing." "0,1"
        textline "              "
        bitfld.long 0x00 27. " BUG_FIXES2 ,Bug fixes bit 2" "0,1"
        textline "              "
        bitfld.long 0x00 28. " BUG_FIXES1 ,Bug fixes bit 1" "0,1"
        textline "              "
        bitfld.long 0x00 29. " VG_DOUBLE_BUFFER ,Double buffering support for VG (second TS-->VG semaphore is present)." "0,1"
        textline "              "
        bitfld.long 0x00 30. " V2_COMPRESSION ,V2 compression." "0,1"
        textline "              "
        bitfld.long 0x00 31. " RSUV_SWIZZLE ,Resolve UV swizzle." "0,1"
width 12.
group.long 0x78++0x3
    line.long 0x00 "TOTALCYCLES,Total Cycle Counter Register"
        hexmask.long.long 0x00 0.--32. 1. " CYCLES ,Total cycles"
width 15.
group.long 0x7c++0x3
    line.long 0x00 "TOTALIDLECYLES,Total Idle Cycle Register"
        hexmask.long.long 0x00 0.--32. 1. " CYCLES ,Total cycles"
width 11.
group.long 0x80++0x3
    line.long 0x00 "CHIPSPECS2,Chip Specification Register"
        hexmask.long.long 0x00 0.--32. 1. " CYCLES ,Total cycles"
width 20.
group.long 0x84++0x3
    line.long 0x00 "MODULEPOWERCONTROLS,Power Control Register"
        hexmask.long.word 0x00 0.--16. 1. " TURN_OFF_COUNTER ,Counter value for clock gating the module if the module is idle for this amount of clock cycles."
        textline "                   "
        hexmask.long.byte 0x00 24.--28. 1. " TURN_ON_COUNTER ,Number of clock cycles to wait after turning on the clock."
        textline "                   "
        bitfld.long 0x00 29. " DISABLE_STARVE_MODULE_CLOCK_GATING ,Disables module level clock gating for starve/idle condition." "0,1"
        textline "                   "
        bitfld.long 0x00 30. " DISABLE_STALL_MODULE_CLOCK_GATING ,Disables module level clock gating for stall condition." "0,1"
        textline "                   "
        bitfld.long 0x00 31. " ENABLE_MODULE_CLOCK_GATING ,Enables module level clock gating." "0,1"
width 25.
group.long 0x88++0x3
    line.long 0x00 "MODULEPOWERMODULECONTROL,Power Level Register"
        bitfld.long 0x00 20. " DISABLE_MODULE_CLOCK_GATING_TS ,Disables module level clock gating for TS." "0,1"
        textline "                        "
        bitfld.long 0x00 21. " DISABLE_MODULE_CLOCK_GATING_FP ,Disables module level clock gating for FP." "0,1"
        textline "                        "
        bitfld.long 0x00 22. " DISABLE_MODULE_CLOCK_GATING_IM ,Disables module level clock gating for IM." "0,1"
        textline "                        "
        bitfld.long 0x00 23. " DISABLE_MODULE_CLOCK_GATING_VG ,Disables module level clock gating for VG." "0,1"
        textline "                        "
        bitfld.long 0x00 24. " DISABLE_MODULE_CLOCK_GATING_TX ,Disables module level clock gating for TX." "0,1"
        textline "                        "
        bitfld.long 0x00 25. " DISABLE_MODULE_CLOCK_GATING_RA ,Disables module level clock gating for RA." "0,1"
        textline "                        "
        bitfld.long 0x00 26. " DISABLE_MODULE_CLOCK_GATING_SE ,Disables module level clock gating for SE." "0,1"
        textline "                        "
        bitfld.long 0x00 27. " DISABLE_MODULE_CLOCK_GATING_PA ,Disables module level clock gating for PA." "0,1"
        textline "                        "
        bitfld.long 0x00 28. " DISABLE_MODULE_CLOCK_GATING_SH ,Disables module level clock gating for SH." "0,1"
        textline "                        "
        bitfld.long 0x00 29. " DISABLE_MODULE_CLOCK_GATING_PE ,Disables module level clock gating for PE." "0,1"
        textline "                        "
        bitfld.long 0x00 30. " DISABLE_MODULE_CLOCK_GATING_DE ,Disables module level clock gating for DE." "0,1"
        textline "                        "
        bitfld.long 0x00 31. " DISABLE_MODULE_CLOCK_GATING_FE ,Disables module level clock gating for FE." "0,1"
width 24.
rgroup.long 0x8c++0x3
    line.long 0x00 "MODULEPOWERMODULESTATUS,Power Status Register"
        bitfld.long 0x00 20. " MODULE_CLOCK_GATED_TS ,Module level clock gating is ON for TS." "0,1"
        textline "                       "
        bitfld.long 0x00 21. " MODULE_CLOCK_GATED_FP ,Module level clock gating is ON for FP." "0,1"
        textline "                       "
        bitfld.long 0x00 22. " MODULE_CLOCK_GATED_IM ,Module level clock gating is ON for IM." "0,1"
        textline "                       "
        bitfld.long 0x00 23. " MODULE_CLOCK_GATED_VG ,Module level clock gating is ON for VG." "0,1"
        textline "                       "
        bitfld.long 0x00 24. " MODULE_CLOCK_GATED_TX ,Module level clock gating is ON for TX." "0,1"
        textline "                       "
        bitfld.long 0x00 25. " MODULE_CLOCK_GATED_RA ,Module level clock gating is ON for RA." "0,1"
        textline "                       "
        bitfld.long 0x00 26. " MODULE_CLOCK_GATED_SE ,Module level clock gating is ON for SE." "0,1"
        textline "                       "
        bitfld.long 0x00 27. " MODULE_CLOCK_GATED_PA ,Module level clock gating is ON for PA." "0,1"
        textline "                       "
        bitfld.long 0x00 28. " MODULE_CLOCK_GATED_SH ,Module level clock gating is ON for SH." "0,1"
        textline "                       "
        bitfld.long 0x00 29. " MODULE_CLOCK_GATED_PE ,Module level clock gating is ON for PE." "0,1"
        textline "                       "
        bitfld.long 0x00 30. " MODULE_CLOCK_GATED_DE ,Module level clock gating is ON for DE." "0,1"
        textline "                       "
        bitfld.long 0x00 31. " MODULE_CLOCK_GATED_FE ,Module level clock gating is ON for FE." "0,1"


tree.end



;--------------------------------------------------------------------------------
; GPU3D
;--------------------------------------------------------------------------------
tree "GPU3D"
    base ad:0x00130000

width 13.
group.long 0x0++0x3
    line.long 0x00 "AQH_CLK_CTRL,AQHiClockControl"
        bitfld.long 0x00 0. " CLK3D_DIS ,Disable 3D clock." "0,1"
        textline "            "
        bitfld.long 0x00 1. " CLK2D_DIS ,Disable 2D clock." "0,1"
        textline "            "
        hexmask.long.byte 0x00 2.--9. 1. " FSCALE_VAL ,-"
        textline "            "
        bitfld.long 0x00 9. " FSCALE_CMD_LOAD ,-" "0,1"
        textline "            "
        bitfld.long 0x00 10. " DISABLE_RAM_CLOCK_GATING ,Disables clock gating for rams." "0,1"
        textline "            "
        bitfld.long 0x00 11. " DISABLE_DEBUG_REGISTERS ,Disable debug registers." "0,1"
        textline "            "
        bitfld.long 0x00 12. " SOFT_RESET ,Soft resets the IP." "0,1"
        textline "            "
        bitfld.long 0x00 16. " IDLE3_D ,3D pipe is idle." "0,1"
        textline "            "
        bitfld.long 0x00 17. " IDLE2_D ,2D pipe is idle." "0,1"
        textline "            "
        bitfld.long 0x00 18. " IDLE_VG ,VG is idle." "0,1"
        textline "            "
        bitfld.long 0x00 19. " ISOLATE_GPU ,Isolate GPU bit" "0,1"
        textline "            "
        hexmask.long.byte 0x00 20.--24. 1. " MULTI_PIPE_REG_SELECT ,Determines which HI/MC to use while reading registers."
        textline "            "
        hexmask.long.byte 0x00 24.--28. 1. " MULTI_PIPE_USE_SINGLE_AXI ,Force all the transactions to go to one AXI"
width 9.
rgroup.long 0x4++0x3
    line.long 0x00 "AQH_IDLE,AQHIdle"
        bitfld.long 0x00 0. " IDLE_FE ,FE is idle." "0,1"
        textline "        "
        bitfld.long 0x00 1. " IDLE_DE ,DE is idle." "0,1"
        textline "        "
        bitfld.long 0x00 2. " IDLE_PE ,PE is idle." "0,1"
        textline "        "
        bitfld.long 0x00 3. " IDLE_SH ,SH is idle." "0,1"
        textline "        "
        bitfld.long 0x00 4. " IDLE_PA ,PA is idle." "0,1"
        textline "        "
        bitfld.long 0x00 5. " IDLE_SE ,SE is idle." "0,1"
        textline "        "
        bitfld.long 0x00 6. " IDLE_RA ,RA is idle." "0,1"
        textline "        "
        bitfld.long 0x00 7. " IDLE_TX ,TX is idle." "0,1"
        textline "        "
        bitfld.long 0x00 8. " IDLE_VG ,VG is idle." "0,1"
        textline "        "
        bitfld.long 0x00 9. " IDLE_IM ,IM is idle." "0,1"
        textline "        "
        bitfld.long 0x00 10. " IDLE_FP ,FP is idle." "0,1"
        textline "        "
        bitfld.long 0x00 11. " IDLE_TS ,TS is idle." "0,1"
        textline "        "
        bitfld.long 0x00 31. " AXI_LP ,AXI is in low power mode." "0,1"
width 8.
group.long 0x8++0x3
    line.long 0x00 "AQA_CFG,AQAxiConfig"
        hexmask.long.byte 0x00 0.--4. 1. " AWID ,AW ID"
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " ARID ,AR ID"
        textline "       "
        hexmask.long.byte 0x00 8.--12. 1. " AWCACHE ,AW Cache"
        textline "       "
        hexmask.long.byte 0x00 12.--16. 1. " ARCACHE ,AR Cache"
width 11.
rgroup.long 0xc++0x3
    line.long 0x00 "AQA_STATUS,AQAxiStatus"
        hexmask.long.byte 0x00 0.--4. 1. " WR_ERR_ID ,-"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " RD_ERR_ID ,-"
        textline "          "
        bitfld.long 0x00 8. " DET_WR_ERR ,-" "0,1"
        textline "          "
        bitfld.long 0x00 9. " DET_RD_ERR ,-" "0,1"
width 8.
rgroup.long 0x10++0x3
    line.long 0x00 "AQI_ACK,AQIntrAcknowledge"
        hexmask.long.long 0x00 0.--32. 1. " INTR_VEC ,-"
width 9.
group.long 0x14++0x3
    line.long 0x00 "AQI_ENBL,AQIntrEnbl"
        hexmask.long.long 0x00 0.--32. 1. " INTR_ENBL_VEC ,-"
width 8.
rgroup.long 0x18++0x3
    line.long 0x00 "AQIDENT,AQIdent"
        hexmask.long.byte 0x00 0.--8. 1. " CUSTOMER ,Customer value."
        textline "       "
        hexmask.long.byte 0x00 8.--12. 1. " TECHNOLOGY ,Technology value."
        textline "       "
        hexmask.long.byte 0x00 12.--16. 1. " REVISION ,Revision value."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " PRODUCT ,Product value."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " FAMILY ,Family value."
width 8.
rgroup.long 0x1c++0x3
    line.long 0x00 "GC_FEAT,GCFeatures"
        bitfld.long 0x00 0. " FAST_CLEAR ,Fast clear." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SPECIAL_ANTI_ALIASING ,Full-screen anti-aliasing." "0,1"
        textline "       "
        bitfld.long 0x00 2. " PIPE_3D ,3D pipe." "0,1"
        textline "       "
        bitfld.long 0x00 3. " DXT_TEXTURE_COMPRESSION ,DXT texture compression." "0,1"
        textline "       "
        bitfld.long 0x00 4. " DEBUG_MODE ,Debug registers." "0,1"
        textline "       "
        bitfld.long 0x00 5. " ZCOMPRESSION ,Depth and color compression." "0,1"
        textline "       "
        bitfld.long 0x00 6. " YUV420_FILTER ,YUV 4:2:0 support in filter blit." "0,1"
        textline "       "
        bitfld.long 0x00 7. " MSAA ,MSAA support." "0,1"
        textline "       "
        bitfld.long 0x00 8. " DC ,Shows if there is a display controller in the IP." "0,1"
        textline "       "
        bitfld.long 0x00 9. " PIPE_2D ,Shows if there is 2D engine." "0,1"
        textline "       "
        bitfld.long 0x00 10. " ETC1_TEXTURE_COMPRESSION ,ETC1 texture compression." "0,1"
        textline "       "
        bitfld.long 0x00 11. " FAST_SCALER ,Shows if the IP has HD scaler." "0,1"
        textline "       "
        bitfld.long 0x00 12. " HIGH_DYNAMIC_RANGE ,Shows if the IP has HDR support." "0,1"
        textline "       "
        bitfld.long 0x00 13. " YUV420_TILER ,YUV 4:2:0 tiler is available." "0,1"
        textline "       "
        bitfld.long 0x00 14. " MODULE_CG ,Secong level clock gating is available." "0,1"
        textline "       "
        bitfld.long 0x00 15. " MIN_AREA ,IP is configured to have minimum area." "0,1"
        textline "       "
        bitfld.long 0x00 16. " NO_EZ ,IP does not have early-Z." "0,1"
        textline "       "
        bitfld.long 0x00 17. " NO422_TEXTURE ,IP does not have 422 texture input format." "0,1"
        textline "       "
        bitfld.long 0x00 18. " BUFFER_INTERLEAVING ,IP supports interleaving depth and color buffers." "0,1"
        textline "       "
        bitfld.long 0x00 19. " BYTE_WRITE_2D ,Supports byte write in 2D." "0,1"
        textline "       "
        bitfld.long 0x00 20. " NO_SCALER ,IP does not have 2D scaler." "0,1"
        textline "       "
        bitfld.long 0x00 21. " YUY2_AVERAGING ,YUY2 averaging support in resolve." "0,1"
        textline "       "
        bitfld.long 0x00 22. " HALF_PE_CACHE ,PE cache is half." "0,1"
        textline "       "
        bitfld.long 0x00 23. " HALF_TX_CACHE ,TX cache is half." "0,1"
        textline "       "
        bitfld.long 0x00 24. " YUY2_RENDER_TARGET ,YUY2 support in PE and YUY2 to RGB conversion in resolve." "0,1"
        textline "       "
        bitfld.long 0x00 25. " MEM32_BIT_SUPPORT ,32 bit memory address support." "0,1"
        textline "       "
        bitfld.long 0x00 26. " PIPE_VG ,VCG pipe is present." "0,1"
        textline "       "
        bitfld.long 0x00 27. " VGTS ,VG tessellator is present." "0,1"
        textline "       "
        bitfld.long 0x00 28. " FE20 ,FE 2.0 is present." "0,1"
        textline "       "
        bitfld.long 0x00 29. " BYTE_WRITE_3D ,3D PE has byte write capability." "0,1"
        textline "       "
        bitfld.long 0x00 30. " RS_YUV_TARGET ,Supports resolving into YUV target." "0,1"
        textline "       "
        bitfld.long 0x00 31. " FE20_BIT_INDEX ,Supports 20 bit index." "0,1"
width 7.
rgroup.long 0x20++0x3
    line.long 0x00 "GCC_ID,GCChipId"
        hexmask.long.long 0x00 0.--32. 1. " ID ,Id"
width 8.
rgroup.long 0x24++0x3
    line.long 0x00 "GCC_REV,GCChipRev"
        hexmask.long.long 0x00 0.--32. 1. " REV ,Revision"
width 9.
rgroup.long 0x28++0x3
    line.long 0x00 "GCC_DATE,GCChipDate"
        hexmask.long.long 0x00 0.--32. 1. " DATE ,Date"
width 9.
rgroup.long 0x2c++0x3
    line.long 0x00 "GCC_TIME,GCChipTime"
        hexmask.long.long 0x00 0.--32. 1. " TIME ,Time"
width 9.
rgroup.long 0x30++0x3
    line.long 0x00 "GCC_CUST,GCChipCustomer"
        hexmask.long.word 0x00 0.--16. 1. " GROUP ,Group"
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " COMPANY ,Company"
width 11.
rgroup.long 0x34++0x3
    line.long 0x00 "GCM_FEAT_0,GCMinorFeatures0"
        bitfld.long 0x00 0. " FLIP_Y ,Y flipping capability is added to resolve." "0,1"
        textline "          "
        bitfld.long 0x00 1. " DUAL_RETURN_BUS ,Dual Return Bus from HI to clients." "0,1"
        textline "          "
        bitfld.long 0x00 2. " ENDIANNESS_CONFIG ,Configurable endianness support." "0,1"
        textline "          "
        bitfld.long 0x00 3. " TESTURE8_K ,Supports 8Kx8K textures." "0,1"
        textline "          "
        bitfld.long 0x00 4. " CORRECT_TEXTURE_CONVERTER ,Driver hack is not needed." "0,1"
        textline "          "
        bitfld.long 0x00 5. " SPECIAL_MSAA_LOD ,Special LOD calculation when MSAA is on." "0,1"
        textline "          "
        bitfld.long 0x00 6. " FAST_CLEAR_FLUSH ,Proper flush is done in fast clear cache." "0,1"
        textline "          "
        bitfld.long 0x00 7. " _2DPE20 ,2D PE 2.0 is present." "0,1"
        textline "          "
        bitfld.long 0x00 8. " CORRECT_AUTO_DISABLE ,Auto disable in FC is correct." "0,1"
        textline "          "
        bitfld.long 0x00 9. " RENDER_8K ,Supports 8K render target." "0,1"
        textline "          "
        bitfld.long 0x00 10. " TILE_STATUS_2BITS ,2 bits are used instead of 4 bits for tile status." "0,1"
        textline "          "
        bitfld.long 0x00 11. " SEPARATE_TILE_STATUS_WHEN_INTERLEAVED ,Use 2 separate tile status buffers in interleaved mode." "0,1"
        textline "          "
        bitfld.long 0x00 12. " SUPER_TILED_32X32 ,32x32 super tile is available." "0,1"
        textline "          "
        bitfld.long 0x00 13. " VG_20 ,Major updates to VG pipe (TS buffer tiling." "0,1"
        textline "          "
        bitfld.long 0x00 14. " TS_EXTENDED_COMMANDS ,New commands added to the tessellator." "0,1"
        textline "          "
        bitfld.long 0x00 15. " COMPRESSION_FIFO_FIXED ,If this bit is not set, the FIFO counter should be set to 50." "0,1"
        textline "          "
        bitfld.long 0x00 16. " EXTRA_SHADER_INSTRUCTIONS0 ,Floor, ceil, and sign instructions are available." "0,1"
        textline "          "
        bitfld.long 0x00 17. " VG_FILTER ,VG filter is available." "0,1"
        textline "          "
        bitfld.long 0x00 18. " VG_21 ,Minor updates to VG pipe (Event generation from VG, TS, PE)." "0,1"
        textline "          "
        bitfld.long 0x00 19. " SHADER_GETS_W ,W is sent to SH from RA." "0,1"
        textline "          "
        bitfld.long 0x00 20. " EXTRA_SHADER_INSTRUCTIONS1 ,Sqrt, sin, cos intructions are available." "0,1"
        textline "          "
        bitfld.long 0x00 21. " DEFAULT_REG0 ,Unavailable registers will return 0." "0,1"
        textline "          "
        bitfld.long 0x00 22. " MC_20 ,New stlye MC with separate paths for color and depth." "0,1"
        textline "          "
        bitfld.long 0x00 23. " SHADER_MSAA_SIDEBAND ,Put the MSAA data into sideband fifo." "0,1"
        textline "          "
        bitfld.long 0x00 24. " BUG_FIXES0 ,Bug fixes bit 0" "0,1"
        textline "          "
        bitfld.long 0x00 25. " VAA ,VAA is available or not." "0,1"
        textline "          "
        bitfld.long 0x00 26. " BYPASS_IN_MSAA ,Shader supports bypass modew when MSAA is enabled." "0,1"
        textline "          "
        bitfld.long 0x00 27. " HIERARCHICAL_Z ,Hierarchical Z is supported." "0,1"
        textline "          "
        bitfld.long 0x00 28. " NEW_TEXTURE ,New texture unit is available." "0,1"
        textline "          "
        bitfld.long 0x00 29. " A8_TARGET_SUPPORT ,2D engine supports A8 target." "0,1"
        textline "          "
        bitfld.long 0x00 30. " CORRECT_STENCIL ,Correct stencil behavior in depth only." "0,1"
        textline "          "
        bitfld.long 0x00 31. " ENHANCE_VR ,Enhance VR and add a mode to walk 16 pixels in 16-bit mode in Vertical pass to improve $ hit rate when rotating 90/270." "0,1"
width 9.
group.long 0x38++0x3
    line.long 0x00 "GCC_CRTL,GCCacheControl"
        hexmask.long.long 0x00 0.--32. 1. " NOT_USED ,-"
width 13.
group.long 0x3c++0x3
    line.long 0x00 "GCR_MEM_CTRS,GCResetMemCounters"
        hexmask.long.long 0x00 0.--32. 1. " RESET ,Reset"
width 10.
rgroup.long 0x40++0x3
    line.long 0x00 "GCT_READS,gcTotalReads"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 11.
rgroup.long 0x44++0x3
    line.long 0x00 "GCT_WRITES,gcTotalWrites"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 10.
rgroup.long 0x48++0x3
    line.long 0x00 "GCC_SPECS,gcChipSpecs"
        hexmask.long.byte 0x00 0.--4. 1. " STREAMS ,Number of vertex streams."
        textline "         "
        hexmask.long.byte 0x00 4.--8. 1. " TEAMP_REGISTERS ,Log2 of temporary registers."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " THREAD_COUNT ,Log2 of thread count."
        textline "         "
        hexmask.long.byte 0x00 12.--17. 1. " VERTEX_CACHE_SIZE ,Number of entries in the vertex shader cache."
        textline "         "
        hexmask.long.byte 0x00 20.--25. 1. " NUM_SHADER_CORES ,Number of shader cores."
        textline "         "
        hexmask.long.byte 0x00 25.--28. 1. " NUM_PIXEL_PIPES ,Number of pixel pipes."
        textline "         "
        hexmask.long.byte 0x00 28.--32. 1. " VERTEX_OUTPUT_BUFFER_SIZE ,Log2 of vertex output buffer size."
width 17.
rgroup.long 0x4c++0x3
    line.long 0x00 "GCT_WRITE_BURSTS,gcTotalWriteBursts"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 15.
rgroup.long 0x50++0x3
    line.long 0x00 "GCT_WRITE_REQS,gcTotalWriteReqs"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 16.
rgroup.long 0x54++0x3
    line.long 0x00 "GCT_WRITE_LASTS,gcTotalWriteLasts"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 16.
rgroup.long 0x58++0x3
    line.long 0x00 "GCT_READ_BURSTS,gcTotalReadBursts"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 14.
rgroup.long 0x60++0x3
    line.long 0x00 "GCT_READ_REQS,gcTotalReadReqs"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 15.
rgroup.long 0x64++0x3
    line.long 0x00 "GCT_READ_LASTS,gcTotalReadLasts"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 8.
group.long 0x68++0x3
    line.long 0x00 "GCGPO_0,gcGpOut0"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 8.
group.long 0x6c++0x3
    line.long 0x00 "GCGPO_1,gcGpOut1"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 8.
group.long 0x70++0x3
    line.long 0x00 "GCGPO_2,gcGpOut2"
        hexmask.long.long 0x00 0.--32. 1. " COUNT ,Count"
width 9.
group.long 0x74++0x3
    line.long 0x00 "GCA_CRTL,gcAxiControl"
        bitfld.long 0x00 0. " WR_FULL_BURST_MODE ,-" "0,1"
width 11.
rgroup.long 0x78++0x3
    line.long 0x00 "GCM_FEAT_1,GCMinorFeatures1"
        bitfld.long 0x00 0. " RSUV_SWIZZLE ,Resolve UV swizzle." "0,1"
        textline "          "
        bitfld.long 0x00 1. " V2_COMPRESSION ,V2 compression." "0,1"
        textline "          "
        bitfld.long 0x00 2. " VG_DOUBLE_BUFFER ,Double buffering support for VG (second TS-->VG semaphore is present)." "0,1"
        textline "          "
        bitfld.long 0x00 3. " BUG_FIXES1 ,Bug fixes bit 1" "0,1"
        textline "          "
        bitfld.long 0x00 4. " BUG_FIXES2 ,Bug fixes bit 2" "0,1"
        textline "          "
        bitfld.long 0x00 5. " TEXTURE_STRIDE ,Texture has stride and memory addressing." "0,1"
width 11.
group.long 0x7c++0x3
    line.long 0x00 "GCT_CYCLES,gcTotalCycles"
        hexmask.long.long 0x00 0.--32. 1. " CYCLES ,Cycles"
width 16.
group.long 0x80++0x3
    line.long 0x00 "GCT_IDLE_CYCLES,gcTotalIdleCycles"
        hexmask.long.long 0x00 0.--32. 1. " CYCLES ,Cycles"


tree.end



;--------------------------------------------------------------------------------
; HDMI
;--------------------------------------------------------------------------------
tree "HDMI"
    base ad:0x00120000

width 10.
rgroup.byte 0x0++0x0
    line.byte 0x00 "DESIGN_ID,Design Identification Register"
        hexmask.byte.byte 0x00 0.--8. 1. " DESIGN_ID ,This is a 1 byte design ID code fixed by Freescale that Identifies the main revision of the HDMI TX controller."
width 12.
rgroup.byte 0x1++0x0
    line.byte 0x00 "REVISION_ID,Revision Identification Register"
        hexmask.byte.byte 0x00 0.--8. 1. " REVISION_ID ,This is a one byte revision ID code fixed by Freescale that Identifies the main revision of the HDMI TX controller."
width 12.
rgroup.byte 0x2++0x0
    line.byte 0x00 "PRODUCT_ID0,Product Identification Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " PRODUCT_ID0 ,This one byte fixed code Identifies Freescale's product line (""A0h"" for HDMI TX products)."
width 12.
rgroup.byte 0x3++0x0
    line.byte 0x00 "PRODUCT_ID1,Product Identification Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " PRODUCT_ID1 ,This one byte fixed code identifies Freescale's product line according to: 01h HDMI TX Controller 02h DWC_hdmi_rx Controller C1h HDMI TX Controller with HDCP encryption engine C2h DWC_hdmi_rx Controller with encryption engine"
width 11.
rgroup.byte 0x4++0x0
    line.byte 0x00 "CONFIG0_ID,Configuration Identification Register 0"
        bitfld.byte 0x00 0. " HDCP ,Indicates if HDCP is present" "0,1"
        textline "          "
        bitfld.byte 0x00 1. " CEC ,Indicates if CEC is present" "0,1"
        textline "          "
        bitfld.byte 0x00 2. " CSC ,Indicates if Color Space Conversion block is present" "0,1"
        textline "          "
        bitfld.byte 0x00 3. " HDMI14 ,Indicates if HDMI 1.4 features are present" "0,1"
        textline "          "
        bitfld.byte 0x00 4. " AUDI2S ,Indicates if I2S interface is present" "0,1"
        textline "          "
        bitfld.byte 0x00 5. " AUDSPDIF ,Indicates if SPDIF interface is present" "0,1"
        textline "          "
        bitfld.byte 0x00 6. " AUDHBR ,Indicates if HBR interface is present" "0,1"
        textline "          "
        bitfld.byte 0x00 7. " PREPEN ,Indicates if it is possible to use internal pixel repetition" "0,1"
width 11.
rgroup.byte 0x5++0x0
    line.byte 0x00 "CONFIG1_ID,Configuration Identification Register 1"
        bitfld.byte 0x00 0. " CONFAHB ,Indicates that configuration interface is AHB interface" "0,1"
        textline "          "
        bitfld.byte 0x00 1. " CONFAPB ,Indicates that configuration interface is APB interface" "0,1"
        textline "          "
        bitfld.byte 0x00 2. " CONFOCP ,Indicates that configuration interface is OCP interface" "0,1"
        textline "          "
        bitfld.byte 0x00 3. " CONFI2C ,Indicates that configuration interface is I2C interface" "0,1"
        textline "          "
        bitfld.byte 0x00 4. " CONFSFRDIR ,Indicates that configuration interface is SFR interface" "0,1"
width 11.
rgroup.byte 0x6++0x0
    line.byte 0x00 "CONFIG2_ID,Configuration Identification Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " PHYTYPE ,Indicates the type of PHY interface selected: 00h Legacy PHY (HDMI TX PHY) F2h PHY_Gen2 (HDMI 3D TX PHY) E2h PHY_Gen2 (HDMI 3D TX PHY) + HEAC PHY"
width 11.
rgroup.byte 0x7++0x0
    line.byte 0x00 "CONFIG3_ID,Configuration Identification Register 3"
        bitfld.byte 0x00 0. " CONFGPAUD ,Indicates that configuration interface is Generic Parallel Audio (GPAUD) interface" "0,1"
width 12.
group.byte 0x100++0x0
    line.byte 0x00 "IH_FC_STAT0,Frame Composer Interrupt Status Register 0"
        bitfld.byte 0x00 0. " NULL_ ,Active after successful transmission of an Null packet." "0,1"
        textline "           "
        bitfld.byte 0x00 1. " ACR ,Active after successful transmission of an Audio Clock Regeneration (N/CTS transmission) packet." "0,1"
        textline "           "
        bitfld.byte 0x00 2. " AUDS ,Active after successful transmission of an Audio Sample packet." "0,1"
        textline "           "
        bitfld.byte 0x00 3. " OBA ,Reserved" "0,1"
        textline "           "
        bitfld.byte 0x00 4. " DST ,Reserved" "0,1"
        textline "           "
        bitfld.byte 0x00 5. " HBR ,Active after successful transmission of an Audio HBR packet." "0,1"
        textline "           "
        bitfld.byte 0x00 6. " ACP ,Active after successful transmission of an Audio Content Protection packet." "0,1"
        textline "           "
        bitfld.byte 0x00 7. " AUDI ,Active after successful transmission of an Audio InfoFrame packet." "0,1"
width 12.
group.byte 0x101++0x0
    line.byte 0x00 "IH_FC_STAT1,Frame Composer Interrupt Status Register 1"
        bitfld.byte 0x00 0. " GCP ,Active after successful transmission of an General Control Packet." "0,1"
        textline "           "
        bitfld.byte 0x00 1. " AVI ,Active after successful transmission of an AVI infoFrame packet." "0,1"
        textline "           "
        bitfld.byte 0x00 2. " MPEG ,Reserved" "0,1"
        textline "           "
        bitfld.byte 0x00 3. " SPD ,Active after successful transmission of an Source Product Descriptor infoFrame packet." "0,1"
        textline "           "
        bitfld.byte 0x00 4. " VSD ,Active after successful transmission of an Vendor Specific Data infoFrame packet." "0,1"
        textline "           "
        bitfld.byte 0x00 5. " ISCR2 ,Active after successful transmission of an International Standard Recording Code 2 packet." "0,1"
        textline "           "
        bitfld.byte 0x00 6. " ISCR1 ,Active after successful transmission of an International Standard Recording Code 1 packet." "0,1"
        textline "           "
        bitfld.byte 0x00 7. " GMD ,Active after successful transmission of an Gamut metadata packet." "0,1"
width 12.
group.byte 0x102++0x0
    line.byte 0x00 "IH_FC_STAT2,Frame Composer Interrupt Status Register 2"
        bitfld.byte 0x00 0. " HIGHPRIORITY_OVERFLOW ,Frame Composer high priority packet queue descriptor overflow indication." "0,1"
        textline "           "
        bitfld.byte 0x00 1. " LOWPRIORITY_OVERFLOW ,Frame Composer low priority packet queue descriptor overflow indication." "0,1"
width 12.
group.byte 0x103++0x0
    line.byte 0x00 "IH_AS_STAT0,Audio Sampler Interrupt Status Register"
        bitfld.byte 0x00 0. " AUD_FIFO_OVERFLOW ,Audio Sampler audio FIFO full indication." "0,1"
        textline "           "
        bitfld.byte 0x00 1. " AUD_FIFO_UNDERFLOW ,Audio Sampler audio FIFO empty indication." "0,1"
        textline "           "
        bitfld.byte 0x00 2. " AUD_FIFO_UNDERFLOW_THR ,Audio Sampler audio FIFO empty threshold (four samples) indication." "0,1"
width 13.
group.byte 0x104++0x0
    line.byte 0x00 "IH_PHY_STAT0,PHY Interface Interrupt Status Register"
        bitfld.byte 0x00 0. " HDP ,HDMI Hot Plug Detect indication." "0,1"
        textline "            "
        bitfld.byte 0x00 1. " TX_PHY_LOCK ,TX PHY PLL lock indication." "0,1"
        textline "            "
        bitfld.byte 0x00 2. " RX_SENSE ,TX PHY RX_SENSE indication for driver 0." "0,1"
        textline "            "
        bitfld.byte 0x00 3. " RX_SENSE1 ,TX PHY RX_SENSE indication for driver 1." "0,1"
        textline "            "
        bitfld.byte 0x00 4. " RX_SENSE2 ,TX PHY RX_SENSE indication for driver 2." "0,1"
        textline "            "
        bitfld.byte 0x00 5. " RX_SENSE3 ,TX PHY RX_SENSE indication for driver 3." "0,1"
width 14.
group.byte 0x105++0x0
    line.byte 0x00 "IH_I2CM_STAT0,E-DDC I2C Master Interrupt Status Register"
        bitfld.byte 0x00 0. " I2CMASTER_ERROR ,I2C Master error indication" "0,1"
        textline "             "
        bitfld.byte 0x00 1. " I2CMASTERDONE ,I2C Master done indication" "0,1"
width 13.
group.byte 0x106++0x0
    line.byte 0x00 "IH_CEC_STAT0,CEC Interrupt Status Register"
        bitfld.byte 0x00 0. " DONE ,CEC Done Indication" "0,1"
        textline "            "
        bitfld.byte 0x00 1. " EOM ,CEC End of Message Indication" "0,1"
        textline "            "
        bitfld.byte 0x00 2. " NACK ,CEC Nack indication" "0,1"
        textline "            "
        bitfld.byte 0x00 3. " ARB_LOST ,CEC Arb_Lost indication" "0,1"
        textline "            "
        bitfld.byte 0x00 4. " ERROR_INITIATOR ,CEC Error_follow indication" "0,1"
        textline "            "
        bitfld.byte 0x00 5. " ERROR_FOLLOW ,CEC Error_follow indication" "0,1"
        textline "            "
        bitfld.byte 0x00 6. " WAKEUP ,CEC Wake-up indication" "0,1"
width 12.
group.byte 0x107++0x0
    line.byte 0x00 "IH_VP_STAT0,Video Packetizer Interrupt Status Register"
        bitfld.byte 0x00 0. " FIFOEMPTYBYP ,Video packetizer 8-bit bypass fifo empty interrupt" "0,1"
        textline "           "
        bitfld.byte 0x00 1. " FIFOFULLBYP ,Video packetizer 8-bit bypass fifo full interrupt" "0,1"
        textline "           "
        bitfld.byte 0x00 2. " FIFOEMPTYREMAP ,Video packetizer pixel YCC 422 re-mapper FIFO empty interrupt" "0,1"
        textline "           "
        bitfld.byte 0x00 3. " FIFOFULLREMAP ,Video packetizer pixel YCC 422 re-mapper FIFO full interrupt" "0,1"
        textline "           "
        bitfld.byte 0x00 4. " FIFOEMPTYPP ,Video packetizer pixel packing FIFO empty interrupt" "0,1"
        textline "           "
        bitfld.byte 0x00 5. " FIFOFULLPP ,Video packetizer pixel packing FIFO full interrupt" "0,1"
        textline "           "
        bitfld.byte 0x00 6. " FIFOEMPTYREPET ,Video packetizer pixel repeater FIFO empty interrupt" "0,1"
        textline "           "
        bitfld.byte 0x00 7. " FIFOFULLREPET ,Video packetizer pixel repeater FIFO full interrupt" "0,1"
width 17.
group.byte 0x108++0x0
    line.byte 0x00 "IH_I2CMPHY_STAT0,PHY GEN2 I2C Master Interrupt Status Register"
        bitfld.byte 0x00 0. " I2CMPHYERROR ,I2C Master PHY error indication" "0,1"
        textline "                "
        bitfld.byte 0x00 1. " I2CMPHYDONE ,I2C Master PHY done indication" "0,1"
width 19.
group.byte 0x109++0x0
    line.byte 0x00 "IH_AHBDMAAUD_STAT0,AHB Audio DMA Interrupt Status Register"
        bitfld.byte 0x00 0. " AHBDMAAUD_INTBUFFEMPTY ,AHB audio DMA Buffer empty interrupt" "0,1"
        textline "                  "
        bitfld.byte 0x00 1. " AHBDMAAUD_INTBUFFFULL ,AHB audio DMA Buffer full interrupt" "0,1"
        textline "                  "
        bitfld.byte 0x00 2. " AHBDMAAUD_INTDONE ,AHB audio DMA done interrupt" "0,1"
        textline "                  "
        bitfld.byte 0x00 3. " AHBDMAAUD_INTRETRYSPLIT ,AHB audio DMA RETRY/SPLIT interrupt" "0,1"
        textline "                  "
        bitfld.byte 0x00 4. " AHBDMAAUD_INTLOSTOWNERSHIP ,AHB audio DMA lost ownership interrupt" "0,1"
        textline "                  "
        bitfld.byte 0x00 5. " AHBDMAAUD_INTERROR ,AHB audio DMA error interrupt" "0,1"
width 17.
group.byte 0x180++0x0
    line.byte 0x00 "IH_MUTE_FC_STAT0,Frame Composer Interrupt Mute Control Register 0"
        bitfld.byte 0x00 0. " NULL_ ,When set to 1, mutes IH_ FC_STAT0[0]" "0,1"
        textline "                "
        bitfld.byte 0x00 1. " ACR ,When set to 1, mutes IH_ FC_STAT0[1]" "0,1"
        textline "                "
        bitfld.byte 0x00 2. " AUDS ,When set to 1, mutes IH_ FC_STAT0[2]" "0,1"
        textline "                "
        bitfld.byte 0x00 3. " OBA ,When set to 1, mutes IH_ FC_STAT0[3]" "0,1"
        textline "                "
        bitfld.byte 0x00 4. " DST ,When set to 1, mutes IH_ FC_STAT0[4]" "0,1"
        textline "                "
        bitfld.byte 0x00 5. " HBR ,When set to 1, mutes IH_ FC_STAT0[5]" "0,1"
        textline "                "
        bitfld.byte 0x00 6. " ACP ,When set to 1, mutes IH_ FC_STAT0[6]" "0,1"
        textline "                "
        bitfld.byte 0x00 7. " AUDI ,When set to 1, mutes IH_ FC_STAT0[7]" "0,1"
width 17.
group.byte 0x181++0x0
    line.byte 0x00 "IH_MUTE_FC_STAT1,Frame Composer Interrupt Mute Control Register 1"
        bitfld.byte 0x00 0. " GCP ,When set to 1, mutes IH_ FC_STAT1[0]" "0,1"
        textline "                "
        bitfld.byte 0x00 1. " AVI ,When set to 1, mutes IH_ FC_STAT1[1]" "0,1"
        textline "                "
        bitfld.byte 0x00 2. " MPEG ,When set to 1, mutes IH_ FC_STAT1[2]" "0,1"
        textline "                "
        bitfld.byte 0x00 3. " SPD ,When set to 1, mutes IH_ FC_STAT1[3]" "0,1"
        textline "                "
        bitfld.byte 0x00 4. " VSD ,When set to 1, mutes IH_ FC_STAT1[4]" "0,1"
        textline "                "
        bitfld.byte 0x00 5. " ISCR2 ,When set to 1, mutes IH_ FC_STAT1[5]" "0,1"
        textline "                "
        bitfld.byte 0x00 6. " ISCR1 ,When set to 1, mutes IH_ FC_STAT1[6]" "0,1"
        textline "                "
        bitfld.byte 0x00 7. " GMD ,When set to 1, mutes IH_ FC_STAT1[7]" "0,1"
width 17.
group.byte 0x182++0x0
    line.byte 0x00 "IH_MUTE_FC_STAT2,Frame Composer Interrupt Mute Control Register 2"
        bitfld.byte 0x00 0. " HIGHPRIORITY_OVERFLOW ,When set to 1, mutes IH_ FC_STAT2[0]" "0,1"
        textline "                "
        bitfld.byte 0x00 1. " LOWPRIORITY_OVERFLOW ,When set to 1, mutes IH_ FC_STAT2[1]" "0,1"
width 17.
group.byte 0x183++0x0
    line.byte 0x00 "IH_MUTE_AS_STAT0,Audio Sampler Interrupt Mute Control Register 0"
        bitfld.byte 0x00 0. " AUD_FIFO_OVERFLOW ,When set to 1, mutes IH_ AS_STAT0[0]" "0,1"
        textline "                "
        bitfld.byte 0x00 1. " AUD_FIFO_UNDERFLOW ,When set to 1, mutes IH_ AS_STAT0[1]" "0,1"
        textline "                "
        bitfld.byte 0x00 2. " AUD_FIFO_UNDERFLOW_THR ,When set to 1, mutes IH_ AS_STAT0[2]" "0,1"
width 18.
group.byte 0x184++0x0
    line.byte 0x00 "IH_MUTE_PHY_STAT0,PHY Interface Interrupt Mute Control Register"
        bitfld.byte 0x00 0. " HDP ,When set to 1, mutes IH_ PHY_STAT0[0]" "0,1"
        textline "                 "
        bitfld.byte 0x00 1. " TX_PHY_LOCK ,When set to 1, mutes IH_ PHY_STAT0[1]" "0,1"
        textline "                 "
        bitfld.byte 0x00 2. " RX_SENSE ,When set to 1, mutes IH_ PHY_STAT0[2]" "0,1"
        textline "                 "
        bitfld.byte 0x00 3. " RX_SENSE1 ,When set to 1, mutes IH_ PHY_STAT0[3]" "0,1"
        textline "                 "
        bitfld.byte 0x00 4. " RX_SENSE2 ,When set to 1, mutes IH_ PHY_STAT0[4]" "0,1"
        textline "                 "
        bitfld.byte 0x00 5. " RX_SENSE3 ,When set to 1, mutes IH_ PHY_STAT0[5]" "0,1"
width 19.
group.byte 0x185++0x0
    line.byte 0x00 "IH_MUTE_I2CM_STAT0,E-DDC I2C Master Interrupt Mute Control Register"
        bitfld.byte 0x00 0. " I2CMASTER_ERROR ,When set to 1, mutes IH_ I2CM_STAT0[0]" "0,1"
        textline "                  "
        bitfld.byte 0x00 1. " I2CMASTERDONE ,When set to 1, mutes IH_ I2CM_STAT0[1]" "0,1"
width 18.
group.byte 0x186++0x0
    line.byte 0x00 "IH_MUTE_CEC_STAT0,CEC Interrupt Mute Control Register"
        bitfld.byte 0x00 0. " DONE ,When set to 1, mutes IH_ CEC_STAT0[0]" "0,1"
        textline "                 "
        bitfld.byte 0x00 1. " EOM ,When set to 1, mutes IH_ CEC_STAT0[1]" "0,1"
        textline "                 "
        bitfld.byte 0x00 2. " NACK ,When set to 1, mutes IH_ CEC_STAT0[2]" "0,1"
        textline "                 "
        bitfld.byte 0x00 3. " ARB_LOST ,When set to 1, mutes IH_ CEC_STAT0[3]" "0,1"
        textline "                 "
        bitfld.byte 0x00 4. " ERROR_INITIATOR ,When set to 1, mutes IH_ CEC_STAT0[4]" "0,1"
        textline "                 "
        bitfld.byte 0x00 5. " ERROR_FOLLOW ,When set to 1, mutes IH_ CEC_STAT0[5]" "0,1"
        textline "                 "
        bitfld.byte 0x00 6. " WAKEUP ,When set to 1, mutes IH_ CEC_STAT0[6]" "0,1"
width 17.
group.byte 0x187++0x0
    line.byte 0x00 "IH_MUTE_VP_STAT0,Video Packetizer Interrupt Mute Control Register"
        bitfld.byte 0x00 0. " FIFOEMPTYBYP ,When set to 1, mutes IH_ VP_STAT0[0]" "0,1"
        textline "                "
        bitfld.byte 0x00 1. " FIFOFULLBYP ,When set to 1, mutes IH_ VP_STAT0[1]" "0,1"
        textline "                "
        bitfld.byte 0x00 2. " FIFOEMPTYREMAP ,When set to 1, mutes IH_ VP_STAT0[2]" "0,1"
        textline "                "
        bitfld.byte 0x00 3. " FIFOFULLREMAP ,When set to 1, mutes IH_ VP_STAT0[3]" "0,1"
        textline "                "
        bitfld.byte 0x00 4. " FIFOEMPTYPP ,When set to 1, mutes IH_ VP_STAT0[4]" "0,1"
        textline "                "
        bitfld.byte 0x00 5. " FIFOFULLPP ,When set to 1, mutes IH_ VP_STAT0[5]" "0,1"
        textline "                "
        bitfld.byte 0x00 6. " FIFOEMPTYREPET ,When set to 1, mutes IH_ VP_STAT0[6]" "0,1"
        textline "                "
        bitfld.byte 0x00 7. " FIFOFULLREPET ,When set to 1, mutes IH_ VP_STAT0[7]" "0,1"
width 22.
group.byte 0x188++0x0
    line.byte 0x00 "IH_MUTE_I2CMPHY_STAT0,PHY GEN 2 I2C Master Interrupt Mute Control Register"
        bitfld.byte 0x00 0. " I2CMPHYERROR ,When set to 1, mutes IH_ I2CMPHY_STAT0[0]" "0,1"
        textline "                     "
        bitfld.byte 0x00 1. " I2CMPHYDONE ,When set to 1, mutes IH_ I2CMPHY_STAT0[1]" "0,1"
width 24.
group.byte 0x189++0x0
    line.byte 0x00 "IH_MUTE_AHBDMAAUD_STAT0,AHB Audio DMA Interrupt Mute Control Register"
        bitfld.byte 0x00 0. " AHBDMAAUD_INTBUFFEMPTY ,When set to 1, mutes IH_AHBDMAAUD_STAT0[0]" "0,1"
        textline "                       "
        bitfld.byte 0x00 1. " AHBDMAAUD_INTBUFFFULL ,When set to 1, mutes IH_AHBDMAAUD_STAT0[1]" "0,1"
        textline "                       "
        bitfld.byte 0x00 2. " AHBDMAAUD_INTDONE ,When set to 1, mutes IH_AHBDMAAUD_STAT0[2]" "0,1"
        textline "                       "
        bitfld.byte 0x00 3. " AHBDMAAUD_INTRETRYSPLIT ,When set to 1, mutes IH_AHBDMAAUD_STAT0[3]" "0,1"
        textline "                       "
        bitfld.byte 0x00 4. " AHBDMAAUD_INTLOSTOWNERSHIP ,When set to 1, mutes IH_AHBDMAAUD_STAT0[4]" "0,1"
        textline "                       "
        bitfld.byte 0x00 5. " AHBDMAAUD_INTERROR ,When set to 1, mutes IH_AHBDMAAUD_STAT0[5]" "0,1"
width 8.
group.byte 0x1ff++0x0
    line.byte 0x00 "IH_MUTE,Global Interrupt Mute Control Register"
        bitfld.byte 0x00 0. " AHBDMAAUD_INTBUFFEMPTY ,When set to 1, mutes IH_AHBDMAAUD_STAT0[0]" "0,1"
        textline "       "
        bitfld.byte 0x00 1. " AHBDMAAUD_INTBUFFFULL ,When set to 1, mutes IH_AHBDMAAUD_STAT0[1]" "0,1"
        textline "       "
        bitfld.byte 0x00 2. " AHBDMAAUD_INTDONE ,When set to 1, mutes IH_AHBDMAAUD_STAT0[2]" "0,1"
        textline "       "
        bitfld.byte 0x00 3. " AHBDMAAUD_INTRETRYSPLIT ,When set to 1, mutes IH_AHBDMAAUD_STAT0[3]" "0,1"
        textline "       "
        bitfld.byte 0x00 4. " AHBDMAAUD_INTLOSTOWNERSHIP ,When set to 1, mutes IH_AHBDMAAUD_STAT0[4]" "0,1"
        textline "       "
        bitfld.byte 0x00 5. " AHBDMAAUD_INTERROR ,When set to 1, mutes IH_AHBDMAAUD_STAT0[5]" "0,1"
width 10.
group.byte 0x200++0x0
    line.byte 0x00 "TX_INVID0,Video Input Mapping and Internal Data Enable Configuration Register"
        hexmask.byte.byte 0x00 0.--5. 1. " VIDEO_MAPPING ,video_mapping"
        textline "         "
        bitfld.byte 0x00 7. " INTERNAL_DE_GENERATOR ,Internal data enable (DE) generator enable." "0,1"
width 14.
group.byte 0x201++0x0
    line.byte 0x00 "TX_INSTUFFING,Video Input Stuffing Enable Register"
        bitfld.byte 0x00 0. " GYDATA_STUFFING ," "0,1"
        textline "             "
        bitfld.byte 0x00 1. " RCRDATA_STUFFING ," "0,1"
        textline "             "
        bitfld.byte 0x00 2. " BCBDATA_STUFFING ," "0,1"
width 11.
group.byte 0x202++0x0
    line.byte 0x00 "TX_GYDATA0,Video Input GY Data Channel Stuffing Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " GYDATA ,gydata[7:0].This register defines the value of gydata[7:0] when TX_INSTUFFING[0] (gydata_stuffing) is set to 1b."
width 11.
group.byte 0x203++0x0
    line.byte 0x00 "TX_GYDATA1,Video Input GY Data Channel Stuffing Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " GYDATA ,gydata[15:8].This register defines the value of gydata[15:8] when TX_INSTUFFING[0] (gydata_stuffing) is set to 1b."
width 12.
group.byte 0x204++0x0
    line.byte 0x00 "TX_RCRDATA0,Video Input RCR Data Channel Stuffing Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " RCRDATA ,rcrdata[7:0]."
width 12.
group.byte 0x205++0x0
    line.byte 0x00 "TX_RCRDATA1,Video Input RCR Data Channel Stuffing Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " RCRDATA ,rcrdata[15:8]."
width 12.
group.byte 0x206++0x0
    line.byte 0x00 "TX_BCBDATA0,Video Input RCB Data Channel Stuffing Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " BCBDATA ,bcbdata[7:0]."
width 12.
group.byte 0x207++0x0
    line.byte 0x00 "TX_BCBDATA1,Video Input RCB Data Channel Stuffing Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " BCBDATA ,bcbdata[15:8]."
width 10.
rgroup.byte 0x800++0x0
    line.byte 0x00 "VP_STATUS,Video Packetizer Packing Phase Status Register"
        hexmask.byte.byte 0x00 0.--4. 1. " PACKING_PHASE ,Read only register that holds the ""packing phase"" output by the Video packetizer block."
width 9.
group.byte 0x801++0x0
    line.byte 0x00 "VP_PR_CD,Video Packetizer Pixel Repetition and Color Depth Register"
        hexmask.byte.byte 0x00 0.--4. 1. " DESIRED_PR_FACTOR ,Desired pixel repetition factor configuration."
        textline "        "
        hexmask.byte.byte 0x00 4.--8. 1. " COLOR_DEPTH ,Color depth configuration: other Reserved."
width 9.
group.byte 0x802++0x0
    line.byte 0x00 "VP_STUFF,Video Packetizer Stuffing and Default Packing Phase Register"
        bitfld.byte 0x00 0. " PR_STUFFING ,Pixel repeater stuffing control" "0,1"
        textline "        "
        bitfld.byte 0x00 1. " PP_STUFFING ,Pixel packing stuffing control" "0,1"
        textline "        "
        bitfld.byte 0x00 2. " YCC422_STUFFING ,YCC 422 remap stuffing control." "0,1"
        textline "        "
        bitfld.byte 0x00 3. " ICX_GOTO_P0_ST ,Reserved." "0,1"
        textline "        "
        bitfld.byte 0x00 4. " IFIX_PP_TO_LAST ,Reserved." "0,1"
        textline "        "
        bitfld.byte 0x00 5. " IDEFAULT_PHASE ,Controls the default phase packing machine used according to: ""If the transmitted video format has timing such that the phase of the first pixel of every Video Data Period corresponds to pixel packing phase 0 (for example, 10P0, 12P0, 16P0), the Source may set the Default_Phase bit in the GCP." "0,1"
width 9.
group.byte 0x803++0x0
    line.byte 0x00 "VP_REMAP,Video Packetizer YCC422 Remapping Register"
        hexmask.byte.byte 0x00 0.--2. 1. " YCC422_SIZE ,YCC 422 remap input video size:"
width 8.
group.byte 0x804++0x0
    line.byte 0x00 "VP_CONF,Video Packetizer Output, Bypass, and Enable Configuration Register"
        hexmask.byte.byte 0x00 0.--2. 1. " OUTPUT_SELECTOR ,Video packetizer output selection."
        textline "       "
        bitfld.byte 0x00 2. " BYPASS_SELECT ," "0,1"
        textline "       "
        bitfld.byte 0x00 3. " YCC422_EN ,YCC 422 select enable." "0,1"
        textline "       "
        bitfld.byte 0x00 4. " PR_EN ,Pixel repeater enable." "0,1"
        textline "       "
        bitfld.byte 0x00 5. " PP_EN ,Pixel packing enable." "0,1"
        textline "       "
        bitfld.byte 0x00 6. " BYPASS_EN ,Bypass enable." "0,1"
width 8.
group.byte 0x807++0x0
    line.byte 0x00 "VP_MASK,Video Packetizer Interrupt Mask Register"
        bitfld.byte 0x00 0. " VPMASK ,Mask bit for VP_INT[0] interrupt bit." "0,1"
        textline "       "
        bitfld.byte 0x00 1. " VPMASK1 ,Mask bit for VP_INT[1] interrupt bit." "0,1"
        textline "       "
        bitfld.byte 0x00 2. " VPMASK2 ,Mask bit for VP_INT[2] interrupt bit." "0,1"
        textline "       "
        bitfld.byte 0x00 3. " VPMASK3 ,Mask bit for VP_INT[3] interrupt bit." "0,1"
        textline "       "
        bitfld.byte 0x00 4. " VPMASK4 ,Mask bit for VP_INT[4] interrupt bit." "0,1"
        textline "       "
        bitfld.byte 0x00 5. " VPMASK5 ,Mask bit for VP_INT[5] interrupt bit." "0,1"
        textline "       "
        bitfld.byte 0x00 6. " VPMASK6 ,Mask bit for VP_INT[6] interrupt bit." "0,1"
        textline "       "
        bitfld.byte 0x00 7. " VPMASK7 ,Mask bit for VP_INT[7] interrupt bit." "0,1"
width 13.
group.byte 0x1000++0x0
    line.byte 0x00 "FC_INVIDCONF,Frame Composer Input Video Configuration and HDCP Keepout Register"
        bitfld.byte 0x00 0. " IN_I_P ,Input video mode:" "0,1"
        textline "            "
        bitfld.byte 0x00 1. " R_V_BLANK_IN_OSC ,Used for CEA861-D modes with fractional Vblank (for example, modes 5, 6, 7, 10, 11, 20, 21, and 22." "0,1"
        textline "            "
        bitfld.byte 0x00 3. " DVI_MODEZ ,Active low" "0,1"
        textline "            "
        bitfld.byte 0x00 4. " DE_IN_POLARITY ,Data enable input polarity" "0,1"
        textline "            "
        bitfld.byte 0x00 5. " HSYNC_IN_POLARITY ,Hsync input polarity" "0,1"
        textline "            "
        bitfld.byte 0x00 6. " VSYNC_IN_POLARITY ,Vsync input polarity" "0,1"
        textline "            "
        bitfld.byte 0x00 7. " HDCP_KEEPOUT ,Start/stop HDCP keepout window generation" "0,1"
width 13.
group.byte 0x1001++0x0
    line.byte 0x00 "FC_INHACTIV0,Frame Composer Input Video HActive Pixels Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " H_IN_ACTIV ,Input video Horizontal active pixel region width."
width 13.
group.byte 0x1002++0x0
    line.byte 0x00 "FC_INHACTIV1,Frame Composer Input Video HActive Pixels Register 1"
        hexmask.byte.byte 0x00 0.--5. 1. " H_IN_ACTIV ,Input video Horizontal active pixel region width."
width 13.
group.byte 0x1003++0x0
    line.byte 0x00 "FC_INHBLANK0,Frame Composer Input Video HBlank Pixels Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " H_IN_BLANK ,Input video Horizontal blanking pixel region width."
width 13.
group.byte 0x1004++0x0
    line.byte 0x00 "FC_INHBLANK1,Frame Composer Input Video HBlank Pixels Register 1"
        hexmask.byte.byte 0x00 0.--5. 1. " H_IN_BLANK ,Input video Horizontal blanking pixel region width."
width 13.
group.byte 0x1005++0x0
    line.byte 0x00 "FC_INVACTIV0,Frame Composer Input Video VActive Pixels Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " V_IN_ACTIV ,Input video Vertical active pixel region width."
width 13.
group.byte 0x1006++0x0
    line.byte 0x00 "FC_INVACTIV1,Frame Composer Input Video VActive Pixels Register 1"
        hexmask.byte.byte 0x00 0.--5. 1. " V_IN_ACTIV ,Input video Vertical active pixel region width."
width 12.
group.byte 0x1007++0x0
    line.byte 0x00 "FC_INVBLANK,Frame Composer Input Video VBlank Pixels Register"
        hexmask.byte.byte 0x00 0.--8. 1. " V_IN_BLANK ,Input video Vertical blanking pixel region width."
width 17.
group.byte 0x1008++0x0
    line.byte 0x00 "FC_HSYNCINDELAY0,Frame Composer Input Video HSync Front Porch Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " H_IN_DELAY ,Input video Hsync active edge delay."
width 17.
group.byte 0x1009++0x0
    line.byte 0x00 "FC_HSYNCINDELAY1,Frame Composer Input Video HSync Front Porch Register 1"
        hexmask.byte.byte 0x00 0.--5. 1. " H_IN_DELAY ,Input video Hsync active edge delay."
width 17.
group.byte 0x100a++0x0
    line.byte 0x00 "FC_HSYNCINWIDTH0,Frame Composer Input Video HSync Width Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " H_IN_WIDTH ,Input video Hsync active pulse width."
width 17.
group.byte 0x100b++0x0
    line.byte 0x00 "FC_HSYNCINWIDTH1,Frame Composer Input Video HSync Width Register 1"
        hexmask.byte.byte 0x00 0.--2. 1. " H_IN_WIDTH ,Input video Hsync active pulse width."
width 16.
group.byte 0x100c++0x0
    line.byte 0x00 "FC_VSYNCINDELAY,Frame Composer Input Video VSync Front Porch Register"
        hexmask.byte.byte 0x00 0.--8. 1. " V_IN_DELAY ,Input video Vsync active edge delay."
width 16.
group.byte 0x100d++0x0
    line.byte 0x00 "FC_VSYNCINWIDTH,Frame Composer Input Video VSync Width Register"
        hexmask.byte.byte 0x00 0.--6. 1. " V_IN_WIDTH ,Value after Reset: 000000b Input video Vsync active pulse width: Integer number of pixel clock cycles [0...63]."
width 11.
group.byte 0x100e++0x0
    line.byte 0x00 "FC_INFREQ0,Frame Composer Input Video Refresh Rate Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " INFREQ ,Video refresh rate in Hz*1E3 format."
width 11.
group.byte 0x100f++0x0
    line.byte 0x00 "FC_INFREQ1,Frame Composer Input Video Refresh Rate Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " INFREQ ,Video refresh rate in Hz*1E3 format."
width 11.
group.byte 0x1010++0x0
    line.byte 0x00 "FC_INFREQ2,Frame Composer Input Video Refresh Rate Register 2"
        hexmask.byte.byte 0x00 0.--4. 1. " INFREQ ,Video refresh rate in Hz*1E3 format."
width 11.
group.byte 0x1011++0x0
    line.byte 0x00 "FC_CTRLDUR,Frame Composer Control Period Duration Register"
        hexmask.byte.byte 0x00 0.--8. 1. " CTRLPERIODDURATION ,Configuration of the control period minimum duration (min."
width 13.
group.byte 0x1012++0x0
    line.byte 0x00 "FC_EXCTRLDUR,Frame Composer Extended Control Period Duration Register"
        hexmask.byte.byte 0x00 0.--8. 1. " EXCTRLPERIODDURATION ,Configuration of the extended control period minimum duration (min."
width 14.
group.byte 0x1013++0x0
    line.byte 0x00 "FC_EXCTRLSPAC,Frame Composer Extended Control Period Maximum Spacing Register"
        hexmask.byte.byte 0x00 0.--8. 1. " EXCTRLPERIODSPACING ,Configuration of the maximum spacing between consecutive extended control periods (max of 50msec, see HDMI 1.4a specification): generated spacing = (1/freq tmds clock)*256*256*extctrlperiodspacing"
width 12.
group.byte 0x1014++0x0
    line.byte 0x00 "FC_CH0PREAM,Frame Composer Channel 0 Non-Preamble Data Register"
        hexmask.byte.byte 0x00 0.--8. 1. " CH0_PREAMBLE_FILTER ,When in control mode, configures 8-bits that are going to fill the channel 0 data lines not used to transmit the preamble (for more clarifications refer to HDMI 1.4a specification)."
width 12.
group.byte 0x1015++0x0
    line.byte 0x00 "FC_CH1PREAM,Frame Composer Channel 1 Non-Preamble Data Register"
        hexmask.byte.byte 0x00 0.--6. 1. " CH1_PREAMBLE_FILTER ,When in control mode, configures 6-bits that are going to fill the channel 1 data lines not used to transmit the preamble (for more clarifications refer to HDMI 1.4a specification)."
width 12.
group.byte 0x1016++0x0
    line.byte 0x00 "FC_CH2PREAM,Frame Composer Channel 2 Non-Preamble Data Register"
        hexmask.byte.byte 0x00 0.--6. 1. " CH2_PREAMBLE_FILTER ,When in control mode, configures 6-bits that are going to fill the channel 2 data lines not used to transmit the preamble (for more clarifications, see HDMI 1.4a specification)."
width 12.
group.byte 0x1017++0x0
    line.byte 0x00 "FC_AVICONF3,Frame Composer AVI Configuration Register 3"
        hexmask.byte.byte 0x00 0.--2. 1. " CN1 ,IT content type according to CEA specification"
        textline "           "
        hexmask.byte.byte 0x00 2.--4. 1. " YQ1 ,Quantization range according to CEA specification."
width 7.
group.byte 0x1018++0x0
    line.byte 0x00 "FC_GCP,Frame Composer GCP Packet Configuration Register"
        bitfld.byte 0x00 0. " CLEAR_AVMUTE ,Value of ""clear_avmute"" in the GCP packet." "0,1"
        textline "      "
        bitfld.byte 0x00 1. " SET_AVMUTE ,Value of ""set_avmute"" in the GCP packet." "0,1"
        textline "      "
        bitfld.byte 0x00 2. " DEFAULT_PHASE ,Value of ""default_phase"" in the GCP packet." "0,1"
width 12.
group.byte 0x1019++0x0
    line.byte 0x00 "FC_AVICONF0,Frame Composer AVI Packet Configuration Register 0"
        hexmask.byte.byte 0x00 0.--2. 1. " FC_AVICONF0 ,RGB/YCC indication Value after Reset: 0b"
        textline "           "
        hexmask.byte.byte 0x00 2.--4. 1. " FC_AVICONF01 ,Bar information"
        textline "           "
        hexmask.byte.byte 0x00 4.--6. 1. " FC_AVICONF02 ,Scan information"
        textline "           "
        bitfld.byte 0x00 6. " FC_AVICONF03 ,Active format present" "0,1"
        textline "           "
        bitfld.byte 0x00 7. " FC_AVICONF04 ," "0,1"
width 12.
group.byte 0x101a++0x0
    line.byte 0x00 "FC_AVICONF1,Frame Composer AVI Packet Configuration Register 1"
        hexmask.byte.byte 0x00 0.--4. 1. " FC_AVICONF1 ,Active aspect ratio Value after Reset: 0b"
        textline "           "
        hexmask.byte.byte 0x00 4.--6. 1. " FC_AVICONF11 ,Picture aspect ratio"
        textline "           "
        hexmask.byte.byte 0x00 6.--8. 1. " FC_AVICONF0 ,Colorimetry"
width 12.
group.byte 0x101b++0x0
    line.byte 0x00 "FC_AVICONF2,FC_AVICONFFrame Composer AVI Packet Configuration Register 2"
        hexmask.byte.byte 0x00 0.--2. 1. " FC_AVICONF2 ,Non-uniform picture scaling Value after Reset: 0b"
        textline "           "
        hexmask.byte.byte 0x00 4.--7. 1. " FC_AVICONF21 ,Extended colorimetry"
        textline "           "
        bitfld.byte 0x00 7. " FC_AVICONF22 ,IT content" "0,1"
width 10.
group.byte 0x101c++0x0
    line.byte 0x00 "FC_AVIVID,Frame Composer AVI Packet VIC Register"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_AVIVID ,the AVI infoFrame Video Identification code."
width 11.
group.byte 0x101d++0x0
    line.byte 0x00 "FC_AVIETB0,Frame Composer AVI Packet End of Top Bar Register 0"
width 11.
group.byte 0x101e++0x0
    line.byte 0x00 "FC_AVIETB1,Frame Composer AVI Packet End of Top Bar Register 1"
width 11.
group.byte 0x101f++0x0
    line.byte 0x00 "FC_AVISBB0,Frame Composer AVI Packet Start of Bottom Bar Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_AVISBB0 ,Line number of Start of Bottom Bar (lower 8 bits)"
width 11.
group.byte 0x1020++0x0
    line.byte 0x00 "FC_AVISBB1,Frame Composer AVI Packet Start of Bottom Bar Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_AVISBB1 ,Line number of Start of Bottom Bar (upper 8 bits)"
width 11.
group.byte 0x1021++0x0
    line.byte 0x00 "FC_AVIELB0,Frame Composer AVI Packet End of Left Bar Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_AVIELB0 ,Pixel number of end of left Bar (lower 8 bits)"
width 11.
group.byte 0x1022++0x0
    line.byte 0x00 "FC_AVIELB1,Frame Composer AVI Packet End of Left Bar Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_AVIELB1 ,Pixel number of end of left Bar (lower 8 bits)"
width 11.
group.byte 0x1023++0x0
    line.byte 0x00 "FC_AVISRB0,Frame Composer AVI Packet Start of Right Bar Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_AVISRB0 ,Pixel number of start of right Bar (lower 8 bits)"
width 11.
group.byte 0x1024++0x0
    line.byte 0x00 "FC_AVISRB1,Frame Composer AVI Packet Start of Right Bar Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_AVISRB1 ,Pixel number of start of right Bar (upper 8 bits)"
width 13.
group.byte 0x1025++0x0
    line.byte 0x00 "FC_AUDICONF0,Frame Composer AUD Packet Configuration Register 0"
        hexmask.byte.byte 0x00 0.--4. 1. " CT ,Coding Type"
        textline "            "
        hexmask.byte.byte 0x00 4.--7. 1. " CC ,Channel count"
width 13.
group.byte 0x1026++0x0
    line.byte 0x00 "FC_AUDICONF1,Frame Composer AUD Packet Configuration Register 1"
        hexmask.byte.byte 0x00 0.--3. 1. " SF ,Sampling frequency"
        textline "            "
        hexmask.byte.byte 0x00 4.--6. 1. " SS ,Sampling size"
width 13.
group.byte 0x1027++0x0
    line.byte 0x00 "FC_AUDICONF2,Frame Composer AUD Packet Configuration Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " CA ,Channel allocation"
width 13.
group.byte 0x1028++0x0
    line.byte 0x00 "FC_AUDICONF3,Frame Composer AUD Packet Configuration Register 3"
        hexmask.byte.byte 0x00 0.--4. 1. " LSV ,Level shift value (for down mixing)"
        textline "            "
        bitfld.byte 0x00 4. " DM_INH ,Down mix enable" "0,1"
        textline "            "
        hexmask.byte.byte 0x00 5.--7. 1. " LFEPBL ,LFE playback information"
width 14.
group.byte 0x1029++0x0
    line.byte 0x00 "FC_VSDIEEEID0,Frame Composer VSI Packet Data IEEE Register 0"
width 11.
group.byte 0x102a++0x0
    line.byte 0x00 "FC_VSDSIZE,Frame Composer VSI Packet Data Size Register"
        hexmask.byte.byte 0x00 0.--5. 1. " VSDSIZE ,Packet size as described in HDMI Vendor Specific InfoFrame (from HDMI specification)."
width 14.
group.byte 0x1030++0x0
    line.byte 0x00 "FC_VSDIEEEID1,Frame Composer VSI Packet Data IEEE Register 1"
width 14.
group.byte 0x1031++0x0
    line.byte 0x00 "FC_VSDIEEEID2,Frame Composer VSI Packet Data IEEE Register 2"
width 15.
group.byte 0x1032++0x0
    line.byte 0x00 "FC_VSDPAYLOAD0,Frame Composer VSI Packet Data IEEE Register 0"
width 15.
group.byte 0x1033++0x0
    line.byte 0x00 "FC_VSDPAYLOAD1,Frame Composer VSI Packet Data IEEE Register 1"
width 15.
group.byte 0x1034++0x0
    line.byte 0x00 "FC_VSDPAYLOAD2,Frame Composer VSI Packet Data IEEE Register 2"
width 15.
group.byte 0x1035++0x0
    line.byte 0x00 "FC_VSDPAYLOAD3,Frame Composer VSI Packet Data IEEE Register 3"
width 15.
group.byte 0x1036++0x0
    line.byte 0x00 "FC_VSDPAYLOAD4,Frame Composer VSI Packet Data IEEE Register 4"
width 15.
group.byte 0x1037++0x0
    line.byte 0x00 "FC_VSDPAYLOAD5,Frame Composer VSI Packet Data IEEE Register 5"
width 15.
group.byte 0x1038++0x0
    line.byte 0x00 "FC_VSDPAYLOAD6,Frame Composer VSI Packet Data IEEE Register 6"
width 15.
group.byte 0x1039++0x0
    line.byte 0x00 "FC_VSDPAYLOAD7,Frame Composer VSI Packet Data IEEE Register 7"
width 15.
group.byte 0x103a++0x0
    line.byte 0x00 "FC_VSDPAYLOAD8,Frame Composer VSI Packet Data IEEE Register 8"
width 15.
group.byte 0x103b++0x0
    line.byte 0x00 "FC_VSDPAYLOAD9,Frame Composer VSI Packet Data IEEE Register 9"
width 16.
group.byte 0x103c++0x0
    line.byte 0x00 "FC_VSDPAYLOAD10,Frame Composer VSI Packet Data IEEE Register 10"
width 16.
group.byte 0x103d++0x0
    line.byte 0x00 "FC_VSDPAYLOAD11,Frame Composer VSI Packet Data IEEE Register 11"
width 16.
group.byte 0x103e++0x0
    line.byte 0x00 "FC_VSDPAYLOAD12,Frame Composer VSI Packet Data IEEE Register 12"
width 16.
group.byte 0x103f++0x0
    line.byte 0x00 "FC_VSDPAYLOAD13,Frame Composer VSI Packet Data IEEE Register 13"
width 16.
group.byte 0x1040++0x0
    line.byte 0x00 "FC_VSDPAYLOAD14,Frame Composer VSI Packet Data IEEE Register 14"
width 16.
group.byte 0x1041++0x0
    line.byte 0x00 "FC_VSDPAYLOAD15,Frame Composer VSI Packet Data IEEE Register 15"
width 16.
group.byte 0x1042++0x0
    line.byte 0x00 "FC_VSDPAYLOAD16,Frame Composer VSI Packet Data IEEE Register 16"
width 16.
group.byte 0x1043++0x0
    line.byte 0x00 "FC_VSDPAYLOAD17,Frame Composer VSI Packet Data IEEE Register 17"
width 16.
group.byte 0x1044++0x0
    line.byte 0x00 "FC_VSDPAYLOAD18,Frame Composer VSI Packet Data IEEE Register 18"
width 16.
group.byte 0x1045++0x0
    line.byte 0x00 "FC_VSDPAYLOAD19,Frame Composer VSI Packet Data IEEE Register 19"
width 16.
group.byte 0x1046++0x0
    line.byte 0x00 "FC_VSDPAYLOAD20,Frame Composer VSI Packet Data IEEE Register 20"
width 16.
group.byte 0x1047++0x0
    line.byte 0x00 "FC_VSDPAYLOAD21,Frame Composer VSI Packet Data IEEE Register 21"
width 16.
group.byte 0x1048++0x0
    line.byte 0x00 "FC_VSDPAYLOAD22,Frame Composer VSI Packet Data IEEE Register 22"
width 16.
group.byte 0x1049++0x0
    line.byte 0x00 "FC_VSDPAYLOAD23,Frame Composer VSI Packet Data IEEE Register 23"
width 18.
group.byte 0x104a++0x0
    line.byte 0x00 "FC_SPDVENDORNAME0,Frame Composer SPD Packet Data Vendor Name Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " VENDOR_NAME ,Vendor name"
width 19.
group.byte 0x1052++0x0
    line.byte 0x00 "FC_SPDPRODUCTNAME0,Frame Composer SPD Packet Data Product Name Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " PRODUCT_NAME ,Product name"
width 16.
group.byte 0x1062++0x0
    line.byte 0x00 "FC_SPDDEVICEINF,Frame Composer SPD Packet Data Source Product Descriptor Register"
        hexmask.byte.byte 0x00 0.--8. 1. " PRODUCT_DESCRIPTOR ,Product descriptor"
width 12.
group.byte 0x1063++0x0
    line.byte 0x00 "FC_AUDSCONF,Frame Composer Audio Sample Flat and Layout Configuration Register"
        bitfld.byte 0x00 0. " AUD_PACKET_LAYOUT ,Set the audio packet layout to be sent in the packet:" "0,1"
        textline "           "
        hexmask.byte.byte 0x00 4.--8. 1. " AUD_PACKET_SAMPFIT ,Set the audio packet sample flat value to be sent on the packet."
width 12.
rgroup.byte 0x1064++0x0
    line.byte 0x00 "FC_AUDSSTAT,Frame Composer Audio Packet Sample Present Status Register"
        hexmask.byte.byte 0x00 0.--4. 1. " PACKET_SAMPPRS ,Shows the data sample present indication of the last Audio sample packet sent by the HDMI TX Controller."
width 13.
group.byte 0x1073++0x0
    line.byte 0x00 "FC_CTRLQHIGH,Frame Composer Number of High Priority Packets Attended Configuration Register"
        hexmask.byte.byte 0x00 0.--5. 1. " ONHIGHATTENDED ,Configures the number of high priority packets or audio sample packets consecutively attended before checking low priority queue status."
width 12.
group.byte 0x1074++0x0
    line.byte 0x00 "FC_CTRLQLOW,Frame Composer Number of Low Priority Packets Attended Configuration Register"
        hexmask.byte.byte 0x00 0.--5. 1. " ONLOWATTENDED ,Configures the number of low priority packets or null packets consecutively attended before checking high priority queue status or audio sample availability."
width 8.
group.byte 0x1075++0x0
    line.byte 0x00 "FC_ACP0,Frame Composer ACP Packet Type Configuration Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " ACPTYPE ,Configures the ACP packet type."
width 8.
group.byte 0x1091++0x0
    line.byte 0x00 "FC_ACP1,Frame Composer ACP Packet Type Configuration Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " AUDIO_CONTENTPACKET ,Audio content packet"
width 11.
group.byte 0x1092++0x0
    line.byte 0x00 "FC_ISCR1_0,FC_ISCR1_Frame Composer Packet Status, Valid, and Continue Configuration Register"
        bitfld.byte 0x00 0. " ISRC_CONT ,Indication of ISRC2." "0,1"
        textline "          "
        bitfld.byte 0x00 1. " ISRC_VALID ,Valid of ISRC1." "0,1"
        textline "          "
        hexmask.byte.byte 0x00 2.--5. 1. " ISRC_STATUS ,Status of ISRC1."
width 11.
group.byte 0x1093++0x0
    line.byte 0x00 "FC_ISCR1_1,Frame Composer ISCR1 Packet Body Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " ISRC1 ,Configures the contents of the ISRC1 packet:"
width 11.
group.byte 0x10a3++0x0
    line.byte 0x00 "FC_ISCR2_0,Frame Composer ISCR2 Packet Body Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " ISRC2 ,Configures the contents of the ISRC1 packet:"
width 12.
group.byte 0x10b3++0x0
    line.byte 0x00 "FC_DATAUTO0,Frame Composer Data Island Auto Packet Scheduling Register 0"
        bitfld.byte 0x00 0. " ACP_AUTO ,Enables ACP automatic packet scheduling" "0,1"
        textline "           "
        bitfld.byte 0x00 1. " ISCR1_AUTO ,Enables ISRC1 automatic packet scheduling" "0,1"
        textline "           "
        bitfld.byte 0x00 2. " ISCR2_AUTO ,Enables ISRC2 automatic packet scheduling" "0,1"
        textline "           "
        bitfld.byte 0x00 3. " VSD_AUTO ,Enables VSD automatic packet scheduling" "0,1"
        textline "           "
        bitfld.byte 0x00 4. " SPD_AUTO ,Enables SPD automatic packet scheduling" "0,1"
width 12.
group.byte 0x10b4++0x0
    line.byte 0x00 "FC_DATAUTO1,Frame Composer Data Island Auto Packet Scheduling Register 1"
        hexmask.byte.byte 0x00 0.--4. 1. " AUTO_FRAME_INTERPOLATION ,Packet frame interpolation, for automatic packet scheduling"
width 12.
group.byte 0x10b5++0x0
    line.byte 0x00 "FC_DATAUTO2,Frame Composer Data Island Auto Packet Scheduling Register 2"
        hexmask.byte.byte 0x00 0.--4. 1. " AUTO_LINE_SPACING ,Packets line spacing, for automatic packet scheduling"
        textline "           "
        hexmask.byte.byte 0x00 4.--8. 1. " AUTO_FRAME_PACKETS ,Packets per frame, for automatic packet scheduling"
width 10.
wgroup.byte 0x10b6++0x0
    line.byte 0x00 "FC_DATMAN,Frame Composer Data Island Manual Packet Request Register"
        bitfld.byte 0x00 0. " ACP_TX ,ACP packet" "0,1"
        textline "         "
        bitfld.byte 0x00 1. " ISR1_TX ,ISRC1 packet" "0,1"
        textline "         "
        bitfld.byte 0x00 2. " ISCR2_TX ,ISRC2 packet" "0,1"
        textline "         "
        bitfld.byte 0x00 3. " VSD_TX ,VSD packet" "0,1"
        textline "         "
        bitfld.byte 0x00 4. " SPD_TX ,SPD packet" "0,1"
        textline "         "
        bitfld.byte 0x00 5. " NULL_TX ,Null packet" "0,1"
width 12.
group.byte 0x10b7++0x0
    line.byte 0x00 "FC_DATAUTO3,Frame Composer Data Island Auto Packet Scheduling Register 3"
        bitfld.byte 0x00 0. " ACR_AUTO ,Enable ACR packet insertion" "0,1"
        textline "           "
        bitfld.byte 0x00 1. " AUDI_AUTO ,Enable AUDI packet insertion" "0,1"
        textline "           "
        bitfld.byte 0x00 2. " GCP_AUTO ,Enable GCP packet insertion" "0,1"
        textline "           "
        bitfld.byte 0x00 3. " AVI_AUTO ,Enable AVI packet insertion" "0,1"
width 9.
group.byte 0x10b8++0x0
    line.byte 0x00 "FC_RDRB0,Frame Composer Round Robin ACR Packet Insertion Register 0"
        hexmask.byte.byte 0x00 0.--4. 1. " ACRFRAMEINTERPOLATION ,ACR frame interpolation"
width 9.
group.byte 0x10b9++0x0
    line.byte 0x00 "FC_RDRB1,Frame Composer Round Robin ACR Packet Insertion Register 1"
        hexmask.byte.byte 0x00 0.--4. 1. " ACRPACKETLINESPACING ,ACR packet line spacing"
        textline "        "
        hexmask.byte.byte 0x00 4.--8. 1. " ACRPACKETSINFRAME ,ACR packets in frame"
width 9.
group.byte 0x10ba++0x0
    line.byte 0x00 "FC_RDRB2,Frame Composer Round Robin ACR Packet Insertion Register 2"
        hexmask.byte.byte 0x00 0.--4. 1. " AUDIFRAMEINTERPOLATION ,Audio frame interpolation"
width 9.
group.byte 0x10bb++0x0
    line.byte 0x00 "FC_RDRB3,Frame Composer Round Robin ACR Packet Insertion Register 3"
        hexmask.byte.byte 0x00 0.--4. 1. " AUDIPACKETLINESPACING ,Audio packets line spacing"
        textline "        "
        hexmask.byte.byte 0x00 4.--8. 1. " AUDIPACKETSINFRAME ,Audio packets per frame"
width 9.
group.byte 0x10bc++0x0
    line.byte 0x00 "FC_RDRB4,Frame Composer Round Robin ACR Packet Insertion Register 4"
        hexmask.byte.byte 0x00 0.--4. 1. " GCPFRAMEINTERPOLATION ,GCP packets line spacing"
width 9.
group.byte 0x10bd++0x0
    line.byte 0x00 "FC_RDRB5,Frame Composer Round Robin ACR Packet Insertion Register 5"
        hexmask.byte.byte 0x00 0.--4. 1. " GCPPACKETLINESPACING ,GCP packets line spacing"
        textline "        "
        hexmask.byte.byte 0x00 4.--8. 1. " GCPPACKETSINFRAME ,GCP packets per frame"
width 9.
group.byte 0x10be++0x0
    line.byte 0x00 "FC_RDRB6,Frame Composer Round Robin ACR Packet Insertion Register 6"
        hexmask.byte.byte 0x00 0.--4. 1. " AVIFRAMEINTERPOLATION ,GCP packets line spacing"
width 9.
group.byte 0x10bf++0x0
    line.byte 0x00 "FC_RDRB7,Frame Composer Round Robin ACR Packet Insertion Register 7"
        hexmask.byte.byte 0x00 0.--4. 1. " AVIPACKETLINESPACING ,AVI packets line spacing"
        textline "        "
        hexmask.byte.byte 0x00 4.--8. 1. " AVIPACKETSINFRAME ,AVI packets per frame"
width 9.
group.byte 0x10d2++0x0
    line.byte 0x00 "FC_MASK0,Frame Composer Packet Interrupt Mask Register 0"
        bitfld.byte 0x00 0. " NULL_ ,Mask bit for FC_INT0.NULL interrupt bit Value after Reset: 0b" "0,1"
        textline "        "
        bitfld.byte 0x00 1. " ACR ,Mask bit for FC_INT0.ACR interrupt bit Value after Reset: 0b" "0,1"
        textline "        "
        bitfld.byte 0x00 2. " AUDS ,Mask bit for FC_INT0.AUDS interrupt bit Value after Reset: 0b" "0,1"
        textline "        "
        bitfld.byte 0x00 5. " HBR ,Mask bit for FC_INT0.HBR interrupt bit Value after Reset: 0b" "0,1"
        textline "        "
        bitfld.byte 0x00 6. " ACP ,Mask bit for FC_INT0.ACP interrupt bit Value after Reset: 0b" "0,1"
        textline "        "
        bitfld.byte 0x00 7. " AUDI ,Mask bit for FC_INT0.AUDI interrupt bit Value after Reset: 0b" "0,1"
width 9.
group.byte 0x10d6++0x0
    line.byte 0x00 "FC_MASK1,Frame Composer Packet Interrupt Mask Register 1"
        bitfld.byte 0x00 0. " GCP ,Mask bit for FC_INT1.GCP interrupt bit" "0,1"
        textline "        "
        bitfld.byte 0x00 1. " AVI ,Mask bit for FC_INT1.AVI interrupt bit" "0,1"
        textline "        "
        bitfld.byte 0x00 3. " SPD ,Mask bit for FC_INT1.SPD interrupt bit" "0,1"
        textline "        "
        bitfld.byte 0x00 4. " VSD ,Mask bit for FC_INT1.VSD interrupt bit" "0,1"
        textline "        "
        bitfld.byte 0x00 5. " ISCR2 ,Mask bit for FC_INT1.ISRC2 interrupt bit" "0,1"
        textline "        "
        bitfld.byte 0x00 6. " ISCR1 ,Mask bit for FC_INT1.ISRC1 interrupt bit" "0,1"
        textline "        "
        bitfld.byte 0x00 7. " GMD ,Mask bit for FC_INT1.GMD interrupt bit" "0,1"
width 9.
group.byte 0x10da++0x0
    line.byte 0x00 "FC_MASK2,Frame Composer High/Low Priority Overflow Interrupt Mask Register 2"
        bitfld.byte 0x00 0. " HIGHPRIORITY_OVERFLOW ,Mask bit for FC_INT1.HighPriority_overflow interrupt bit Value after Reset: 0b" "0,1"
width 10.
group.byte 0x10e0++0x0
    line.byte 0x00 "FC_PRCONF,Frame Composer Pixel Repetition Configuration Register"
        hexmask.byte.byte 0x00 0.--4. 1. " OUTPUT_PR_FACTOR ,Configures the video pixel repetition ratio to be sent on the AVI infoFrame."
        textline "         "
        hexmask.byte.byte 0x00 4.--8. 1. " INCOMING_PR_FACTOR ,Configures the input video pixel repetition."
width 12.
rgroup.byte 0x1100++0x0
    line.byte 0x00 "FC_GMD_STAT,Frame Composer GMD Packet Status Register"
        hexmask.byte.byte 0x00 0.--4. 1. " IGMDCURRENT_GAMUT_SEQ_NUM ,Gamut scheduling: Current Gamut packet sequence number"
        textline "           "
        hexmask.byte.byte 0x00 4.--6. 1. " IGMDPACKET_SEQ ,Gamut scheduling: Gamut packet sequence"
        textline "           "
        bitfld.byte 0x00 6. " IGMDDNEXT_FIELD ,Gamut scheduling: Gamut Next field" "0,1"
        textline "           "
        bitfld.byte 0x00 7. " IGMDNO_CRNT_GBD ,Gamut scheduling: No current gamut data" "0,1"
width 10.
group.byte 0x1101++0x0
    line.byte 0x00 "FC_GMD_EN,Frame Composer GMD Packet Enable Register"
        bitfld.byte 0x00 0. " GMDENABLETX ,Gamut Metadata packet transmission enable (1b)." "0,1"
width 10.
wgroup.byte 0x1102++0x0
    line.byte 0x00 "FC_GMD_UP,Frame Composer GMD Packet Update Register"
        bitfld.byte 0x00 0. " GMDUPDATEPACKET ,Gamut Metadata packet update." "0,1"
width 12.
group.byte 0x1103++0x0
    line.byte 0x00 "FC_GMD_CONF,Frame Composer GMD Packet Schedule Configuration Register"
        hexmask.byte.byte 0x00 0.--4. 1. " GMDPACKETLINESPACING ,Number of line spacing between the transmitted GMD packets"
        textline "           "
        hexmask.byte.byte 0x00 4.--8. 1. " GMDPACKETSINFRAME ,Number of GMD packets per frame or video field (profile P0)"
width 10.
group.byte 0x1104++0x0
    line.byte 0x00 "FC_GMD_HB,Frame Composer GMD Packet Profile and Gamut Sequence Configuration Register"
        hexmask.byte.byte 0x00 0.--4. 1. " GMDAFFECTED_GAMUT_SEQ_NUM ,Affected gamut sequence number"
        textline "         "
        hexmask.byte.byte 0x00 4.--7. 1. " GMDGBD_PROFILE ,GMD profile bits"
width 11.
group.byte 0x1105++0x0
    line.byte 0x00 "FC_GMD_PB0,Frame Composer GMD Packet Body Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB0 ,Gamut Metadata packet byte0"
width 11.
group.byte 0x1106++0x0
    line.byte 0x00 "FC_GMD_PB1,Frame Composer GMD Packet Body Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB1 ,Gamut Metadata packet byte1"
width 11.
group.byte 0x1107++0x0
    line.byte 0x00 "FC_GMD_PB2,Frame Composer GMD Packet Body Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB2 ,Gamut Metadata packet byte2"
width 11.
group.byte 0x1108++0x0
    line.byte 0x00 "FC_GMD_PB3,Frame Composer GMD Packet Body Register 3"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB3 ,Gamut Metadata packet byte3"
width 11.
group.byte 0x1109++0x0
    line.byte 0x00 "FC_GMD_PB4,Frame Composer GMD Packet Body Register 4"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB4 ,Gamut Metadata packet byte4"
width 11.
group.byte 0x110a++0x0
    line.byte 0x00 "FC_GMD_PB5,Frame Composer GMD Packet Body Register 5"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB5 ,Gamut Metadata packet byte5"
width 11.
group.byte 0x110b++0x0
    line.byte 0x00 "FC_GMD_PB6,Frame Composer GMD Packet Body Register 6"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB6 ,Gamut Metadata packet byte6"
width 11.
group.byte 0x110c++0x0
    line.byte 0x00 "FC_GMD_PB7,Frame Composer GMD Packet Body Register 7"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB2 ,Gamut Metadata packet byte7"
width 11.
group.byte 0x110d++0x0
    line.byte 0x00 "FC_GMD_PB8,Frame Composer GMD Packet Body Register 8"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB8 ,Gamut Metadata packet byte8"
width 11.
group.byte 0x110e++0x0
    line.byte 0x00 "FC_GMD_PB9,Frame Composer GMD Packet Body Register 9"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB9 ,Gamut Metadata packet byte9"
width 12.
group.byte 0x110f++0x0
    line.byte 0x00 "FC_GMD_PB10,Frame Composer GMD Packet Body Register 10"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB10 ,Gamut Metadata packet byte10"
width 12.
group.byte 0x1110++0x0
    line.byte 0x00 "FC_GMD_PB11,Frame Composer GMD Packet Body Register 11"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB11 ,Gamut Metadata packet byte11"
width 12.
group.byte 0x1111++0x0
    line.byte 0x00 "FC_GMD_PB12,Frame Composer GMD Packet Body Register 12"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB12 ,Gamut Metadata packet byte12"
width 12.
group.byte 0x1112++0x0
    line.byte 0x00 "FC_GMD_PB13,Frame Composer GMD Packet Body Register 13"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB13 ,Gamut Metadata packet byte13"
width 12.
group.byte 0x1113++0x0
    line.byte 0x00 "FC_GMD_PB14,Frame Composer GMD Packet Body Register 14"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB14 ,Gamut Metadata packet byte14"
width 12.
group.byte 0x1114++0x0
    line.byte 0x00 "FC_GMD_PB15,Frame Composer GMD Packet Body Register 15"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB15 ,Gamut Metadata packet byte15"
width 12.
group.byte 0x1115++0x0
    line.byte 0x00 "FC_GMD_PB16,Frame Composer GMD Packet Body Register 16"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB16 ,Gamut Metadata packet byte16"
width 12.
group.byte 0x1116++0x0
    line.byte 0x00 "FC_GMD_PB17,Frame Composer GMD Packet Body Register 17"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB17 ,Gamut Metadata packet byte17"
width 12.
group.byte 0x1117++0x0
    line.byte 0x00 "FC_GMD_PB18,Frame Composer GMD Packet Body Register 18"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB18 ,Gamut Metadata packet byte18"
width 12.
group.byte 0x1118++0x0
    line.byte 0x00 "FC_GMD_PB19,Frame Composer GMD Packet Body Register 19"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB18 ,Gamut Metadata packet byte18"
width 12.
group.byte 0x1119++0x0
    line.byte 0x00 "FC_GMD_PB20,Frame Composer GMD Packet Body Register 20"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB20 ,Gamut Metadata packet byte20"
width 12.
group.byte 0x111a++0x0
    line.byte 0x00 "FC_GMD_PB21,Frame Composer GMD Packet Body Register 21"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB21 ,Gamut Metadata packet byte21"
width 12.
group.byte 0x111b++0x0
    line.byte 0x00 "FC_GMD_PB22,Frame Composer GMD Packet Body Register 22"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB22 ,Gamut Metadata packet byte22"
width 12.
group.byte 0x111c++0x0
    line.byte 0x00 "FC_GMD_PB23,Frame Composer GMD Packet Body Register 23"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB23 ,Gamut Metadata packet byte23"
width 12.
group.byte 0x111d++0x0
    line.byte 0x00 "FC_GMD_PB24,Frame Composer GMD Packet Body Register 24"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB24 ,Gamut Metadata packet byte24"
width 12.
group.byte 0x111e++0x0
    line.byte 0x00 "FC_GMD_PB25,Frame Composer GMD Packet Body Register 25"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB25 ,Gamut Metadata packet byte25"
width 12.
group.byte 0x111f++0x0
    line.byte 0x00 "FC_GMD_PB26,Frame Composer GMD Packet Body Register 26"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB26 ,Gamut Metadata packet byte26"
width 12.
group.byte 0x1120++0x0
    line.byte 0x00 "FC_GMD_PB27,Frame Composer GMD Packet Body Register 27"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_GMD_PB27 ,Gamut Metadata packet byte27"
width 12.
group.byte 0x1200++0x0
    line.byte 0x00 "FC_DBGFORCE,Frame Composer Video/Audio Force Enable Register"
        bitfld.byte 0x00 0. " FORCEVIDEO ,Force fixed video output with FC_DBGTMDSx registers contain." "0,1"
        textline "           "
        bitfld.byte 0x00 4. " FORCEAUDIO ,Force fixed audio output with FC_DBGAUDxCHx registers contain." "0,1"
width 14.
group.byte 0x1201++0x0
    line.byte 0x00 "FC_DBGAUD0CH0,Frame Composer Audio Channel 0 Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD0CH0 ,the audio fixed data byte0 to be used in channel 0 when in fixed audio selection"
width 14.
group.byte 0x1202++0x0
    line.byte 0x00 "FC_DBGAUD1CH0,Frame Composer Audio Channel 0 Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD1CH0 ,the audio fixed data byte1 to be used in channel 0 when in fixed audio selection"
width 14.
group.byte 0x1203++0x0
    line.byte 0x00 "FC_DBGAUD2CH0,Frame Composer Audio Channel 0 Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD2CH0 ,the audio fixed data byte2 to be used in channel 0 when in fixed audio selection"
width 14.
group.byte 0x1204++0x0
    line.byte 0x00 "FC_DBGAUD0CH1,Frame Composer Audio Channel 1 Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD0CH1 ,the audio fixed data byte2 to be used in channel 0 when in fixed audio selection"
width 14.
group.byte 0x1205++0x0
    line.byte 0x00 "FC_DBGAUD1CH1,Frame Composer Audio Channel 1 Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD1CH1 ,the audio fixed data byte1 to be used in channel 1 when in fixed audio selection"
width 14.
group.byte 0x1206++0x0
    line.byte 0x00 "FC_DBGAUD2CH1,Frame Composer Audio Channel 1 Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD2CH1 ,the audio fixed data byte2 to be used in channel 1 when in fixed audio selection"
width 14.
group.byte 0x1207++0x0
    line.byte 0x00 "FC_DBGAUD0CH2,Frame Composer Debug Audio Channel 2 Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD0CH2 ,the audio fixed data byte0 to be used in channel 2 when in fixed audio selection"
width 14.
group.byte 0x1208++0x0
    line.byte 0x00 "FC_DBGAUD1CH2,Frame Composer Debug Audio Channel 2 Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD1CH2 ,the audio fixed data byte1 to be used in channel 2 when in fixed audio selection"
width 14.
group.byte 0x1209++0x0
    line.byte 0x00 "FC_DBGAUD2CH2,Frame Composer Audio Channel 2 Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD2CH2 ,the audio fixed data byte2 to be used in channel 2 when in fixed audio selection"
width 14.
group.byte 0x120a++0x0
    line.byte 0x00 "FC_DBGAUD0CH3,Frame Composer Audio Channel 3 Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD0CH3 ,the audio fixed data byte0 to be used in channel 3 when in fixed audio selection"
width 14.
group.byte 0x120b++0x0
    line.byte 0x00 "FC_DBGAUD1CH3,Frame Composer Audio Channel 3 Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD1CH3 ,the audio fixed data byte1 to be used in channel 3 when in fixed audio selection"
width 14.
group.byte 0x120c++0x0
    line.byte 0x00 "FC_DBGAUD2CH3,Frame Composer Audio Channel 3 Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD2CH3 ,the audio fixed data byte2 to be used in channel 3 when in fixed audio selection"
width 14.
group.byte 0x120d++0x0
    line.byte 0x00 "FC_DBGAUD0CH4,Frame Composer Audio Channel 4 Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD0CH4 ,the audio fixed data byte0 to be used in channel 4 when in fixed audio selection"
width 14.
group.byte 0x120e++0x0
    line.byte 0x00 "FC_DBGAUD1CH4,Frame Composer Audio Channel 4 Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD1CH4 ,the audio fixed data byte1 to be used in channel 4 when in fixed audio selection"
width 14.
group.byte 0x120f++0x0
    line.byte 0x00 "FC_DBGAUD2CH4,Frame Composer Audio Channel 4 Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD2CH4 ,the audio fixed data byte2 to be used in channel 4 when in fixed audio selection"
width 14.
group.byte 0x1210++0x0
    line.byte 0x00 "FC_DBGAUD0CH5,Frame Composer Audio Channel 5 Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD0CH5 ,the audio fixed data byte0 to be used in channel 5 when in fixed audio selection"
width 14.
group.byte 0x1211++0x0
    line.byte 0x00 "FC_DBGAUD1CH5,Frame Composer Audio Channel 5 Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD1CH5 ,the audio fixed data byte1 to be used in channel 5 when in fixed audio selection"
width 14.
group.byte 0x1212++0x0
    line.byte 0x00 "FC_DBGAUD2CH5,Frame Composer Audio Channel 5 Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD2CH5 ,the audio fixed data byte2 to be used in channel 5 when in fixed audio selection"
width 14.
group.byte 0x1213++0x0
    line.byte 0x00 "FC_DBGAUD0CH6,Frame Composer Audio Channel 6 Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD0CH6 ,The audio fixed data byte0 to be used in channel 6 when in fixed audio selection"
width 14.
group.byte 0x1214++0x0
    line.byte 0x00 "FC_DBGAUD1CH6,Frame Composer Audio Channel 6 Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD1CH6 ,the audio fixed data byte1 to be used in channel 6 when in fixed audio selection"
width 14.
group.byte 0x1215++0x0
    line.byte 0x00 "FC_DBGAUD2CH6,Frame Composer Audio Channel 6 Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD2CH6 ,the audio fixed data byte2 to be used in channel 6 when in fixed audio selection"
width 14.
group.byte 0x1216++0x0
    line.byte 0x00 "FC_DBGAUD0CH7,Frame Composer Audio Channel 7 Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD0CH7 ,the audio fixed data byte0 to be used in channel 7 when in fixed audio selection"
width 14.
group.byte 0x1217++0x0
    line.byte 0x00 "FC_DBGAUD1CH7,Frame Composer Audio Channel 7 Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD1CH7 ,the audio fixed data byte1 to be used in channel 0 when in fixed audio selection"
width 14.
group.byte 0x1218++0x0
    line.byte 0x00 "FC_DBGAUD2CH7,Frame Composer Audio Channel 7 Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGAUD2CH7 ,the audio fixed data byte2 to be used in channel 0 when in fixed audio selection"
width 12.
group.byte 0x1219++0x0
    line.byte 0x00 "FC_DBGTMDS0,Frame Composer TMDS Channel 0 Register"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGTMDS0 ,set B pixel component value in RGB video or Cb pixel component value in YCbCr"
width 12.
group.byte 0x121a++0x0
    line.byte 0x00 "FC_DBGTMDS1,Frame Composer TMDS Channel 1 Register"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGTMDS1 ,set G pixel component value in RGB video or Y pixel component value in YCbCr"
width 12.
group.byte 0x121b++0x0
    line.byte 0x00 "FC_DBGTMDS2,Frame Composer TMDS Channel 2 Register"
        hexmask.byte.byte 0x00 0.--8. 1. " FC_DBGTMDS2 ,set R pixel component value in RGB video or Cr pixel component value in YCbCr"
width 10.
group.byte 0x3000++0x0
    line.byte 0x00 "PHY_CONF0,PHY Configuration Register"
        bitfld.byte 0x00 0. " SELDIPIF ,Select interface control." "0,1"
        textline "         "
        bitfld.byte 0x00 1. " SELDATAENPOL ,Select data enable polarity." "0,1"
        textline "         "
        bitfld.byte 0x00 2. " GEN2_ENHPDRXSENSE ,PHY_Gen2 ENHPDRXSENSE signal Value after Reset: 1b" "0,1"
        textline "         "
        bitfld.byte 0x00 3. " GEN2_TXPWRON ,PHY_Gen2 TXPWRON signal Value after Reset: 0b" "0,1"
        textline "         "
        bitfld.byte 0x00 4. " GEN2_PDDQ ,PHY_Gen2 PDDQ signal Value after Reset: 0b" "0,1"
        textline "         "
        bitfld.byte 0x00 5. " SPARECTRL ,Reserved." "0,1"
        textline "         "
        bitfld.byte 0x00 6. " ENTMDS ,Enable TMDS drivers, bias, and TMDS digital logic." "0,1"
        textline "         "
        bitfld.byte 0x00 7. " PDZ ,Power-down enable (active low 0b)." "0,1"
width 9.
group.byte 0x3001++0x0
    line.byte 0x00 "PHY_TST0,PHY Test Interface Register 0"
        bitfld.byte 0x00 0. " TESTCLK ,Test clock signal." "0,1"
        textline "        "
        bitfld.byte 0x00 4. " TESTEN ,Reserved." "0,1"
        textline "        "
        bitfld.byte 0x00 5. " TESTCLR ,Enable TMDS drivers, bias and tmds digital logic." "0,1"
width 9.
group.byte 0x3002++0x0
    line.byte 0x00 "PHY_TST1,PHY Test Interface Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " TESTDIN ,Test data input."
width 9.
rgroup.byte 0x3003++0x0
    line.byte 0x00 "PHY_TST2,PHY Test Interface Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " TESTDOUT ,Test data output."
width 10.
rgroup.byte 0x3004++0x0
    line.byte 0x00 "PHY_STAT0,PHY RXSENSE, PLL lock, and HPD Status Register"
        bitfld.byte 0x00 0. " TX_PHY_LOCK ,Status bit." "0,1"
        textline "         "
        bitfld.byte 0x00 1. " HPD ,Status bit." "0,1"
        textline "         "
        bitfld.byte 0x00 4. " RX_SENSE ,Status bit." "0,1"
        textline "         "
        bitfld.byte 0x00 5. " RX_SENSE1 ,Status bit." "0,1"
        textline "         "
        bitfld.byte 0x00 6. " RX_SENSE2 ,Status bit." "0,1"
        textline "         "
        bitfld.byte 0x00 7. " RX_SENSE3 ,Status bit." "0,1"
width 9.
rgroup.byte 0x3005++0x0
    line.byte 0x00 "PHY_INT0,PHY RXSENSE, PLL lock, and HPD Interrupt Register"
        bitfld.byte 0x00 0. " TX_PHY_LOCK ,Interrupt indication bit TX PHY PLL lock indication interrupt." "0,1"
        textline "        "
        bitfld.byte 0x00 1. " HPD ,Interrupt indication bit HDMI Hot Plug Detect indication interrupt." "0,1"
        textline "        "
        bitfld.byte 0x00 4. " RX_SENSE ,Interrupt indication bit TX PHY RX_SENSE indication interrupt for TMDS channel 0 driver." "0,1"
        textline "        "
        bitfld.byte 0x00 5. " RX_SENSE1 ,Interrupt indication bit TX PHY RX_SENSE indication interrupt for TMDS channel 1 driver." "0,1"
        textline "        "
        bitfld.byte 0x00 6. " RX_SENSE2 ,Interrupt indication bit TX PHY RX_SENSE indication interrupt for TMDS channel 2 driver." "0,1"
        textline "        "
        bitfld.byte 0x00 7. " RX_SENSE3 ,Interrupt indication bit TX PHY RX_SENSE indication interrupt for TMDS CLK driver." "0,1"
width 10.
group.byte 0x3006++0x0
    line.byte 0x00 "PHY_MASK0,PHY RXSENSE, PLL lock, and HPD Mask Register"
        bitfld.byte 0x00 0. " TX_PHY_LOCK ,Mask bit for PHY_INT0.TX_PHY_LOCK interrupt bit" "0,1"
        textline "         "
        bitfld.byte 0x00 1. " HPD ,Mask bit for PHY_INT0.HPD interrupt bit" "0,1"
        textline "         "
        bitfld.byte 0x00 4. " RX_SENSE ,Mask bit for PHY_INT0.RX_SENSE[0] interrupt bit" "0,1"
        textline "         "
        bitfld.byte 0x00 5. " RX_SENSE1 ,Mask bit for PHY_INT0.RX_SENSE[1] interrupt bit" "0,1"
        textline "         "
        bitfld.byte 0x00 6. " RX_SENSE2 ,Mask bit for PHY_INT0.RX_SENSE[2] interrupt bit" "0,1"
        textline "         "
        bitfld.byte 0x00 7. " RX_SENSE3 ,Mask bit for PHY_INT0.RX_SENSE[3] interrupt bit" "0,1"
width 9.
group.byte 0x3007++0x0
    line.byte 0x00 "PHY_POL0,PHY RXSENSE, PLL lock and HPD Polarity Register"
        bitfld.byte 0x00 0. " TX_PHY_LOCK ,Polarity bit for PHY_INT0.TX_PHY_LOCK interrupt bit" "0,1"
        textline "        "
        bitfld.byte 0x00 1. " HPD ,Polarity bit for PHY_INT0.HPD interrupt bit" "0,1"
        textline "        "
        bitfld.byte 0x00 4. " RX_SENSE ,Polarity bit for PHY_INT0.RX_SENSE[0] interrupt bit" "0,1"
        textline "        "
        bitfld.byte 0x00 5. " RX_SENSE1 ,Polarity bit for PHY_INT0.RX_SENSE[1] interrupt bit" "0,1"
        textline "        "
        bitfld.byte 0x00 6. " RX_SENSE2 ,Polarity bit for PHY_INT0.RX_SENSE[2] interrupt bit" "0,1"
        textline "        "
        bitfld.byte 0x00 7. " RX_SENSE3 ,Polarity bit for PHY_INT0.RX_SENSE[3] interrupt bit" "0,1"
width 20.
group.byte 0x3020++0x0
    line.byte 0x00 "PHY_I2CM_SLAVE_ADDR,PHY I2C Slave Address Configuration Register"
width 22.
group.byte 0x3021++0x0
    line.byte 0x00 "PHY_I2CM_ADDRESS_ADDR,PHY I2C Address Configuration Register"
        hexmask.byte.byte 0x00 0.--8. 1. " ADDRESS ,Register address for read and write operations."
width 22.
group.byte 0x3022++0x0
    line.byte 0x00 "PHY_I2CM_DATAO_1_ADDR,PHY I2C Data Write Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " DATAO ,MSB's of data to be written on register pointed by address [7:0]."
width 22.
group.byte 0x3023++0x0
    line.byte 0x00 "PHY_I2CM_DATAO_0_ADDR,PHY I2C Data Write Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " DATAO ,LSB's of data to be written on register pointed by address [7:0]."
width 22.
rgroup.byte 0x3024++0x0
    line.byte 0x00 "PHY_I2CM_DATAI_1_ADDR,PHY I2C Data Read Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " DATAI ,MSB's of data read from the register pointed by address [7:0]."
width 22.
group.byte 0x3025++0x0
    line.byte 0x00 "PHY_I2CM_DATAI_0_ADDR,PHY I2C Data Read Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " DATAI ,LSB's of data read from the register pointed by address [7:0]."
width 24.
wgroup.byte 0x3026++0x0
    line.byte 0x00 "PHY_I2CM_OPERATION_ADDR,PHY I2C Read/Write Operation"
        bitfld.byte 0x00 0. " READ ,Read operation request." "0,1"
        textline "                       "
        bitfld.byte 0x00 4. " WRITE ,Write operation request" "0,1"
width 18.
group.byte 0x3027++0x0
    line.byte 0x00 "PHY_I2CM_INT_ADDR,PHY I2C Done Interrupt Register"
        bitfld.byte 0x00 0. " DONE_STATUS ,Operation done status bit.Marks the end of a rd or write operation." "0,1"
        textline "                 "
        bitfld.byte 0x00 1. " DONE_INTERRUPT ,Operation done interrupt bit.{done_interrupt =(done_mask==0b)&& (done_status==done_pol)}." "0,1"
        textline "                 "
        bitfld.byte 0x00 2. " DONE_MASK ,Done interrupt mask signal Value after Reset: 0b" "0,1"
        textline "                 "
        bitfld.byte 0x00 3. " DONE_POL ,Done interrupt polarity configuration Value after Reset: 1b" "0,1"
width 21.
group.byte 0x3028++0x0
    line.byte 0x00 "PHY_I2CM_CTLINT_ADDR,PHY I2C Done Interrupt Register"
        bitfld.byte 0x00 0. " ARBITRATION_STATUS ,Arbitration error status bit." "0,1"
        textline "                    "
        bitfld.byte 0x00 1. " ARBITRATION_INTERRUPT ,Arbitration error interrupt bit.{arbitration_interrupt = (arbitration_mask==0b)&& (arbitration_status==arbitration_pol)}." "0,1"
        textline "                    "
        bitfld.byte 0x00 2. " ARBITRATION_MASK ,Arbitration error interrupt mask signal." "0,1"
        textline "                    "
        bitfld.byte 0x00 3. " ARBITRATION_POL ,Arbitration error interrupt polarity configuration." "0,1"
        textline "                    "
        bitfld.byte 0x00 4. " NACK_STATUS ,Not acknowledge error status bit.Error on I2C not acknowledge." "0,1"
        textline "                    "
        bitfld.byte 0x00 5. " NACK_INTERRUPT ,Not acknowledge error interrupt bit.{nack_interrupt = nack_mask==0b) && (nack_status==nack_pol)}." "0,1"
        textline "                    "
        bitfld.byte 0x00 6. " NACK_MASK ,Not acknowledge error interrupt mask signal Value after Reset: 0b" "0,1"
        textline "                    "
        bitfld.byte 0x00 7. " NACK_POL ,Not acknowledge error interrupt polarity configuration." "0,1"
width 18.
group.byte 0x3029++0x0
    line.byte 0x00 "PHY_I2CM_DIV_ADDR,PHY I2C Speed Control Register"
        hexmask.byte.byte 0x00 0.--4. 1. " FAST_MODE ,Sets the I2C Master to work in Fast Mode or Standard Mode (x implies that it can take any value) Value after Reset: 1011b 1xxxb Fast Mode 0xxxb Standard Mode"
width 23.
group.byte 0x302a++0x0
    line.byte 0x00 "PHY_I2CM_SOFTRSTZ_ADDR,PHY I2C Software Reset Register"
        bitfld.byte 0x00 0. " I2C_SOFTRST ,I2C Master PHY Software Reset." "0,1"
width 28.
group.byte 0x302b++0x0
    line.byte 0x00 "PHY_I2CM_SS_SCL_HCNT_1_ADDR,PHY I2C Slow Speed SCL High Level Control Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_SS_SCL_HCNT ,Value after Reset: 8'h00"
width 28.
group.byte 0x302c++0x0
    line.byte 0x00 "PHY_I2CM_SS_SCL_HCNT_0_ADDR,PHY I2C Slow Speed SCL High Level Control Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_SS_SCL_HCNT ,Value after Reset: 8'h6C"
width 28.
group.byte 0x302d++0x0
    line.byte 0x00 "PHY_I2CM_SS_SCL_LCNT_1_ADDR,PHY I2C Slow Speed SCL Low Level Control Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_SS_SCL_LCNT ,Value after Reset: 8'h00"
width 28.
group.byte 0x302e++0x0
    line.byte 0x00 "PHY_I2CM_SS_SCL_LCNT_0_ADDR,PHY I2C Slow Speed SCL Low Level Control Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_SS_SCL_LCNT ,Value after Reset: 8'h7F"
width 28.
group.byte 0x302f++0x0
    line.byte 0x00 "PHY_I2CM_FS_SCL_HCNT_1_ADDR,PHY I2C Fast Speed SCL High Level Control Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_FS_SCL_HCNT ,Value after Reset: 8'h00"
width 28.
group.byte 0x3030++0x0
    line.byte 0x00 "PHY_I2CM_FS_SCL_HCNT_0_ADDR,PHY I2C Fast Speed SCL High Level Control Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_FS_SCL_HCNT ,Value after Reset: 8'h11"
width 28.
group.byte 0x3031++0x0
    line.byte 0x00 "PHY_I2CM_FS_SCL_LCNT_1_ADDR,PHY I2C Fast Speed SCL Low Level Control Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_FS_SCL_LCNT ,Value after Reset: 8'h00"
width 28.
group.byte 0x3032++0x0
    line.byte 0x00 "PHY_I2CM_FS_SCL_LCNT_0_ADDR,PHY I2C Fast Speed SCL Low Level Control Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_FS_SCL_LCNT ,Value after Reset: 8'h24"
width 7.
group.byte 0x3200++0x0
    line.byte 0x00 "AUD_N1,Audio Clock Regenerator N Value Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " AUDN ,HDMI Audio Clock Regenerator N value"
width 7.
group.byte 0x3201++0x0
    line.byte 0x00 "AUD_N2,Audio Clock Regenerator N Value Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " AUDN ,HDMI Audio Clock Regenerator N value"
width 7.
group.byte 0x3202++0x0
    line.byte 0x00 "AUD_N3,Audio Clock Regenerator N Value Register 3"
        hexmask.byte.byte 0x00 0.--4. 1. " AUDN ,HDMI Audio Clock Regenerator N value"
width 9.
group.byte 0x3203++0x0
    line.byte 0x00 "AUD_CTS1,AUD_CTS1"
        hexmask.byte.byte 0x00 0.--8. 1. " AUDCTS ,HDMI Audio Clock Regenerator CTS calculated value."
width 9.
group.byte 0x3204++0x0
    line.byte 0x00 "AUD_CTS2,AUD_CTS2"
        hexmask.byte.byte 0x00 0.--8. 1. " AUDCTS ,HDMI Audio Clock Regenerator CTS calculated value."
width 9.
group.byte 0x3205++0x0
    line.byte 0x00 "AUD_CTS3,AUD_CTS3"
        hexmask.byte.byte 0x00 0.--4. 1. " AUDCTS ,HDMI Audio Clock Regenerator CTS calculated value."
width 14.
group.byte 0x3600++0x0
    line.byte 0x00 "AHB_DMA_CONF0,Audio DMA Start Register"
        bitfld.byte 0x00 0. " BURST_MODE ," "0,1"
        textline "             "
        hexmask.byte.byte 0x00 1.--3. 1. " INCR_TYPE ,Forced size burst mode."
        textline "             "
        bitfld.byte 0x00 3. " ENABLE_HLOCK ,Enable request of locked burst AHB mechanism." "0,1"
        textline "             "
        bitfld.byte 0x00 4. " HBR ,HBR packets enable." "0,1"
        textline "             "
        bitfld.byte 0x00 7. " SW_FIFO_RST ,This is the software reset bit for the audio and FIFOs clear." "0,1"
width 14.
group.byte 0x3601++0x0
    line.byte 0x00 "AHB_DMA_START,AHB_DMA_START"
        bitfld.byte 0x00 0. " DATA_BUFFER_READY ,Data buffer ready" "0,1"
width 13.
group.byte 0x3602++0x0
    line.byte 0x00 "AHB_DMA_STOP,Audio DMA Stop Register"
        bitfld.byte 0x00 0. " STOP_DMA_TRANSACTION ,Stop DMA transaction" "0,1"
width 15.
group.byte 0x3603++0x0
    line.byte 0x00 "AHB_DMA_THRSLD,Audio DMA FIFO Threshold Register"
        hexmask.byte.byte 0x00 0.--8. 1. " FIFO_THRESHOLD ,FIFO medium threshold occupation value"
width 17.
group.byte 0x3604++0x0
    line.byte 0x00 "AHB_DMA_STRADDR0,Audio DMA Start Address Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " INITIAL_ADDR ,Defines init_addr[7:0] for bits 7-0 to initiate DMA burst transactions"
width 17.
group.byte 0x3605++0x0
    line.byte 0x00 "AHB_DMA_STRADDR1,Audio DMA Start Address Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " INITIAL_ADDR ,Defines init_addr[15:8] for bits 7-0 to initiate DMA burst transactions"
width 17.
group.byte 0x3606++0x0
    line.byte 0x00 "AHB_DMA_STRADDR2,Audio DMA Start Address Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " INITIAL_ADDR ,Defines init_addr[23:16] for bits 7-0 to initiate DMA burst transactions"
width 17.
group.byte 0x3607++0x0
    line.byte 0x00 "AHB_DMA_STRADDR3,Audio DMA Start Address Register 3"
        hexmask.byte.byte 0x00 0.--8. 1. " INITIAL_ADDR ,Defines init_addr[31:24] for bits 7-0 to initiate DMA burst transactions"
width 17.
group.byte 0x3608++0x0
    line.byte 0x00 "AHB_DMA_STPADDR0,Audio DMA Stop Address Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " FINAL_ADDR ,Defines final_addr[7:0] for bits 7-0 to initiate DMA burst transactions"
width 17.
group.byte 0x3609++0x0
    line.byte 0x00 "AHB_DMA_STPADDR1,Audio DMA Stop Address Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " FINAL_ADDR ,Defines final_addr[15:8] for bits 7-0 to initiate DMA burst transactions"
width 17.
group.byte 0x360a++0x0
    line.byte 0x00 "AHB_DMA_STPADDR2,Audio DMA Stop Address Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " FINAL_ADDR ,Defines final_addr[23:16] for bits 7-0 to initiate DMA burst transactions"
width 17.
group.byte 0x360b++0x0
    line.byte 0x00 "AHB_DMA_STPADDR3,Audio DMA Stop Address Register 3"
        hexmask.byte.byte 0x00 0.--8. 1. " FINAL_ADDR ,Defines final_addr[31:24] for bits 7-0 to initiate DMA burst transactions"
width 17.
rgroup.byte 0x360c++0x0
    line.byte 0x00 "AHB_DMA_BSTADDR0,Audio DMA Burst Start Address Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " BURST_START ,Start address for the current burst operation"
width 17.
rgroup.byte 0x360d++0x0
    line.byte 0x00 "AHB_DMA_BSTADDR1,Audio DMA Burst Start Address Register 1"
        hexmask.byte.byte 0x00 0.--8. 1. " BURST_START ,Start address for the current burst operation"
width 17.
rgroup.byte 0x360e++0x0
    line.byte 0x00 "AHB_DMA_BSTADDR2,Audio DMA Burst Start Address Register 2"
        hexmask.byte.byte 0x00 0.--8. 1. " BURST_START ,Start address for the current burst operation"
width 17.
rgroup.byte 0x360f++0x0
    line.byte 0x00 "AHB_DMA_BSTADDR3,Audio DMA Burst Start Address Register 3"
        hexmask.byte.byte 0x00 0.--8. 1. " BURST_START ,Start address for the current burst operation"
width 18.
rgroup.byte 0x3610++0x0
    line.byte 0x00 "AHB_DMA_MBLENGTH0,Audio DMA Burst Length Register 0"
        hexmask.byte.byte 0x00 0.--8. 1. " MBURSTLENGTH ,Requested burst length"
width 18.
rgroup.byte 0x3611++0x0
    line.byte 0x00 "AHB_DMA_MBLENGTH1,Audio DMA Burst Length Register 1"
        bitfld.byte 0x00 0. " MBURSTLENGTH ,Requested burst length" "0,1"
        textline "                 "
        bitfld.byte 0x00 1. " MBURSTLENGTH1 ,Requested burst length" "0,1"
        textline "                 "
        bitfld.byte 0x00 2. " MBURSTLENGTH2 ,Requested burst length" "0,1"
width 13.
rgroup.byte 0x3612++0x0
    line.byte 0x00 "AHB_DMA_STAT,Audio DMA Interrupt Status Register"
        bitfld.byte 0x00 0. " STATFIFOEMPTY ,Status of audio FIFO empty interrupt." "0,1"
        textline "            "
        bitfld.byte 0x00 1. " STATFIFOFULL ,Status of audio FIFO full interrupt." "0,1"
        textline "            "
        bitfld.byte 0x00 2. " STATTHRFIFOEMPTY ,Status of audio FIFO empty when audio FIFO has less than four samples." "0,1"
        textline "            "
        bitfld.byte 0x00 4. " STATERROR ,Status of error interrupt." "0,1"
        textline "            "
        bitfld.byte 0x00 5. " STATLOSTOWNERSHIP ,Status of master lost ownership when in burst transfer." "0,1"
        textline "            "
        bitfld.byte 0x00 6. " STATRETRYSPLIT ,Status of retry/split interrupt." "0,1"
        textline "            "
        bitfld.byte 0x00 7. " STATDONE ,Status of DMA end of operation interrupt." "0,1"
width 12.
rgroup.byte 0x3613++0x0
    line.byte 0x00 "AHB_DMA_INT,Audio DMA Interrupt Register"
        bitfld.byte 0x00 0. " INTFIFOEMPTY ,Audio FIFO empty interrupt." "0,1"
        textline "           "
        bitfld.byte 0x00 1. " INTFIFOFULL ,Audio FIFO full interrupt." "0,1"
        textline "           "
        bitfld.byte 0x00 2. " INTTHRFIFOEMPTY ,Audio FIFO empty interrupt when audio FIFO has less than four samples." "0,1"
        textline "           "
        bitfld.byte 0x00 4. " INTERROR ,Error interrupt." "0,1"
        textline "           "
        bitfld.byte 0x00 5. " INTLOSTOWNERSHIP ,Master lost ownership interrupt when in burst transfer." "0,1"
        textline "           "
        bitfld.byte 0x00 6. " INTRETRYSPLIT ,Retry/split interrupt." "0,1"
        textline "           "
        bitfld.byte 0x00 7. " INTDONE ,DMA end of operation interrupt." "0,1"
width 13.
group.byte 0x3614++0x0
    line.byte 0x00 "AHB_DMA_MASK,Audio DMA Mask Interrupt Register"
        bitfld.byte 0x00 0. " FIFO_EMPTY_MASK ,Audio FIFO empty interrupt mask." "0,1"
        textline "            "
        bitfld.byte 0x00 1. " FIFO_FULL_MASK ,Audio FIFO full interrupt mask." "0,1"
        textline "            "
        bitfld.byte 0x00 2. " FIFO_THREMPTY_MASK ,Audio FIFO empty interrupt mask when audio FIFO has less than four samples." "0,1"
        textline "            "
        bitfld.byte 0x00 4. " ERROR_MASK ,Error interrupt mask." "0,1"
        textline "            "
        bitfld.byte 0x00 5. " LOSTOWNERSHIP_MASK ,Master lost ownership interrupt mask when in burst transfer." "0,1"
        textline "            "
        bitfld.byte 0x00 6. " RETRYSPLIT_MASK ,Retry/split interrupt mask." "0,1"
        textline "            "
        bitfld.byte 0x00 7. " DONE_MASK ,DMA end of operation interrupt mask." "0,1"
width 12.
group.byte 0x3615++0x0
    line.byte 0x00 "AHB_DMA_POL,Audio DMA Polarity Interrupt Register"
        bitfld.byte 0x00 0. " FIFO_EMPTY_POLARITY ,Audio FIFO empty interrupt mask." "0,1"
        textline "           "
        bitfld.byte 0x00 1. " FIFO_FULL_POLARITY ,Audio FIFO full interrupt mask." "0,1"
        textline "           "
        bitfld.byte 0x00 2. " FIFO_THRFIFOEMPTY_POLARITY ,Audio FIFO empty interrupt mask when audio FIFO has less than four samples." "0,1"
        textline "           "
        bitfld.byte 0x00 4. " ERROR_POLARITY ,Error interrupt mask." "0,1"
        textline "           "
        bitfld.byte 0x00 5. " LOSTOWNERSHIP_POLARITY ,Master lost ownership interrupt mask when in burst transfer." "0,1"
        textline "           "
        bitfld.byte 0x00 6. " RETRYSPLIT_POLARITY ,Retry/split interrupt mask." "0,1"
        textline "           "
        bitfld.byte 0x00 7. " DONE_POLARITY ,DMA end of operation interrupt mask." "0,1"
width 14.
group.byte 0x3616++0x0
    line.byte 0x00 "AHB_DMA_CONF1,Audio DMA Channel Enable Configuration Register 1"
        bitfld.byte 0x00 0. " CH_IN_EN ,Channel 0 is always enabled." "0,1"
        textline "             "
        bitfld.byte 0x00 1. " CH_IN_EN1 ,Channel 1 is always enabled." "0,1"
        textline "             "
        bitfld.byte 0x00 2. " CH_IN_EN2 ,Channel 2 enable bit" "0,1"
        textline "             "
        bitfld.byte 0x00 3. " CH_IN_EN3 ,Channel 3 enable bit" "0,1"
        textline "             "
        bitfld.byte 0x00 4. " CH_IN_EN4 ,Channel 4 enable bit" "0,1"
        textline "             "
        bitfld.byte 0x00 5. " CH_IN_EN5 ,Channel 5 enable bit" "0,1"
        textline "             "
        bitfld.byte 0x00 6. " CH_IN_EN6 ,Channel 6 enable bit" "0,1"
        textline "             "
        bitfld.byte 0x00 7. " CH_IN_EN7 ,Channel 7 enable bit" "0,1"
width 17.
rgroup.byte 0x3617++0x0
    line.byte 0x00 "AHB_DMA_BUFFSTAT,Audio DMA Buffer Interrupt Status Register"
        bitfld.byte 0x00 0. " BUFF_EMPTY ,Buffer empty flag status" "0,1"
        textline "                "
        bitfld.byte 0x00 1. " BUFF_FULL ,Buffer full flag status" "0,1"
width 16.
rgroup.byte 0x3618++0x0
    line.byte 0x00 "AHB_DMA_BUFFINT,Audio DMA Buffer Interrupt Register"
        bitfld.byte 0x00 0. " INT_BUFF_EMPTY ,Buffer empty flag interrupt" "0,1"
        textline "               "
        bitfld.byte 0x00 1. " INT_BUFF_FULL ,Buffer full flag interrupt" "0,1"
width 17.
group.byte 0x3619++0x0
    line.byte 0x00 "AHB_DMA_BUFFMASK,Audio DMA Buffer Mask Interrupt Register"
        bitfld.byte 0x00 0. " INT_BUFF_EMPTY ,Buffer empty flag mask" "0,1"
        textline "                "
        bitfld.byte 0x00 1. " INT_BUFF_FULL ,Buffer full flag mask" "0,1"
width 16.
group.byte 0x361a++0x0
    line.byte 0x00 "AHB_DMA_BUFFPOL,Audio DMA Buffer Polarity Interrupt Register"
        bitfld.byte 0x00 0. " INT_BUFF_EMPTY ,Buffer empty flag polarity" "0,1"
        textline "               "
        bitfld.byte 0x00 1. " INT_BUFF_FULL ,Buffer full flag polarity" "0,1"
width 10.
group.byte 0x4001++0x0
    line.byte 0x00 "MC_CLKDIS,Main Controller Synchronous Clock Domain Disable Register"
        bitfld.byte 0x00 0. " PIXELCLK_DISABLE ,Pixel clock synchronous disable signal." "0,1"
        textline "         "
        bitfld.byte 0x00 1. " TMDSCLK_DISABLE ,TMDS clock synchronous disable signal." "0,1"
        textline "         "
        bitfld.byte 0x00 2. " PREPCLK_DISABLE ,Pixel Repetition clock synchronous disable signal." "0,1"
        textline "         "
        bitfld.byte 0x00 3. " AUDCLK_DISABLE ,Audio Sampler clock synchronous disable signal." "0,1"
        textline "         "
        bitfld.byte 0x00 4. " CSCCLK_DISABLE ,Color Space Converter clock synchronous disable signal." "0,1"
        textline "         "
        bitfld.byte 0x00 5. " CECCLK_DISABLE ,CEC Engine clock synchronous disable signal." "0,1"
        textline "         "
        bitfld.byte 0x00 6. " HDCPCLK_DISABLE ,HDCP clock synchronous disable signal." "0,1"
width 13.
group.byte 0x4002++0x0
    line.byte 0x00 "MC_SWRSTZREQ,Main Controller Software Reset Register"
        bitfld.byte 0x00 0. " PIXELSWRST_REQ ,Pixel software reset request." "0,1"
        textline "            "
        bitfld.byte 0x00 1. " TMDSSWRST_REQ ,TMDS software reset request." "0,1"
        textline "            "
        bitfld.byte 0x00 2. " PREPSWRST_REQ ,Pixel Repetition clock synchronous disable signal." "0,1"
        textline "            "
        bitfld.byte 0x00 6. " CECSWRST_REQ ,CEC software reset request." "0,1"
width 12.
group.byte 0x4004++0x0
    line.byte 0x00 "MC_FLOWCTRL,Main Controller Feed Through Control Register"
        bitfld.byte 0x00 0. " FEED_THROUGH_OFF ,Video path Feed Through enable bit:" "0,1"
width 11.
group.byte 0x4005++0x0
    line.byte 0x00 "MC_PHYRSTZ,Main Controller PHY Reset Register"
        bitfld.byte 0x00 0. " PHYRSTZ ,HDMI Source PHY active low reset control." "0,1"
width 15.
group.byte 0x4006++0x0
    line.byte 0x00 "MC_LOCKONCLOCK,Main Controller Clock Present Register"
        bitfld.byte 0x00 0. " CECCLK ,CEC clock status." "0,1"
        textline "              "
        bitfld.byte 0x00 4. " PREPCLK ,Pixel repetition clock status." "0,1"
        textline "              "
        bitfld.byte 0x00 5. " TCLKTCLK ,TMDS clock status." "0,1"
        textline "              "
        bitfld.byte 0x00 6. " PCLK ,Pixel clock status." "0,1"
width 15.
group.byte 0x4007++0x0
    line.byte 0x00 "MC_HEACPHY_RST,Main Controller HEAC PHY Reset Register"
        bitfld.byte 0x00 0. " HEACPHYRST ,HEAC PHY reset (active high)" "0,1"
width 8.
group.byte 0x4100++0x0
    line.byte 0x00 "CSC_CFG,Color Space Converter Interpolation and Decimation Configuration Register"
        hexmask.byte.byte 0x00 0.--2. 1. " DECMODE ,Chroma decimation configuration: decmode[1:0] Chroma decimation 00 decimation disabled 01 H d?"
        textline "       "
        hexmask.byte.byte 0x00 4.--6. 1. " INTMODE ,Chroma interpolation configuration: 00 interpolation disabled 01 H u (z) = 1 + z -1 10 H u (z)=1/2 + Z -1 +1/2 z -2 11 interpolation disabled."
width 10.
group.byte 0x4101++0x0
    line.byte 0x00 "CSC_SCALE,Color Space Converter Scale and Deep Color Configuration Register"
        hexmask.byte.byte 0x00 0.--2. 1. " CSC_SCALE ,Defines the csc_scale[1:0] scale factor to apply to all coefficients in Color Space Conversion."
        textline "         "
        hexmask.byte.byte 0x00 4.--8. 1. " CSC_COLORDEPTH ,Color space converter color depth configuration: Other: Reserved."
width 16.
group.byte 0x4102++0x0
    line.byte 0x00 "CSC_COEF_A1_MSB,CSC_COEF_A1_MSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_A1_MSB ,Color Space Conversion A1 MSB coefficient."
width 16.
group.byte 0x4103++0x0
    line.byte 0x00 "CSC_COEF_A1_LSB,CSC_COEF_A1_LSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_A1_LSB ,Color Space Conversion A1 LSB coefficient"
width 16.
group.byte 0x4104++0x0
    line.byte 0x00 "CSC_COEF_A2_MSB,CSC_COEF_A2_MSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_A2_MSB ,Color Space Conversion A2 MSB coefficient."
width 16.
group.byte 0x4105++0x0
    line.byte 0x00 "CSC_COEF_A2_LSB,CSC_COEF_A2_LSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_A2_LSB ,Color Space Conversion A2 LSB coefficient."
width 16.
group.byte 0x4106++0x0
    line.byte 0x00 "CSC_COEF_A3_MSB,CSC_COEF_A3_MSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_A3_MSB ,Color Space Conversion A3 MSB coefficient."
width 16.
group.byte 0x4107++0x0
    line.byte 0x00 "CSC_COEF_A3_LSB,CSC_COEF_A3_LSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_A3_LSB ,Color Space Conversion A3 LSB coefficient."
width 16.
group.byte 0x4108++0x0
    line.byte 0x00 "CSC_COEF_A4_MSB,CSC_COEF_A4_MSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_A4_MSB ,Color Space Conversion A4 MSB coefficient."
width 16.
group.byte 0x4109++0x0
    line.byte 0x00 "CSC_COEF_A4_LSB,CSC_COEF_A4_LSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_A4_LSB ,Color Space Conversion A4 LSB coefficient."
width 16.
group.byte 0x410a++0x0
    line.byte 0x00 "CSC_COEF_B1_MSB,CSC_COEF_B1_MSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_B1_MSB ,Color Space Conversion B1 MSB coefficient."
width 16.
group.byte 0x410b++0x0
    line.byte 0x00 "CSC_COEF_B1_LSB,CSC_COEF_B1_LSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_B1_LSB ,Color Space Conversion B1 LSB coefficient."
width 16.
group.byte 0x410c++0x0
    line.byte 0x00 "CSC_COEF_B2_MSB,CSC_COEF_B2_MSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_B2_MSB ,Color Space Conversion B2 MSB coefficient."
width 16.
group.byte 0x410d++0x0
    line.byte 0x00 "CSC_COEF_B2_LSB,CSC_COEF_B2_LSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_B2_LSB ,Color Space Conversion B2 LSB coefficient."
width 16.
group.byte 0x410e++0x0
    line.byte 0x00 "CSC_COEF_B3_MSB,CSC_COEF_B3_MSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_B3_MSB ,Color Space Conversion B3 MSB coefficient."
width 16.
group.byte 0x410f++0x0
    line.byte 0x00 "CSC_COEF_B3_LSB,CSC_COEF_B3_LSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_B3_LSB ,Color Space Conversion B3 LSB coefficient."
width 16.
group.byte 0x4110++0x0
    line.byte 0x00 "CSC_COEF_B4_MSB,CSC_COEF_B4_MSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_B4_MSB ,Color Space Conversion B4 MSB coefficient."
width 16.
group.byte 0x4111++0x0
    line.byte 0x00 "CSC_COEF_B4_LSB,CSC_COEF_B4_LSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_B4_LSB ,Color Space Conversion B4 LSB coefficient."
width 16.
group.byte 0x4112++0x0
    line.byte 0x00 "CSC_COEF_C1_MSB,CSC_COEF_C1_MSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_C1_MSB ,Color Space Conversion C1 MSB coefficient."
width 16.
group.byte 0x4113++0x0
    line.byte 0x00 "CSC_COEF_C1_LSB,CSC_COEF_C1_LSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_C1_LSB ,Color Space Conversion C1 LSB coefficient."
width 16.
group.byte 0x4114++0x0
    line.byte 0x00 "CSC_COEF_C2_MSB,CSC_COEF_C2_MSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_C2_MSB ,Color Space Conversion C2 MSB coefficient."
width 16.
group.byte 0x4115++0x0
    line.byte 0x00 "CSC_COEF_C2_LSB,CSC_COEF_C2_LSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_C2_LSB ,Color Space Conversion C2 LSB coefficient."
width 16.
group.byte 0x4116++0x0
    line.byte 0x00 "CSC_COEF_C3_MSB,CSC_COEF_C3_MSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_C3_MSB ,Color Space Conversion C3 MSB coefficient."
width 16.
group.byte 0x4117++0x0
    line.byte 0x00 "CSC_COEF_C3_LSB,CSC_COEF_C3_LSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_C3_LSB ,Color Space Conversion C3 LSB coefficient."
width 16.
group.byte 0x4118++0x0
    line.byte 0x00 "CSC_COEF_C4_MSB,CSC_COEF_C4_MSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_C4_MSB ,Color Space Conversion C4 MSB coefficient."
width 16.
group.byte 0x4119++0x0
    line.byte 0x00 "CSC_COEF_C4_LSB,CSC_COEF_C4_LSB"
        hexmask.byte.byte 0x00 0.--8. 1. " CSC_COEF_C4_LSB ,Color Space Conversion C4 LSB coefficient."
width 11.
group.byte 0x5000++0x0
    line.byte 0x00 "A_HDCPCFG0,A_HDCPCFG0"
        bitfld.byte 0x00 0. " HDMIDVI ,Configures the transmitter to operate with a HDMI capable device or with a DVI device." "0,1"
        textline "          "
        bitfld.byte 0x00 1. " EN11FEATURE ,Enable the use of features 1.1 from the transmitter's side" "0,1"
        textline "          "
        bitfld.byte 0x00 2. " RXDETECT ,Information that a RX device was detected connected to the HDMI port" "0,1"
        textline "          "
        bitfld.byte 0x00 3. " AVMUTE ,Command given by the API system to enter in AVMUTE state" "0,1"
        textline "          "
        bitfld.byte 0x00 4. " SYNCRICHECK ,Configure if the Ri check should be done at every 2s even or synchronously to every 128 encrypted frame." "0,1"
        textline "          "
        bitfld.byte 0x00 5. " BYPENCRYPTION ,Bypasses all the data encryption stage." "0,1"
        textline "          "
        bitfld.byte 0x00 6. " I2CFASTMODE ,Enable the I2C fast mode option from the transmitter's side." "0,1"
        textline "          "
        bitfld.byte 0x00 7. " ELVENA ,Enables the Enhanced Link Verification from the transmitter's side." "0,1"
width 11.
group.byte 0x5001++0x0
    line.byte 0x00 "A_HDCPCFG1,A_HDCPCFG1"
        bitfld.byte 0x00 0. " SWRESET ,Software reset signal, active by writing a zero and auto cleared to one in the following cycle." "0,1"
        textline "          "
        bitfld.byte 0x00 1. " ENCRYPTIONDISABLE ,Disable encryption without losing authentication." "0,1"
        textline "          "
        bitfld.byte 0x00 2. " PH2UPSHFTENC ,This bit enables the encoding of packet header in the tmdsch0 bit[0] with cipher[2] instead of the tmdsch0 bit[2]." "0,1"
        textline "          "
        bitfld.byte 0x00 3. " DISSHA1CHECK ,This bit disables the request to the API processor to verify the SHA1 message digest of a received KSV List." "0,1"
width 11.
rgroup.byte 0x5002++0x0
    line.byte 0x00 "A_HDCPOBS0,A_HDCPOBS0"
        bitfld.byte 0x00 0. " HDCPENGAGED ,Informs that the current HDMI link has the HDCP protocol fully engaged." "0,1"
        textline "          "
        hexmask.byte.byte 0x00 1.--4. 1. " DISSHA1CHECK ,Observability register informs in which sub-state the authentication is on."
        textline "          "
        hexmask.byte.byte 0x00 4.--8. 1. " STATEA ,Observability register informs in which state the authentication machine is on."
width 11.
rgroup.byte 0x5003++0x0
    line.byte 0x00 "A_HDCPOBS1,A_HDCPOBS1"
        hexmask.byte.byte 0x00 0.--3. 1. " STATER ,Observability register informs in which state the revocation machine is on."
        textline "          "
        hexmask.byte.byte 0x00 3.--6. 1. " STATEOEG ,Observability register informs in which state the OESS machine is on."
width 11.
rgroup.byte 0x5004++0x0
    line.byte 0x00 "A_HDCPOBS2,A_HDCPOBS2"
        hexmask.byte.byte 0x00 0.--3. 1. " STATEEEG ,Observability register informs in which state the EESS machine is on."
        textline "          "
        hexmask.byte.byte 0x00 3.--6. 1. " STATEE ,Observability register informs in which state the cipher machine is on."
width 11.
rgroup.byte 0x5005++0x0
    line.byte 0x00 "A_HDCPOBS3,A_HDCPOBS3"
        bitfld.byte 0x00 0. " FAST_REAUTHENTICATION ,From RX: Bcap(0x40) bit 0." "0,1"
        textline "          "
        bitfld.byte 0x00 1. " FEATURES_1_1 ,From RX: Bcap(0x40) bit 1." "0,1"
        textline "          "
        bitfld.byte 0x00 2. " HDMI_MODE ,From RX: Bstatus(0x41) bit 12." "0,1"
        textline "          "
        bitfld.byte 0x00 3. " HDMI_RESERVED_2 ,From RX: Bstatus(0x41) bit 13." "0,1"
        textline "          "
        bitfld.byte 0x00 4. " FAST_I_2C ,From RX: Bcap(0x40) bit 4." "0,1"
        textline "          "
        bitfld.byte 0x00 5. " KSV_FIFO_READY ,From RX: Bcap(0x40) bit 5." "0,1"
        textline "          "
        bitfld.byte 0x00 6. " REPEATER ,From RX: Bcap(0x40) bit 6." "0,1"
        textline "          "
        bitfld.byte 0x00 7. " HDMI_RESERVED_1 ,From RX: Bcap(0x40) bit 7." "0,1"
width 12.
wgroup.byte 0x5006++0x0
    line.byte 0x00 "A_APIINTCLR,A_APIINTCLR"
        bitfld.byte 0x00 0. " KSVACCESSINT ,Clear the interruption related to KSV memory access grant for Read-Write access." "0,1"
        textline "           "
        bitfld.byte 0x00 1. " KSVSHA1CALCINT ,Clear the interruption related to KSV list update in memory that needs to be SHA1 verified." "0,1"
        textline "           "
        bitfld.byte 0x00 2. " KEEPOUTERRORINT ,Clear the interruption related to keep out window error." "0,1"
        textline "           "
        bitfld.byte 0x00 3. " LOSTARBITRATION ,Clear the interruption related to I2C arbitration lost." "0,1"
        textline "           "
        bitfld.byte 0x00 4. " I2CNACK ,Clear the interruption related to I2C NACK reception." "0,1"
        textline "           "
        bitfld.byte 0x00 6. " HDCP_FAILED ,Clear the interruption related to HDCP authentication process failed." "0,1"
        textline "           "
        bitfld.byte 0x00 7. " HDCP_ENGAGED ,Clear the interruption related to HDCP authentication process successful." "0,1"
width 13.
rgroup.byte 0x5007++0x0
    line.byte 0x00 "A_APIINTSTAT,A_APIINTSTAT"
        bitfld.byte 0x00 0. " KSVACCESSINT ,Notifies that the KSV memory access as been guaranteed for Read-Write access." "0,1"
        textline "            "
        bitfld.byte 0x00 1. " KSVSHA1CALCINT ,Notifies that the HDCP13TCTRL core as updated a KSV list in memory that needs to be SHA1 verified." "0,1"
        textline "            "
        bitfld.byte 0x00 2. " KEEPOUTERRORINT ,Notifies that during the keep out window, the ctlout[3:0] bus was used besides control period." "0,1"
        textline "            "
        bitfld.byte 0x00 3. " LOSTARBITRATION ,Notifies that the I2C lost the arbitration to communicate." "0,1"
        textline "            "
        bitfld.byte 0x00 4. " I2CNACK ,Notifies that the I2C received a NACK from slave device." "0,1"
        textline "            "
        bitfld.byte 0x00 6. " HDCP_FAILED ,Notifies that the HDCP authentication process was failed." "0,1"
        textline "            "
        bitfld.byte 0x00 7. " HCDP_ENGAGED ,Notifies that the HDCP authentication process was successful." "0,1"
width 12.
group.byte 0x5008++0x0
    line.byte 0x00 "A_APIINTMSK,A_APIINTMSK"
        bitfld.byte 0x00 0. " KSVACCESSINT ,Masks the interruption related to KSV memory access grant for Read-Write access." "0,1"
        textline "           "
        bitfld.byte 0x00 1. " KSVSHA1CALCINT ,Masks the interruption related to KSV list update in memory that needs to be SHA1 verified." "0,1"
        textline "           "
        bitfld.byte 0x00 2. " KEEPOUTERRORINT ,Masks the interruption related to keep out window error." "0,1"
        textline "           "
        bitfld.byte 0x00 3. " LOSTARBITRATION ,Masks the interruption related to I2C arbitration lost." "0,1"
        textline "           "
        bitfld.byte 0x00 4. " I2CNACK ,Masks the interruption related to I2C NACK reception." "0,1"
        textline "           "
        bitfld.byte 0x00 6. " HDCP_FAILED ,Masks the interruption related to HDCP authentication process failed." "0,1"
        textline "           "
        bitfld.byte 0x00 7. " HCDP_ENGAGED ,Masks the interruption related to HDCP authentication process successful." "0,1"
width 12.
group.byte 0x5009++0x0
    line.byte 0x00 "A_VIDPOLCFG,A_VIDPOLCFG"
        bitfld.byte 0x00 1. " HSYNCPOL ,Configuration of the video Horizontal synchronism polarity." "0,1"
        textline "           "
        bitfld.byte 0x00 3. " VSYNCPOL ,Configuration of the video Vertical synchronism polarity." "0,1"
        textline "           "
        bitfld.byte 0x00 4. " DATAENPOL ,Configuration of the video data enable polarity." "0,1"
        textline "           "
        hexmask.byte.byte 0x00 5.--7. 1. " UNENCRYPTCONF ,Configuration of the color sent when sending unencrypted video data"
width 11.
group.byte 0x500a++0x0
    line.byte 0x00 "A_OESSWCFG,A_OESSWCFG"
        hexmask.byte.byte 0x00 0.--8. 1. " A_OESSWCFG ,Size of the window of opportunity for the OESS mode."
width 13.
rgroup.byte 0x5014++0x0
    line.byte 0x00 "A_COREVERLSB,A_COREVERLSB"
        hexmask.byte.byte 0x00 0.--8. 1. " A_COREVERLSB ,Design ID number"
width 13.
rgroup.byte 0x5015++0x0
    line.byte 0x00 "A_COREVERMSB,A_COREVERMSB"
        hexmask.byte.byte 0x00 0.--8. 1. " A_COREVERMSB ,Revision ID number"
width 13.
group.byte 0x5016++0x0
    line.byte 0x00 "A_KSVMEMCTRL,A_KSVMEMCTRL"
        bitfld.byte 0x00 0. " KSVMEMREQUEST ,Request access to the KSV memory, must be de-asserted after the access is completed by the system." "0,1"
        textline "            "
        bitfld.byte 0x00 1. " KSVMEMACCESS ,Notification that the KSV memory access as been guaranteed." "0,1"
        textline "            "
        bitfld.byte 0x00 2. " KSVCTRLUPD ,Set to inform that the KSV list in memory has been analyzed and the response to it's Message Digest as been updated." "0,1"
        textline "            "
        bitfld.byte 0x00 3. " SHA1FAIL ,Notification that the KSV list's message digest is correct or not." "0,1"
width 14.
rgroup.byte 0x7800++0x0
    line.byte 0x00 "HDCPREG_BKSV0,HDCPREG_BKSV0"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_BKSV0 ,Contains the value of BKSV[7:0] During HDCP authentication, the HDCP Transmitter (Device A) sends an A Key Selection Vector (AKSV) to the HDCP Receiver (Device B), which affirms its authorization to the HDCP Transmitter by sending a B Key Selection Vector (BKSV)."
width 14.
rgroup.byte 0x7801++0x0
    line.byte 0x00 "HDCPREG_BKSV1,HDCPREG_BKSV1"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_BKSV1 ,Contains the value of BKSV[15:8] During HDCP authentication, the HDCP Transmitter (Device A) sends an A Key Selection Vector (AKSV) to the HDCP Receiver (Device B), which affirms its authorization to the HDCP Transmitter by sending a B Key Selection Vector (BKSV)."
width 14.
rgroup.byte 0x7802++0x0
    line.byte 0x00 "HDCPREG_BKSV2,HDCPREG_BKSV2"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_BKSV2 ,Contains the value of BKSV[23:16] During HDCP authentication, the HDCP Transmitter (Device A) sends an A Key Selection Vector (AKSV) to the HDCP Receiver (Device B), which affirms its authorization to the HDCP Transmitter by sending a B Key Selection Vector (BKSV)."
width 14.
rgroup.byte 0x7803++0x0
    line.byte 0x00 "HDCPREG_BKSV3,HDCPREG_BKSV3"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_BKSV3 ,Contains the value of BKSV[31:24] During HDCP authentication, the HDCP Transmitter (Device A) sends an A Key Selection Vector (AKSV) to the HDCP Receiver (Device B), which affirms its authorization to the HDCP Transmitter by sending a B Key Selection Vector (BKSV)."
width 14.
rgroup.byte 0x7804++0x0
    line.byte 0x00 "HDCPREG_BKSV4,HDCPREG_BKSV4"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_BKSV4 ,Contains the value of BKSV[39:32] During HDCP authentication, the HDCP Transmitter (Device A) sends an A Key Selection Vector (AKSV) to the HDCP Receiver (Device B), which affirms its authorization to the HDCP Transmitter by sending a B Key Selection Vector (BKSV)."
width 15.
group.byte 0x7805++0x0
    line.byte 0x00 "HDCPREG_ANCONF,HDCPREG_ANCONF"
        bitfld.byte 0x00 0. " OANBYPASS ,When oanbypass=1, the value of AN used in the HDCP engine comes from the registers HDCPREG_AN0 to HDCPREG_AN7." "0,1"
width 12.
group.byte 0x7806++0x0
    line.byte 0x00 "HDCPREG_AN0,HDCPREG_AN0"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_AN0 ,Contains the value of AN[7:0]"
width 12.
group.byte 0x7807++0x0
    line.byte 0x00 "HDCPREG_AN1,HDCPREG_AN1"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_AN1 ,Contains the value of AN[15:8]"
width 12.
group.byte 0x7808++0x0
    line.byte 0x00 "HDCPREG_AN2,HDCPREG_AN2"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_AN2 ,Contains the value of AN[23:16]"
width 12.
group.byte 0x7809++0x0
    line.byte 0x00 "HDCPREG_AN3,HDCPREG_AN3"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_AN3 ,Contains the value of AN[31:24]"
width 12.
group.byte 0x780a++0x0
    line.byte 0x00 "HDCPREG_AN4,HDCPREG_AN4"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_AN4 ,Contains the value of AN[39:32]"
width 12.
group.byte 0x780b++0x0
    line.byte 0x00 "HDCPREG_AN5,HDCPREG_AN5"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_AN5 ,Contains the value of AN[47:40]"
width 12.
group.byte 0x780c++0x0
    line.byte 0x00 "HDCPREG_AN6,HDCPREG_AN6"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_AN6 ,Contains the value of AN[55:48]"
width 12.
group.byte 0x780d++0x0
    line.byte 0x00 "HDCPREG_AN7,HDCPREG_AN7"
        hexmask.byte.byte 0x00 0.--8. 1. " HDCPREG_AN7 ,Contains the value of AN[63:56]"
width 9.
group.byte 0x7d00++0x0
    line.byte 0x00 "CEC_CTRL,CEC_CTRL"
        bitfld.byte 0x00 0. " SEND ," "0,1"
        textline "        "
        hexmask.byte.byte 0x00 1.--3. 1. " FRAME_TYP ,"
        textline "        "
        bitfld.byte 0x00 3. " BC_NACK ," "0,1"
        textline "        "
        bitfld.byte 0x00 4. " STANDBY ," "0,1"
width 9.
group.byte 0x7d02++0x0
    line.byte 0x00 "CEC_MASK,CEC_MASK"
        bitfld.byte 0x00 0. " DONE_MASK ,The current transmission is successful (for initiator only)." "0,1"
        textline "        "
        bitfld.byte 0x00 1. " EOM_MASK ,EOM is detected so that the received data is ready in the receiver data buffer (for follower only)." "0,1"
        textline "        "
        bitfld.byte 0x00 2. " NACK_MASK ,A frame is not acknowledged in a directly addressed message." "0,1"
        textline "        "
        bitfld.byte 0x00 3. " ARB_LOST_MASK ,The initiator losses the CEC line arbitration to a second initiator." "0,1"
        textline "        "
        bitfld.byte 0x00 4. " ERROR_INIT_MASK ,An error is detected on cec line (for initiator only)." "0,1"
        textline "        "
        bitfld.byte 0x00 5. " ERROR_FOLL__MASK ,An error is notified by a follower." "0,1"
        textline "        "
        bitfld.byte 0x00 6. " WAKEUP_MASK ,Follower wake-up signal mask" "0,1"
width 11.
group.byte 0x7d05++0x0
    line.byte 0x00 "CEC_ADDR_L,CEC_ADDR_L"
        bitfld.byte 0x00 0. " CEC_ADDR_L ,Logical address 0 - Device TV" "0,1"
        textline "          "
        bitfld.byte 0x00 1. " CEC_ADDR_L1 ,Logical address 1 - Recording Device 1" "0,1"
        textline "          "
        bitfld.byte 0x00 2. " CEC_ADDR_L2 ,Logical address 2 - Recording Device 2" "0,1"
        textline "          "
        bitfld.byte 0x00 3. " CEC_ADDR_L3 ,Logical address 3 - Tuner 1" "0,1"
        textline "          "
        bitfld.byte 0x00 4. " CEC_ADDR_L4 ,Logical address 4 - Playback Device 1" "0,1"
        textline "          "
        bitfld.byte 0x00 5. " CEC_ADDR_L5 ,Logical address 5 - Audio System" "0,1"
        textline "          "
        bitfld.byte 0x00 6. " CEC_ADDR_L6 ,Logical address 6 - Tuner 2" "0,1"
        textline "          "
        bitfld.byte 0x00 7. " CEC_ADDR_L7 ,Logical address 7 - Tuner 3" "0,1"
width 11.
group.byte 0x7d06++0x0
    line.byte 0x00 "CEC_ADDR_H,CEC_ADDR_H"
        bitfld.byte 0x00 0. " CEC_ADDR_H ,Logical address 8 - Playback Device 2" "0,1"
        textline "          "
        bitfld.byte 0x00 1. " CEC_ADDR_H1 ,Logical address 9 - Playback Device 3" "0,1"
        textline "          "
        bitfld.byte 0x00 2. " CEC_ADDR_H2 ,Logical address 10 - Tuner 4" "0,1"
        textline "          "
        bitfld.byte 0x00 3. " CEC_ADDR_H3 ,Logical address 11 - Playback Device 3" "0,1"
        textline "          "
        bitfld.byte 0x00 4. " CEC_ADDR_H4 ,Logical address 12 - Reserved" "0,1"
        textline "          "
        bitfld.byte 0x00 5. " CEC_ADDR_H5 ,Logical address 13 - Reserved" "0,1"
        textline "          "
        bitfld.byte 0x00 6. " CEC_ADDR_H6 ,Logical address 14 - Free use" "0,1"
        textline "          "
        bitfld.byte 0x00 7. " CEC_ADDR_H7 ,Logical address 15 - Unregistered (as initiator address), Broadcast (as destination address)" "0,1"
width 11.
group.byte 0x7d07++0x0
    line.byte 0x00 "CEC_TX_CNT,CEC_TX_CNT"
        hexmask.byte.byte 0x00 0.--5. 1. " CEC_TX_CNT ,CEC Transmitter Counter register: Value after Reset: 5'b00000"
width 11.
rgroup.byte 0x7d08++0x0
    line.byte 0x00 "CEC_RX_CNT,CEC_RX_CNT"
        hexmask.byte.byte 0x00 0.--5. 1. " CEC_RX_CNT ,CEC Receiver Counter register Value after Reset: 5'b00000"
width 13.
group.byte 0x7d10++0x0
    line.byte 0x00 "CEC_TX_DATA0,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 13.
group.byte 0x7d11++0x0
    line.byte 0x00 "CEC_TX_DATA1,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 13.
group.byte 0x7d12++0x0
    line.byte 0x00 "CEC_TX_DATA2,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 13.
group.byte 0x7d13++0x0
    line.byte 0x00 "CEC_TX_DATA3,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 13.
group.byte 0x7d14++0x0
    line.byte 0x00 "CEC_TX_DATA4,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 13.
group.byte 0x7d15++0x0
    line.byte 0x00 "CEC_TX_DATA5,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 13.
group.byte 0x7d16++0x0
    line.byte 0x00 "CEC_TX_DATA6,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 13.
group.byte 0x7d17++0x0
    line.byte 0x00 "CEC_TX_DATA7,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 13.
group.byte 0x7d18++0x0
    line.byte 0x00 "CEC_TX_DATA8,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 13.
group.byte 0x7d19++0x0
    line.byte 0x00 "CEC_TX_DATA9,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 14.
group.byte 0x7d1a++0x0
    line.byte 0x00 "CEC_TX_DATA10,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 14.
group.byte 0x7d1b++0x0
    line.byte 0x00 "CEC_TX_DATA11,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 14.
group.byte 0x7d1c++0x0
    line.byte 0x00 "CEC_TX_DATA12,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 14.
group.byte 0x7d1d++0x0
    line.byte 0x00 "CEC_TX_DATA13,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 14.
group.byte 0x7d1e++0x0
    line.byte 0x00 "CEC_TX_DATA14,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 14.
group.byte 0x7d1f++0x0
    line.byte 0x00 "CEC_TX_DATA15,CEC_TX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " RX_DATA ,Header block in CEC_RX_DATA0 Data blockn in CEC_RX_DATAn"
width 13.
rgroup.byte 0x7d20++0x0
    line.byte 0x00 "CEC_RX_DATA0,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 13.
rgroup.byte 0x7d21++0x0
    line.byte 0x00 "CEC_RX_DATA1,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 13.
rgroup.byte 0x7d22++0x0
    line.byte 0x00 "CEC_RX_DATA2,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 13.
rgroup.byte 0x7d23++0x0
    line.byte 0x00 "CEC_RX_DATA3,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 13.
rgroup.byte 0x7d24++0x0
    line.byte 0x00 "CEC_RX_DATA4,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 13.
rgroup.byte 0x7d25++0x0
    line.byte 0x00 "CEC_RX_DATA5,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 13.
rgroup.byte 0x7d26++0x0
    line.byte 0x00 "CEC_RX_DATA6,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 13.
rgroup.byte 0x7d27++0x0
    line.byte 0x00 "CEC_RX_DATA7,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 13.
rgroup.byte 0x7d28++0x0
    line.byte 0x00 "CEC_RX_DATA8,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 13.
rgroup.byte 0x7d29++0x0
    line.byte 0x00 "CEC_RX_DATA9,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 14.
rgroup.byte 0x7d2a++0x0
    line.byte 0x00 "CEC_RX_DATA10,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 14.
rgroup.byte 0x7d2b++0x0
    line.byte 0x00 "CEC_RX_DATA11,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 14.
rgroup.byte 0x7d2c++0x0
    line.byte 0x00 "CEC_RX_DATA12,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 14.
rgroup.byte 0x7d2d++0x0
    line.byte 0x00 "CEC_RX_DATA13,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 14.
rgroup.byte 0x7d2e++0x0
    line.byte 0x00 "CEC_RX_DATA14,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 14.
rgroup.byte 0x7d2f++0x0
    line.byte 0x00 "CEC_RX_DATA15,CEC_RX_DATAn"
        hexmask.byte.byte 0x00 0.--8. 1. " TX_DATA ,Header block in CEC_TX_DATA0 Data blockn in CEC_TX_DATAn"
width 9.
group.byte 0x7d30++0x0
    line.byte 0x00 "CEC_LOCK,CEC_LOCK"
        bitfld.byte 0x00 0. " LOCKED_BUFFER ,When a frame is received, this bit would be active." "0,1"
width 13.
group.byte 0x7d31++0x0
    line.byte 0x00 "CEC_WKUPCTRL,CEC_WKUPCTRL"
        bitfld.byte 0x00 0. " OPCODE0X04EN ,OPCODE 0x04 wake up enable" "0,1"
        textline "            "
        bitfld.byte 0x00 1. " OPCODE0X0DEN ,OPCODE 0x0D wake up enable" "0,1"
        textline "            "
        bitfld.byte 0x00 2. " OPCODE0X41EN ,OPCODE 0x41 wake up enable" "0,1"
        textline "            "
        bitfld.byte 0x00 3. " OPCODE0X42EN ,OPCODE 0x42 wake up enable" "0,1"
        textline "            "
        bitfld.byte 0x00 4. " OPCODE0X44EN ,OPCODE 0x44 wake up enable" "0,1"
        textline "            "
        bitfld.byte 0x00 5. " OPCODE0X70EN ,OPCODE 0x70 wake up enable" "0,1"
        textline "            "
        bitfld.byte 0x00 6. " OPCODE0X82EN ,OPCODE 0x82 wake up enable" "0,1"
        textline "            "
        bitfld.byte 0x00 7. " OPCODE0X86EN ,OPCODE 0x86 wake up enable" "0,1"
width 11.
group.byte 0x7e00++0x0
    line.byte 0x00 "I2CM_SLAVE,I2CM_SLAVE"
        hexmask.byte.byte 0x00 0.--7. 1. " SLAVEADDR ,Slave address to be sent during read and write normal operations."
width 13.
group.byte 0x7e01++0x0
    line.byte 0x00 "I2CM_ADDRESS,I2CM_ADDRESS"
        hexmask.byte.byte 0x00 0.--8. 1. " ADDRESS ,Register address for read and write operations."
width 11.
group.byte 0x7e02++0x0
    line.byte 0x00 "I2CM_DATAO,I2CM_DATAO"
        hexmask.byte.byte 0x00 0.--8. 1. " DATAO ,Data to be written on register pointed by address[7:0]."
width 11.
rgroup.byte 0x7e03++0x0
    line.byte 0x00 "I2CM_DATAI,I2CM_DATAI"
        hexmask.byte.byte 0x00 0.--8. 1. " DATAI ,Data read from register pointed by address[7:0]."
width 15.
wgroup.byte 0x7e04++0x0
    line.byte 0x00 "I2CM_OPERATION,I2CM_OPERATION"
        bitfld.byte 0x00 0. " RD ,Read operation request." "0,1"
        textline "              "
        bitfld.byte 0x00 1. " RD_EXT ,After writing 1'b1 to rd_ext bit a extended data read operation is started (E- DDC read operation)." "0,1"
        textline "              "
        bitfld.byte 0x00 4. " WR ,Write operation request." "0,1"
width 9.
group.byte 0x7e05++0x0
    line.byte 0x00 "I2CM_INT,I2CM_INT"
        bitfld.byte 0x00 0. " DONE_STATUS ,Operation done status bit." "0,1"
        textline "        "
        bitfld.byte 0x00 1. " DONE_INTERRUPT ,Operation done interrupt bit." "0,1"
        textline "        "
        bitfld.byte 0x00 2. " DONE_MASK ,Done interrupt mask signal." "0,1"
        textline "        "
        bitfld.byte 0x00 3. " DONE_POL ,Done interrupt polarity configuration." "0,1"
width 12.
group.byte 0x7e06++0x0
    line.byte 0x00 "I2CM_CTLINT,I2CM_CTLINT"
        bitfld.byte 0x00 0. " ARBITRATION_STATUS ,Arbitration error status bit." "0,1"
        textline "           "
        bitfld.byte 0x00 1. " ARBITRATION_INTERRUPT ,Arbitration error interrupt bit." "0,1"
        textline "           "
        bitfld.byte 0x00 2. " ARBITRATION_MASK ,Arbitration error interrupt mask signal." "0,1"
        textline "           "
        bitfld.byte 0x00 3. " ARBITRATION_POL ,Arbitration error interrupt polarity configuration." "0,1"
        textline "           "
        bitfld.byte 0x00 4. " NACK_STATUS ,Not acknowledge error status bit." "0,1"
        textline "           "
        bitfld.byte 0x00 5. " NACK_INTERRUPT ,Not acknowledge error interrupt bit." "0,1"
        textline "           "
        bitfld.byte 0x00 6. " NACK_MASK ,Not acknowledge error interrupt mask signal." "0,1"
        textline "           "
        bitfld.byte 0x00 7. " NACK_POL ,Not acknowledge error interrupt polarity configuration." "0,1"
width 9.
group.byte 0x7e07++0x0
    line.byte 0x00 "I2CM_DIV,I2CM_DIV"
        bitfld.byte 0x00 3. " FAST_STD_MODE ,Sets the I2C Master to work in Fast Mode or Standard Mode:" "0,1"
width 13.
group.byte 0x7e08++0x0
    line.byte 0x00 "I2CM_SEGADDR,I2CM_SEGADDR"
        hexmask.byte.byte 0x00 0.--7. 1. " SEGADDR ,E-DDC Extended read segment address"
width 14.
group.byte 0x7e09++0x0
    line.byte 0x00 "I2CM_SOFTRSTZ,I2CM_SOFTRSTZ"
        bitfld.byte 0x00 0. " I2C_SOFTRST ,I2C Master Software Reset." "0,1"
width 12.
group.byte 0x7e0a++0x0
    line.byte 0x00 "I2CM_SEGPTR,I2CM_SEGPTR"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CM_SEGPTR ,I2CM_SEGPTR is used for EDID reading operations, particularly for the Extended Data Read Operation (See "") which is used for Enhanced DDC."
width 24.
group.byte 0x7e0b++0x0
    line.byte 0x00 "I2CM_SS_SCL_HCNT_1_ADDR,I2CM_SS_SCL_HCNT_1_ADDR"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_SS_SCL_HCNT ,Value after Reset: 8'h00"
width 24.
group.byte 0x7e0c++0x0
    line.byte 0x00 "I2CM_SS_SCL_HCNT_0_ADDR,I2CM_SS_SCL_HCNT_0_ADDR"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_SS_SCL_HCNT ,Value after Reset: 8'h6C"
width 24.
group.byte 0x7e0d++0x0
    line.byte 0x00 "I2CM_SS_SCL_LCNT_1_ADDR,I2CM_SS_SCL_LCNT_1_ADDR"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_SS_SCL_LCNT ,Value after Reset: 8'h00"
width 24.
group.byte 0x7e0e++0x0
    line.byte 0x00 "I2CM_SS_SCL_LCNT_0_ADDR,I2CM_SS_SCL_LCNT_0_ADDR"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_SS_SCL_LCNT ,Value after Reset: 8'h7F"
width 24.
group.byte 0x7e0f++0x0
    line.byte 0x00 "I2CM_FS_SCL_HCNT_1_ADDR,I2CM_FS_SCL_HCNT_1_ADDR"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_FS_SCL_HCNT ,Value after Reset: 8'h00"
width 24.
group.byte 0x7e10++0x0
    line.byte 0x00 "I2CM_FS_SCL_HCNT_0_ADDR,I2CM_FS_SCL_HCNT_0_ADDR"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_FS_SCL_HCNT ,Value after Reset: 8'h11"
width 24.
group.byte 0x7e11++0x0
    line.byte 0x00 "I2CM_FS_SCL_LCNT_1_ADDR,I2CM_FS_SCL_LCNT_1_ADDR"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_FS_SCL_LCNT ,Value after Reset: 8'h00"
width 24.
group.byte 0x7e12++0x0
    line.byte 0x00 "I2CM_FS_SCL_LCNT_0_ADDR,I2CM_FS_SCL_LCNT_0_ADDR"
        hexmask.byte.byte 0x00 0.--8. 1. " I2CMP_FS_SCL_LCNT ,Value after Reset: 8'h24"
width 18.
group.byte 0x7f00++0x0
    line.byte 0x00 "BASE_POINTER_ADDR,BASE_POINTER_ADDR"
        hexmask.byte.byte 0x00 0.--7. 1. " BASE_POINTER_BASE_ADDR ,Defines the base address for base pointer operation mode."
        textline "                 "
        bitfld.byte 0x00 7. " EN_BASE_POINTER_ADDR ,Enables the base pointer operation mode." "0,1"


tree.end



;--------------------------------------------------------------------------------
; I2C
;--------------------------------------------------------------------------------
tree.open "I2C"
    tree "I2C1"
        base ad:0x021a0000

width 5.
group.word 0x0++0x1
    line.word 0x00 "IADR,I2C Address Register"
        hexmask.word.byte 0x00 1.--8. 1. " ADR ,Slave address."
width 5.
group.word 0x4++0x1
    line.word 0x00 "IFDR,I2C Frequency Divider Register"
        hexmask.word.byte 0x00 0.--6. 1. " IC ,I2C clock rate."
width 5.
group.word 0x8++0x1
    line.word 0x00 "I2CR,I2C Control Register"
        bitfld.word 0x00 2. " RSTA ,Repeat start." "0,1"
        textline "    "
        bitfld.word 0x00 3. " TXAK ,Transmit acknowledge enable." "0,1"
        textline "    "
        bitfld.word 0x00 4. " MTX ,Transmit/receive mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 5. " MSTA ,Master/slave mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IIEN ,I2C interrupt enable." "0,1"
        textline "    "
        bitfld.word 0x00 7. " IEN ,I2C enable." "0,1"
width 5.
group.word 0xc++0x1
    line.word 0x00 "I2SR,I2C Status Register"
        bitfld.word 0x00 0. " RXAK ,Received acknowledge." "0,1"
        textline "    "
        bitfld.word 0x00 1. " IIF ,I2C interrupt." "0,1"
        textline "    "
        bitfld.word 0x00 2. " SRW ,Slave read/write." "0,1"
        textline "    "
        bitfld.word 0x00 4. " IAL ,Arbitration lost." "0,1"
        textline "    "
        bitfld.word 0x00 5. " IBB ,I2C bus busy bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IAAS ,I2C addressed as a slave bit." "0,1"
        textline "    "
        bitfld.word 0x00 7. " ICF ,Data transferring bit." "0,1"
width 5.
group.word 0x10++0x1
    line.word 0x00 "I2DR,I2C Data I/O Register"
        hexmask.word.byte 0x00 0.--8. 1. " DATA ,Data Byte."


    tree.end
    tree "I2C2"
        base ad:0x021a4000

width 5.
group.word 0x0++0x1
    line.word 0x00 "IADR,I2C Address Register"
        hexmask.word.byte 0x00 1.--8. 1. " ADR ,Slave address."
width 5.
group.word 0x4++0x1
    line.word 0x00 "IFDR,I2C Frequency Divider Register"
        hexmask.word.byte 0x00 0.--6. 1. " IC ,I2C clock rate."
width 5.
group.word 0x8++0x1
    line.word 0x00 "I2CR,I2C Control Register"
        bitfld.word 0x00 2. " RSTA ,Repeat start." "0,1"
        textline "    "
        bitfld.word 0x00 3. " TXAK ,Transmit acknowledge enable." "0,1"
        textline "    "
        bitfld.word 0x00 4. " MTX ,Transmit/receive mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 5. " MSTA ,Master/slave mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IIEN ,I2C interrupt enable." "0,1"
        textline "    "
        bitfld.word 0x00 7. " IEN ,I2C enable." "0,1"
width 5.
group.word 0xc++0x1
    line.word 0x00 "I2SR,I2C Status Register"
        bitfld.word 0x00 0. " RXAK ,Received acknowledge." "0,1"
        textline "    "
        bitfld.word 0x00 1. " IIF ,I2C interrupt." "0,1"
        textline "    "
        bitfld.word 0x00 2. " SRW ,Slave read/write." "0,1"
        textline "    "
        bitfld.word 0x00 4. " IAL ,Arbitration lost." "0,1"
        textline "    "
        bitfld.word 0x00 5. " IBB ,I2C bus busy bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IAAS ,I2C addressed as a slave bit." "0,1"
        textline "    "
        bitfld.word 0x00 7. " ICF ,Data transferring bit." "0,1"
width 5.
group.word 0x10++0x1
    line.word 0x00 "I2DR,I2C Data I/O Register"
        hexmask.word.byte 0x00 0.--8. 1. " DATA ,Data Byte."


    tree.end
    tree "I2C3"
        base ad:0x021a8000

width 5.
group.word 0x0++0x1
    line.word 0x00 "IADR,I2C Address Register"
        hexmask.word.byte 0x00 1.--8. 1. " ADR ,Slave address."
width 5.
group.word 0x4++0x1
    line.word 0x00 "IFDR,I2C Frequency Divider Register"
        hexmask.word.byte 0x00 0.--6. 1. " IC ,I2C clock rate."
width 5.
group.word 0x8++0x1
    line.word 0x00 "I2CR,I2C Control Register"
        bitfld.word 0x00 2. " RSTA ,Repeat start." "0,1"
        textline "    "
        bitfld.word 0x00 3. " TXAK ,Transmit acknowledge enable." "0,1"
        textline "    "
        bitfld.word 0x00 4. " MTX ,Transmit/receive mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 5. " MSTA ,Master/slave mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IIEN ,I2C interrupt enable." "0,1"
        textline "    "
        bitfld.word 0x00 7. " IEN ,I2C enable." "0,1"
width 5.
group.word 0xc++0x1
    line.word 0x00 "I2SR,I2C Status Register"
        bitfld.word 0x00 0. " RXAK ,Received acknowledge." "0,1"
        textline "    "
        bitfld.word 0x00 1. " IIF ,I2C interrupt." "0,1"
        textline "    "
        bitfld.word 0x00 2. " SRW ,Slave read/write." "0,1"
        textline "    "
        bitfld.word 0x00 4. " IAL ,Arbitration lost." "0,1"
        textline "    "
        bitfld.word 0x00 5. " IBB ,I2C bus busy bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IAAS ,I2C addressed as a slave bit." "0,1"
        textline "    "
        bitfld.word 0x00 7. " ICF ,Data transferring bit." "0,1"
width 5.
group.word 0x10++0x1
    line.word 0x00 "I2DR,I2C Data I/O Register"
        hexmask.word.byte 0x00 0.--8. 1. " DATA ,Data Byte."


    tree.end
    tree "I2C4"
        base ad:0x021f8000

width 5.
group.word 0x0++0x1
    line.word 0x00 "IADR,I2C Address Register"
        hexmask.word.byte 0x00 1.--8. 1. " ADR ,Slave address."
width 5.
group.word 0x4++0x1
    line.word 0x00 "IFDR,I2C Frequency Divider Register"
        hexmask.word.byte 0x00 0.--6. 1. " IC ,I2C clock rate."
width 5.
group.word 0x8++0x1
    line.word 0x00 "I2CR,I2C Control Register"
        bitfld.word 0x00 2. " RSTA ,Repeat start." "0,1"
        textline "    "
        bitfld.word 0x00 3. " TXAK ,Transmit acknowledge enable." "0,1"
        textline "    "
        bitfld.word 0x00 4. " MTX ,Transmit/receive mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 5. " MSTA ,Master/slave mode select bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IIEN ,I2C interrupt enable." "0,1"
        textline "    "
        bitfld.word 0x00 7. " IEN ,I2C enable." "0,1"
width 5.
group.word 0xc++0x1
    line.word 0x00 "I2SR,I2C Status Register"
        bitfld.word 0x00 0. " RXAK ,Received acknowledge." "0,1"
        textline "    "
        bitfld.word 0x00 1. " IIF ,I2C interrupt." "0,1"
        textline "    "
        bitfld.word 0x00 2. " SRW ,Slave read/write." "0,1"
        textline "    "
        bitfld.word 0x00 4. " IAL ,Arbitration lost." "0,1"
        textline "    "
        bitfld.word 0x00 5. " IBB ,I2C bus busy bit." "0,1"
        textline "    "
        bitfld.word 0x00 6. " IAAS ,I2C addressed as a slave bit." "0,1"
        textline "    "
        bitfld.word 0x00 7. " ICF ,Data transferring bit." "0,1"
width 5.
group.word 0x10++0x1
    line.word 0x00 "I2DR,I2C Data I/O Register"
        hexmask.word.byte 0x00 0.--8. 1. " DATA ,Data Byte."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; IOMUXC
;--------------------------------------------------------------------------------
tree "IOMUXC"
    base ad:0x020e0000

width 5.
group.long 0x0++0x3
    line.long 0x00 "GPR0,GPR0"
        bitfld.long 0x00 0. " DMAREQ_MUX_SEL0 ,Selects between two possible sources for SDMA_EVENT[2]:" "0,1"
        textline "    "
        bitfld.long 0x00 1. " DMAREQ_MUX_SEL1 ,Selects between two possible sources for SDMA_EVENT[3]:" "0,1"
        textline "    "
        bitfld.long 0x00 2. " DMAREQ_MUX_SEL2 ,Selects between two possible sources for SDMA_EVENT[4]:" "0,1"
        textline "    "
        bitfld.long 0x00 3. " DMAREQ_MUX_SEL3 ,Selects between two possible sources for SDMA_EVENT[5]:" "0,1"
        textline "    "
        bitfld.long 0x00 4. " DMAREQ_MUX_SEL4 ,Selects between two possible sources for SDMA_EVENT[10]:" "0,1"
        textline "    "
        bitfld.long 0x00 5. " DMAREQ_MUX_SEL5 ,Selects between two possible sources for SDMA_EVENT[9]:" "0,1"
        textline "    "
        bitfld.long 0x00 6. " DMAREQ_MUX_SEL6 ,Selects between two possible sources for SDMA_EVENT[23]:" "0,1"
        textline "    "
        bitfld.long 0x00 7. " DMAREQ_MUX_SEL7 ,Selects between two possible sources for SDMA_EVENT[14]:" "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--11. 1. " PCIE_RX0_EQ ,control pcie phy's rx0_eq bits"
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " TX_CLK2_MUX_SEL ,Selects the source of tx_clk2 in SPDIF according to ASRC clock muxing scheme:"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " CLOCK_1_MUX_SEL ,Selects the source of asrck_clock_1 in ASRC according to clock muxing scheme:"
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " CLOCK_9_MUX_SEL ,Selects the source of asrck_clock_9 in ASRC according to clock muxing scheme:"
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " CLOCK_2_MUX_SEL ,Selects the source of asrck_clock_2 in ASRC according to clock muxing scheme:"
        textline "    "
        hexmask.long.byte 0x00 22.--24. 1. " CLOCK_A_MUX_SEL ,Selects the source of asrck_clock_a in ASRC according to clock muxing scheme:"
        textline "    "
        hexmask.long.byte 0x00 24.--26. 1. " CLOCK_3_MUX_SEL ,Selects the source of asrck_clock_3 in ASRC according to clock muxing scheme:"
        textline "    "
        hexmask.long.byte 0x00 26.--28. 1. " CLOCK_B_MUX_SEL ,Selects the source of asrck_clock_b in ASRC according to clock muxing scheme:"
        textline "    "
        hexmask.long.byte 0x00 28.--30. 1. " CLOCK_0_MUX_SEL ,Selects the source of asrck_clock_0 in ASRC according to clock muxing scheme:"
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " CLOCK_8_MUX_SEL ,Selects the source of asrck_clock_8 in ASRC according to clock muxing scheme"
width 5.
group.long 0x4++0x3
    line.long 0x00 "GPR1,GPR1"
        bitfld.long 0x00 0. " ACT_CS0 ,See description for ADDRS3[10]" "0,1"
        textline "    "
        hexmask.long.byte 0x00 1.--3. 1. " ADDRS0 ,See description for ADDRS3[10]"
        textline "    "
        bitfld.long 0x00 3. " ACT_CS1 ,See description for ADDRS3[10]" "0,1"
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ADDRS1 ,See description for ADDRS3[10]"
        textline "    "
        bitfld.long 0x00 6. " ACT_CS2 ,See description for ADDRS3[10]" "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--9. 1. " ADDRS2 ,See description for ADDRS3[10]"
        textline "    "
        bitfld.long 0x00 9. " ACT_CS3 ,See description for ADDRS3[10]" "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ADDRS3 ,Active Chip Select and Address Space."
        textline "    "
        bitfld.long 0x00 12. " GINT ,Global interrupt ""0"" bit (connected to ARM IRQ#0 and GPC)" "0,1"
        textline "    "
        bitfld.long 0x00 14. " SYS_INT ,PCIe_CTL - When SYS_INT goes from low to high, the core generates an Assert_INTx Message." "0,1"
        textline "    "
        bitfld.long 0x00 15. " USB_EXP_MODE ,USB Exposure mode" "0,1"
        textline "    "
        bitfld.long 0x00 16. " REF_SSP_EN ,PCIe_PHY - Reference Clock Enable for SS function." "0,1"
        textline "    "
        bitfld.long 0x00 18. " TEST_POWERDOWN ,PCIe_PHY - All Circuits Power-Down Control Function: Powers down all circuitry in the PHY for IDDQ testing." "0,1"
        textline "    "
        bitfld.long 0x00 21. " ENET_CLK_SEL ,choose enet reference clk mode" "0,1"
        textline "    "
        bitfld.long 0x00 22. " EXC_MON ,Exclusive monitor response select of illegal command (of lal gaskets, except MMDC)" "0,1"
        textline "    "
        bitfld.long 0x00 24. " MIPI_DPI_OFF ,MIPI DPI shutdown request" "0,1"
        textline "    "
        bitfld.long 0x00 25. " MIPI_COLOR_SW ,MIPI color switch control" "0,1"
        textline "    "
        bitfld.long 0x00 26. " APP_REQ_ENTR_L1 ,PCIe_CTL - Application Request to Enter L1." "0,1"
        textline "    "
        bitfld.long 0x00 27. " APP_READY_ENTR_L23 ,PCIe_CTL - Application Ready to Enter L23." "0,1"
        textline "    "
        bitfld.long 0x00 28. " APP_REQ_EXIT_L1 ,PCIe_CTL - Application Request to Exit L1." "0,1"
        textline "    "
        bitfld.long 0x00 30. " APP_CLK_REQ_N ,PCIe_CTL (CLK LOGIC CONTROLLER GLUE) - Indicates that application logic is ready to have reference clock removed." "0,1"
        textline "    "
        bitfld.long 0x00 31. " CFG_L1_CLK_REMOVAL_EN ,PCIe_CTL (CLK LOGIC CONTROLLER GLUE) - Enable the reference clock removal in L1 state." "0,1"
width 5.
group.long 0x8++0x3
    line.long 0x00 "GPR2,GPR2"
        hexmask.long.byte 0x00 0.--2. 1. " CH0_MODE ,LVDS channel 0 operation mode"
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " CH1_MODE ,LVDS channel 1 operation mode"
        textline "    "
        bitfld.long 0x00 4. " SPLIT_MODE_EN ,Enable split mode." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DATA_WIDTH_CH0 ,Data width for LVDS channel 0." "0,1"
        textline "    "
        bitfld.long 0x00 6. " BIT_MAPPING_CH0 ,Data mapping for LVDS channel 0." "0,1"
        textline "    "
        bitfld.long 0x00 7. " DATA_WIDTH_CH1 ,Data width for LVDS channel 1." "0,1"
        textline "    "
        bitfld.long 0x00 8. " BIT_MAPPING_CH1 ,Data mapping for LVDS channel 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " DI0_VS_POLARITY ,Vsync polarity for IPU's DI0 interface." "0,1"
        textline "    "
        bitfld.long 0x00 10. " DI1_VS_POLARITY ,Vsync polarity for IPU's DI1 interface." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--19. 1. " LVDS_CLK_SHIFT ,Shifts the LVDS output clock in relation to the data."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " COUNTER_RESET_VAL ,Reset value for the LDB counter which determines when the shift registers are loaded with data."
width 5.
group.long 0xc++0x3
    line.long 0x00 "GPR3,GPR3"
        hexmask.long.byte 0x00 2.--4. 1. " HDMI_MUX_CTL ,HDMI MUX control"
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " MIPI_MUX_CTL ,MIPI MUX control"
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " LVDS0_MUX_CTL ,LVDS0 MUX control"
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " LVDS1_MUX_CTL ,LVDS1 MUX control"
        textline "    "
        bitfld.long 0x00 10. " MIPI_DBI_MUX_CTL ,MIPI DBI mux control" "0,1"
        textline "    "
        bitfld.long 0x00 11. " TZASC1_BOOT_LOCK ,TZASC-1 secure boot lock" "0,1"
        textline "    "
        bitfld.long 0x00 12. " TZASC2_BOOT_LOCK ,TZASC-2 secure boot lock" "0,1"
        textline "    "
        bitfld.long 0x00 13. " CORE0_DBG_ACK_EN ,Mask control of Core 1 debug acknowledge to global debug acknowledge" "0,1"
        textline "    "
        bitfld.long 0x00 14. " CORE1_DBG_ACK_EN ,Mask control of Core 1 debug acknowledge to global debug acknowledge." "0,1"
        textline "    "
        hexmask.long.byte 0x00 17.--21. 1. " OCRAM_STATUS ,This field shows the OCRAM pipeline settings status, controlled by OCRAM_CTL[24:21] bits respectively."
        textline "    "
        hexmask.long.byte 0x00 21.--25. 1. " OCRAM_CTL ,OCRAM_CTL[24] write address pipeline control bit."
        textline "    "
        bitfld.long 0x00 25. " USDHCX_RD_CACHE_CTL ,Control uSDHCx [1-4] blocks cacheable attribute of AXI read transactions" "0,1"
        textline "    "
        bitfld.long 0x00 26. " USDHCX_WR_CACHE_CTL ,Control uSDHCx [1-4] blocks cacheable attribute of AXI write transactions" "0,1"
        textline "    "
        bitfld.long 0x00 27. " BCH_RD_CACHE_CTL ,Control BCH block cacheable attribute of AXI read transactions Set of the cache bits, enable packet optimization through the bus system to DDR controller." "0,1"
        textline "    "
        bitfld.long 0x00 28. " BCH_WR_CACHE_CTL ,Control BCH block cacheable attribute of AXI write transactions" "0,1"
        textline "    "
        hexmask.long.byte 0x00 29.--31. 1. " GPU_DBG ,GPU debug busses to IOMUX"
width 5.
group.long 0x10++0x3
    line.long 0x00 "GPR4,GPR4"
        bitfld.long 0x00 0. " IPU_RD_CACHE_CTL ,Control IPU-1 block cacheable attribute of AXI read transactions Set of the cache bits, enable packet optimization through the bus system to DDR controller." "0,1"
        textline "    "
        bitfld.long 0x00 1. " IPU_WR_CACHE_CTL ,Control IPU-1 block cacheable attribute of AXI write transactions" "0,1"
        textline "    "
        bitfld.long 0x00 2. " VPU_P_RD_CACHE_VAL ,VPU (primary bus) block cacheable attribute value of AXI read transactions The value of VPU_P_RD_CACHE_VAL is affecting the transactions only if VPU_RD_CACHE_SEL is set." "0,1"
        textline "    "
        bitfld.long 0x00 3. " VPU_P_WR_CACHE_VAL ,VPU (primary bus) block cacheable attribute value of AXI write transactions The value of VPU_P_WR_CACHE_VAL is affecting the transactions only if VPU_WR_CACHE_SEL is set." "0,1"
        textline "    "
        bitfld.long 0x00 4. " VPU_S_RD_CACHE_VAL ,VPU (secondary bus) block cacheable attribute value of AXI read transactions The value of VPU_S_RD_CACHE_VAL is affecting the transactions only if VPU_RD_CACHE_SEL is set." "0,1"
        textline "    "
        bitfld.long 0x00 5. " VPU_S_WR_CACHE_VAL ,VPU (secondary bus) block cacheable attribute value of AXI write transactions The value of VPU_S_WR_CACHE_VAL is affecting the transactions only if VPU_WR_CACHE_SEL is set." "0,1"
        textline "    "
        bitfld.long 0x00 6. " VPU_RD_CACHE_SEL ,This bit selects the cacheable attribute of VPU AXI read transcations (both primary and secondary AXI buses)" "0,1"
        textline "    "
        bitfld.long 0x00 7. " VPU_WR_CACHE_SEL ,This bit selects the cacheable attribute of VPU AXI write transcations (both primary and secondary AXI buses)" "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " SOC_VERSION ,This is status (read only) field."
        textline "    "
        bitfld.long 0x00 16. " ENET_STOP_ACK ,ENET stop acknowledge." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CAN1_STOP_ACK ,CAN-1 stop acknowledge." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CAN2_STOP_ACK ,CAN-2 stop acknowledge." "0,1"
        textline "    "
        bitfld.long 0x00 19. " SDMA_STOP_ACK ,SDMA stop acknowledge." "0,1"
        textline "    "
        bitfld.long 0x00 24. " PCIE_RD_CACHE_VAL ,PCIe block cacheable attribute value of AXI read transactions The value of PCIe_RD_CACHE_VAL is affecting the transactions only if PCIe_RD_CACHE_SEL is set." "0,1"
        textline "    "
        bitfld.long 0x00 25. " PCIE_WR_CACHE_VAL ,PCIe block cacheable attribute value of AXI write transactions The value of PCIe_WR_CACHE_VAL is affecting the transactions only if PCIe_WR_CACHE_SEL is set." "0,1"
        textline "    "
        bitfld.long 0x00 26. " PCIE_RD_CACHE_SEL ,This bit selects the cacheable attribute of PCIe AXI read transcations)" "0,1"
        textline "    "
        bitfld.long 0x00 27. " PCIE_WR_CACHE_SEL ,This bit selects the cacheable attribute of PCIe AXI write transcations" "0,1"
        textline "    "
        bitfld.long 0x00 28. " VDOA_RD_CACHE_VAL ,VDOA block cacheable attribute value of AXI read transactions The value of VDOA_RD_CACHE_VAL is affecting the transactions only if VDOA_RD_CACHE_SEL is set." "0,1"
        textline "    "
        bitfld.long 0x00 29. " VDOA_WR_CACHE_VAL ,VDOA block cacheable attribute value of AXI write transactions The value of VDOA_WR_CACHE_VAL is affecting the transactions only if VDOA_WR_CACHE_SEL is set." "0,1"
        textline "    "
        bitfld.long 0x00 30. " VDOA_RD_CACHE_SEL ,This bit selects the cacheable attribute of VDOA AXI read transcations)" "0,1"
        textline "    "
        bitfld.long 0x00 31. " VDOA_WR_CACHE_SEL ,This bit selects the cacheable attribute of VDOA AXI write transcations" "0,1"
width 5.
group.long 0x14++0x3
    line.long 0x00 "GPR5,GPR5"
        hexmask.long.byte 0x00 0.--2. 1. " ARM_WFI ,ARM WFI event out indicating on WFI state of the cores (these are status, read only bits)"
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ARM_WFE ,ARM WFE event out indication on WFE state of the cores (these are status, read only bits)"
        textline "    "
        bitfld.long 0x00 8. " L2_CLK_STOP ,L2 cache clock stop indication (this is a status, read only bit]" "0,1"
width 5.
group.long 0x18++0x3
    line.long 0x00 "GPR6,GPR6"
        hexmask.long.byte 0x00 0.--4. 1. " IPU1_ID00_WR_QOS ,IPU1 Write AXI ID=00 Quality of Service (QoS) priority"
        textline "    "
        hexmask.long.byte 0x00 4.--8. 1. " IPU1_ID01_WR_QOS ,IPU1 Write AXI ID=01 Quality of Service (QoS) priority"
        textline "    "
        hexmask.long.byte 0x00 8.--12. 1. " IPU1_ID10_WR_QOS ,IPU1 Write AXI ID=10 Quality of Service (QoS) priority"
        textline "    "
        hexmask.long.byte 0x00 12.--16. 1. " IPU1_ID11_WR_QOS ,IPU1 Write AXI ID=11 Quality of Service (QoS) priority"
        textline "    "
        hexmask.long.byte 0x00 16.--20. 1. " IPU1_ID00_RD_QOS ,IPU1 Read AXI ID=00 Quality of Service (QoS) priority"
        textline "    "
        hexmask.long.byte 0x00 20.--24. 1. " IPU1_ID01_RD_QOS ,IPU1 Read AXI ID=01 Quality of Service (QoS) priority"
        textline "    "
        hexmask.long.byte 0x00 24.--28. 1. " IPU1_ID10_RD_QOS ,IPU1 Read AXI ID=10 Quality of Service (QoS) priority"
        textline "    "
        hexmask.long.byte 0x00 28.--32. 1. " IPU1_ID11_RD_QOS ,IPU1 Read AXI ID=11 Quality of Service (QoS) priority"
width 5.
group.long 0x1c++0x3
    line.long 0x00 "GPR7,GPR7"
width 5.
group.long 0x20++0x3
    line.long 0x00 "GPR8,GPR8"
        hexmask.long.byte 0x00 0.--6. 1. " PCS_TX_DEEMPH_GEN1 ,PCIe_PHY - This static value sets the Tx driver de-emphasis value in the case where pipe0_tx_deemph is set to 1'b1 (the default setting) and the PHY is running at the Gen1 rate."
        textline "    "
        hexmask.long.byte 0x00 6.--12. 1. " PCS_TX_DEEMPH_GEN2_3P5DB ,PCIe_PHY - This static value sets the Tx driver de-emphasis value in the case where pipe0_tx_deemph is set to 1'b1 (the default setting) and the PHY is running at the Gen2 rate."
        textline "    "
        hexmask.long.byte 0x00 12.--18. 1. " PCS_TX_DEEMPH_GEN2_6DB ,PCIe_PHY - This static value sets the Tx driver de-emphasis value in the case where pipe0_tx_deemph is set to 1'b0 and the PHY is running at the Gen2 rate."
        textline "    "
        hexmask.long.byte 0x00 18.--25. 1. " PCS_TX_SWING_FULL ,PCIe_PHY - This static value sets the Tx driver de-emphasis value in the case where pipe0_tx_deemph is set to 1'b0 and the PHY is running at the Gen2 rate."
        textline "    "
        hexmask.long.byte 0x00 25.--32. 1. " PCS_TX_SWING_LOW ,PCIe_PHY - This static value sets the launch amplitude of the transmitter when pipe0_tx_swing is set to 1'b0 (default state)."
width 5.
group.long 0x24++0x3
    line.long 0x00 "GPR9,GPR9"
        bitfld.long 0x00 0. " TZASC1_BYP ,TZASC-1 BYPASS MUX control" "0,1"
        textline "    "
        bitfld.long 0x00 1. " TZASC2_BYP ,TZASC-2 BYPASS MUX control" "0,1"
width 6.
group.long 0x28++0x3
    line.long 0x00 "GPR10,GPR10"
        hexmask.long.byte 0x00 0.--2. 1. " DCIC1_MUX_CTL ,DCIC-1 MUX control"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " DCIC2_MUX_CTL ,DCIC-2 MUX control"
        textline "     "
        bitfld.long 0x00 4. " OCRAM_TZ_EN ,OCRAM TrustZone (TZ) enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 5.--10. 1. " OCRAM_TZ_ADDR ,OCRAM TrustZone (TZ) start address."
        textline "     "
        bitfld.long 0x00 11. " SEC_ERR_RESP ,Security error response enable for all security gaskets (on both AHB and AXI busses)" "0,1"
        textline "     "
        bitfld.long 0x00 12. " DBG_CLK_EN ,ARM Debug clock enable" "0,1"
        textline "     "
        bitfld.long 0x00 13. " DBG_EN ,ARM non secure (non-invasive) debug enable" "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " LOCK_DCIC1_MUX_CTL ,Lock DCIC1_MUX_CTL field for changes."
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " LOCK_DCIC2_MUX_CTL ,Lock DCIC2_MUX_CTL field for changes."
        textline "     "
        bitfld.long 0x00 20. " LOCK_OCRAM_TZ_EN ,Lock OCRAM_TZ_EN field for changes." "0,1"
        textline "     "
        hexmask.long.byte 0x00 21.--26. 1. " LOCK_OCRAM_TZ_ADDR ,Lock OCRAM_TZ_ADDR field for changes."
        textline "     "
        bitfld.long 0x00 27. " LOCK_SEC_ERR_RESP ,Lock SEC_ERR_RESP field for changes." "0,1"
        textline "     "
        bitfld.long 0x00 28. " LOCK_DBG_CLK_EN ,Lock DBG_CLK_EN field for changes." "0,1"
        textline "     "
        bitfld.long 0x00 29. " LOCK_DBG_EN ,Lock DBG_EN field for changes." "0,1"
width 6.
group.long 0x2c++0x3
    line.long 0x00 "GPR11,GPR11"
width 6.
group.long 0x30++0x3
    line.long 0x00 "GPR12,GPR12"
        hexmask.long.byte 0x00 2.--4. 1. " USDHC_DBG_MUX ,uSDHC debug mux control TBD"
        textline "     "
        hexmask.long.byte 0x00 4.--9. 1. " LOS_LEVEL ,PCIe_PHY - Loss-of-Signal Detector Sensitivity Level Control Function: Sets the sensitivity level for the Loss-of-Signal detector."
        textline "     "
        bitfld.long 0x00 9. " APPS_PM_XMT_PME ,PCIe_CTL - Wake Up." "0,1"
        textline "     "
        bitfld.long 0x00 10. " APP_LTSSM_ENABLE ,PCIe_CTL - Driven low by the application after reset to hold the LTSSM in the Detect state until the application is ready." "0,1"
        textline "     "
        bitfld.long 0x00 11. " APP_INIT_RST ,PCIe_CTL - Request from the application to send a Hot Reset to the downstream device." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " DEVICE_TYPE ,PCIe_CTL - Device/Port Type."
        textline "     "
        bitfld.long 0x00 16. " APPS_PM_XMT_TURNOFF ,PCIe_CTL - Request from the application to generate a PM_Turn_Off Message." "0,1"
        textline "     "
        hexmask.long.byte 0x00 17.--21. 1. " DIAG_STATUS_BUS_SELECT ,PCIe_CTL - used for debug to select what part of diag_status_bus will be reflected on the 32 bits of the iomux"
        textline "     "
        hexmask.long.byte 0x00 21.--24. 1. " PCIE_CTL_7 ,PCIe control of diagnostic bus select TBD"
        textline "     "
        bitfld.long 0x00 24. " ARMP_APB_CLK_EN ,ARM platform APB clock enable" "0,1"
        textline "     "
        bitfld.long 0x00 25. " ARMP_ATB_CLK_EN ,ARM platform ATB clock enable" "0,1"
        textline "     "
        bitfld.long 0x00 26. " ARMP_AHB_CLK_EN ,ARM platform AHB clock enable" "0,1"
        textline "     "
        bitfld.long 0x00 27. " ARMP_IPG_CLK_EN ,ARM platform IPG clock enable" "0,1"
width 6.
group.long 0x34++0x3
    line.long 0x00 "GPR13,GPR13"
        hexmask.long.byte 0x00 0.--3. 1. " IPU_CSI0_MUX ,"
        textline "     "
        hexmask.long.byte 0x00 3.--6. 1. " IPU_CSI1_MUX ,"
        textline "     "
        bitfld.long 0x00 8. " PXP_RD_CACHE_VAL ,PXP block cacheable attribute value of AXI read transactions The value of PXP_RD_CACHE_VAL is affecting the transactions only if PXP_RD_CACHE_SEL is set." "0,1"
        textline "     "
        bitfld.long 0x00 9. " PXP_WR_CACHE_VAL ,PXP block cacheable attribute value of AXI write transactions The value of PXP_WR_CACHE_VAL is affecting the transactions only if PXP_WR_CACHE_SEL is set." "0,1"
        textline "     "
        bitfld.long 0x00 10. " PXP_RD_CACHE_SEL ,This bit selects the cacheable attribute of PXP AXI read transcations)" "0,1"
        textline "     "
        bitfld.long 0x00 11. " PXP_WR_CACHE_SEL ,This bit selects the cacheable attribute of PXP AXI write transcations" "0,1"
        textline "     "
        bitfld.long 0x00 12. " EPDC_RD_CACHE_VAL ,EPDC block cacheable attribute value of AXI read transactions The value of EPDC_RD_CACHE_VAL is affecting the transactions only if EPDC_RD_CACHE_SEL is set." "0,1"
        textline "     "
        bitfld.long 0x00 13. " EPDC_WR_CACHE_VAL ,EPDC block cacheable attribute value of AXI write transactions The value of EPDC_WR_CACHE_VAL is affecting the transactions only if EPDC_WR_CACHE_SEL is set." "0,1"
        textline "     "
        bitfld.long 0x00 14. " EPDC_RD_CACHE_SEL ,This bit selects the cacheable attribute of EPDC AXI read transcations)" "0,1"
        textline "     "
        bitfld.long 0x00 15. " EPDC_WR_CACHE_SEL ,This bit selects the cacheable attribute of EPDC AXI write transcations" "0,1"
        textline "     "
        bitfld.long 0x00 16. " LCDIF_RD_CACHE_VAL ,LCDIF block cacheable attribute value of AXI read transactions The value of LCDIF_RD_CACHE_VAL is affecting the transactions only if LCDIF_RD_CACHE_SEL is set." "0,1"
        textline "     "
        bitfld.long 0x00 18. " LCDIF_RD_CACHE_SEL ,This bit selects the cacheable attribute of LCDIF AXI read transcations)" "0,1"
        textline "     "
        bitfld.long 0x00 27. " ENET_STOP_REQ ,ENET stop request" "0,1"
        textline "     "
        bitfld.long 0x00 28. " CAN1_STOP_REQ ,CAN1 stop request" "0,1"
        textline "     "
        bitfld.long 0x00 29. " CAN2_STOP_REQ ,CAN2 stop request" "0,1"
        textline "     "
        bitfld.long 0x00 30. " SDMA_STOP_REQ ,SDMA stop request" "0,1"
width 27.
group.long 0x4c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA10,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: CSI0_DAT10."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x50++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA11,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: CSI0_DAT11."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x54++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA12,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: CSI0_DAT12."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x58++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA13,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: CSI0_DAT13."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x5c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA14,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: CSI0_DAT14."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x60++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA15,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: CSI0_DAT15."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x64++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA16,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: CSI0_DAT16."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x68++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA17,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: CSI0_DAT17."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x6c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA18,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: CSI0_DAT18."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x70++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA19,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: CSI0_DAT19."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x74++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA04,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: CSI0_DAT4."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x78++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA05,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: CSI0_DAT5."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x7c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA06,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: CSI0_DAT6."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x80++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA07,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: CSI0_DAT7."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x84++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA08,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: CSI0_DAT8."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x88++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA09,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: CSI0_DAT9."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x8c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_DATA_EN,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: CSI0_DATA_EN."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x90++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_HSYNC,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: CSI0_MCLK."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x94++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_PIXCLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: CSI0_PIXCLK."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x98++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_CSI0_VSYNC,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: CSI0_VSYNC."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x9c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DI0_DISP_CLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: DI0_DISP_CLK."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0xa0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DI0_PIN15,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: DI0_PIN15."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0xa4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DI0_PIN02,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: DI0_PIN2."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0xa8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DI0_PIN03,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: DI0_PIN3."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0xac++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DI0_PIN04,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: DI0_PIN4."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xb0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA00,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: DISP0_DAT0."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xb4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA01,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: DISP0_DAT1."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xb8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA10,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: DISP0_DAT10."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xbc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA11,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: DISP0_DAT11."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xc0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA12,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: DISP0_DAT12."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xc4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA13,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: DISP0_DAT13."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xc8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA14,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: DISP0_DAT14."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xcc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA15,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: DISP0_DAT15."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xd0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA16,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: DISP0_DAT16."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xd4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA17,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: DISP0_DAT17."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xd8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA18,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: DISP0_DAT18."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xdc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA19,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: DISP0_DAT19."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xe0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA02,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: DISP0_DAT2."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xe4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA20,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: DISP0_DAT20."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xe8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA21,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: DISP0_DAT21."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xec++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA22,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: DISP0_DAT22."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xf0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA23,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: DISP0_DAT23."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xf4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA03,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: DISP0_DAT3."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xf8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA04,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: DISP0_DAT4."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0xfc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA05,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: DISP0_DAT5."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x100++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA06,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: DISP0_DAT6."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x104++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA07,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: DISP0_DAT7."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x108++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA08,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: DISP0_DAT8."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x10c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_DISP0_DATA09,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: DISP0_DAT9."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x110++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_ADDR16,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_A16."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x114++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_ADDR17,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_A17."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x118++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_ADDR18,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_A18."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x11c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_ADDR19,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_A19."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x120++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_ADDR20,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_A20."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x124++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_ADDR21,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_A21."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x128++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_ADDR22,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_A22."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x12c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_ADDR23,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EIM_A23."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x130++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_ADDR24,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EIM_A24."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x134++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_ADDR25,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 9 iomux modes to be used for pad: EIM_A25."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x138++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_BCLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: EIM_BCLK."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x13c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_CS0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: EIM_CS0."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x140++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_CS1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: EIM_CS1."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x144++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA16,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: EIM_D16."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x148++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA17,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: EIM_D17."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x14c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA18,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: EIM_D18."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x150++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA19,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: EIM_D19."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x154++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA20,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EIM_D20."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x158++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA21,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: EIM_D21."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x15c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA22,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: EIM_D22."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x160++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA23,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 9 iomux modes to be used for pad: EIM_D23."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x164++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA24,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 9 iomux modes to be used for pad: EIM_D24."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x168++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA25,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 9 iomux modes to be used for pad: EIM_D25."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x16c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA26,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 9 iomux modes to be used for pad: EIM_D26."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x170++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA27,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 9 iomux modes to be used for pad: EIM_D27."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x174++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA28,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 9 iomux modes to be used for pad: EIM_D28."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x178++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA29,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: EIM_D29."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x17c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA30,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: EIM_D30."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x180++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_DATA31,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 9 iomux modes to be used for pad: EIM_D31."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x184++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD00,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA0."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x188++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD01,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA1."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x18c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD10,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA10."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x190++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD11,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA11."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x194++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD12,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA12."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x198++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD13,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: EIM_DA13."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x19c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD14,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: EIM_DA14."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1a0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD15,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA15."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1a4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD02,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA2."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1a8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD03,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA3."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1ac++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD04,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA4."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1b0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD05,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA5."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1b4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD06,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA6."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1b8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD07,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA7."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1bc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD08,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA8."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1c0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_AD09,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_DA9."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x1c4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_EB0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: EIM_EB0."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x1c8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_EB1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_EB1."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x1cc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_EB2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: EIM_EB2."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x1d0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_EB3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 10 iomux modes to be used for pad: EIM_EB3."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x1d4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_LBA,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_LBA."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x1d8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_OE,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: EIM_OE."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x1dc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_RW,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: EIM_RW."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1e0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_EIM_WAIT,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: EIM_WAIT."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x1e4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ENET_CRS_DV,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: ENET_CRS_DV."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x1e8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ENET_MDC,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: ENET_MDC."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x1ec++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ENET_MDIO,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: ENET_MDIO."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x1f0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ENET_REF_CLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: ENET_REF_CLK."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x1f4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ENET_RX_ER,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: ENET_RX_ER."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 29.
group.long 0x1f8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ENET_RX_DATA0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: ENET_RXD0."
        textline "                            "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 29.
group.long 0x1fc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ENET_RX_DATA1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: ENET_RXD1."
        textline "                            "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x200++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ENET_TX_EN,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: ENET_TX_EN."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 29.
group.long 0x204++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ENET_TX_DATA0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: ENET_TXD0."
        textline "                            "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 29.
group.long 0x208++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_ENET_TX_DATA1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: ENET_TXD1."
        textline "                            "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x20c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO00,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: GPIO_0."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x210++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO01,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: GPIO_1."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x214++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO16,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: GPIO_16."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x218++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO17,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: GPIO_17."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x21c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO18,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: GPIO_18."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x220++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO19,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: GPIO_19."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x224++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO02,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: GPIO_2."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x228++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO03,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: GPIO_3."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x22c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO04,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: GPIO_4."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x230++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO05,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: GPIO_5."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x234++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO06,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: GPIO_6."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x238++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO07,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 8 iomux modes to be used for pad: GPIO_7."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x23c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO08,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 9 iomux modes to be used for pad: GPIO_8."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 22.
group.long 0x240++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_GPIO09,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: GPIO_9."
        textline "                     "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x244++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_COL0."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x248++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_COL1."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x24c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_COL2."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x250++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_COL3."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x254++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_COL4,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: KEY_COL4."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x258++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_ROW0."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x25c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_ROW1."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x260++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 7 iomux modes to be used for pad: KEY_ROW2."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x264++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: KEY_ROW3."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x268++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_KEY_ROW4,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: KEY_ROW4."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x26c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_ALE,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: NANDF_ALE."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 24.
group.long 0x270++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_CLE,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 2 iomux modes to be used for pad: NANDF_CLE."
        textline "                       "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x274++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_CS0_B,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 2 iomux modes to be used for pad: NANDF_CS0."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x278++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_CS1_B,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: NANDF_CS1."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x27c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_CS2_B,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: NANDF_CS2."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x280++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_CS3_B,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: NANDF_CS3."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x284++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_DATA00,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: NANDF_D0."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x288++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_DATA01,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: NANDF_D1."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x28c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_DATA02,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: NANDF_D2."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x290++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_DATA03,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: NANDF_D3."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x294++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_DATA04,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: NANDF_D4."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x298++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_DATA05,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: NANDF_D5."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x29c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_DATA06,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: NANDF_D6."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x2a0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_DATA07,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: NANDF_D7."
        textline "                          "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 26.
group.long 0x2a4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_READY,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 2 iomux modes to be used for pad: NANDF_RB0."
        textline "                         "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2a8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_NAND_WP_B,Pad Mux Register"
        hexmask.long.byte 0x00 0.--4. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: NANDF_WP_B."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2ac++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_RGMII_RD0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: RGMII_RD0."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2b0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_RGMII_RD1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: RGMII_RD1."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2b4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_RGMII_RD2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: RGMII_RD2."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2b8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_RGMII_RD3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: RGMII_RD3."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x2bc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_RGMII_RX_CTL,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: RGMII_RX_CTL."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2c0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_RGMII_RXC,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: RGMII_RXC."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2c4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_RGMII_TD0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: RGMII_TD0."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2c8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_RGMII_TD1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: RGMII_TD1."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2cc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_RGMII_TD2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: RGMII_TD2."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2d0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_RGMII_TD3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: RGMII_TD3."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 28.
group.long 0x2d4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_RGMII_TX_CTL,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: RGMII_TX_CTL."
        textline "                           "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2d8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_RGMII_TXC,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: RGMII_TXC."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x2dc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_CLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD1_CLK."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x2e0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_CMD,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: SD1_CMD."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2e4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_DATA0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD1_DAT0."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2e8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_DATA1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: SD1_DAT1."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2ec++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_DATA2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD1_DAT2."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2f0++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD1_DATA3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 6 iomux modes to be used for pad: SD1_DAT3."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x2f4++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_CLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: SD2_CLK."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x2f8++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_CMD,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: SD2_CMD."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x2fc++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_DATA0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: SD2_DAT0."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x300++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_DATA1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: SD2_DAT1."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x304++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_DATA2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 5 iomux modes to be used for pad: SD2_DAT2."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x308++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD2_DATA3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: SD2_DAT3."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x30c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_CLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: SD3_CLK."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x310++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_CMD,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: SD3_CMD."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x314++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_DATA0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: SD3_DAT0."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x318++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_DATA1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: SD3_DAT1."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x31c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_DATA2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 2 iomux modes to be used for pad: SD3_DAT2."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x320++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_DATA3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD3_DAT3."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x324++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_DATA4,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD3_DAT4."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x328++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_DATA5,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD3_DAT5."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x32c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_DATA6,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD3_DAT6."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x330++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_DATA7,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD3_DAT7."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x334++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD3_RESET,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD3_RST."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x338++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD4_CLK,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: SD4_CLK."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 23.
group.long 0x33c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD4_CMD,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 4 iomux modes to be used for pad: SD4_CMD."
        textline "                      "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x340++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD4_DATA0,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD4_DAT0."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x344++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD4_DATA1,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD4_DAT1."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x348++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD4_DATA2,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD4_DAT2."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x34c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD4_DATA3,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 2 iomux modes to be used for pad: SD4_DAT3."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x350++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD4_DATA4,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD4_DAT4."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x354++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD4_DATA5,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD4_DAT5."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x358++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD4_DATA6,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD4_DAT6."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 25.
group.long 0x35c++0x3
    line.long 0x00 "SW_MUX_CTL_PAD_SD4_DATA7,Pad Mux Register"
        hexmask.long.byte 0x00 0.--3. 1. " MUX_MODE ,Select 1 of 3 iomux modes to be used for pad: SD4_DAT7."
        textline "                        "
        bitfld.long 0x00 4. " SION ,Force the selected mux mode input path no matter of MUX_MODE functionality." "0,1"
width 27.
group.long 0x360++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA10,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT10."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT10."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT10." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT10." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT10."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT10." "0,1"
width 27.
group.long 0x364++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA11,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT11."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT11."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT11." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT11." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT11."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT11." "0,1"
width 27.
group.long 0x368++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA12,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT12."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT12."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT12." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT12." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT12."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT12." "0,1"
width 27.
group.long 0x36c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA13,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT13."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT13."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT13." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT13." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT13."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT13." "0,1"
width 27.
group.long 0x370++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA14,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT14."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT14."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT14." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT14." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT14."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT14." "0,1"
width 27.
group.long 0x374++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA15,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT15."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT15."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT15." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT15." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT15."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT15." "0,1"
width 27.
group.long 0x378++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA16,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT16."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT16."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT16." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT16." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT16."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT16." "0,1"
width 27.
group.long 0x37c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA17,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT17."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT17."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT17." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT17." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT17."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT17." "0,1"
width 27.
group.long 0x380++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA18,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT18."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT18."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT18." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT18." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT18."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT18." "0,1"
width 27.
group.long 0x384++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA19,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT19."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT19."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT19." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT19." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT19."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT19." "0,1"
width 27.
group.long 0x388++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA04,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT4."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT4."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT4." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT4." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT4."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT4." "0,1"
width 27.
group.long 0x38c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA05,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT5."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT5."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT5." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT5." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT5."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT5." "0,1"
width 27.
group.long 0x390++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA06,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT6."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT6."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT6." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT6." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT6."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT6." "0,1"
width 27.
group.long 0x394++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA07,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT7."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT7."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT7." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT7." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT7."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT7." "0,1"
width 27.
group.long 0x398++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA08,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT8."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT8."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT8." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT8." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT8."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT8." "0,1"
width 27.
group.long 0x39c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA09,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DAT9."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DAT9."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DAT9." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DAT9." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DAT9."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DAT9." "0,1"
width 28.
group.long 0x3a0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_DATA_EN,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_DATA_EN."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_DATA_EN."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_DATA_EN." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_DATA_EN." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_DATA_EN."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_DATA_EN." "0,1"
width 26.
group.long 0x3a4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_HSYNC,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_MCLK."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_MCLK."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_MCLK." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_MCLK." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_MCLK."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_MCLK." "0,1"
width 27.
group.long 0x3a8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_PIXCLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_PIXCLK."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_PIXCLK."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_PIXCLK." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_PIXCLK." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_PIXCLK."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_PIXCLK." "0,1"
width 26.
group.long 0x3ac++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_CSI0_VSYNC,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: CSI0_VSYNC."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: CSI0_VSYNC."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: CSI0_VSYNC." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: CSI0_VSYNC." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: CSI0_VSYNC."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: CSI0_VSYNC." "0,1"
width 28.
group.long 0x3b0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DI0_DISP_CLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DI0_DISP_CLK."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DI0_DISP_CLK."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DI0_DISP_CLK." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DI0_DISP_CLK." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DI0_DISP_CLK."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DI0_DISP_CLK." "0,1"
width 25.
group.long 0x3b4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DI0_PIN15,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DI0_PIN15."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DI0_PIN15."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DI0_PIN15." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DI0_PIN15." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DI0_PIN15."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DI0_PIN15." "0,1"
width 25.
group.long 0x3b8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DI0_PIN02,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DI0_PIN2."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DI0_PIN2."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DI0_PIN2." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DI0_PIN2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DI0_PIN2."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DI0_PIN2." "0,1"
width 25.
group.long 0x3bc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DI0_PIN03,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DI0_PIN3."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DI0_PIN3."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DI0_PIN3." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DI0_PIN3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DI0_PIN3."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DI0_PIN3." "0,1"
width 25.
group.long 0x3c0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DI0_PIN04,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DI0_PIN4."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DI0_PIN4."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DI0_PIN4." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DI0_PIN4." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DI0_PIN4."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DI0_PIN4." "0,1"
width 28.
group.long 0x3c4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA00,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT0."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT0."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT0." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT0." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT0."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT0." "0,1"
width 28.
group.long 0x3c8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA01,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT1."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT1."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT1." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT1." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT1."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT1." "0,1"
width 28.
group.long 0x3cc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA10,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT10."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT10."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT10." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT10." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT10."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT10." "0,1"
width 28.
group.long 0x3d0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA11,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT11."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT11."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT11." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT11." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT11."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT11." "0,1"
width 28.
group.long 0x3d4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA12,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT12."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT12."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT12." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT12." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT12."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT12." "0,1"
width 28.
group.long 0x3d8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA13,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT13."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT13."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT13." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT13." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT13."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT13." "0,1"
width 28.
group.long 0x3dc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA14,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT14."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT14."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT14." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT14." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT14."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT14." "0,1"
width 28.
group.long 0x3e0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA15,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT15."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT15."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT15." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT15." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT15."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT15." "0,1"
width 28.
group.long 0x3e4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA16,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT16."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT16."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT16." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT16." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT16."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT16." "0,1"
width 28.
group.long 0x3e8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA17,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT17."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT17."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT17." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT17." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT17."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT17." "0,1"
width 28.
group.long 0x3ec++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA18,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT18."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT18."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT18." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT18." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT18."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT18." "0,1"
width 28.
group.long 0x3f0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA19,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT19."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT19."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT19." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT19." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT19."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT19." "0,1"
width 28.
group.long 0x3f4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA02,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT2."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT2."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT2." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT2." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT2."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT2." "0,1"
width 28.
group.long 0x3f8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA20,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT20."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT20."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT20." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT20." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT20."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT20." "0,1"
width 28.
group.long 0x3fc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA21,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT21."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT21."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT21." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT21." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT21."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT21." "0,1"
width 28.
group.long 0x400++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA22,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT22."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT22."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT22." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT22." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT22."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT22." "0,1"
width 28.
group.long 0x404++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA23,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT23."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT23."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT23." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT23." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT23."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT23." "0,1"
width 28.
group.long 0x408++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA03,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT3."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT3."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT3." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT3." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT3."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT3." "0,1"
width 28.
group.long 0x40c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA04,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT4."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT4."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT4." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT4." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT4."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT4." "0,1"
width 28.
group.long 0x410++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA05,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT5."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT5."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT5." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT5." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT5."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT5." "0,1"
width 28.
group.long 0x414++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA06,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT6."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT6."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT6." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT6." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT6."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT6." "0,1"
width 28.
group.long 0x418++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA07,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT7."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT7."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT7." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT7." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT7."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT7." "0,1"
width 28.
group.long 0x41c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA08,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT8."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT8."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT8." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT8." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT8."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT8." "0,1"
width 28.
group.long 0x420++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DISP0_DATA09,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DISP0_DAT9."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: DISP0_DAT9."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DISP0_DAT9." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DISP0_DAT9." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DISP0_DAT9."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DISP0_DAT9." "0,1"
width 27.
group.long 0x424++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR00,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A0."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A0." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A0." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x428++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR01,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A1."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A1." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A1." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x42c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR10,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A10."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A10." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A10." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x430++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR11,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A11."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A11." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A11." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x434++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR12,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A12."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A12." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A12." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x438++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR13,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A13."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A13." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A13." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x43c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR14,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A14."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A14." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A14." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x440++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR15,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A15."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A15." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A15." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x444++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR02,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A2."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A2." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A2." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x448++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR03,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A3."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A3." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A3." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x44c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR04,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A4."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A4." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A4." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x450++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR05,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A5."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A5." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A5." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x454++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR06,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A6."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A6." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A6." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x458++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR07,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A7."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A7." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A7." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x45c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR08,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A8."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A8." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A8." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x460++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ADDR09,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_A9."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_A9." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_A9." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_A9." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 24.
group.long 0x464++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_CAS,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_CAS."
        textline "                       "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_CAS."
        textline "                       "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_CAS." "0,1"
        textline "                       "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_CAS." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 24.
group.long 0x468++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_CS0,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                       "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_CS0."
        textline "                       "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_CS0." "0,1"
        textline "                       "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_CS0." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 24.
group.long 0x46c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_CS1,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                       "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_CS1."
        textline "                       "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_CS1." "0,1"
        textline "                       "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_CS1." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x470++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_DQM0,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_DQM0."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_DQM0."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_DQM0." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_DQM0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x474++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_DQM1,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_DQM1."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_DQM1."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_DQM1." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_DQM1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x478++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_DQM2,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_DQM2."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_DQM2."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_DQM2." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_DQM2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x47c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_DQM3,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_DQM3."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_DQM3."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_DQM3." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_DQM3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x480++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_DQM4,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_DQM4."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_DQM4."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_DQM4." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_DQM4." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x484++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_DQM5,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_DQM5."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_DQM5."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_DQM5." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_DQM5." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x488++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_DQM6,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_DQM6."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_DQM6."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_DQM6." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_DQM6." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x48c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_DQM7,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_DQM7."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_DQM7."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_DQM7." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_DQM7." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 24.
group.long 0x490++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_RAS,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_RAS."
        textline "                       "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_RAS."
        textline "                       "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_RAS." "0,1"
        textline "                       "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_RAS." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 26.
group.long 0x494++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_RESET,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_RESET."
        textline "                         "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_RESET."
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_RESET." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_RESET." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_RESET."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_RESET." "0,1"
        textline "                         "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_RESET." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,Select one of next values for pad: DRAM_RESET."
width 26.
group.long 0x498++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDBA0,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                         "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDBA0."
        textline "                         "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDBA0." "0,1"
        textline "                         "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDBA0." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 26.
group.long 0x49c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDBA1,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                         "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDBA1."
        textline "                         "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDBA1." "0,1"
        textline "                         "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDBA1." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 26.
group.long 0x4a0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDBA2,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                         "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDBA2."
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDBA2." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDBA2." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDBA2." "0,1"
        textline "                         "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDBA2." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x4a4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDCKE0,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDCKE0."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDCKE0." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDCKE0." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDCKE0."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDCKE0." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDCKE0." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 27.
group.long 0x4a8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDCKE1,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                          "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDCKE1."
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDCKE1." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDCKE1." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDCKE1."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDCKE1." "0,1"
        textline "                          "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDCKE1." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 29.
group.long 0x4ac++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDCLK0_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDCLK_0."
        textline "                            "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDCLK_0."
        textline "                            "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                            "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                            "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDCLK_0." "0,1"
        textline "                            "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDCLK_0." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 29.
group.long 0x4b0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDCLK1_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDCLK_1."
        textline "                            "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDCLK_1."
        textline "                            "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                            "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                            "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDCLK_1." "0,1"
        textline "                            "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDCLK_1." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x4b4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ODT0,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDODT0."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDODT0."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDODT0." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDODT0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDODT0."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDODT0." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDODT0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x4b8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_ODT1,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDODT1."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDODT1."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDODT1." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDODT1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDODT1."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDODT1." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDODT1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x4bc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDQS0_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDQS0."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDQS0." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDQS0." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDQS0."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x4c0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDQS1_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDQS1."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDQS1." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDQS1." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDQS1."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x4c4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDQS2_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDQS2."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDQS2." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDQS2." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDQS2."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x4c8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDQS3_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDQS3."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDQS3." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDQS3." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDQS3."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x4cc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDQS4_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDQS4."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDQS4." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDQS4." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDQS4."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x4d0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDQS5_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDQS5."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDQS5." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDQS5." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDQS5."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x4d4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDQS6_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDQS6."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDQS6." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDQS6." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDQS6."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x4d8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDQS7_P,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: DRAM_SDQS7."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: DRAM_SDQS7." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: DRAM_SDQS7." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: DRAM_SDQS7."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x4dc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_DRAM_SDWE,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for pad: DRAM_SDWE."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK Note: The value of this field does not reflect the value of the Group Control Register." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: DRAM_SDWE." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: DRAM_SDWE." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE Note: The value of this field does not reflect the value of the Group Control Register."
width 26.
group.long 0x4e0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_ADDR16,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_A16."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_A16."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_A16." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_A16." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_A16."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_A16." "0,1"
width 26.
group.long 0x4e4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_ADDR17,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_A17."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_A17."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_A17." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_A17." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_A17."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_A17." "0,1"
width 26.
group.long 0x4e8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_ADDR18,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_A18."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_A18."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_A18." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_A18." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_A18."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_A18." "0,1"
width 26.
group.long 0x4ec++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_ADDR19,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_A19."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_A19."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_A19." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_A19." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_A19."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_A19." "0,1"
width 26.
group.long 0x4f0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_ADDR20,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_A20."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_A20."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_A20." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_A20." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_A20."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_A20." "0,1"
width 26.
group.long 0x4f4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_ADDR21,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_A21."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_A21."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_A21." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_A21." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_A21."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_A21." "0,1"
width 26.
group.long 0x4f8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_ADDR22,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_A22."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_A22."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_A22." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_A22." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_A22."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_A22." "0,1"
width 26.
group.long 0x4fc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_ADDR23,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_A23."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_A23."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_A23." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_A23." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_A23."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_A23." "0,1"
width 26.
group.long 0x500++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_ADDR24,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_A24."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_A24."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_A24." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_A24." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_A24."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_A24." "0,1"
width 26.
group.long 0x504++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_ADDR25,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_A25."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_A25."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_A25." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_A25." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_A25."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_A25." "0,1"
width 24.
group.long 0x508++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_BCLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_BCLK."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_BCLK."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_BCLK." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_BCLK." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_BCLK."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_BCLK." "0,1"
width 23.
group.long 0x50c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_CS0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_CS0."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_CS0."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_CS0." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_CS0." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_CS0."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_CS0." "0,1"
width 23.
group.long 0x510++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_CS1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_CS1."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_CS1."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_CS1." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_CS1." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_CS1."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_CS1." "0,1"
width 26.
group.long 0x514++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA16,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D16."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D16."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D16." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D16." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D16."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D16." "0,1"
width 26.
group.long 0x518++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA17,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D17."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D17."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D17." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D17." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D17."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D17." "0,1"
width 26.
group.long 0x51c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA18,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D18."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D18."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D18." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D18." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D18."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D18." "0,1"
width 26.
group.long 0x520++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA19,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D19."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D19."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D19." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D19." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D19."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D19." "0,1"
width 26.
group.long 0x524++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA20,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D20."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D20."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D20." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D20." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D20."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D20." "0,1"
width 26.
group.long 0x528++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA21,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D21."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D21."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D21." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D21." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D21."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D21." "0,1"
width 26.
group.long 0x52c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA22,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D22."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D22."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D22." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D22." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D22."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D22." "0,1"
width 26.
group.long 0x530++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA23,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D23."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D23."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D23." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D23." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D23."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D23." "0,1"
width 26.
group.long 0x534++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA24,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D24."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D24."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D24." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D24." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D24."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D24." "0,1"
width 26.
group.long 0x538++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA25,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D25."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D25."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D25." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D25." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D25."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D25." "0,1"
width 26.
group.long 0x53c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA26,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D26."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D26."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D26." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D26." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D26."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D26." "0,1"
width 26.
group.long 0x540++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA27,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D27."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D27."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D27." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D27." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D27."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D27." "0,1"
width 26.
group.long 0x544++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA28,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D28."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D28."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D28." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D28." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D28."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D28." "0,1"
width 26.
group.long 0x548++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA29,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D29."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D29."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D29." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D29." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D29."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D29." "0,1"
width 26.
group.long 0x54c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA30,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D30."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D30."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D30." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D30." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D30."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D30." "0,1"
width 26.
group.long 0x550++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_DATA31,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_D31."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_D31."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_D31." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_D31." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_D31."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_D31." "0,1"
width 24.
group.long 0x554++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD00,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA0."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA0."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA0." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA0." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA0."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA0." "0,1"
width 24.
group.long 0x558++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD01,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA1."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA1."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA1." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA1." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA1."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA1." "0,1"
width 24.
group.long 0x55c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD10,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA10."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA10."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA10." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA10." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA10."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA10." "0,1"
width 24.
group.long 0x560++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD11,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA11."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA11."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA11." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA11." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA11."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA11." "0,1"
width 24.
group.long 0x564++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD12,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA12."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA12."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA12." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA12." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA12."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA12." "0,1"
width 24.
group.long 0x568++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD13,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA13."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA13."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA13." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA13." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA13."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA13." "0,1"
width 24.
group.long 0x56c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD14,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA14."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA14."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA14." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA14." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA14."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA14." "0,1"
width 24.
group.long 0x570++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD15,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA15."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA15."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA15." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA15." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA15."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA15." "0,1"
width 24.
group.long 0x574++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD02,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA2."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA2."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA2." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA2." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA2."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA2." "0,1"
width 24.
group.long 0x578++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD03,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA3."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA3."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA3." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA3." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA3."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA3." "0,1"
width 24.
group.long 0x57c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD04,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA4."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA4."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA4." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA4." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA4."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA4." "0,1"
width 24.
group.long 0x580++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD05,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA5."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA5."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA5." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA5." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA5."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA5." "0,1"
width 24.
group.long 0x584++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD06,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA6."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA6."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA6." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA6." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA6."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA6." "0,1"
width 24.
group.long 0x588++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD07,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA7."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA7."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA7." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA7." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA7."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA7." "0,1"
width 24.
group.long 0x58c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD08,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA8."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA8."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA8." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA8." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA8."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA8." "0,1"
width 24.
group.long 0x590++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_AD09,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_DA9."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_DA9."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_DA9." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_DA9." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_DA9."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_DA9." "0,1"
width 23.
group.long 0x594++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_EB0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_EB0."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_EB0."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_EB0." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_EB0." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_EB0."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_EB0." "0,1"
width 23.
group.long 0x598++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_EB1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_EB1."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_EB1."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_EB1." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_EB1." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_EB1."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_EB1." "0,1"
width 23.
group.long 0x59c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_EB2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_EB2."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_EB2."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_EB2." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_EB2." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_EB2."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_EB2." "0,1"
width 23.
group.long 0x5a0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_EB3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_EB3."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_EB3."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_EB3." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_EB3." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_EB3."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_EB3." "0,1"
width 23.
group.long 0x5a4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_LBA,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_LBA."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_LBA."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_LBA." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_LBA." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_LBA."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_LBA." "0,1"
width 22.
group.long 0x5a8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_OE,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_OE."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_OE."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_OE." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_OE." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_OE."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_OE." "0,1"
width 22.
group.long 0x5ac++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_RW,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_RW."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_RW."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_RW." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_RW." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_RW."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_RW." "0,1"
width 24.
group.long 0x5b0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_EIM_WAIT,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: EIM_WAIT."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: EIM_WAIT."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: EIM_WAIT." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: EIM_WAIT." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: EIM_WAIT."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: EIM_WAIT." "0,1"
width 27.
group.long 0x5b4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ENET_CRS_DV,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ENET_CRS_DV."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ENET_CRS_DV." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ENET_CRS_DV." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ENET_CRS_DV."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ENET_CRS_DV." "0,1"
width 24.
group.long 0x5b8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ENET_MDC,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ENET_MDC."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ENET_MDC."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ENET_MDC." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ENET_MDC." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ENET_MDC."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ENET_MDC." "0,1"
width 25.
group.long 0x5bc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ENET_MDIO,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ENET_MDIO."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ENET_MDIO."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ENET_MDIO." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ENET_MDIO." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ENET_MDIO."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ENET_MDIO." "0,1"
width 28.
group.long 0x5c0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ENET_REF_CLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ENET_REF_CLK."
        textline "                           "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ENET_REF_CLK."
        textline "                           "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ENET_REF_CLK." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ENET_REF_CLK." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ENET_REF_CLK."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ENET_REF_CLK." "0,1"
width 26.
group.long 0x5c4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ENET_RX_ER,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ENET_RX_ER."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ENET_RX_ER."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ENET_RX_ER." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ENET_RX_ER." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ENET_RX_ER."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ENET_RX_ER." "0,1"
width 29.
group.long 0x5c8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ENET_RX_DATA0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ENET_RXD0."
        textline "                            "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                            "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                            "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ENET_RXD0." "0,1"
        textline "                            "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ENET_RXD0." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ENET_RXD0."
        textline "                            "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ENET_RXD0." "0,1"
width 29.
group.long 0x5cc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ENET_RX_DATA1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ENET_RXD1."
        textline "                            "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ENET_RXD1."
        textline "                            "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                            "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ENET_RXD1." "0,1"
        textline "                            "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ENET_RXD1." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ENET_RXD1."
        textline "                            "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ENET_RXD1." "0,1"
width 26.
group.long 0x5d0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ENET_TX_EN,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ENET_TX_EN."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ENET_TX_EN."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ENET_TX_EN." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ENET_TX_EN." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ENET_TX_EN."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ENET_TX_EN." "0,1"
width 29.
group.long 0x5d4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ENET_TX_DATA0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ENET_TXD0."
        textline "                            "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ENET_TXD0."
        textline "                            "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                            "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ENET_TXD0." "0,1"
        textline "                            "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ENET_TXD0." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ENET_TXD0."
        textline "                            "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ENET_TXD0." "0,1"
width 29.
group.long 0x5d8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_ENET_TX_DATA1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: ENET_TXD1."
        textline "                            "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: ENET_TXD1."
        textline "                            "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                            "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: ENET_TXD1." "0,1"
        textline "                            "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: ENET_TXD1." "0,1"
        textline "                            "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: ENET_TXD1."
        textline "                            "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: ENET_TXD1." "0,1"
width 22.
group.long 0x5dc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO00,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_0."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_0." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_0." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_0."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_0." "0,1"
width 22.
group.long 0x5e0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO01,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_1."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: GPIO_1."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_1." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_1." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_1."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_1." "0,1"
width 22.
group.long 0x5e4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO16,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_16."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: GPIO_16."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_16." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_16." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_16."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_16." "0,1"
width 22.
group.long 0x5e8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO17,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_17."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_17." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_17." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_17."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_17." "0,1"
width 22.
group.long 0x5ec++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO18,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_18."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: GPIO_18."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_18." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_18." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_18."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_18." "0,1"
width 22.
group.long 0x5f0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO19,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_19."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: GPIO_19."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_19." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_19." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_19."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_19." "0,1"
width 22.
group.long 0x5f4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO02,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_2."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: GPIO_2."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_2." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_2." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_2."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_2." "0,1"
width 22.
group.long 0x5f8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO03,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_3."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: GPIO_3."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_3." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_3." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_3."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_3." "0,1"
width 22.
group.long 0x5fc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO04,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_4."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: GPIO_4."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_4." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_4." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_4."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_4." "0,1"
width 22.
group.long 0x600++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO05,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_5."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: GPIO_5."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_5." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_5." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_5."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_5." "0,1"
width 22.
group.long 0x604++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO06,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_6."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: GPIO_6."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_6." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_6." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_6."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_6." "0,1"
width 22.
group.long 0x608++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO07,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_7."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: GPIO_7."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_7." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_7." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_7."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_7." "0,1"
width 22.
group.long 0x60c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO08,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_8."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: GPIO_8."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_8." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_8." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_8."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_8." "0,1"
width 22.
group.long 0x610++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_GPIO09,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: GPIO_9."
        textline "                     "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: GPIO_9."
        textline "                     "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                     "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: GPIO_9." "0,1"
        textline "                     "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: GPIO_9." "0,1"
        textline "                     "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: GPIO_9."
        textline "                     "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: GPIO_9." "0,1"
width 24.
group.long 0x614++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_JTAG_MOD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: JTAG_MOD." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: JTAG_MOD."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: JTAG_MOD." "0,1"
width 24.
group.long 0x618++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_JTAG_TCK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: JTAG_TCK." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: JTAG_TCK."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: JTAG_TCK." "0,1"
width 24.
group.long 0x61c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_JTAG_TDI,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: JTAG_TDI." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: JTAG_TDI."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: JTAG_TDI." "0,1"
width 24.
group.long 0x620++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_JTAG_TDO,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: JTAG_TDO." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
width 24.
group.long 0x624++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_JTAG_TMS,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: JTAG_TMS." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: JTAG_TMS."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: JTAG_TMS." "0,1"
width 26.
group.long 0x628++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_JTAG_TRSTB,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: JTAG_TRSTB." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: JTAG_TRSTB."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: JTAG_TRSTB." "0,1"
width 24.
group.long 0x62c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL0."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL0."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL0." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL0." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL0."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL0." "0,1"
width 24.
group.long 0x630++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL1."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL1."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL1." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL1." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL1."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL1." "0,1"
width 24.
group.long 0x634++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL2."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL2."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL2." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL2." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL2."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL2." "0,1"
width 24.
group.long 0x638++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL3."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL3."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL3." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL3." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL3."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL3." "0,1"
width 24.
group.long 0x63c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_COL4,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_COL4."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_COL4."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_COL4." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_COL4." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_COL4."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_COL4." "0,1"
width 24.
group.long 0x640++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW0."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW0."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW0." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW0." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW0."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW0." "0,1"
width 24.
group.long 0x644++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW1."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW1."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW1." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW1." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW1."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW1." "0,1"
width 24.
group.long 0x648++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW2."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW2."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW2." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW2." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW2."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW2." "0,1"
width 24.
group.long 0x64c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW3."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW3."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW3." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW3." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW3."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW3." "0,1"
width 24.
group.long 0x650++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_KEY_ROW4,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: KEY_ROW4."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: KEY_ROW4."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: KEY_ROW4." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: KEY_ROW4." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: KEY_ROW4."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: KEY_ROW4." "0,1"
width 24.
group.long 0x654++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_ALE,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_ALE."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_ALE."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_ALE." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_ALE." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_ALE."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_ALE." "0,1"
width 24.
group.long 0x658++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_CLE,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_CLE."
        textline "                       "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_CLE."
        textline "                       "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                       "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_CLE." "0,1"
        textline "                       "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_CLE." "0,1"
        textline "                       "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_CLE."
        textline "                       "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_CLE." "0,1"
width 26.
group.long 0x65c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_CS0_B,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_CS0."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_CS0."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_CS0." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_CS0." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_CS0."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_CS0." "0,1"
width 26.
group.long 0x660++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_CS1_B,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_CS1."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_CS1."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_CS1." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_CS1." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_CS1."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_CS1." "0,1"
width 26.
group.long 0x664++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_CS2_B,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_CS2."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_CS2."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_CS2." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_CS2." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_CS2."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_CS2." "0,1"
width 26.
group.long 0x668++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_CS3_B,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_CS3."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_CS3."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_CS3." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_CS3." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_CS3."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_CS3." "0,1"
width 27.
group.long 0x66c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_DATA00,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_D0."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_D0."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_D0." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_D0." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_D0."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_D0." "0,1"
width 27.
group.long 0x670++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_DATA01,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_D1."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_D1."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_D1." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_D1." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_D1."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_D1." "0,1"
width 27.
group.long 0x674++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_DATA02,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_D2."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_D2."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_D2." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_D2." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_D2."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_D2." "0,1"
width 27.
group.long 0x678++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_DATA03,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_D3."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_D3."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_D3." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_D3." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_D3."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_D3." "0,1"
width 27.
group.long 0x67c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_DATA04,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_D4."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_D4."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_D4." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_D4." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_D4."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_D4." "0,1"
width 27.
group.long 0x680++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_DATA05,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_D5."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_D5."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_D5." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_D5." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_D5."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_D5." "0,1"
width 27.
group.long 0x684++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_DATA06,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_D6."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_D6."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_D6." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_D6." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_D6."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_D6." "0,1"
width 27.
group.long 0x688++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_DATA07,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_D7."
        textline "                          "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_D7."
        textline "                          "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                          "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_D7." "0,1"
        textline "                          "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_D7." "0,1"
        textline "                          "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_D7."
        textline "                          "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_D7." "0,1"
width 26.
group.long 0x68c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_READY,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_RB0."
        textline "                         "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_RB0."
        textline "                         "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                         "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_RB0." "0,1"
        textline "                         "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_RB0." "0,1"
        textline "                         "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_RB0."
        textline "                         "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_RB0." "0,1"
width 25.
group.long 0x690++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_NAND_WP_B,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: NANDF_WP_B."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: NANDF_WP_B."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: NANDF_WP_B." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: NANDF_WP_B." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: NANDF_WP_B."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: NANDF_WP_B." "0,1"
width 25.
group.long 0x694++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_RGMII_RD0,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: RGMII_RD0."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: RGMII_RD0." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: RGMII_RD0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: RGMII_RD0."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: RGMII_RD0." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: RGMII_RD0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x698++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_RGMII_RD1,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: RGMII_RD1."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: RGMII_RD1." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: RGMII_RD1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: RGMII_RD1."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: RGMII_RD1." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: RGMII_RD1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x69c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_RGMII_RD2,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: RGMII_RD2."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: RGMII_RD2." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: RGMII_RD2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: RGMII_RD2."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: RGMII_RD2." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: RGMII_RD2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x6a0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_RGMII_RD3,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: RGMII_RD3."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: RGMII_RD3." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: RGMII_RD3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: RGMII_RD3."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: RGMII_RD3." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: RGMII_RD3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x6a4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_RGMII_RX_CTL,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: RGMII_RX_CTL."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: RGMII_RX_CTL." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: RGMII_RX_CTL." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: RGMII_RX_CTL."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: RGMII_RX_CTL." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: RGMII_RX_CTL." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x6a8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_RGMII_RXC,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: RGMII_RXC."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_RGMII_TERM Note: The value of this field does not reflect the value of the Group Control Register."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: RGMII_RXC." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: RGMII_RXC." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: RGMII_RXC."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: RGMII_RXC." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: RGMII_RXC." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x6ac++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_RGMII_TD0,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: RGMII_TD0."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: RGMII_TD0." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: RGMII_TD0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: RGMII_TD0."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: RGMII_TD0." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: RGMII_TD0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x6b0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_RGMII_TD1,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: RGMII_TD1."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: RGMII_TD1." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: RGMII_TD1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: RGMII_TD1."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: RGMII_TD1." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: RGMII_TD1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x6b4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_RGMII_TD2,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: RGMII_TD2."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: RGMII_TD2." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: RGMII_TD2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: RGMII_TD2."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: RGMII_TD2." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: RGMII_TD2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x6b8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_RGMII_TD3,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: RGMII_TD3."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: RGMII_TD3." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: RGMII_TD3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: RGMII_TD3."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: RGMII_TD3." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for pad: RGMII_TD3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII Note: The value of this field does not reflect the value of the Group Control Register."
width 28.
group.long 0x6bc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_RGMII_TX_CTL,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: RGMII_TX_CTL."
        textline "                           "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                           "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: RGMII_TX_CTL." "0,1"
        textline "                           "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: RGMII_TX_CTL." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: RGMII_TX_CTL."
        textline "                           "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: RGMII_TX_CTL." "0,1"
        textline "                           "
        bitfld.long 0x00 17. " DDR_INPUT ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                           "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII Note: The value of this field does not reflect the value of the Group Control Register."
width 25.
group.long 0x6c0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_RGMII_TXC,Pad Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: RGMII_TXC."
        textline "                        "
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Read Only Field The value of this field is fixed and cannot be changed."
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: RGMII_TXC." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: RGMII_TXC." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: RGMII_TXC."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: RGMII_TXC." "0,1"
        textline "                        "
        bitfld.long 0x00 17. " DDR_INPUT ,Read Only Field The value of this field is fixed and cannot be changed." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,This property can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RGMII Note: The value of this field does not reflect the value of the Group Control Register."
width 23.
group.long 0x6c4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_CLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_CLK."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_CLK."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_CLK." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_CLK." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_CLK."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_CLK." "0,1"
width 23.
group.long 0x6c8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_CMD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_CMD."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_CMD."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_CMD." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_CMD." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_CMD."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_CMD." "0,1"
width 25.
group.long 0x6cc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_DATA0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_DAT0."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_DAT0."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_DAT0." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_DAT0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_DAT0."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_DAT0." "0,1"
width 25.
group.long 0x6d0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_DATA1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_DAT1."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_DAT1."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_DAT1." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_DAT1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_DAT1."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_DAT1." "0,1"
width 25.
group.long 0x6d4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_DATA2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_DAT2."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_DAT2."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_DAT2." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_DAT2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_DAT2."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_DAT2." "0,1"
width 25.
group.long 0x6d8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD1_DATA3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD1_DAT3."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD1_DAT3."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD1_DAT3." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD1_DAT3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD1_DAT3."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD1_DAT3." "0,1"
width 23.
group.long 0x6dc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_CLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_CLK."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_CLK."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_CLK." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_CLK." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_CLK."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_CLK." "0,1"
width 23.
group.long 0x6e0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_CMD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_CMD."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_CMD."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_CMD." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_CMD." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_CMD."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_CMD." "0,1"
width 25.
group.long 0x6e4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_DATA0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_DAT0."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_DAT0."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_DAT0." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_DAT0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_DAT0."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_DAT0." "0,1"
width 25.
group.long 0x6e8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_DATA1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_DAT1."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_DAT1."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_DAT1." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_DAT1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_DAT1."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_DAT1." "0,1"
width 25.
group.long 0x6ec++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_DATA2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_DAT2."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_DAT2."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_DAT2." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_DAT2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_DAT2."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_DAT2." "0,1"
width 25.
group.long 0x6f0++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD2_DATA3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD2_DAT3."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD2_DAT3."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD2_DAT3." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD2_DAT3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD2_DAT3."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD2_DAT3." "0,1"
width 23.
group.long 0x6f4++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_CLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_CLK."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_CLK."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_CLK." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_CLK." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_CLK."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_CLK." "0,1"
width 23.
group.long 0x6f8++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_CMD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_CMD."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_CMD."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_CMD." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_CMD." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_CMD."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_CMD." "0,1"
width 25.
group.long 0x6fc++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_DATA0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_DAT0."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_DAT0."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_DAT0." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_DAT0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_DAT0."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_DAT0." "0,1"
width 25.
group.long 0x700++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_DATA1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_DAT1."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_DAT1."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_DAT1." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_DAT1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_DAT1."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_DAT1." "0,1"
width 25.
group.long 0x704++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_DATA2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_DAT2."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_DAT2."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_DAT2." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_DAT2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_DAT2."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_DAT2." "0,1"
width 25.
group.long 0x708++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_DATA3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_DAT3."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_DAT3."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_DAT3." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_DAT3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_DAT3."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_DAT3." "0,1"
width 25.
group.long 0x70c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_DATA4,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_DAT4."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_DAT4."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_DAT4." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_DAT4." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_DAT4."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_DAT4." "0,1"
width 25.
group.long 0x710++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_DATA5,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_DAT5."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_DAT5."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_DAT5." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_DAT5." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_DAT5."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_DAT5." "0,1"
width 25.
group.long 0x714++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_DATA6,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_DAT6."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_DAT6."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_DAT6." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_DAT6." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_DAT6."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_DAT6." "0,1"
width 25.
group.long 0x718++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_DATA7,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_DAT7."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_DAT7."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_DAT7." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_DAT7." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_DAT7."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_DAT7." "0,1"
width 25.
group.long 0x71c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD3_RESET,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD3_RST."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD3_RST."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD3_RST." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD3_RST." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD3_RST."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD3_RST." "0,1"
width 23.
group.long 0x720++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD4_CLK,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD4_CLK."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD4_CLK."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD4_CLK." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD4_CLK." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD4_CLK."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD4_CLK." "0,1"
width 23.
group.long 0x724++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD4_CMD,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD4_CMD."
        textline "                      "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD4_CMD."
        textline "                      "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                      "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD4_CMD." "0,1"
        textline "                      "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD4_CMD." "0,1"
        textline "                      "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD4_CMD."
        textline "                      "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD4_CMD." "0,1"
width 25.
group.long 0x728++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD4_DATA0,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD4_DAT0."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD4_DAT0."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD4_DAT0." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD4_DAT0." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD4_DAT0."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD4_DAT0." "0,1"
width 25.
group.long 0x72c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD4_DATA1,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD4_DAT1."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD4_DAT1."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD4_DAT1." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD4_DAT1." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD4_DAT1."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD4_DAT1." "0,1"
width 25.
group.long 0x730++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD4_DATA2,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD4_DAT2."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD4_DAT2."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD4_DAT2." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD4_DAT2." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD4_DAT2."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD4_DAT2." "0,1"
width 25.
group.long 0x734++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD4_DATA3,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD4_DAT3."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD4_DAT3."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD4_DAT3." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD4_DAT3." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD4_DAT3."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD4_DAT3." "0,1"
width 25.
group.long 0x738++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD4_DATA4,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD4_DAT4."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD4_DAT4."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD4_DAT4." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD4_DAT4." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD4_DAT4."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD4_DAT4." "0,1"
width 25.
group.long 0x73c++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD4_DATA5,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD4_DAT5."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD4_DAT5."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD4_DAT5." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD4_DAT5." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD4_DAT5."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD4_DAT5." "0,1"
width 25.
group.long 0x740++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD4_DATA6,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD4_DAT6."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD4_DAT6."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD4_DAT6." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD4_DAT6." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD4_DAT6."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD4_DAT6." "0,1"
width 25.
group.long 0x744++0x3
    line.long 0x00 "SW_PAD_CTL_PAD_SD4_DATA7,Pad Control Register"
        bitfld.long 0x00 0. " SRE ,Slew rate control." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for pad: SD4_DAT7."
        textline "                        "
        hexmask.long.byte 0x00 6.--8. 1. " SPEED ,Select one of next values for pad: SD4_DAT7."
        textline "                        "
        bitfld.long 0x00 11. " ODE ,Enables open drain of the pin." "0,1"
        textline "                        "
        bitfld.long 0x00 12. " PKE ,Select one of next values for pad: SD4_DAT7." "0,1"
        textline "                        "
        bitfld.long 0x00 13. " PUE ,Select one of next values for pad: SD4_DAT7." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 14.--16. 1. " PUS ,Select one of next values for pad: SD4_DAT7."
        textline "                        "
        bitfld.long 0x00 16. " HYS ,Select one of next values for pad: SD4_DAT7." "0,1"
width 20.
group.long 0x748++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_B7DS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 21.
group.long 0x74c++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_ADDDS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 27.
group.long 0x750++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDRMODE_CTL,Pad Group Control Register"
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for group: ." "0,1"
width 22.
group.long 0x754++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDRPKE,Pad Group Control Register"
        bitfld.long 0x00 12. " PKE ,Select one of next values for group: ." "0,1"
width 21.
group.long 0x758++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDRPK,Pad Group Control Register"
        bitfld.long 0x00 13. " PUE ,Select one of next values for group: ." "0,1"
width 22.
group.long 0x75c++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDRHYS,Pad Group Control Register"
        bitfld.long 0x00 16. " HYS ,Select one of next values for group: ." "0,1"
width 23.
group.long 0x760++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDRMODE,Pad Group Control Register"
        bitfld.long 0x00 17. " DDR_INPUT ,Select one of next values for group: ." "0,1"
width 20.
group.long 0x764++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_B0DS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 30.
group.long 0x768++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDR_TYPE_RGMII,Pad Group Control Register"
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL_RGMII ,Select one of next values for group: ."
width 21.
group.long 0x76c++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_CTLDS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 20.
group.long 0x770++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_B1DS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 24.
group.long 0x774++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_DDR_TYPE,Pad Group Control Register"
        hexmask.long.byte 0x00 18.--20. 1. " DDR_SEL ,Select one of next values for group: ."
width 20.
group.long 0x778++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_B2DS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 20.
group.long 0x77c++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_B3DS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 20.
group.long 0x780++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_B4DS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 20.
group.long 0x784++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_B5DS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 26.
group.long 0x788++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_RGMII_TERM,Pad Group Control Register"
        hexmask.long.byte 0x00 8.--11. 1. " ODT ,Select one of next values for group: ."
width 20.
group.long 0x78c++0x3
    line.long 0x00 "SW_PAD_CTL_GRP_B6DS,Pad Group Control Register"
        hexmask.long.byte 0x00 3.--6. 1. " DSE ,Select one of next values for group: ."
width 31.
group.long 0x790++0x3
    line.long 0x00 "ANALOG_USB_OTG_ID_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x794++0x3
    line.long 0x00 "ASRC_ASRCK_CLOCK_6_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 31.
group.long 0x798++0x3
    line.long 0x00 "AUD4_INPUT_DA_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x79c++0x3
    line.long 0x00 "AUD4_INPUT_DB_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 34.
group.long 0x7a0++0x3
    line.long 0x00 "AUD4_INPUT_RXCLK_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 33.
group.long 0x7a4++0x3
    line.long 0x00 "AUD4_INPUT_RXFS_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 34.
group.long 0x7a8++0x3
    line.long 0x00 "AUD4_INPUT_TXCLK_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 33.
group.long 0x7ac++0x3
    line.long 0x00 "AUD4_INPUT_TXFS_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x7b0++0x3
    line.long 0x00 "AUD5_INPUT_DA_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x7b4++0x3
    line.long 0x00 "AUD5_INPUT_DB_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 34.
group.long 0x7b8++0x3
    line.long 0x00 "AUD5_INPUT_RXCLK_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 33.
group.long 0x7bc++0x3
    line.long 0x00 "AUD5_INPUT_RXFS_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 34.
group.long 0x7c0++0x3
    line.long 0x00 "AUD5_INPUT_TXCLK_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 33.
group.long 0x7c4++0x3
    line.long 0x00 "AUD5_INPUT_TXFS_AMX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x7c8++0x3
    line.long 0x00 "FLEXCAN1_RX_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x7cc++0x3
    line.long 0x00 "FLEXCAN2_RX_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x7d4++0x3
    line.long 0x00 "CCM_PMIC_READY_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x7d8++0x3
    line.long 0x00 "ECSPI1_CSPI_CLK_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x7dc++0x3
    line.long 0x00 "ECSPI1_MISO_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x7e0++0x3
    line.long 0x00 "ECSPI1_MOSI_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 24.
group.long 0x7e4++0x3
    line.long 0x00 "ECSPI1_SS0_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 24.
group.long 0x7e8++0x3
    line.long 0x00 "ECSPI1_SS1_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 24.
group.long 0x7ec++0x3
    line.long 0x00 "ECSPI1_SS2_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x7f0++0x3
    line.long 0x00 "ECSPI1_SS3_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x7f4++0x3
    line.long 0x00 "ECSPI2_CSPI_CLK_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x7f8++0x3
    line.long 0x00 "ECSPI2_MISO_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x7fc++0x3
    line.long 0x00 "ECSPI2_MOSI_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 24.
group.long 0x800++0x3
    line.long 0x00 "ECSPI2_SS0_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 24.
group.long 0x804++0x3
    line.long 0x00 "ECSPI2_SS1_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x808++0x3
    line.long 0x00 "ECSPI4_SS0_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 26.
group.long 0x80c++0x3
    line.long 0x00 "ENET_REF_CLK_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x810++0x3
    line.long 0x00 "ENET_MAC0_MDIO_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 30.
group.long 0x814++0x3
    line.long 0x00 "ENET_MAC0_RX_CLK_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x818++0x3
    line.long 0x00 "ENET_MAC0_RX_DATA0_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x81c++0x3
    line.long 0x00 "ENET_MAC0_RX_DATA1_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x820++0x3
    line.long 0x00 "ENET_MAC0_RX_DATA2_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x824++0x3
    line.long 0x00 "ENET_MAC0_RX_DATA3_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 29.
group.long 0x828++0x3
    line.long 0x00 "ENET_MAC0_RX_EN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x82c++0x3
    line.long 0x00 "ESAI_RX_FS_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 24.
group.long 0x830++0x3
    line.long 0x00 "ESAI_TX_FS_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x834++0x3
    line.long 0x00 "ESAI_RX_HF_CLK_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x838++0x3
    line.long 0x00 "ESAI_TX_HF_CLK_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x83c++0x3
    line.long 0x00 "ESAI_RX_CLK_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x840++0x3
    line.long 0x00 "ESAI_TX_CLK_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 23.
group.long 0x844++0x3
    line.long 0x00 "ESAI_SDO0_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 23.
group.long 0x848++0x3
    line.long 0x00 "ESAI_SDO1_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x84c++0x3
    line.long 0x00 "ESAI_SDO2_SDI3_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x850++0x3
    line.long 0x00 "ESAI_SDO3_SDI2_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x854++0x3
    line.long 0x00 "ESAI_SDO4_SDI1_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x858++0x3
    line.long 0x00 "ESAI_SDO5_SDI0_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x85c++0x3
    line.long 0x00 "HDMI_ICECIN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 29.
group.long 0x860++0x3
    line.long 0x00 "HDMI_II2C_CLKIN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 30.
group.long 0x864++0x3
    line.long 0x00 "HDMI_II2C_DATAIN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x868++0x3
    line.long 0x00 "I2C1_SCL_IN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x86c++0x3
    line.long 0x00 "I2C1_SDA_IN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x870++0x3
    line.long 0x00 "I2C2_SCL_IN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x874++0x3
    line.long 0x00 "I2C2_SDA_IN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 25.
group.long 0x878++0x3
    line.long 0x00 "I2C3_SCL_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x87c++0x3
    line.long 0x00 "I2C3_SDA_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x880++0x3
    line.long 0x00 "I2C4_SCL_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 25.
group.long 0x884++0x3
    line.long 0x00 "I2C4_SDA_IN_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 31.
group.long 0x888++0x3
    line.long 0x00 "IPU1_SENS1_DATA10_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x88c++0x3
    line.long 0x00 "IPU1_SENS1_DATA11_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x890++0x3
    line.long 0x00 "IPU1_SENS1_DATA12_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x894++0x3
    line.long 0x00 "IPU1_SENS1_DATA13_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x898++0x3
    line.long 0x00 "IPU1_SENS1_DATA14_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x89c++0x3
    line.long 0x00 "IPU1_SENS1_DATA15_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x8a0++0x3
    line.long 0x00 "IPU1_SENS1_DATA16_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x8a4++0x3
    line.long 0x00 "IPU1_SENS1_DATA17_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x8a8++0x3
    line.long 0x00 "IPU1_SENS1_DATA18_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 31.
group.long 0x8ac++0x3
    line.long 0x00 "IPU1_SENS1_DATA19_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x8b0++0x3
    line.long 0x00 "IPU1_SENS1_DATA_EN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 30.
group.long 0x8b4++0x3
    line.long 0x00 "IPU1_SENS1_HSYNC_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x8b8++0x3
    line.long 0x00 "IPU1_SENS1_PIX_CLK_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 30.
group.long 0x8bc++0x3
    line.long 0x00 "IPU1_SENS1_VSYNC_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 22.
group.long 0x8c0++0x3
    line.long 0x00 "KEY_COL5_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x8c4++0x3
    line.long 0x00 "KEY_COL6_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x8c8++0x3
    line.long 0x00 "KEY_COL7_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x8cc++0x3
    line.long 0x00 "KEY_ROW5_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x8d0++0x3
    line.long 0x00 "KEY_ROW6_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x8d4++0x3
    line.long 0x00 "KEY_ROW7_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 22.
group.long 0x8d8++0x3
    line.long 0x00 "LCD_BUSY_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x8dc++0x3
    line.long 0x00 "MLB_MLB_CLK_IN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 29.
group.long 0x8e0++0x3
    line.long 0x00 "MLB_MLB_DATA_IN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 28.
group.long 0x8e4++0x3
    line.long 0x00 "MLB_MLB_SIG_IN_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 27.
group.long 0x8e8++0x3
    line.long 0x00 "SDMA_EVENTS14_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 27.
group.long 0x8ec++0x3
    line.long 0x00 "SDMA_EVENTS15_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 29.
group.long 0x8f0++0x3
    line.long 0x00 "SPDIF_SPDIF_IN1_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 27.
group.long 0x8f4++0x3
    line.long 0x00 "SPDIF_TX_CLK2_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 30.
group.long 0x8f8++0x3
    line.long 0x00 "UART1_UART_RTS_B_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 32.
group.long 0x8fc++0x3
    line.long 0x00 "UART1_UART_RX_DATA_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 30.
group.long 0x900++0x3
    line.long 0x00 "UART2_UART_RTS_B_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--3. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 32.
group.long 0x904++0x3
    line.long 0x00 "UART2_UART_RX_DATA_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--3. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 30.
group.long 0x908++0x3
    line.long 0x00 "UART3_UART_RTS_B_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--3. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 32.
group.long 0x90c++0x3
    line.long 0x00 "UART3_UART_RX_DATA_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 30.
group.long 0x910++0x3
    line.long 0x00 "UART4_UART_RTS_B_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 32.
group.long 0x914++0x3
    line.long 0x00 "UART4_UART_RX_DATA_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 30.
group.long 0x918++0x3
    line.long 0x00 "UART5_UART_RTS_B_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 32.
group.long 0x91c++0x3
    line.long 0x00 "UART5_UART_RX_DATA_SELECT_INPUT,Select Input Register"
        hexmask.long.byte 0x00 0.--2. 1. " DAISY ,Selecting Pads Involved in Daisy Chain."
width 24.
group.long 0x920++0x3
    line.long 0x00 "USB_OTG_OC_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 23.
group.long 0x924++0x3
    line.long 0x00 "USB_H1_OC_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"
width 26.
group.long 0x92c++0x3
    line.long 0x00 "USDHC1_WP_ON_SELECT_INPUT,Select Input Register"
        bitfld.long 0x00 0. " DAISY ,Selecting Pads Involved in Daisy Chain." "0,1"


tree.end



;--------------------------------------------------------------------------------
; IPU
;--------------------------------------------------------------------------------
tree "IPU"
    base ad:0x02600000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CONF,Configuration Register"
        bitfld.long 0x00 0. " CSI0_EN ,Camera Sensor Interface 0 Enable bit" "0,1"
        textline "    "
        bitfld.long 0x00 1. " CSI1_EN ,Camera Sensor Interface 1 Enable bit" "0,1"
        textline "    "
        bitfld.long 0x00 2. " IC_EN ,Image Conversion Sub-Block Enable bit" "0,1"
        textline "    "
        bitfld.long 0x00 3. " IRT_EN ,Image Rotation Sub-Block Enable bit" "0,1"
        textline "    "
        bitfld.long 0x00 5. " DP_EN ,Display processor Sub-block Enable bit" "0,1"
        textline "    "
        bitfld.long 0x00 6. " DI0_EN ,Display interface Sub-block 0 Enable bit" "0,1"
        textline "    "
        bitfld.long 0x00 7. " DI1_EN ,Display Interface Sub-block 1 Enable bit" "0,1"
        textline "    "
        bitfld.long 0x00 8. " SMFC_EN ,Sensor's Multi FIFO Controller Sub-block (SMFC) Enable bit" "0,1"
        textline "    "
        bitfld.long 0x00 9. " DC_EN ,Display Controller sub-block (DC) Enable bit" "0,1"
        textline "    "
        bitfld.long 0x00 10. " DMFC_EN ,Display's Multi FIFO Controller sub-block (DMFC) Enable bit" "0,1"
        textline "    "
        bitfld.long 0x00 11. " SISG_EN ,Still Image Synchronization Generator (SISG) Enable bit" "0,1"
        textline "    "
        bitfld.long 0x00 12. " VDI_EN ,VDI enable bit." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--21. 1. " IPU_DIAGBUS_MODE ,IPU diagnostic bus mode."
        textline "    "
        bitfld.long 0x00 21. " IPU_DIAGBUS_ON ,IPU Diagnostics bus on This bit is connected to the IPU's output." "0,1"
        textline "    "
        bitfld.long 0x00 22. " IDMAC_DISABLE ,Image DMA controller (IDMAC) disable bit." "0,1"
        textline "    "
        bitfld.long 0x00 25. " IC_DMFC_SEL ,IC to DMFC select Selects the DMAIC_1 (channel 21) channel's connectivity between the IC and the DMFC" "0,1"
        textline "    "
        bitfld.long 0x00 26. " IC_DMFC_SYNC ,IC to DMFC Sync flow This bit defines if the direct flow between IC to DMFC is synchronous or asynchronous" "0,1"
        textline "    "
        bitfld.long 0x00 27. " VDI_DMFC_SYNC ,This bit enables the direct path VDI C -> IC_VF -> DMFC for sync flow." "0,1"
        textline "    "
        bitfld.long 0x00 28. " CSI0_DATA_SOURCE ,CSI0 data Source This bit selects what is the data source for the CSI0." "0,1"
        textline "    "
        bitfld.long 0x00 29. " CSI1_DATA_SOURCE ,CSI1 data Source This bit selects what is the data source for the CSI1." "0,1"
        textline "    "
        bitfld.long 0x00 30. " IC_INPUT ,IC Input select bit." "0,1"
        textline "    "
        bitfld.long 0x00 31. " CSI_SEL ,CSI select bit; This bit selects manually between the 2 CSI's." "0,1"
width 11.
group.long 0x4++0x3
    line.long 0x00 "SISG_CTRL0,SISG Control 0 Register"
        bitfld.long 0x00 0. " VSYNC_RST_CNT ,VSYNC Resets counters Defines if the counters are stooped following VSYNC or when the counters reach a pre defined value (VAL_STOP_SISG_COUNTER)" "0,1"
        textline "          "
        hexmask.long.byte 0x00 1.--4. 1. " NO_VSYNC_2_STRT_CNT ,VSYCs to Start Counter This bits define how many VSYNCs signals will be counter before activating the SISG counters."
        textline "          "
        hexmask.long.long 0x00 4.--29. 1. " VAL_STOP_SISG_COUNTER ,SISG Stop Counters value."
        textline "          "
        bitfld.long 0x00 29. " MCU_ACTV_TRIG ,Reserved, should be cleared." "0,1"
        textline "          "
        bitfld.long 0x00 30. " EXT_ACTV ,External Active Define if an external active trigger will start the counters." "0,1"
width 11.
group.long 0x8++0x3
    line.long 0x00 "SISG_CTRL1,SISG Control 1 Register"
        hexmask.long.byte 0x00 0.--5. 1. " SISG_STROBE_CNT ,SISG Strobe Count The SISG can repeat the sequence for up to 32 cycles; this is used for generating a train of pulses."
        textline "          "
        hexmask.long.byte 0x00 8.--14. 1. " SISG_OUT_POL ,SISG_OUT_POL This bits defines the polarity of the SISG output signals"
width 11.
group.long 0xc++0x3
    line.long 0x00 "SISG_SET_I,SISG Set<i> Register"
        hexmask.long.long 0x00 0.--25. 1. " SISG_SET_I ,SISG SET <i> value These bits define the set value of the SISG counter #<i>"
width 11.
group.long 0x24++0x3
    line.long 0x00 "SISG_CLR_I,SISG Clear <i> Register"
        hexmask.long.long 0x00 0.--25. 1. " SISG_CLEAR_I ,SISG CLR <i> value These bits define the clear value of the SISG counter #<i>"
width 11.
group.long 0x3c++0x3
    line.long 0x00 "INT_CTRL_1,Interrupt Control Register 1"
        bitfld.long 0x00 0. " IDMAC_EOF_EN_0 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 1. " IDMAC_EOF_EN_1 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 2. " IDMAC_EOF_EN_2 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 3. " IDMAC_EOF_EN_3 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 5. " IDMAC_EOF_EN_5 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 8. " IDMAC_EOF_EN_8 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_EOF_EN_9 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_EOF_EN_10 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_EOF_EN_11 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_EOF_EN_12 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 13. " IDMAC_EOF_EN_13 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 14. " IDMAC_EOF_EN_14 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 15. " IDMAC_EOF_EN_15 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 17. " IDMAC_EOF_EN_17 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 18. " IDMAC_EOF_EN_18 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_EOF_EN_19 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_EOF_EN_20 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 21. " IDMAC_EOF_EN_21 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 22. " IDMAC_EOF_EN_22 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 23. " IDMAC_EOF_EN_23 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 24. " IDMAC_EOF_EN_24 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 25. " IDMAC_EOF_EN_25 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 26. " IDMAC_EOF_EN_26 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 27. " IDMAC_EOF_EN_27 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 28. " IDMAC_EOF_EN_28 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 29. " IDMAC_EOF_EN_29 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 31. " IDMAC_EOF_EN_31 ,Enable End of Frame of Channel interrupt." "0,1"
width 11.
group.long 0x40++0x3
    line.long 0x00 "INT_CTRL_2,Interrupt Control Register 2"
        bitfld.long 0x00 1. " IDMAC_EOF_EN_33 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 8. " IDMAC_EOF_EN_40 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_EOF_EN_41 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_EOF_EN_42 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_EOF_EN_43 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_EOF_EN_44 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 13. " IDMAC_EOF_EN_45 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 14. " IDMAC_EOF_EN_46 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 15. " IDMAC_EOF_EN_47 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 16. " IDMAC_EOF_EN_48 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 17. " IDMAC_EOF_EN_49 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 18. " IDMAC_EOF_EN_50 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_EOF_EN_51 ,Enable End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_EOF_EN_52 ,Enable End of Frame of Channel interrupt." "0,1"
width 11.
group.long 0x44++0x3
    line.long 0x00 "INT_CTRL_3,Interrupt Control Register 3"
        bitfld.long 0x00 0. " IDMAC_NFACK_EN_0 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 1. " IDMAC_NFACK_EN_1 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 2. " IDMAC_NFACK_EN_2 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 3. " IDMAC_NFACK_EN_3 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 5. " IDMAC_NFACK_EN_5 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 8. " IDMAC_NFACK_EN_8 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_NFACK_EN_9 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_NFACK_EN_10 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_NFACK_EN_11 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_NFACK_EN_12 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 13. " IDMAC_NFACK_EN_13 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 14. " IDMAC_NFACK_EN_14 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 15. " IDMAC_NFACK_EN_15 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 17. " IDMAC_NFACK_EN_17 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 18. " IDMAC_NFACK_EN_18 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_NFACK_EN_19 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_NFACK_EN_20 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 21. " IDMAC_NFACK_EN_21 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 22. " IDMAC_NFACK_EN_22 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 23. " IDMAC_NFACK_EN_23 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 24. " IDMAC_NFACK_EN_24 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 25. " IDMAC_NFACK_EN_25 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 26. " IDMAC_NFACK_EN_26 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 27. " IDMAC_NFACK_EN_27 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 28. " IDMAC_NFACK_EN_28 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 29. " IDMAC_NFACK_EN_29 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 31. " IDMAC_NFACK_EN_31 ,Enable New Frame Ack of Channel interrupt." "0,1"
width 11.
group.long 0x48++0x3
    line.long 0x00 "INT_CTRL_4,Interrupt Control Register 4"
        bitfld.long 0x00 1. " IDMAC_NFACK_EN_33 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 8. " IDMAC_NFACK_EN_40 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_NFACK_EN_41 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_NFACK_EN_42 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_NFACK_EN_43 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_NFACK_EN_44 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 13. " IDMAC_NFACK_EN_45 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 14. " IDMAC_NFACK_EN_46 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 15. " IDMAC_NFACK_EN_47 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 16. " IDMAC_NFACK_EN_48 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 17. " IDMAC_NFACK_EN_49 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 18. " IDMAC_NFACK_EN_50 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_NFACK_EN_51 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_NFACK_EN_52 ,Enable New Frame Ack of Channel interrupt." "0,1"
width 11.
group.long 0x4c++0x3
    line.long 0x00 "INT_CTRL_5,Interrupt Control Register 5"
        bitfld.long 0x00 0. " IDMAC_NFB4EOF_EN_0 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 1. " IDMAC_NFB4EOF_EN_1 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 2. " IDMAC_NFB4EOF_EN_2 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 3. " IDMAC_NFB4EOF_EN_3 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 5. " IDMAC_NFB4EOF_EN_5 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 8. " IDMAC_NFB4EOF_EN_8 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_NFB4EOF_EN_9 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_NFB4EOF_EN_10 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_NFB4EOF_EN_11 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_NFB4EOF_EN_12 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 13. " IDMAC_NFB4EOF_EN_13 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 14. " IDMAC_NFB4EOF_EN_14 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 15. " IDMAC_NFB4EOF_EN_15 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 17. " IDMAC_NFB4EOF_EN_17 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 18. " IDMAC_NFB4EOF_EN_18 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_NFB4EOF_EN_19 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_NFB4EOF_EN_20 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 21. " IDMAC_NFB4EOF_EN_21 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 22. " IDMAC_NFB4EOF_EN_22 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 23. " IDMAC_NFB4EOF_EN_23 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 24. " IDMAC_NFB4EOF_EN_24 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 25. " IDMAC_NFB4EOF_EN_25 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 26. " IDMAC_NFB4EOF_EN_26 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 27. " IDMAC_NFB4EOF_EN_27 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 28. " IDMAC_NFB4EOF_EN_28 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 29. " IDMAC_NFB4EOF_EN_29 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 31. " IDMAC_NFB4EOF_EN_31 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
width 11.
group.long 0x50++0x3
    line.long 0x00 "INT_CTRL_6,Interrupt Control Register 6"
        bitfld.long 0x00 1. " IDMAC_NFB4EOF_EN_33 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 8. " IDMAC_NFB4EOF_EN_40 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_NFB4EOF_EN_41 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_NFB4EOF_EN_42 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_NFB4EOF_EN_43 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_NFB4EOF_EN_44 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 13. " IDMAC_NFB4EOF_EN_45 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 14. " IDMAC_NFB4EOF_EN_46 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 15. " IDMAC_NFB4EOF_EN_47 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 16. " IDMAC_NFB4EOF_EN_48 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 17. " IDMAC_NFB4EOF_EN_49 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 18. " IDMAC_NFB4EOF_EN_50 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_NFB4EOF_EN_51 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_NFB4EOF_EN_52 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
width 11.
group.long 0x54++0x3
    line.long 0x00 "INT_CTRL_7,Interrupt Control Register 7"
        bitfld.long 0x00 19. " IDMAC_EOS_EN_19 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 23. " IDMAC_EOS_EN_23 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 24. " IDMAC_EOS_EN_24 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 25. " IDMAC_EOS_EN_25 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 26. " IDMAC_EOS_EN_26 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 27. " IDMAC_EOS_EN_27 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 28. " IDMAC_EOS_EN_28 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 29. " IDMAC_EOS_EN_29 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 31. " IDMAC_EOS_EN_31 ,End of Scroll indication of Channel interrupt." "0,1"
width 11.
group.long 0x58++0x3
    line.long 0x00 "INT_CTRL_8,Interrupt Control Register 8"
        bitfld.long 0x00 1. " IDMAC_EOS_EN_33 ,End of Scroll of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_EOS_EN_41 ,End of Scroll of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_EOS_EN_42 ,End of Scroll of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_EOS_EN_43 ,End of Scroll of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_EOS_EN_44 ,End of Scroll of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_EOS_EN_51 ,End of Scroll of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_EOS_EN_52 ,End of Scroll of Channel interrupt." "0,1"
width 11.
group.long 0x5c++0x3
    line.long 0x00 "INT_CTRL_9,Interrupt Control Register 9"
        bitfld.long 0x00 0. " VDI_FIFO1_OVF_EN ,FIFO1 overflow Interrupt1 Enable The VDI C generates FIFO1 overflow interrupt1 when the write pointer of FIFO1 overruns read pointer." "0,1"
        textline "          "
        bitfld.long 0x00 26. " IC_BAYER_BUF_OVF_EN ,This bit enables an interrupt that is a result of the IC Buffer overflow for bayer coming from the IC." "0,1"
        textline "          "
        bitfld.long 0x00 27. " IC_ENC_BUF_OVF_EN ,This bit enables an interrupt that is a result of the IC Buffer overflow for encoding coming from the IC." "0,1"
        textline "          "
        bitfld.long 0x00 28. " IC_VF_BUF_OVF_EN ,This bit enables an interrupt that is a result of the IC Buffer overflow for view finder coming from the IC." "0,1"
        textline "          "
        bitfld.long 0x00 30. " CSI0_PUPE_EN ,CSI0_PUPE_EN - CSI0 parameters update error interrupt enable." "0,1"
        textline "          "
        bitfld.long 0x00 31. " CSI1_PUPE_EN ,CSI1_PUPE_EN - CSI1 parameters update error interrupt enable." "0,1"
width 12.
group.long 0x60++0x3
    line.long 0x00 "INT_CTRL_10,Interrupt Control Register 10"
        bitfld.long 0x00 0. " SMFC0_FRM_LOST_EN ,Frame Lost of SMFC channel 0 interrupt enable bit This bit enables an interrupt that is a result of a Frame Lost of SMFC channel 0." "0,1"
        textline "           "
        bitfld.long 0x00 1. " SMFC1_FRM_LOST_EN ,Frame Lost of SMFC channel 1 interrupt enable bit This bit enables an interrupt that is a result of a Frame Lost of SMFC channel 1." "0,1"
        textline "           "
        bitfld.long 0x00 2. " SMFC2_FRM_LOST_EN ,Frame Lost of SMFC channel 2 interrupt enable bit This bit enables an interrupt that is a result of a Frame Lost of SMFC channel 2." "0,1"
        textline "           "
        bitfld.long 0x00 3. " SMFC3_FRM_LOST_EN ,Frame Lost of SMFC channel 3 interrupt enable bit This bit enables an interrupt that is a result of a Frame Lost of SMFC channel 3." "0,1"
        textline "           "
        bitfld.long 0x00 16. " DC_TEARING_ERR_1_EN ,Tearing Error #1 enable This bit enables the interrupt that is a result of tearing error while the anti tearing mechanism is activated for DC channel 1" "0,1"
        textline "           "
        bitfld.long 0x00 17. " DC_TEARING_ERR_2_EN ,Tearing Error #2 enable This bit enables the interrupt that is a result of tearing error while the anti tearing mechanism is activated for DC channel 2" "0,1"
        textline "           "
        bitfld.long 0x00 18. " DC_TEARING_ERR_6_EN ,Tearing Error #6 enable This bit enables the interrupt that is a result of tearing error while the anti tearing mechanism is activated for DC channel 6" "0,1"
        textline "           "
        bitfld.long 0x00 19. " DI0_SYNC_DISP_ERR_EN ,DI0 Synchronous display error enable This bit enables the interrupt that is a result of an error during access to a synchronous display via DI0" "0,1"
        textline "           "
        bitfld.long 0x00 20. " DI1_SYNC_DISP_ERR_EN ,DI1 Synchronous display error enable This bit enables the interrupt that is a result of an error during access to a synchronous display via DI1" "0,1"
        textline "           "
        bitfld.long 0x00 21. " DI0_TIME_OUT_ERR_EN ,DI0 time outwore interrupt enable This bit enables the interrupt that is a result of a time out error during a read access via DI0" "0,1"
        textline "           "
        bitfld.long 0x00 22. " DI1_TIME_OUT_ERR_EN ,DI1 time out error interrupt enable This bit enables the interrupt that is a result of a time out error during a read access via DI1" "0,1"
        textline "           "
        bitfld.long 0x00 24. " IC_VF_FRM_LOST_ERR_EN ,This bit enables an interrupt that is a result of IC's view finder frame lost." "0,1"
        textline "           "
        bitfld.long 0x00 25. " IC_ENC_FRM_LOST_ERR_EN ,This bit enables an interrupt that is a result of IC's encoding frame lost." "0,1"
        textline "           "
        bitfld.long 0x00 26. " IC_BAYER_FRM_LOST_ERR_EN ,This bit enables an interrupt that is a result of IC's Bayer frame lost." "0,1"
        textline "           "
        bitfld.long 0x00 28. " NON_PRIVILEGED_ACC_ERR_EN ,Non Privileged Access Error interrupt enable." "0,1"
        textline "           "
        bitfld.long 0x00 29. " AXIW_ERR_EN ,This bit enables an interrupt that is a result of AXI write access resulted with error response." "0,1"
        textline "           "
        bitfld.long 0x00 30. " AXIR_ERR_EN ,This bit enables an interrupt that is a result of AXI read access resulted with error response." "0,1"
width 12.
group.long 0x64++0x3
    line.long 0x00 "INT_CTRL_11,Interrupt Control Register 11"
        bitfld.long 0x00 0. " IDMAC_EOBND_EN_0 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 1. " IDMAC_EOBND_EN_1 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 2. " IDMAC_EOBND_EN_2 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 3. " IDMAC_EOBND_EN_3 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 5. " IDMAC_EOBND_EN_5 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 11. " IDMAC_EOBND_EN_11 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 12. " IDMAC_EOBND_EN_12 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 20. " IDMAC_EOBND_EN_20 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 21. " IDMAC_EOBND_EN_21 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 22. " IDMAC_EOBND_EN_22 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 25. " IDMAC_EOBND_EN_25 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 26. " IDMAC_EOBND_EN_26 ,end-of-band indication of Channel interrupt." "0,1"
width 12.
group.long 0x68++0x3
    line.long 0x00 "INT_CTRL_12,Interrupt Control Register 12"
        bitfld.long 0x00 13. " IDMAC_EOBND_EN_45 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 14. " IDMAC_EOBND_EN_46 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 15. " IDMAC_EOBND_EN_47 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 16. " IDMAC_EOBND_EN_48 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 17. " IDMAC_EOBND_EN_49 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 18. " IDMAC_EOBND_EN_50 ,end-of-band indication of Channel interrupt." "0,1"
width 12.
group.long 0x6c++0x3
    line.long 0x00 "INT_CTRL_13,Interrupt Control Register 13"
        bitfld.long 0x00 0. " IDMAC_TH_EN_0 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 1. " IDMAC_TH_EN_1 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 2. " IDMAC_TH_EN_2 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 3. " IDMAC_TH_EN_3 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 5. " IDMAC_TH_EN_5 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 8. " IDMAC_TH_EN_8 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 9. " IDMAC_TH_EN_9 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 10. " IDMAC_TH_EN_10 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 11. " IDMAC_TH_EN_11 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 12. " IDMAC_TH_EN_12 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 13. " IDMAC_TH_EN_13 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 14. " IDMAC_TH_EN_14 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 15. " IDMAC_TH_EN_15 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 17. " IDMAC_TH_EN_17 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 18. " IDMAC_TH_EN_18 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 19. " IDMAC_TH_EN_19 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 20. " IDMAC_TH_EN_20 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 21. " IDMAC_TH_EN_21 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 22. " IDMAC_TH_EN_22 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 23. " IDMAC_TH_EN_23 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 24. " IDMAC_TH_EN_24 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 25. " IDMAC_TH_EN_25 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 26. " IDMAC_TH_EN_26 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 27. " IDMAC_TH_EN_27 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 28. " IDMAC_TH_EN_28 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 29. " IDMAC_TH_EN_29 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 31. " IDMAC_TH_EN_31 ,Threshold crossing indication of Channel interrupt." "0,1"
width 12.
group.long 0x70++0x3
    line.long 0x00 "INT_CTRL_14,Interrupt Control Register 14"
        bitfld.long 0x00 1. " IDMAC_TH_EN_33 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 8. " IDMAC_TH_EN_40 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 9. " IDMAC_TH_EN_41 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 10. " IDMAC_TH_EN_42 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 11. " IDMAC_TH_EN_43 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 12. " IDMAC_TH_EN_44 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 13. " IDMAC_TH_EN_45 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 14. " IDMAC_TH_EN_46 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 15. " IDMAC_TH_EN_47 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 16. " IDMAC_TH_EN_48 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 17. " IDMAC_TH_EN_49 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 18. " IDMAC_TH_EN_50 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 19. " IDMAC_TH_EN_51 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 20. " IDMAC_TH_EN_52 ,Threshold crossing indication of Channel interrupt." "0,1"
width 12.
group.long 0x74++0x3
    line.long 0x00 "INT_CTRL_15,Interrupt Control Register15"
        bitfld.long 0x00 0. " SNOOPING1_INT_EN ,IPU snooping 1 interrupt enable bit." "0,1"
        textline "           "
        bitfld.long 0x00 1. " SNOOPING2_INT_EN ,IPU snooping 2 interrupt enable bit." "0,1"
        textline "           "
        bitfld.long 0x00 2. " DP_SF_START_EN ,DP Sync Flow Start enable bit." "0,1"
        textline "           "
        bitfld.long 0x00 3. " DP_SF_END_EN ,DP Sync Flow End enable bit." "0,1"
        textline "           "
        bitfld.long 0x00 4. " DP_ASF_START_EN ,DP Async Flow Start enable bit." "0,1"
        textline "           "
        bitfld.long 0x00 5. " DP_ASF_END_EN ,DP Async Flow End enable bit." "0,1"
        textline "           "
        bitfld.long 0x00 6. " DP_SF_BRAKE_EN ,DP Sync Flow Brake enable bit." "0,1"
        textline "           "
        bitfld.long 0x00 7. " DP_ASF_BRAKE_EN ,DP Async Flow Brake enable bit." "0,1"
        textline "           "
        bitfld.long 0x00 8. " DC_FC_0_EN ,This bit enables they'd Frame Complete on channel #0 interrupt" "0,1"
        textline "           "
        bitfld.long 0x00 9. " DC_FC_1_EN ,This bit enables they'd Frame Complete on channel #1 interrupt" "0,1"
        textline "           "
        bitfld.long 0x00 10. " DC_FC_2_EN ,This bit enables the DC Frame Complete on channel #2 interrupt" "0,1"
        textline "           "
        bitfld.long 0x00 11. " DC_FC_3_EN ,This bit enables the DC Frame Complete on channel #3 interrupt" "0,1"
        textline "           "
        bitfld.long 0x00 12. " DC_FC_4_EN ,This bit enables the DC Frame Complete on channel #4 interrupt" "0,1"
        textline "           "
        bitfld.long 0x00 13. " DC_FC_6_EN ,This bit enables the DC Frame Complete on channel #6 interrupt" "0,1"
        textline "           "
        bitfld.long 0x00 14. " DI_VSYNC_PRE_0_EN ,This bit enables the DI0 interrupt indicating of a VSYNC signal asserted 2 rows before the VSYNC sent to the display" "0,1"
        textline "           "
        bitfld.long 0x00 15. " DI_VSYNC_PRE_1_EN ,This bit enables the DI1 interrupt indicating of a VSYNC signal asserted 2 rows before the VSYNC sent to the display" "0,1"
        textline "           "
        bitfld.long 0x00 16. " DC_DP_START_EN ,This bit enables the interrupt asserted anytime the DP start a new sync or async flow or when an async flow is interrupted by a sync flow" "0,1"
        textline "           "
        bitfld.long 0x00 17. " DC_ASYNC_STOP_EN ,This bit enables the interrupt asserted anytime the DP stops an async flow and moves to a sync flow" "0,1"
        textline "           "
        bitfld.long 0x00 18. " DI0_CNT_EN_PRE_0_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #0 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 19. " DI0_CNT_EN_PRE_1_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #1 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 20. " DI0_CNT_EN_PRE_2_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #2 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 21. " DI0_CNT_EN_PRE_3_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #3 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 22. " DI0_CNT_EN_PRE_4_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #4 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 23. " DI0_CNT_EN_PRE_5_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #5 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 24. " DI0_CNT_EN_PRE_6_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #6 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 25. " DI0_CNT_EN_PRE_7_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #7 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 26. " DI0_CNT_EN_PRE_8_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #8 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 27. " DI0_CNT_EN_PRE_9_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #9 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 28. " DI0_CNT_EN_PRE_10_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #10 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 29. " DI1_DISP_CLK_EN_PRE_EN ,DI1_DISP_CLK_EN_PRE_EN" "0,1"
        textline "           "
        bitfld.long 0x00 30. " DI1_CNT_EN_PRE_3_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #3 of DI1" "0,1"
        textline "           "
        bitfld.long 0x00 31. " DI1_CNT_EN_PRE_8_EN ,This bit enables the interrupt that is a result of a trigger generated by counter #8 of DI1" "0,1"
width 13.
group.long 0x78++0x3
    line.long 0x00 "SDMA_EVENT_1,SDMA Event Control Register 1"
        bitfld.long 0x00 0. " IDMAC_EOF_SDMA_EN_0 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 1. " IDMAC_EOF_SDMA_EN_1 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 2. " IDMAC_EOF_SDMA_EN_2 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 3. " IDMAC_EOF_SDMA_EN_3 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 5. " IDMAC_EOF_SDMA_EN_5 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 8. " IDMAC_EOF_SDMA_EN_8 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 9. " IDMAC_EOF_SDMA_EN_9 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 10. " IDMAC_EOF_SDMA_EN_10 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 11. " IDMAC_EOF_SDMA_EN_11 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 12. " IDMAC_EOF_SDMA_EN_12 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 13. " IDMAC_EOF_SDMA_EN_13 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 14. " IDMAC_EOF_SDMA_EN_14 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 15. " IDMAC_EOF_SDMA_EN_15 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 17. " IDMAC_EOF_SDMA_EN_17 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 18. " IDMAC_EOF_SDMA_EN_18 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 19. " IDMAC_EOF_SDMA_EN_19 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 20. " IDMAC_EOF_SDMA_EN_20 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 21. " IDMAC_EOF_SDMA_EN_21 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 22. " IDMAC_EOF_SDMA_EN_22 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 23. " IDMAC_EOF_SDMA_EN_23 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 24. " IDMAC_EOF_SDMA_EN_24 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 25. " IDMAC_EOF_SDMA_EN_25 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 26. " IDMAC_EOF_SDMA_EN_26 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 27. " IDMAC_EOF_SDMA_EN_27 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 28. " IDMAC_EOF_SDMA_EN_28 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 29. " IDMAC_EOF_SDMA_EN_29 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 31. " IDMAC_EOF_SDMA_EN_31 ,Enable End of Frame of Channel SDMA event." "0,1"
width 13.
group.long 0x7c++0x3
    line.long 0x00 "SDMA_EVENT_2,SDMA Event Control Register 2"
        bitfld.long 0x00 1. " IDMAC_EOF_SDMA_EN_33 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 8. " IDMAC_EOF_SDMA_EN_40 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 9. " IDMAC_EOF_SDMA_EN_41 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 10. " IDMAC_EOF_SDMA_EN_42 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 11. " IDMAC_EOF_SDMA_EN_43 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 12. " IDMAC_EOF_SDMA_EN_44 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 13. " IDMAC_EOF_SDMA_EN_45 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 14. " IDMAC_EOF_SDMA_EN_46 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 15. " IDMAC_EOF_SDMA_EN_47 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 16. " IDMAC_EOF_SDMA_EN_48 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 17. " IDMAC_EOF_SDMA_EN_49 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 18. " IDMAC_EOF_SDMA_EN_50 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 19. " IDMAC_EOF_SDMA_EN_51 ,Enable End of Frame of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 20. " IDMAC_EOF_SDMA_EN_52 ,Enable End of Frame of Channel SDMA event." "0,1"
width 13.
group.long 0x80++0x3
    line.long 0x00 "SDMA_EVENT_3,SDMA Event Control Register 3"
        bitfld.long 0x00 0. " IDMAC_NFACK_SDMA_EN_0 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 1. " IDMAC_NFACK_SDMA_EN_1 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 2. " IDMAC_NFACK_SDMA_EN_2 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 3. " IDMAC_NFACK_SDMA_EN_3 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 5. " IDMAC_NFACK_SDMA_EN_5 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 8. " IDMAC_NFACK_SDMA_EN_8 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 9. " IDMAC_NFACK_SDMA_EN_9 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 10. " IDMAC_NFACK_SDMA_EN_10 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 11. " IDMAC_NFACK_SDMA_EN_11 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 12. " IDMAC_NFACK_SDMA_EN_12 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 13. " IDMAC_NFACK_SDMA_EN_13 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 14. " IDMAC_NFACK_SDMA_EN_14 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 15. " IDMAC_NFACK_SDMA_EN_15 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 17. " IDMAC_NFACK_SDMA_EN_17 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 18. " IDMAC_NFACK_SDMA_EN_18 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 19. " IDMAC_NFACK_SDMA_EN_19 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 20. " IDMAC_NFACK_SDMA_EN_20 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 21. " IDMAC_NFACK_SDMA_EN_21 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 22. " IDMAC_NFACK_SDMA_EN_22 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 23. " IDMAC_NFACK_SDMA_EN_23 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 24. " IDMAC_NFACK_SDMA_EN_24 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 25. " IDMAC_NFACK_SDMA_EN_25 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 26. " IDMAC_NFACK_SDMA_EN_26 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 27. " IDMAC_NFACK_SDMA_EN_27 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 28. " IDMAC_NFACK_SDMA_EN_28 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 29. " IDMAC_NFACK_SDMA_EN_29 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 31. " IDMAC_NFACK_SDMA_EN_31 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
width 13.
group.long 0x84++0x3
    line.long 0x00 "SDMA_EVENT_4,SDMA Event Control Register 4"
        bitfld.long 0x00 1. " IDMAC_NFACK_SDMA_EN_33 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 8. " IDMAC_NFACK_SDMA_EN_40 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 9. " IDMAC_NFACK_SDMA_EN_41 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 10. " IDMAC_NFACK_SDMA_EN_42 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 11. " IDMAC_NFACK_SDMA_EN_43 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 12. " IDMAC_NFACK_SDMA_EN_44 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 13. " IDMAC_NFACK_SDMA_EN_45 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 14. " IDMAC_NFACK_SDMA_EN_46 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 15. " IDMAC_NFACK_SDMA_EN_47 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 16. " IDMAC_NFACK_SDMA_EN_48 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 17. " IDMAC_NFACK_SDMA_EN_49 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 18. " IDMAC_NFACK_SDMA_EN_50 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 19. " IDMAC_NFACK_SDMA_EN_51 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 20. " IDMAC_NFACK_SDMA_EN_52 ,Enable New Frame Acknowledge of Channel SDMA event." "0,1"
width 13.
group.long 0x88++0x3
    line.long 0x00 "SDMA_EVENT_7,SDMA Event Control Register 7"
        bitfld.long 0x00 19. " IDMAC_EOS_SDMA_EN_19 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 23. " IDMAC_EOS_SDMA_EN_23 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 24. " IDMAC_EOS_SDMA_EN_24 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 25. " IDMAC_EOS_SDMA_EN_25 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 26. " IDMAC_EOS_SDMA_EN_26 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 27. " IDMAC_EOS_SDMA_EN_27 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 28. " IDMAC_EOS_SDMA_EN_28 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 29. " IDMAC_EOS_SDMA_EN_29 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 31. " IDMAC_EOS_SDMA_EN_31 ,Enable End of Scroll of Channel SDMA event." "0,1"
width 13.
group.long 0x8c++0x3
    line.long 0x00 "SDMA_EVENT_8,SDMA Event Control Register 8"
        bitfld.long 0x00 1. " IDMAC_EOS_SDMA_EN_33 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 9. " IDMAC_EOS_SDMA_EN_41 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 10. " IDMAC_EOS_SDMA_EN_42 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 11. " IDMAC_EOS_SDMA_EN_43 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 12. " IDMAC_EOS_SDMA_EN_44 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 19. " IDMAC_EOS_SDMA_EN_51 ,Enable End of Scroll of Channel SDMA event." "0,1"
        textline "            "
        bitfld.long 0x00 20. " IDMAC_EOS_SDMA_EN_52 ,Enable End of Scroll of Channel SDMA event." "0,1"
width 14.
group.long 0x90++0x3
    line.long 0x00 "SDMA_EVENT_11,SDMA Event Control Register 11"
        bitfld.long 0x00 0. " IDMAC_EOBND_SDMA_EN_0 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 1. " IDMAC_EOBND_SDMA_EN_1 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 2. " IDMAC_EOBND_SDMA_EN_2 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 3. " IDMAC_EOBND_SDMA_EN_3 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 5. " IDMAC_EOBND_SDMA_EN_5 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 11. " IDMAC_EOBND_SDMA_EN_11 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 12. " IDMAC_EOBND_SDMA_EN_12 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 20. " IDMAC_EOBND_SDMA_EN_20 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 21. " IDMAC_EOBND_SDMA_EN_21 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 22. " IDMAC_EOBND_SDMA_EN_22 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 25. " IDMAC_EOBND_SDMA_EN_25 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 26. " IDMAC_EOBND_SDMA_EN_26 ,Enable End of Band of Channel SDMA event." "0,1"
width 14.
group.long 0x94++0x3
    line.long 0x00 "SDMA_EVENT_12,SDMA Event Control Register 12"
        bitfld.long 0x00 13. " IDMAC_EOBND_SDMA_EN_45 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 14. " IDMAC_EOBND_SDMA_EN_46 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 15. " IDMAC_EOBND_SDMA_EN_47 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 16. " IDMAC_EOBND_SDMA_EN_48 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 17. " IDMAC_EOBND_SDMA_EN_49 ,Enable End of Band of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 18. " IDMAC_EOBND_SDMA_EN_50 ,Enable End of Band of Channel SDMA event." "0,1"
width 14.
group.long 0x98++0x3
    line.long 0x00 "SDMA_EVENT_13,SDMA Event Control Register 13"
        bitfld.long 0x00 0. " IDMAC_TH_SDMA_EN_0 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 1. " IDMAC_TH_SDMA_EN_1 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 2. " IDMAC_TH_SDMA_EN_2 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 3. " IDMAC_TH_SDMA_EN_3 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 5. " IDMAC_TH_SDMA_EN_5 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 8. " IDMAC_TH_SDMA_EN_8 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 9. " IDMAC_TH_SDMA_EN_9 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 10. " IDMAC_TH_SDMA_EN_10 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 11. " IDMAC_TH_SDMA_EN_11 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 12. " IDMAC_TH_SDMA_EN_12 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 13. " IDMAC_TH_SDMA_EN_13 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 14. " IDMAC_TH_SDMA_EN_14 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 15. " IDMAC_TH_SDMA_EN_15 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 17. " IDMAC_TH_SDMA_EN_17 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 18. " IDMAC_TH_SDMA_EN_18 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 19. " IDMAC_TH_SDMA_EN_19 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 20. " IDMAC_TH_SDMA_EN_20 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 21. " IDMAC_TH_SDMA_EN_21 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 22. " IDMAC_TH_SDMA_EN_22 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 23. " IDMAC_TH_SDMA_EN_23 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 24. " IDMAC_TH_SDMA_EN_24 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 25. " IDMAC_TH_SDMA_EN_25 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 26. " IDMAC_TH_SDMA_EN_26 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 27. " IDMAC_TH_SDMA_EN_27 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 28. " IDMAC_TH_SDMA_EN_28 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 29. " IDMAC_TH_SDMA_EN_29 ,Enable Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 31. " IDMAC_TH_SDMA_EN_31 ,Enable Threshold of Channel SDMA event." "0,1"
width 14.
group.long 0x9c++0x3
    line.long 0x00 "SDMA_EVENT_14,SDMA Event Control Register 14"
        bitfld.long 0x00 1. " IDMAC_TH_SDMA_EN_33 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 8. " IDMAC_TH_SDMA_EN_40 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 9. " IDMAC_TH_SDMA_EN_41 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 10. " IDMAC_TH_SDMA_EN_42 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 11. " IDMAC_TH_SDMA_EN_43 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 12. " IDMAC_TH_SDMA_EN_44 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 13. " IDMAC_TH_SDMA_EN_45 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 14. " IDMAC_TH_SDMA_EN_46 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 15. " IDMAC_TH_SDMA_EN_47 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 16. " IDMAC_TH_SDMA_EN_48 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 17. " IDMAC_TH_SDMA_EN_49 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 18. " IDMAC_TH_SDMA_EN_50 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 19. " IDMAC_TH_SDMA_EN_51 ,Threshold of Channel SDMA event." "0,1"
        textline "             "
        bitfld.long 0x00 20. " IDMAC_TH_SDMA_EN_52 ,Threshold of Channel SDMA event." "0,1"
width 9.
group.long 0xa0++0x3
    line.long 0x00 "SRM_PRI1,Shadow Registers Memory Priority 1 Register"
        hexmask.long.byte 0x00 0.--3. 1. " CSI1_SRM_PRI ,CSI1 SRM priority This bits define the priority of the CSI0 module"
        textline "        "
        hexmask.long.byte 0x00 3.--5. 1. " CSI1_SRM_MODE ,CSI1 SRM Mode This field controls the SRM logic that handles the CSI1 registers"
        textline "        "
        hexmask.long.byte 0x00 8.--11. 1. " CSI0_SRM_PRI ,CSI0 SRM priority This bits define the priority of the CSI1 block"
        textline "        "
        hexmask.long.byte 0x00 11.--13. 1. " CSI0_SRM_MODE ,CSI0 SRM Mode This field controls the SRM logic that handles the CSI0 registers"
width 9.
group.long 0xa4++0x3
    line.long 0x00 "SRM_PRI2,Shadow Registers Memory Priority 2 Register"
        hexmask.long.byte 0x00 0.--3. 1. " DP_SRM_PRI ,DP SRM priority This bits define the priority of the DP module"
        textline "        "
        hexmask.long.byte 0x00 3.--5. 1. " DP_S_SRM_MODE ,DP sync flow SRM Mode This field controls the SRM logic that handles the DP sync flow registers"
        textline "        "
        hexmask.long.byte 0x00 5.--7. 1. " DP_A0_SRM_MODE ,DP Async flow #0 SRM Mode This field controls the SRM logic that handles the DP Async flow #0 registers"
        textline "        "
        hexmask.long.byte 0x00 7.--9. 1. " DP_A1_SRM_MODE ,DP Async flow #1 SRM Mode This field controls the SRM logic that handles the DP Async flow #1 registers"
        textline "        "
        hexmask.long.byte 0x00 9.--12. 1. " DC_SRM_PRI ,DC SRM priority This bits define the priority of the DC module"
        textline "        "
        hexmask.long.byte 0x00 12.--14. 1. " DC_2_SRM_MODE ,DC Group #2 SRM Mode This field controls the SRM logic that handles the DC Group #2 registers"
        textline "        "
        hexmask.long.byte 0x00 14.--16. 1. " DC_6_SRM_MODE ,DC Group #6 SRM Mode This field controls the SRM logic that handles the DC Group #6 registers"
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " DI0_SRM_PRI ,DI0 SRM priority This bits define the priority of the DI0 module"
        textline "        "
        hexmask.long.byte 0x00 19.--21. 1. " DI0_SRM_MCU_USE ,DI0 SRM is used by ARM platform This bit indicates that the registers of the DI0 are currently being updated by the ARM platform."
        textline "        "
        hexmask.long.byte 0x00 24.--27. 1. " DI1_SRM_PRI ,DI1 SRM priority This bits define the priority of the DI1 module"
        textline "        "
        hexmask.long.byte 0x00 27.--29. 1. " DI1_SRM_MODE ,DCI1 SRM Mode This field controls the SRM logic that handles the DI1 registers"
width 14.
group.long 0xa8++0x3
    line.long 0x00 "FS_PROC_FLOW1,FSU Processing Flow 1 Register"
        hexmask.long.byte 0x00 0.--4. 1. " PRPENC_ROT_SRC_SEL ,Source select for the encoding task of the IRT"
        textline "             "
        hexmask.long.byte 0x00 8.--12. 1. " PRPVF_ROT_SRC_SEL ,Source select for the view finder task of the IRT 0000 ARM platform"
        textline "             "
        hexmask.long.byte 0x00 12.--16. 1. " PP_SRC_SEL ,Source select for the pre processing task of the IC"
        textline "             "
        hexmask.long.byte 0x00 16.--20. 1. " PP_ROT_SRC_SEL ,Source select for the pre processing task of the IRT (CH 50)"
        textline "             "
        hexmask.long.byte 0x00 20.--22. 1. " VDI1_SRC_SEL ,Source select for the VDIC plane #1 (IDMAC's CH26) This field is relevant only if the VDIC works in combining mode (VDI_CMB_EN bit is set)"
        textline "             "
        hexmask.long.byte 0x00 22.--24. 1. " VDI3_SRC_SEL ,Source select for the VDIC plane #3 (IDMAC's CH 25)"
        textline "             "
        hexmask.long.byte 0x00 24.--28. 1. " PRP_SRC_SEL ,Source select for the Pre Processing Task 0000 ARM platform"
        textline "             "
        hexmask.long.byte 0x00 28.--30. 1. " VDI_SRC_SEL ,Source select for the VDI C This field is relevant if the VDIC works in de-interlacing mode (when VDI_CMB_EN bit is clear)"
        textline "             "
        bitfld.long 0x00 30. " ENC_IN_VALID ,Encoding Input valid." "0,1"
        textline "             "
        bitfld.long 0x00 31. " VF_IN_VALID ,View-finder Input valid." "0,1"
width 14.
group.long 0xac++0x3
    line.long 0x00 "FS_PROC_FLOW2,FSU Processing Flow 2 Register"
        hexmask.long.byte 0x00 0.--4. 1. " PRP_ENC_DEST_SEL ,Destination select for Encoding task"
        textline "             "
        hexmask.long.byte 0x00 4.--8. 1. " PRPVF_DEST_SEL ,Destination select for View finder task"
        textline "             "
        hexmask.long.byte 0x00 8.--12. 1. " PRPVF_ROT_DEST_SEL ,Destination select for Rotation task coming from the View finder input"
        textline "             "
        hexmask.long.byte 0x00 12.--16. 1. " PP_DEST_SEL ,Destination select for post processing task"
        textline "             "
        hexmask.long.byte 0x00 16.--20. 1. " PP_ROT_DEST_SEL ,Destination select for Rotation task coming from the Post Processing input"
        textline "             "
        hexmask.long.byte 0x00 20.--24. 1. " PRPENC_ROT_DEST_SEL ,Destination select for Rotation task coming from the Encoding input"
        textline "             "
        hexmask.long.byte 0x00 24.--28. 1. " PRP_DEST_SEL ,Pre processing destination select (for channel DMAIC_7)"
width 14.
group.long 0xb0++0x3
    line.long 0x00 "FS_PROC_FLOW3,FSU Processing Flow 3 Register"
        hexmask.long.byte 0x00 0.--4. 1. " SMFC0_DEST_SEL ,Destination select for SMFC0"
        textline "             "
        hexmask.long.byte 0x00 4.--7. 1. " SMFC1_DEST_SEL ,Destination select for SMFC1"
        textline "             "
        hexmask.long.byte 0x00 7.--11. 1. " SMFC2_DEST_SEL ,Destination select for SMFC2"
        textline "             "
        hexmask.long.byte 0x00 11.--14. 1. " SMFC3_DEST_SEL ,Destination select for SMFC3"
        textline "             "
        hexmask.long.byte 0x00 16.--18. 1. " VDOA_DEST_SEL ,Destination select for VDOA"
        textline "             "
        hexmask.long.byte 0x00 20.--22. 1. " EXT_SRC1_DEST_SEL ,Destination select for External Source 1"
        textline "             "
        hexmask.long.byte 0x00 22.--24. 1. " EXT_SRC2_DEST_SEL ,Destination select for External Source 2"
        textline "             "
        hexmask.long.byte 0x00 24.--26. 1. " VPU_DEST_SEL ,This bits selects the corresponding IDMAC channel's EOL indication to be used for sub frame synchronization with the VPU."
width 14.
group.long 0xb4++0x3
    line.long 0x00 "FS_DISP_FLOW1,FSU Displaying Flow 1 Register"
        hexmask.long.byte 0x00 0.--4. 1. " DP_SYNC0_SRC_SEL ,Source select for DS2 - MG (graphics) plane (ch23)"
        textline "             "
        hexmask.long.byte 0x00 4.--8. 1. " DP_SYNC1_SRC_SEL ,Source select for DS1/DS2 - Vx (video) plane (ch27)"
        textline "             "
        hexmask.long.byte 0x00 8.--12. 1. " DP_ASYNC0_SRC_SEL ,Source select for DS2 - MG (graphics) plane (ch29)"
        textline "             "
        hexmask.long.byte 0x00 12.--16. 1. " DP_ASYNC1_SRC_SEL ,Source select for DS1/DS2 - Vx (video) plane (ch24)"
        textline "             "
        hexmask.long.byte 0x00 16.--20. 1. " DC2_SRC_SEL ,Source select for DS3 (ch41)"
        textline "             "
        hexmask.long.byte 0x00 20.--24. 1. " DC1_SRC_SEL ,Source select for DS1/DS2 - MG (graphics) plane (ch28)"
width 14.
group.long 0xb8++0x3
    line.long 0x00 "FS_DISP_FLOW2,FSU Displaying Flow 2 Register"
        hexmask.long.byte 0x00 0.--4. 1. " DP_ASYNC0_ALT_SRC_SEL ,Source select for alternate DS2 - MG (graphics) plane (ch29)"
        textline "             "
        hexmask.long.byte 0x00 4.--8. 1. " DP_ASYNC1_ALT_SRC_SEL ,Source select for alternate DS1/DS2 - Vx (video) plane (ch24)"
        textline "             "
        hexmask.long.byte 0x00 16.--20. 1. " DC2_ALT_SRC_SEL ,Source select for Alternate DS3 (ch41)"
width 5.
group.long 0xbc++0x3
    line.long 0x00 "SKIP,SKIP Register"
        hexmask.long.byte 0x00 0.--3. 1. " CSI_MAX_RATIO_SKIP_IC_ENC ,CSI Maximum Ratio Skip for IC (encoding task) These bits define the number of frames in a skipping set."
        textline "    "
        hexmask.long.byte 0x00 3.--8. 1. " CSI_SKIP_IC_ENC ,CSI SKIP IC_ENC These 5 bits define the skipping pattern of the frames send to the IC for encoding task from one of the CSIs as defined on the CSI_SEL and IC_INPUT bits Skipping is done for a set of frames."
        textline "    "
        hexmask.long.byte 0x00 8.--11. 1. " CSI_MAX_RATIO_SKIP_IC_VF ,CSI Maximum Ratio Skip for IC (view finder task) These bits define the number of frames in a skipping set."
        textline "    "
        hexmask.long.byte 0x00 11.--16. 1. " CSI_SKIP_IC_VF ,CSI SKIP IC_VF These 5 bits define the skipping pattern of the frames send to the IC for view finder task from one of the CSIs as defined on the CSI_SEL and IC_INPUT bits Skipping is done for a set of frames."
        textline "    "
        hexmask.long.byte 0x00 16.--20. 1. " VDI_MAX_RATIO_SKIP ,Maximum Ratio Skip for VDI C These bits define the number of frames in a skipping set."
        textline "    "
        hexmask.long.word 0x00 20.--32. 1. " VDI_SKIP ,VDI_SKIP These 12 bits define the skipping pattern of the frames send from the VDI C ."
width 14.
group.long 0xc0++0x3
    line.long 0x00 "DISP_ALT_CONF,Display Alternate Configuration Register"
width 9.
group.long 0xc4++0x3
    line.long 0x00 "DISP_GEN,Display General Control Register"
        bitfld.long 0x00 0. " DI0_DUAL_MODE ,DI0 dual mode control" "0,1"
        textline "        "
        bitfld.long 0x00 1. " DI1_DUAL_MODE ,DI1 dual mode control" "0,1"
        textline "        "
        bitfld.long 0x00 2. " DC2_DOUBLE_FLOW ,DC2 Double Flow." "0,1"
        textline "        "
        bitfld.long 0x00 3. " DP_ASYNC_DOUBLE_FLOW ,DP Async Double Flow." "0,1"
        textline "        "
        bitfld.long 0x00 4. " DP_FG_EN_ASYNC0 ,FG_EN - partial plane Enable for async flow 0." "0,1"
        textline "        "
        bitfld.long 0x00 5. " DP_FG_EN_ASYNC1 ,FG_EN - partial plane Enable for async flow 1." "0,1"
        textline "        "
        bitfld.long 0x00 6. " DP_PIPE_CLR ,DP Pipe Clear This bit clears the internal pipe of the DP." "0,1"
        textline "        "
        bitfld.long 0x00 16. " MCU_DI_ID_8 ,MCU_DI_ID_8 - DI ID via DC channel 8." "0,1"
        textline "        "
        bitfld.long 0x00 17. " MCU_DI_ID_9 ,MCU_DI_ID_9 - DI ID via DC channel 9." "0,1"
        textline "        "
        hexmask.long.byte 0x00 18.--22. 1. " MCU_T ,The address space for accesses through the AHB-lite slave port is MB and it is split internally (with 32MB resolution) according to bits [28:25] of the address."
        textline "        "
        bitfld.long 0x00 22. " MCU_MAX_BURST_STOP ,ARM platform Maximal burst This bit limit the maximal unspecified length burst." "0,1"
        textline "        "
        bitfld.long 0x00 23. " CSI_VSYNC_DEST ,CSI_VSYNC destination This bit defines the destination of the VSYNC coming from the CSI's" "0,1"
        textline "        "
        bitfld.long 0x00 24. " DI0_COUNTER_RELEASE ,DI1 Counter release By default the DI0 counters responsible for waveform generation for sync flow are frozen." "0,1"
        textline "        "
        bitfld.long 0x00 25. " DI1_COUNTER_RELEASE ,DI1 Counter release By default the DI0 counters responsible for waveform generation for sync flow are frozen." "0,1"
width 10.
group.long 0xc8++0x3
    line.long 0x00 "DISP_ALT1,Display Alternate Flow Control Register 1"
        hexmask.long.word 0x00 0.--12. 1. " RUN_VALUE_M1_ALT_0 ,Counter pre defined value This fields defines the counter pre defines value."
        textline "         "
        hexmask.long.byte 0x00 12.--15. 1. " CNT_CLR_SEL_ALT_0 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "         "
        bitfld.long 0x00 15. " CNT_AUTO_RELOAD_ALT_0 ,Counter auto reload mode" "0,1"
        textline "         "
        hexmask.long.word 0x00 16.--28. 1. " STEP_REPEAT_ALT_0 ,This fields defines the amount of repetitions that will be performed by the counter"
        textline "         "
        hexmask.long.byte 0x00 28.--32. 1. " SEL_ALT_0 ,Select alternative parameters instead of DI Sync Wave Gen counter#."
width 10.
group.long 0xcc++0x3
    line.long 0x00 "DISP_ALT2,Display Alternate Flow Control Register 2"
        hexmask.long.word 0x00 0.--12. 1. " OFFSET_VALUE_ALT_0 ,Counter offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "         "
        hexmask.long.byte 0x00 12.--15. 1. " OFFSET_RESOLUTION_ALT_0 ,Counter offset Resolution This field defines the trigger causing the offset counter to increment The counter offset resolution should be defined in the same way as in original DI's counter#"
        textline "         "
        hexmask.long.byte 0x00 16.--19. 1. " RUN_RESOLUTION_ALT_0 ,Counter Run Resolution This field defines the trigger causing the counter to increment."
width 10.
group.long 0xd0++0x3
    line.long 0x00 "DISP_ALT3,Display Alternate Flow Control Register 3"
        hexmask.long.word 0x00 0.--12. 1. " RUN_VALUE_M1_ALT_1 ,Counter pre defined value This fields defines the counter pre defines value."
        textline "         "
        hexmask.long.byte 0x00 12.--15. 1. " CNT_CLR_SEL_ALT_1 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "         "
        bitfld.long 0x00 15. " CNT_AUTO_RELOAD_ALT_1 ,Counter auto reload mode" "0,1"
        textline "         "
        hexmask.long.word 0x00 16.--28. 1. " STEP_REPEAT_ALT_1 ,This fields defines the amount of repetitions that will be performed by the counter"
        textline "         "
        hexmask.long.byte 0x00 28.--32. 1. " SEL_ALT_1 ,Select alternative parameters instead of DI Sync Wave Gen counter#."
width 10.
group.long 0xd4++0x3
    line.long 0x00 "DISP_ALT4,Display Alternate Flow Control Register 4"
        hexmask.long.word 0x00 0.--12. 1. " OFFSET_VALUE_ALT_1 ,Counter offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "         "
        hexmask.long.byte 0x00 12.--15. 1. " OFFSET_RESOLUTION_ALT_1 ,Counter offset Resolution This field defines the trigger causing the offset counter to increment The counter offset resolution should be defined in the same way as in original DI's counter#"
        textline "         "
        hexmask.long.byte 0x00 16.--19. 1. " RUN_RESOLUTION_ALT_1 ,Counter Run Resolution This field defines the trigger causing the counter to increment."
width 8.
group.long 0xdc++0x3
    line.long 0x00 "MEM_RST,Memory Reset Control Register"
        hexmask.long.long 0x00 0.--23. 1. " RST_MEM_EN ,Reset Memory Enable Each bit on this field enables the memory reset mechanism for a specific memory."
        textline "       "
        bitfld.long 0x00 31. " RST_MEM_START ,Memory Reset Start Writing one to this bit activate the memory reset mechanism." "0,1"
width 3.
group.long 0xe0++0x3
    line.long 0x00 "PM,Power Modes Control Register"
        hexmask.long.byte 0x00 0.--7. 1. " DI0_CLK_PERIOD_0 ,DI0_CLK period option 0."
        textline "  "
        hexmask.long.byte 0x00 7.--14. 1. " DI0_CLK_PERIOD_1 ,DI0_CLK period option 1."
        textline "  "
        bitfld.long 0x00 14. " DI0_SRM_CLOCK_CHANGE_MODE ,SRM clock change mode When the clock is going to be changed to any new ratio other then 1:1, 1:2." "0,1"
        textline "  "
        bitfld.long 0x00 15. " CLCOK_MODE_STAT ,Clock mode status This is a read only bit indicating what is the current clock mode" "0,1"
        textline "  "
        hexmask.long.byte 0x00 16.--23. 1. " DI1_CLK_PERIOD_0 ,DI1_CLK period option 0."
        textline "  "
        hexmask.long.byte 0x00 23.--30. 1. " DI1_CLK_PERIOD_1 ,DI1_CLK period option 1."
        textline "  "
        bitfld.long 0x00 30. " DI1_SRM_CLOCK_CHANGE_MODE ,SRM clock change mode When the clock is going to be changed to any new ratio other then 1:1, 1:2." "0,1"
        textline "  "
        bitfld.long 0x00 31. " LPSR_MODE ,LPSR Mode This bit indicates that the next attempt for entering low power mode is an attempt to move to LPST mode." "0,1"
width 4.
group.long 0xe4++0x3
    line.long 0x00 "GPR,General Purpose Register"
        hexmask.long.long 0x00 0.--20. 1. " IPU_GPN ,IPU General Purpose bit."
        textline "   "
        bitfld.long 0x00 20. " IPU_CH_BUF2_RDY0_CLR ,This bit defines the IPU_CH_BUF2_RDY0 properties." "0,1"
        textline "   "
        bitfld.long 0x00 21. " IPU_CH_BUF2_RDY1_CLR ,This bit defines the IPU_CH_BUF2_RDY1 properties." "0,1"
        textline "   "
        bitfld.long 0x00 22. " IPU_DI0_CLK_CHANGE_ACK_DIS ,Disable DI0's clock change mechanism." "0,1"
        textline "   "
        bitfld.long 0x00 23. " IPU_DI1_CLK_CHANGE_ACK_DIS ,Disable DI1's clock change mechanism." "0,1"
        textline "   "
        bitfld.long 0x00 24. " IPU_ALT_CH_BUF0_RDY0_CLR ,This bit defines the IPU_ALT_CH_BUF0_RDY0 properties." "0,1"
        textline "   "
        bitfld.long 0x00 25. " IPU_ALT_CH_BUF0_RDY1_CLR ,This bit defines the IPU_ALT_CH_BUF0_RDY1 properties." "0,1"
        textline "   "
        bitfld.long 0x00 26. " IPU_ALT_CH_BUF1_RDY0_CLR ,This bit defines the IPU_ALT_CH_BUF1_RDY0 properties." "0,1"
        textline "   "
        bitfld.long 0x00 27. " IPU_ALT_CH_BUF1_RDY1_CLR ,This bit defines the IPU_ALT_CH_BUF1_RDY1 properties." "0,1"
        textline "   "
        bitfld.long 0x00 28. " IPU_CH_BUF0_RDY0_CLR ,This bit defines the IPU_CH_BUF0_RDY0 properties." "0,1"
        textline "   "
        bitfld.long 0x00 29. " IPU_CH_BUF0_RDY1_CLR ,This bit defines the IPU_CH_BUF0_RDY1 properties." "0,1"
        textline "   "
        bitfld.long 0x00 30. " IPU_CH_BUF1_RDY0_CLR ,This bit defines the IPU_CH_BUF1_RDY0 properties." "0,1"
        textline "   "
        bitfld.long 0x00 31. " IPU_CH_BUF1_RDY1_CLR ,This bit defines the IPU_CH_BUF1_RDY1 properties." "0,1"
width 16.
group.long 0x154++0x3
    line.long 0x00 "CH_DB_MODE_SEL1,Channel Double Buffer Mode Select 1 Register"
        bitfld.long 0x00 1. " DMA_CH_DB_MODE_SEL_33 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 8. " DMA_CH_DB_MODE_SEL_40 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 9. " DMA_CH_DB_MODE_SEL_41 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 10. " DMA_CH_DB_MODE_SEL_42 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 11. " DMA_CH_DB_MODE_SEL_43 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 12. " DMA_CH_DB_MODE_SEL_44 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 13. " DMA_CH_DB_MODE_SEL_45 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 14. " DMA_CH_DB_MODE_SEL_46 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 15. " DMA_CH_DB_MODE_SEL_47 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 16. " DMA_CH_DB_MODE_SEL_48 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 17. " DMA_CH_DB_MODE_SEL_49 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 18. " DMA_CH_DB_MODE_SEL_50 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 19. " DMA_CH_DB_MODE_SEL_51 ,Double Buffer Mode Select." "0,1"
        textline "               "
        bitfld.long 0x00 20. " DMA_CH_DB_MODE_SEL_52 ,Double Buffer Mode Select." "0,1"
width 20.
group.long 0x168++0x3
    line.long 0x00 "ALT_CH_DB_MODE_SEL0,Alternate Channel Double Buffer Mode Select 0 Register"
        bitfld.long 0x00 4. " DMA_CH_ALT_DB_MODE_SEL_4 ,Double Buffer Mode Select." "0,1"
        textline "                   "
        bitfld.long 0x00 5. " DMA_CH_ALT_DB_MODE_SEL_5 ,Double Buffer Mode Select." "0,1"
        textline "                   "
        bitfld.long 0x00 6. " DMA_CH_ALT_DB_MODE_SEL_6 ,Double Buffer Mode Select." "0,1"
        textline "                   "
        bitfld.long 0x00 7. " DMA_CH_ALT_DB_MODE_SEL_7 ,Double Buffer Mode Select." "0,1"
        textline "                   "
        bitfld.long 0x00 24. " DMA_CH_ALT_DB_MODE_SEL_24 ,Double Buffer Mode Select." "0,1"
        textline "                   "
        bitfld.long 0x00 29. " DMA_CH_ALT_DB_MODE_SEL_29 ,Double Buffer Mode Select." "0,1"
width 20.
group.long 0x16c++0x3
    line.long 0x00 "ALT_CH_DB_MODE_SEL1,Alternate Channel Double Buffer Mode Select1 Register"
        bitfld.long 0x00 1. " DMA_CH_ALT_DB_MODE_SEL_33 ,Double Buffer Mode Select." "0,1"
        textline "                   "
        bitfld.long 0x00 9. " DMA_CH_ALT_DB_MODE_SEL_41 ,Double Buffer Mode Select." "0,1"
        textline "                   "
        bitfld.long 0x00 20. " DMA_CH_ALT_DB_MODE_SEL_52 ,Double Buffer Mode Select." "0,1"
width 21.
group.long 0x178++0x3
    line.long 0x00 "ALT_CH_TRB_MODE_SEL0,Alternate Channel Triple Buffer Mode Select 0 Register"
        bitfld.long 0x00 8. " DMA_CH_TRB_MODE_SEL_8 ,Triple Buffer Mode Select." "0,1"
        textline "                    "
        bitfld.long 0x00 9. " DMA_CH_TRB_MODE_SEL_9 ,Triple Buffer Mode Select." "0,1"
        textline "                    "
        bitfld.long 0x00 10. " DMA_CH_TRB_MODE_SEL_10 ,Triple Buffer Mode Select." "0,1"
        textline "                    "
        bitfld.long 0x00 13. " DMA_CH_TRB_MODE_SEL_13 ,Triple Buffer Mode Select." "0,1"
        textline "                    "
        bitfld.long 0x00 21. " DMA_CH_TRB_MODE_SEL_21 ,Triple Buffer Mode Select." "0,1"
        textline "                    "
        bitfld.long 0x00 23. " DMA_CH_TRB_MODE_SEL_23 ,Triple Buffer Mode Select." "0,1"
        textline "                    "
        bitfld.long 0x00 27. " DMA_CH_TRB_MODE_SEL_27 ,Triple Buffer Mode Select." "0,1"
        textline "                    "
        bitfld.long 0x00 28. " DMA_CH_TRB_MODE_SEL_28 ,Triple Buffer Mode Select." "0,1"
width 21.
group.long 0x17c++0x3
    line.long 0x00 "ALT_CH_TRB_MODE_SEL1,Alternate Channel Triple Buffer Mode Select 1 Register"
        hexmask.long.long 0x00 0.--32. 1. " DMA_CH_TRB_MODE_SEL_N ,Triple Buffer Mode Select."
width 11.
group.long 0x200++0x3
    line.long 0x00 "INT_STAT_1,Interrupt Status Register 1"
        bitfld.long 0x00 0. " IDMAC_EOF_0 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 1. " IDMAC_EOF_1 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 2. " IDMAC_EOF_2 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 3. " IDMAC_EOF_3 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 5. " IDMAC_EOF_5 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 8. " IDMAC_EOF_8 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_EOF_9 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_EOF_10 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_EOF_11 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_EOF_12 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 13. " IDMAC_EOF_13 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 14. " IDMAC_EOF_14 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 15. " IDMAC_EOF_15 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 17. " IDMAC_EOF_17 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 18. " IDMAC_EOF_18 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_EOF_19 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_EOF_20 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 21. " IDMAC_EOF_21 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 22. " IDMAC_EOF_22 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 23. " IDMAC_EOF_23 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 24. " IDMAC_EOF_24 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 25. " IDMAC_EOF_25 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 26. " IDMAC_EOF_26 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 27. " IDMAC_EOF_27 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 28. " IDMAC_EOF_28 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 29. " IDMAC_EOF_29 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 31. " IDMAC_EOF_31 ,End of Frame of Channel interrupt." "0,1"
width 11.
group.long 0x204++0x3
    line.long 0x00 "INT_STAT_2,Interrupt Status Register2"
        bitfld.long 0x00 1. " IDMAC_EOF_33 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 8. " IDMAC_EOF_40 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_EOF_41 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_EOF_42 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_EOF_43 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_EOF_44 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 13. " IDMAC_EOF_45 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 14. " IDMAC_EOF_46 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 15. " IDMAC_EOF_47 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 16. " IDMAC_EOF_48 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 17. " IDMAC_EOF_49 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 18. " IDMAC_EOF_50 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_EOF_51 ,End of Frame of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_EOF_52 ,End of Frame of Channel interrupt." "0,1"
width 11.
group.long 0x208++0x3
    line.long 0x00 "INT_STAT_3,Interrupt Status Register 3"
        bitfld.long 0x00 0. " IDMAC_NFACK_0 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 1. " IDMAC_NFACK_1 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 2. " IDMAC_NFACK_2 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 3. " IDMAC_NFACK_3 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 5. " IDMAC_NFACK_5 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 8. " IDMAC_NFACK_8 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_NFACK_9 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_NFACK_10 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_NFACK_11 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_NFACK_12 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 13. " IDMAC_NFACK_13 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 14. " IDMAC_NFACK_14 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 15. " IDMAC_NFACK_15 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 17. " IDMAC_NFACK_17 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 18. " IDMAC_NFACK_18 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_NFACK_19 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_NFACK_20 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 21. " IDMAC_NFACK_21 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 22. " IDMAC_NFACK_22 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 23. " IDMAC_NFACK_23 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 24. " IDMAC_NFACK_24 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 25. " IDMAC_NFACK_25 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 26. " IDMAC_NFACK_26 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 27. " IDMAC_NFACK_27 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 28. " IDMAC_NFACK_28 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 29. " IDMAC_NFACK_29 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 31. " IDMAC_NFACK_31 ,Enable New Frame Ack of Channel interrupt." "0,1"
width 11.
group.long 0x20c++0x3
    line.long 0x00 "INT_STAT_4,Interrupt Status Register 4"
        bitfld.long 0x00 1. " IDMAC_NFACK_33 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 8. " IDMAC_NFACK_40 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_NFACK_41 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_NFACK_42 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_NFACK_43 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_NFACK_44 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 13. " IDMAC_NFACK_45 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 14. " IDMAC_NFACK_46 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 15. " IDMAC_NFACK_47 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 16. " IDMAC_NFACK_48 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 17. " IDMAC_NFACK_49 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 18. " IDMAC_NFACK_50 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_NFACK_51 ,Enable New Frame Ack of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_NFACK_52 ,Enable New Frame Ack of Channel interrupt." "0,1"
width 11.
group.long 0x210++0x3
    line.long 0x00 "INT_STAT_5,Interrupt Status Register 5"
        bitfld.long 0x00 0. " IDMAC_NFB4EOF_ERR_0 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 1. " IDMAC_NFB4EOF_ERR_1 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 2. " IDMAC_NFB4EOF_ERR_2 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 3. " IDMAC_NFB4EOF_ERR_3 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 5. " IDMAC_NFB4EOF_ERR_5 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 8. " IDMAC_NFB4EOF_ERR_8 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_NFB4EOF_ERR_9 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_NFB4EOF_ERR_10 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_NFB4EOF_ERR_11 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_NFB4EOF_ERR_12 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 13. " IDMAC_NFB4EOF_ERR_13 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 14. " IDMAC_NFB4EOF_ERR_14 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 15. " IDMAC_NFB4EOF_ERR_15 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 17. " IDMAC_NFB4EOF_ERR_17 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 18. " IDMAC_NFB4EOF_ERR_18 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_NFB4EOF_ERR_19 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_NFB4EOF_ERR_20 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 21. " IDMAC_NFB4EOF_ERR_21 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 22. " IDMAC_NFB4EOF_ERR_22 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 23. " IDMAC_NFB4EOF_ERR_23 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 24. " IDMAC_NFB4EOF_ERR_24 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 25. " IDMAC_NFB4EOF_ERR_25 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 26. " IDMAC_NFB4EOF_ERR_26 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 27. " IDMAC_NFB4EOF_ERR_27 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 28. " IDMAC_NFB4EOF_ERR_28 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 29. " IDMAC_NFB4EOF_ERR_29 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 31. " IDMAC_NFB4EOF_ERR_31 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
width 11.
group.long 0x214++0x3
    line.long 0x00 "INT_STAT_6,Interrupt Status Register 6"
        bitfld.long 0x00 1. " IDMAC_NFB4EOF_ERR_33 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 8. " IDMAC_NFB4EOF_ERR_40 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_NFB4EOF_ERR_41 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_NFB4EOF_ERR_42 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_NFB4EOF_ERR_43 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_NFB4EOF_ERR_44 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 13. " IDMAC_NFB4EOF_ERR_45 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 14. " IDMAC_NFB4EOF_ERR_46 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 15. " IDMAC_NFB4EOF_ERR_47 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 16. " IDMAC_NFB4EOF_ERR_48 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 17. " IDMAC_NFB4EOF_ERR_49 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 18. " IDMAC_NFB4EOF_ERR_50 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_NFB4EOF_ERR_51 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_NFB4EOF_ERR_52 ,New Frame before end-of-frame error indication of Channel interrupt." "0,1"
width 11.
group.long 0x218++0x3
    line.long 0x00 "INT_STAT_7,Interrupt Status Register7 1"
        bitfld.long 0x00 19. " IDMAC_EOS_EN_19 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 23. " IDMAC_EOS_EN_23 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 24. " IDMAC_EOS_EN_24 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 25. " IDMAC_EOS_EN_25 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 26. " IDMAC_EOS_EN_26 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 27. " IDMAC_EOS_EN_27 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 28. " IDMAC_EOS_EN_28 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 29. " IDMAC_EOS_EN_29 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 31. " IDMAC_EOS_EN_31 ,End of Scroll indication of Channel interrupt." "0,1"
width 11.
group.long 0x21c++0x3
    line.long 0x00 "INT_STAT_8,Interrupt Status Register 8"
        bitfld.long 0x00 1. " IDMAC_EOS_EN_33 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 9. " IDMAC_EOS_EN_41 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 10. " IDMAC_EOS_EN_42 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 11. " IDMAC_EOS_EN_43 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 12. " IDMAC_EOS_EN_44 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 19. " IDMAC_EOS_EN_51 ,End of Scroll indication of Channel interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 20. " IDMAC_EOS_EN_52 ,End of Scroll indication of Channel interrupt." "0,1"
width 11.
group.long 0x220++0x3
    line.long 0x00 "INT_STAT_9,Interrupt Status Register 9"
        bitfld.long 0x00 0. " VDI_FIFO1_OVF ,FIFO1 overflow Interrupt1 The VDI C generate FIFO1 overflow interrupt1 when write pointer of FIFO1 overrun read pointer." "0,1"
        textline "          "
        bitfld.long 0x00 26. " IC_BAYER_BUF_OVF ,This bit indicates on an interrupt that is a result of the IC Buffer overflow for Bayer coming from the IC." "0,1"
        textline "          "
        bitfld.long 0x00 27. " IC_ENC_BUF_OVF ,This bit indicates on an interrupt that is a result of the IC Buffer overflow for encoding coming from the IC." "0,1"
        textline "          "
        bitfld.long 0x00 28. " IC_VF_BUF_OVF ,This bit indicates on an interrupt that is a result of the IC Buffer overflow for view finder coming from the IC." "0,1"
        textline "          "
        bitfld.long 0x00 30. " CSI0_PUPE ,CSI0_PUPE - CSI0 parameters update error interrupt." "0,1"
        textline "          "
        bitfld.long 0x00 31. " CSI1_PUPE ,CSI1_PUPE - CSI1 parameters update error interrupt." "0,1"
width 12.
group.long 0x224++0x3
    line.long 0x00 "INT_STAT_10,Interrupt Status Register 10"
        bitfld.long 0x00 0. " SMFC0_FRM_LOST ,Frame Lost of SMFC channel 0 interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 1. " SMFC1_FRM_LOST ,Frame Lost of SMFC channel 1 interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 2. " SMFC2_FRM_LOST ,Frame Lost of SMFC channel 2 interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 3. " SMFC3_FRM_LOST ,Frame Lost of SMFC channel 3 interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 16. " DC_TEARING_ERR_1 ,Tearing Error #1 interrupt This bit indicates on the interrupt that is a result of tearing error while the anti tearing mechanism is activated for DC channel 1" "0,1"
        textline "           "
        bitfld.long 0x00 17. " DC_TEARING_ERR_2 ,Tearing Error #2 interrupt This bit indicates on the interrupt that is a result of tearing error while the anti tearing mechanism is activated for DC channel 2" "0,1"
        textline "           "
        bitfld.long 0x00 18. " DC_TEARING_ERR_6 ,Tearing Error #6 interrupt This bit indicates on the interrupt that is a result of tearing error while the anti tearing mechanism is activated for DC channel 6" "0,1"
        textline "           "
        bitfld.long 0x00 19. " DI0_SYNC_DISP_ERR ,DI0 Synchronous display error interrupt This bit indicates on the interrupt that is a result of an error during access to a synchronous display via DI0" "0,1"
        textline "           "
        bitfld.long 0x00 20. " DI1_SYNC_DISP_ERR ,DI1 Synchronous display error interrupt This bit indicates on the interrupt that is a result of an error during access to a synchronous display via DI1" "0,1"
        textline "           "
        bitfld.long 0x00 21. " DI0_TIME_OUT_ERR ,DI0 time out error interrupt This bit indicates on the interrupt that is a result of a time out error during a read access via DI0" "0,1"
        textline "           "
        bitfld.long 0x00 22. " DI1_TIME_OUT_ERR ,DI1 time out error interrupt This bit indicates on the interrupt that is a result of a time out error during a read access via DI1" "0,1"
        textline "           "
        bitfld.long 0x00 24. " IC_VF_FRM_LOST_ERR ,This bit indicates on an interrupt that is a result of IC's view finder frame lost." "0,1"
        textline "           "
        bitfld.long 0x00 25. " IC_ENC_FRM_LOST_ERR ,This bit indicates on an interrupt that is a result of IC's encoding frame lost." "0,1"
        textline "           "
        bitfld.long 0x00 26. " IC_BAYER_FRM_LOST_ERR ,This bit indicates on an interrupt that is a result of IC's Bayer frame lost." "0,1"
        textline "           "
        bitfld.long 0x00 28. " NON_PRIVILEGED_ACC_ERR ,Non Privileged Access Error interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 29. " AXIW_ERR ,This bit indicates on an interrupt that is a result of AXI write access resulted with error response." "0,1"
        textline "           "
        bitfld.long 0x00 30. " AXIR_ERR ,This bit indicates on an interrupt that is a result of AXI read access resulted with error response." "0,1"
width 12.
group.long 0x228++0x3
    line.long 0x00 "INT_STAT_11,Interrupt Status Register 11"
        bitfld.long 0x00 0. " IDMAC_EOBND_EN_0 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 1. " IDMAC_EOBND_EN_1 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 2. " IDMAC_EOBND_EN_2 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 3. " IDMAC_EOBND_EN_3 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 5. " IDMAC_EOBND_EN_5 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 11. " IDMAC_EOBND_EN_11 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 12. " IDMAC_EOBND_EN_12 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 20. " IDMAC_EOBND_EN_20 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 21. " IDMAC_EOBND_EN_21 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 22. " IDMAC_EOBND_EN_22 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 25. " IDMAC_EOBND_EN_25 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 26. " IDMAC_EOBND_EN_26 ,end-of-band indication of Channel interrupt." "0,1"
width 12.
group.long 0x22c++0x3
    line.long 0x00 "INT_STAT_12,Interrupt Status Register 12"
        bitfld.long 0x00 13. " IDMAC_EOBND_EN_45 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 14. " IDMAC_EOBND_EN_46 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 15. " IDMAC_EOBND_EN_47 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 16. " IDMAC_EOBND_EN_48 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 17. " IDMAC_EOBND_EN_49 ,end-of-band indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 18. " IDMAC_EOBND_EN_50 ,end-of-band indication of Channel interrupt." "0,1"
width 12.
group.long 0x230++0x3
    line.long 0x00 "INT_STAT_13,Interrupt Status Register 13"
        bitfld.long 0x00 0. " IDMAC_TH_0 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 1. " IDMAC_TH_1 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 2. " IDMAC_TH_2 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 3. " IDMAC_TH_3 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 5. " IDMAC_TH_5 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 8. " IDMAC_TH_8 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 9. " IDMAC_TH_9 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 10. " IDMAC_TH_10 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 11. " IDMAC_TH_11 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 12. " IDMAC_TH_12 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 13. " IDMAC_TH_13 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 14. " IDMAC_TH_14 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 15. " IDMAC_TH_15 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 17. " IDMAC_TH_17 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 18. " IDMAC_TH_18 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 19. " IDMAC_TH_19 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 20. " IDMAC_TH_20 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 21. " IDMAC_TH_21 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 22. " IDMAC_TH_22 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 23. " IDMAC_TH_23 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 24. " IDMAC_TH_24 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 25. " IDMAC_TH_25 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 26. " IDMAC_TH_26 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 27. " IDMAC_TH_27 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 28. " IDMAC_TH_28 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 29. " IDMAC_TH_29 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 31. " IDMAC_TH_31 ,Threshold crossing indication of Channel interrupt." "0,1"
width 12.
group.long 0x234++0x3
    line.long 0x00 "INT_STAT_14,Interrupt Status Register 14"
        bitfld.long 0x00 1. " IDMAC_TH_33 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 8. " IDMAC_TH_40 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 9. " IDMAC_TH_41 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 10. " IDMAC_TH_42 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 11. " IDMAC_TH_43 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 12. " IDMAC_TH_44 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 13. " IDMAC_TH_45 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 14. " IDMAC_TH_46 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 15. " IDMAC_TH_47 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 16. " IDMAC_TH_48 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 17. " IDMAC_TH_49 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 18. " IDMAC_TH_50 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 19. " IDMAC_TH_51 ,Threshold crossing indication of Channel interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 20. " IDMAC_TH_52 ,Threshold crossing indication of Channel interrupt." "0,1"
width 12.
group.long 0x238++0x3
    line.long 0x00 "INT_STAT_15,Interrupt Status Register 15"
        bitfld.long 0x00 0. " SNOOPING1_INT ,IPU snooping 1 event indication interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 1. " SNOOPING2_INT ,IPU snooping 2 event indication interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 2. " DP_SF_START ,DP Sync Flow Start indication interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 3. " DP_SF_END ,DP Sync Flow End indication interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 4. " DP_ASF_START ,DP Async Flow Start indication interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 5. " DP_ASF_END ,DP Async Flow End indication interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 6. " DP_SF_BRAKE ,DP Sync Flow Brake indication interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 7. " DP_ASF_BRAKE ,DP Async Flow Brake indication interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 8. " DC_FC_0 ,DC Frame Complete on channel #0 interrupt indication" "0,1"
        textline "           "
        bitfld.long 0x00 9. " DC_FC_1 ,DC Frame Complete on channel #1 interrupt indication" "0,1"
        textline "           "
        bitfld.long 0x00 10. " DC_FC_2 ,DC Frame Complete on channel #2 interrupt indication" "0,1"
        textline "           "
        bitfld.long 0x00 11. " DC_FC_3 ,DC Frame Complete on channel #3 interrupt indication" "0,1"
        textline "           "
        bitfld.long 0x00 12. " DC_FC_4 ,DC Frame Complete on channel #4 interrupt indication" "0,1"
        textline "           "
        bitfld.long 0x00 13. " DC_FC_6 ,DC Frame Complete on channel #6 interrupt indication" "0,1"
        textline "           "
        bitfld.long 0x00 14. " DI_VSYNC_PRE_0 ,DI0 interrupt indicating of a VSYNC signal asserted 2 rows before the VSYNC sent to the display" "0,1"
        textline "           "
        bitfld.long 0x00 15. " DI_VSYNC_PRE_1 ,DI1 interrupt indicating of a VSYNC signal asserted 2 rows before the VSYNC sent to the display" "0,1"
        textline "           "
        bitfld.long 0x00 16. " DC_DP_START ,This bit indicates on an interrupt asserted anytime the DP start a new sync or async flow or when an async flow is interrupted by a sync flow" "0,1"
        textline "           "
        bitfld.long 0x00 17. " DC_ASYNC_STOP ,This bit indicates on an interrupt asserted anytime the DP stops an async flow and moves to a sync flow" "0,1"
        textline "           "
        bitfld.long 0x00 18. " DI0_CNT_EN_PRE_0 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #0 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 19. " DI0_CNT_EN_PRE_1 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #1 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 20. " DI0_CNT_EN_PRE_2 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #2 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 21. " DI0_CNT_EN_PRE_3 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #3 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 22. " DI0_CNT_EN_PRE_4 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #4 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 23. " DI0_CNT_EN_PRE_5 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #5 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 24. " DI0_CNT_EN_PRE_6 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #6 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 25. " DI0_CNT_EN_PRE_7 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #7 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 26. " DI0_CNT_EN_PRE_8 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #8 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 27. " DI0_CNT_EN_PRE_9 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #9 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 28. " DI0_CNT_EN_PRE_10 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #10 of DI0" "0,1"
        textline "           "
        bitfld.long 0x00 29. " DI1_DISP_CLK_EN_PRE ,DI1_DISP_CLK_EN_PRE" "0,1"
        textline "           "
        bitfld.long 0x00 30. " DI1_CNT_EN_PRE_3 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #3 of DI1" "0,1"
        textline "           "
        bitfld.long 0x00 31. " DI1_CNT_EN_PRE_8 ,This bit indicates on the interrupt that is a result of a trigger generated by counter #8 of DI1" "0,1"
width 10.
rgroup.long 0x23c++0x3
    line.long 0x00 "CUR_BUF_0,Current Buffer Register 0"
        bitfld.long 0x00 0. " DMA_CH_CUR_BUF_0 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 1. " DMA_CH_CUR_BUF_1 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 2. " DMA_CH_CUR_BUF_2 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 3. " DMA_CH_CUR_BUF_3 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 5. " DMA_CH_CUR_BUF_5 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 8. " DMA_CH_CUR_BUF_8 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 9. " DMA_CH_CUR_BUF_9 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 10. " DMA_CH_CUR_BUF_10 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 11. " DMA_CH_CUR_BUF_11 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 12. " DMA_CH_CUR_BUF_12 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 13. " DMA_CH_CUR_BUF_13 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 14. " DMA_CH_CUR_BUF_14 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 15. " DMA_CH_CUR_BUF_15 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 17. " DMA_CH_CUR_BUF_17 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 18. " DMA_CH_CUR_BUF_18 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 19. " DMA_CH_CUR_BUF_19 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 20. " DMA_CH_CUR_BUF_20 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 21. " DMA_CH_CUR_BUF_21 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 22. " DMA_CH_CUR_BUF_22 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 23. " DMA_CH_CUR_BUF_23 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 24. " DMA_CH_CUR_BUF_24 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 25. " DMA_CH_CUR_BUF_25 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 26. " DMA_CH_CUR_BUF_26 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 27. " DMA_CH_CUR_BUF_27 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 28. " DMA_CH_CUR_BUF_28 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 29. " DMA_CH_CUR_BUF_29 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 31. " DMA_CH_CUR_BUF_31 ,Current Buffer." "0,1"
width 10.
rgroup.long 0x240++0x3
    line.long 0x00 "CUR_BUF_1,Current Buffer Register 1"
        bitfld.long 0x00 1. " DMA_CH_CUR_BUF_33 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 8. " DMA_CH_CUR_BUF_40 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 9. " DMA_CH_CUR_BUF_41 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 10. " DMA_CH_CUR_BUF_42 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 11. " DMA_CH_CUR_BUF_43 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 12. " DMA_CH_CUR_BUF_44 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 13. " DMA_CH_CUR_BUF_45 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 14. " DMA_CH_CUR_BUF_46 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 15. " DMA_CH_CUR_BUF_47 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 16. " DMA_CH_CUR_BUF_48 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 17. " DMA_CH_CUR_BUF_49 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 18. " DMA_CH_CUR_BUF_50 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 19. " DMA_CH_CUR_BUF_51 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 20. " DMA_CH_CUR_BUF_52 ,Current Buffer." "0,1"
width 10.
rgroup.long 0x244++0x3
    line.long 0x00 "ALT_CUR_0,Alternate Current Buffer Register 0"
        bitfld.long 0x00 24. " DMA_CH_ALT_CUR_BUF_24 ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 29. " DMA_CH_ALT_CUR_BUF_29 ,Current Buffer." "0,1"
width 10.
rgroup.long 0x248++0x3
    line.long 0x00 "ALT_CUR_1,Alternate Current Buffer Register 1"
        bitfld.long 0x00 1. " DMA_CH_ALT_CUR_BUF0_N ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 9. " DMA_CH_ALT_CUR_BUF1_N ,Current Buffer." "0,1"
        textline "         "
        bitfld.long 0x00 20. " DMA_CH_ALT_CUR_BUF_52 ,Current Buffer." "0,1"
width 9.
rgroup.long 0x24c++0x3
    line.long 0x00 "SRM_STAT,Shadow Registers Memory Status Register"
        bitfld.long 0x00 0. " DP_S_SRM_STAT ,DP SYNC FLOW SRM STAT This bit indicates that the SRM is currently updating the DP sync flow registers" "0,1"
        textline "        "
        bitfld.long 0x00 1. " DP_A0_SRM_STAT ,DP ASYNC0 FLOW SRM STAT This bit indicates that the SRM is currently updating the DP async flow 0 registers" "0,1"
        textline "        "
        bitfld.long 0x00 2. " DP_A1_SRM_STAT ,DP ASYNC1 FLOW SRM STAT This bit indicates that the SRM is currently updating the DP async flow 1 registers" "0,1"
        textline "        "
        bitfld.long 0x00 4. " DC_2_SRM_STAT ,DC group #2 SRM STAT This bit indicates that the SRM is currently updating the DC group #2 registers" "0,1"
        textline "        "
        bitfld.long 0x00 5. " DC_6_SRM_STAT ,DC group #6 SRM STAT This bit indicates that the SRM is currently updating the DC group #6 registers" "0,1"
        textline "        "
        bitfld.long 0x00 6. " CSI0_SRM_STAT ,CSI1_SRM_STAT" "0,1"
        textline "        "
        bitfld.long 0x00 7. " CSI1_SRM_STAT ,CSI1_SRM_STAT" "0,1"
        textline "        "
        bitfld.long 0x00 8. " DI0_SRM_STAT ,DI0 SRM STAT This bit indicates that the SRM is currently updating the DI0 registers" "0,1"
        textline "        "
        bitfld.long 0x00 9. " DI1_SRM_STAT ,DI1 SRM STAT This bit indicates that the SRM is currently updating the DI1 registers" "0,1"
width 16.
rgroup.long 0x250++0x3
    line.long 0x00 "PROC_TASKS_STAT,Processing Status Tasks Register"
        hexmask.long.byte 0x00 0.--2. 1. " ENC_TSTAT ,Status of the encoding task"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " VF_TSTAT ,Status of the viewfinder task"
        textline "               "
        hexmask.long.byte 0x00 4.--6. 1. " PP_TSTAT ,Status of the post processing task"
        textline "               "
        hexmask.long.byte 0x00 6.--8. 1. " ENC_ROT_TSTAT ,Status of the rotation for encoding task"
        textline "               "
        hexmask.long.byte 0x00 8.--10. 1. " VF_ROT_TSTAT ,Status of the rotation for viewfinder task"
        textline "               "
        hexmask.long.byte 0x00 10.--12. 1. " PP_ROT_TSTAT ,Status of the rotation for post processing task"
        textline "               "
        hexmask.long.byte 0x00 12.--15. 1. " MEM2PRP_TSTAT ,Status of the pre processing tasks (viewfinder and encoding) when the source is coming from the memory."
width 16.
rgroup.long 0x254++0x3
    line.long 0x00 "DISP_TASKS_STAT,Display Tasks Status Register"
        hexmask.long.byte 0x00 0.--3. 1. " DP_ASYNC_STAT ,Status of the Asynchronous flow through the DP"
        textline "               "
        bitfld.long 0x00 3. " DP_ASYNC_CUR_FLOW ,Current asynchronous flow via the DP" "0,1"
        textline "               "
        hexmask.long.byte 0x00 4.--6. 1. " DC_ASYNC1_STAT ,Status of the Asynchronous flow #1 through the DC (ch 28)"
        textline "               "
        hexmask.long.byte 0x00 8.--11. 1. " DC_ASYNCH2_STAT ,Status of the Asynchronous flow #2 through the DC"
        textline "               "
        bitfld.long 0x00 11. " DC_ASYNC2_CUR_FLOW ,Current asynchronous #2 flow via the DC" "0,1"
width 17.
rgroup.long 0x258++0x3
    line.long 0x00 "TRIPLE_CUR_BUF_0,Triple Current Buffer Register 0"
        hexmask.long.byte 0x00 16.--18. 1. " DMA_CH_TRIPLE_CUR_BUF_8 ,Current Buffer for triple buffer mode."
        textline "                "
        hexmask.long.byte 0x00 18.--20. 1. " DMA_CH_TRIPLE_CUR_BUF_9 ,Current Buffer for triple buffer mode."
        textline "                "
        hexmask.long.byte 0x00 20.--22. 1. " DMA_CH_TRIPLE_CUR_BUF_10 ,Current Buffer for triple buffer mode."
        textline "                "
        hexmask.long.byte 0x00 26.--28. 1. " DMA_CH_TRIPLE_CUR_BUF_13 ,Current Buffer for triple buffer mode."
width 17.
rgroup.long 0x25c++0x3
    line.long 0x00 "TRIPLE_CUR_BUF_1,Triple Current Buffer Register 1"
        hexmask.long.byte 0x00 10.--12. 1. " DMA_CH_TRIPLE_CUR_BUF_21 ,Current Buffer for triple buffer mode."
        textline "                "
        hexmask.long.byte 0x00 14.--16. 1. " DMA_CH_TRIPLE_CUR_BUF_23 ,Current Buffer for triple buffer mode."
        textline "                "
        hexmask.long.byte 0x00 22.--24. 1. " DMA_CH_TRIPLE_CUR_BUF_27 ,Current Buffer for triple buffer mode."
        textline "                "
        hexmask.long.byte 0x00 24.--26. 1. " DMA_CH_TRIPLE_CUR_BUF_28 ,Current Buffer for triple buffer mode."
width 17.
rgroup.long 0x260++0x3
    line.long 0x00 "TRIPLE_CUR_BUF_2,Triple Current Buffer Register 2"
        hexmask.long.long 0x00 0.--32. 1. " DMA_CH_TRIPLE_CUR_BUF_N ,Current Buffer for triple buffer mode."
width 17.
rgroup.long 0x264++0x3
    line.long 0x00 "TRIPLE_CUR_BUF_3,Triple Current Buffer Register 3"
        hexmask.long.long 0x00 0.--32. 1. " DMA_CH_TRIPLE_CUR_BUF_N ,Current Buffer for triple buffer mode."
width 13.
group.long 0x268++0x3
    line.long 0x00 "CH_BUF0_RDY0,IPU Channels Buffer 0 Ready 0 Register"
        bitfld.long 0x00 0. " DMA_CH_BUF0_RDY_0 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 1. " DMA_CH_BUF0_RDY_1 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 2. " DMA_CH_BUF0_RDY_2 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 3. " DMA_CH_BUF0_RDY_3 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 4. " DMA_CH_BUF0_RDY_4 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 5. " DMA_CH_BUF0_RDY_5 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 6. " DMA_CH_BUF0_RDY_6 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 7. " DMA_CH_BUF0_RDY_7 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 8. " DMA_CH_BUF0_RDY_8 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 9. " DMA_CH_BUF0_RDY_9 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 10. " DMA_CH_BUF0_RDY_10 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 11. " DMA_CH_BUF0_RDY_11 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 12. " DMA_CH_BUF0_RDY_12 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 13. " DMA_CH_BUF0_RDY_13 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 14. " DMA_CH_BUF0_RDY_14 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 15. " DMA_CH_BUF0_RDY_15 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 17. " DMA_CH_BUF0_RDY_17 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 18. " DMA_CH_BUF0_RDY_18 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 20. " DMA_CH_BUF0_RDY_20 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 21. " DMA_CH_BUF0_RDY_21 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 22. " DMA_CH_BUF0_RDY_22 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 23. " DMA_CH_BUF0_RDY_23 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 24. " DMA_CH_BUF0_RDY_24 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 27. " DMA_CH_BUF0_RDY_27 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 28. " DMA_CH_BUF0_RDY_28 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 29. " DMA_CH_BUF0_RDY_29 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 31. " DMA_CH_BUF0_RDY_31 ,Buffer 0 is ready." "0,1"
width 13.
group.long 0x26c++0x3
    line.long 0x00 "CH_BUF0_RDY1,IPU Channels Buffer 0 Ready 1 Register"
        bitfld.long 0x00 1. " DMA_CH_BUF0_RDY_33 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 8. " DMA_CH_BUF0_RDY_40 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 9. " DMA_CH_BUF0_RDY_41 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 10. " DMA_CH_BUF0_RDY_42 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 11. " DMA_CH_BUF0_RDY_43 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 12. " DMA_CH_BUF0_RDY_44 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 13. " DMA_CH_BUF0_RDY_45 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 14. " DMA_CH_BUF0_RDY_46 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 15. " DMA_CH_BUF0_RDY_47 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 16. " DMA_CH_BUF0_RDY_48 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 17. " DMA_CH_BUF0_RDY_49 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 18. " DMA_CH_BUF0_RDY_50 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 19. " DMA_CH_BUF0_RDY_51 ,Buffer 0 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 20. " DMA_CH_BUF0_RDY_52 ,Buffer 0 is ready." "0,1"
width 13.
group.long 0x270++0x3
    line.long 0x00 "CH_BUF1_RDY0,IPU Channels Buffer 1 Ready 0 Register"
        bitfld.long 0x00 0. " DMA_CH_BUF1_RDY_0 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 1. " DMA_CH_BUF1_RDY_1 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 2. " DMA_CH_BUF1_RDY_2 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 3. " DMA_CH_BUF1_RDY_3 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 5. " DMA_CH_BUF1_RDY_5 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 8. " DMA_CH_BUF1_RDY_8 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 9. " DMA_CH_BUF1_RDY_9 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 10. " DMA_CH_BUF1_RDY_10 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 11. " DMA_CH_BUF1_RDY ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 12. " DMA_CH_BUF1_RDY_12 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 13. " DMA_CH_BUF1_RDY_13 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 14. " DMA_CH_BUF1_RDY_14 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 15. " DMA_CH_BUF1_RDY_15 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 17. " DMA_CH_BUF1_RDY_17 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 18. " DMA_CH_BUF1_RDY_18 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 19. " DMA_CH_BUF1_RDY_19 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 20. " DMA_CH_BUF1_RDY_20 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 21. " DMA_CH_BUF1_RDY_21 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 22. " DMA_CH_BUF1_RDY_22 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 23. " DMA_CH_BUF1_RDY_23 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 24. " DMA_CH_BUF1_RDY_24 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 25. " DMA_CH_BUF1_RDY_25 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 26. " DMA_CH_BUF1_RDY_26 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 27. " DMA_CH_BUF1_RDY_27 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 28. " DMA_CH_BUF1_RDY_28 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 29. " DMA_CH_BUF1_RDY_29 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 31. " DMA_CH_BUF1_RDY_31 ,Buffer 1 is ready." "0,1"
width 13.
group.long 0x274++0x3
    line.long 0x00 "CH_BUF1_RDY1,IPU Channels Buffer 1 Ready 1Register"
        bitfld.long 0x00 1. " DMA_CH_BUF0_RDY_33 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 8. " DMA_CH_BUF0_RDY_40 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 9. " DMA_CH_BUF0_RDY_41 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 10. " DMA_CH_BUF0_RDY_42 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 11. " DMA_CH_BUF0_RDY_43 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 12. " DMA_CH_BUF0_RDY_44 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 13. " DMA_CH_BUF0_RDY_45 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 14. " DMA_CH_BUF0_RDY_46 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 15. " DMA_CH_BUF0_RDY_47 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 16. " DMA_CH_BUF0_RDY_48 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 17. " DMA_CH_BUF0_RDY_49 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 18. " DMA_CH_BUF0_RDY_50 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 19. " DMA_CH_BUF0_RDY_51 ,Buffer 1 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 20. " DMA_CH_BUF0_RDY_52 ,Buffer 1 is ready." "0,1"
width 17.
group.long 0x278++0x3
    line.long 0x00 "ALT_CH_BUF0_RDY0,IPU Alternate Channels Buffer 0 Ready 0 Register"
        bitfld.long 0x00 24. " DMA_CH_ALT_BUF0_RDY_24 ,Buffer 0 is ready." "0,1"
        textline "                "
        bitfld.long 0x00 29. " DMA_CH_ALT_BUF0_RDY_29 ,Buffer 0 is ready." "0,1"
width 17.
group.long 0x27c++0x3
    line.long 0x00 "ALT_CH_BUF0_RDY1,IPU Alternate Channels Buffer 0 Ready 1 Register"
        bitfld.long 0x00 1. " DMA_CH_ALT_BUF0_RDY_33 ,Buffer 0 is ready." "0,1"
        textline "                "
        bitfld.long 0x00 9. " DMA_CH_ALT_BUF0_RDY_41 ,Buffer 0 is ready." "0,1"
        textline "                "
        bitfld.long 0x00 20. " DMA_CH_ALT_BUF0_RDY_52 ,Buffer 0 is ready." "0,1"
width 17.
group.long 0x280++0x3
    line.long 0x00 "ALT_CH_BUF1_RDY0,IPU Alternate Channels Buffer1 Ready 0 Register"
        bitfld.long 0x00 24. " DMA_CH_ALT_BUF1_RDY_24 ,Buffer 1 is ready." "0,1"
        textline "                "
        bitfld.long 0x00 29. " DMA_CH_ALT_BUF1_RDY_29 ,Buffer 1 is ready." "0,1"
width 17.
group.long 0x284++0x3
    line.long 0x00 "ALT_CH_BUF1_RDY1,IPU Alternate Channels Buffer 1 Ready 1 Register"
        bitfld.long 0x00 1. " DMA_CH_ALT_BUF1_RDY_33 ,Buffer 1 is ready." "0,1"
        textline "                "
        bitfld.long 0x00 9. " DMA_CH_ALT_BUF1_RDY_41 ,Buffer 1 is ready." "0,1"
        textline "                "
        bitfld.long 0x00 20. " DMA_CH_ALT_BUF1_RDY_52 ,Buffer 1 is ready." "0,1"
width 13.
group.long 0x288++0x3
    line.long 0x00 "CH_BUF2_RDY0,IPU Channels Buffer 2 Ready 0 Register"
        bitfld.long 0x00 0. " DMA_CH_BUF2_RDY_0 ,Buffer 2 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 2. " DMA_CH_BUF2_RDY_2 ,Buffer 2 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 8. " DMA_CH_BUF2_RDY_8 ,Buffer 2 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 9. " DMA_CH_BUF2_RDY_9 ,Buffer 2 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 10. " DMA_CH_BUF2_RDY_10 ,Buffer 2 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 13. " DMA_CH_BUF2_RDY_13 ,Buffer 2 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 21. " DMA_CH_BUF2_RDY_21 ,Buffer 2 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 23. " DMA_CH_BUF2_RDY_23 ,Buffer 2 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 27. " DMA_CH_ALT_BUF1_RDY_27 ,buffer 2 is ready." "0,1"
        textline "            "
        bitfld.long 0x00 28. " DMA_CH_BUF2_RDY_28 ,Buffer 2 is ready." "0,1"
width 13.
group.long 0x28c++0x3
    line.long 0x00 "CH_BUF2_RDY1,IPU Channels Buffer 2 Ready 1 Register"
        hexmask.long.long 0x00 0.--32. 1. " DMA_CH_BUF2_RDY_X ,Buffer 2 is ready."
width 11.
group.long 0x1f40++0x3
    line.long 0x00 "IDMAC_CONF,IDMAC Configuration Register"
        hexmask.long.byte 0x00 0.--3. 1. " MAX_REQ_READ ,Maximum Read Requests."
        textline "          "
        hexmask.long.byte 0x00 3.--5. 1. " WIDPT ,Write Interleaving Depth These 2 bits define the Write Interleaving Depth of the AXI port."
        textline "          "
        bitfld.long 0x00 5. " RDI ,Read Data Interleaving." "0,1"
        textline "          "
        bitfld.long 0x00 16. " P_ENDIAN ,Pixel Endianness." "0,1"
        textline "          "
        hexmask.long.byte 0x00 17.--20. 1. " USED_BUFS_MAX_W ,Limit the number of pending non real time write requests."
        textline "          "
        bitfld.long 0x00 20. " USED_BUFS_EN_W ,Enables the limit on the number of pending non real time write requests." "0,1"
        textline "          "
        hexmask.long.byte 0x00 21.--25. 1. " USED_BUFS_MAX_R ,Limit the number of pending non real time read requests."
        textline "          "
        bitfld.long 0x00 25. " USED_BUFS_EN_R ,Enables the limit on the number of pending non real time read requests." "0,1"
width 14.
group.long 0x1f44++0x3
    line.long 0x00 "IDMAC_CH_EN_1,IDMAC Channel Enable 1 Register"
        bitfld.long 0x00 0. " IDMAC_CH_EN_0 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 1. " IDMAC_CH_EN_1 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 2. " IDMAC_CH_EN_2 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 3. " IDMAC_CH_EN_3 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 5. " IDMAC_CH_EN_5 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 8. " IDMAC_CH_EN_8 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 9. " IDMAC_CH_EN_9 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 10. " IDMAC_CH_EN_10 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 11. " IDMAC_CH_EN_11 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 12. " IDMAC_CH_EN_12 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 13. " IDMAC_CH_EN_13 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 14. " IDMAC_CH_EN_14 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 15. " IDMAC_CH_EN_15 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 17. " IDMAC_CH_EN_17 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 18. " IDMAC_CH_EN_18 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 19. " IDMAC_CH_EN_19 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 20. " IDMAC_CH_EN_20 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 21. " IDMAC_CH_EN_21 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 22. " IDMAC_CH_EN_22 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 23. " IDMAC_CH_EN_23 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 24. " IDMAC_CH_EN_24 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 25. " IDMAC_CH_EN_25 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 26. " IDMAC_CH_EN_26 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 27. " IDMAC_CH_EN_27 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 28. " IDMAC_CH_EN_28 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 29. " IDMAC_CH_EN_29 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 31. " IDMAC_CH_EN_31 ,IDMAC Channel enable bit [i]" "0,1"
width 14.
group.long 0x1f48++0x3
    line.long 0x00 "IDMAC_CH_EN_2,IDMAC Channel Enable 2 Register"
        bitfld.long 0x00 1. " IDMAC_CH_EN_33 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 8. " IDMAC_CH_EN_40 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 9. " IDMAC_CH_EN_41 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 10. " IDMAC_CH_EN_42 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 11. " IDMAC_CH_EN_43 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 12. " IDMAC_CH_EN_44 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 13. " IDMAC_CH_EN_45 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 14. " IDMAC_CH_EN_46 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 15. " IDMAC_CH_EN_47 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 16. " IDMAC_CH_EN_48 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 17. " IDMAC_CH_EN_49 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 18. " IDMAC_CH_EN_50 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 19. " IDMAC_CH_EN_51 ,IDMAC Channel enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 20. " IDMAC_CH_EN_52 ,IDMAC Channel enable bit [i]" "0,1"
width 20.
group.long 0x1f4a++0x3
    line.long 0x00 "IDMAC_ALT_SEP_ALPHA,IDMAC Alternate Separate Alpha Indication Register"
        bitfld.long 0x00 23. " IDMAC_ALT_SEP_AL_23 ,IDMAC Alternate Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers." "0,1"
        textline "                   "
        bitfld.long 0x00 24. " IDMAC_ALT_SEP_AL_24 ,IDMAC Alternate Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers." "0,1"
        textline "                   "
        bitfld.long 0x00 29. " IDMAC_ALT_SEP_AL_29 ,IDMAC Alternate Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers." "0,1"
width 15.
group.long 0x1f4e++0x3
    line.long 0x00 "IDMAC_CH_PRI_1,IDMAC Channel Priority 1 Register"
        bitfld.long 0x00 0. " IDMAC_CH_PRI_0 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 1. " IDMAC_CH_PRI_1 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 2. " IDMAC_CH_PRI_2 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 3. " IDMAC_CH_PRI_3 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 5. " IDMAC_CH_PRI_5 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 8. " IDMAC_CH_PRI_8 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 9. " IDMAC_CH_PRI_9 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 10. " IDMAC_CH_PRI_10 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 11. " IDMAC_CH_PRI_11 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 12. " IDMAC_CH_PRI_12 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 13. " IDMAC_CH_PRI_13 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 14. " IDMAC_CH_PRI_14 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 15. " IDMAC_CH_PRI_15 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 20. " IDMAC_CH_PRI_20 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 21. " IDMAC_CH_PRI_21 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 22. " IDMAC_CH_PRI_22 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 23. " IDMAC_CH_PRI_23 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 24. " IDMAC_CH_PRI_24 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 25. " IDMAC_CH_PRI_25 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 26. " IDMAC_CH_PRI_26 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 27. " IDMAC_CH_PRI_27 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 28. " IDMAC_CH_PRI_28 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 29. " IDMAC_CH_PRI_29 ,IDMAC Channel enable bit [i]" "0,1"
width 15.
group.long 0x1f52++0x3
    line.long 0x00 "IDMAC_CH_PRI_2,IDMAC Channel Priority 2 Register"
        bitfld.long 0x00 8. " IDMAC_CH_PRI_8 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 9. " IDMAC_CH_PRI_9 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 10. " IDMAC_CH_PRI_10 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 11. " IDMAC_CH_PRI_11 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 12. " IDMAC_CH_PRI_12 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 13. " IDMAC_CH_PRI_13 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 14. " IDMAC_CH_PRI_14 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 15. " IDMAC_CH_PRI_15 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 16. " IDMAC_CH_PRI_16 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 17. " IDMAC_CH_PRI_17 ,IDMAC Channel enable bit [i]" "0,1"
        textline "              "
        bitfld.long 0x00 18. " IDMAC_CH_PRI_18 ,IDMAC Channel enable bit [i]" "0,1"
width 14.
group.long 0x1f54++0x3
    line.long 0x00 "IDMAC_WM_EN_2,IDMAC Channel Watermark Enable 2 Register"
        bitfld.long 0x00 8. " IDMAC_WM_EN_40 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 9. " IDMAC_WM_EN_41 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 10. " IDMAC_WM_EN_42 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 11. " IDMAC_WM_EN_43 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 12. " IDMAC_WM_EN_44 ,IDMAC Watermark enable bit [i]" "0,1"
width 16.
group.long 0x1f58++0x3
    line.long 0x00 "IDMAC_LOCK_EN_1,IDMAC Channel Lock Enable 1Register"
        hexmask.long.byte 0x00 0.--2. 1. " IDMAC_LOCK_EN_5 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " IDMAC_LOCK_EN_11 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 4.--6. 1. " IDMAC_LOCK_EN_12 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 6.--8. 1. " IDMAC_LOCK_EN_14 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 8.--10. 1. " IDMAC_LOCK_EN_15 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 10.--12. 1. " IDMAC_LOCK_EN_20 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 12.--14. 1. " IDMAC_LOCK_EN_21 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 14.--16. 1. " IDMAC_LOCK_EN_22 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 16.--18. 1. " IDMAC_LOCK_EN_23 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 18.--20. 1. " IDMAC_LOCK_EN_27 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 20.--22. 1. " IDMAC_LOCK_EN_28 ,IDMAC lock bits for channel [i]"
width 16.
group.long 0x1f5c++0x3
    line.long 0x00 "IDMAC_LOCK_EN_2,IDMAC Channel Lock Enable 2Register"
        hexmask.long.byte 0x00 0.--2. 1. " IDMAC_LOCK_45 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " IDMAC_LOCK_46 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 4.--6. 1. " IDMAC_LOCK_47 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 6.--8. 1. " IDMAC_LOCK_48 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 8.--10. 1. " IDMAC_LOCK_49 ,IDMAC lock bits for channel [i]"
        textline "               "
        hexmask.long.byte 0x00 10.--12. 1. " IDMAC_LOCK_50 ,IDMAC lock bits for channel [i]"
width 17.
group.long 0x1f5e++0x3
    line.long 0x00 "IDMAC_SUB_ADDR_1,IDMAC Channel Alternate Address 1 Register"
        hexmask.long.byte 0x00 0.--7. 1. " IDMAC_SUB_ADDR_23 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
        textline "                "
        hexmask.long.byte 0x00 8.--15. 1. " IDMAC_SUB_ADDR_24 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
        textline "                "
        hexmask.long.byte 0x00 16.--23. 1. " IDMAC_SUB_ADDR_29 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
        textline "                "
        hexmask.long.byte 0x00 24.--31. 1. " IDMAC_SUB_ADDR_33 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
width 17.
group.long 0x1f62++0x3
    line.long 0x00 "IDMAC_SUB_ADDR_2,IDMAC Channel Alternate Address 2 Register"
        hexmask.long.byte 0x00 0.--7. 1. " IDMAC_SUB_ADDR_41 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
        textline "                "
        hexmask.long.byte 0x00 8.--15. 1. " IDMAC_SUB_ADDR_51 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
        textline "                "
        hexmask.long.byte 0x00 16.--23. 1. " IDMAC_SUB_ADDR_52 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
width 17.
group.long 0x1f66++0x3
    line.long 0x00 "IDMAC_SUB_ADDR_3,IDMAC Channel Alternate Address 3 Register"
        hexmask.long.byte 0x00 0.--7. 1. " IDMAC_SUB_ADDR_9 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
        textline "                "
        hexmask.long.byte 0x00 8.--15. 1. " IDMAC_SUB_ADDR_10 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
        textline "                "
        hexmask.long.byte 0x00 16.--23. 1. " IDMAC_SUB_ADDR_13 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
        textline "                "
        hexmask.long.byte 0x00 24.--31. 1. " IDMAC_SUB_ADDR_27 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
width 16.
group.long 0x1f68++0x3
    line.long 0x00 "IDMAC_BNDM_EN_1,IDMAC Band Mode Enable 1 Register"
        bitfld.long 0x00 0. " IDMAC_BNDM_EN_0 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 1. " IDMAC_BNDM_EN_1 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 2. " IDMAC_BNDM_EN_2 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 3. " IDMAC_BNDM_EN_3 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 5. " IDMAC_BNDM_EN_5 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 11. " IDMAC_BNDM_EN_11 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 12. " IDMAC_BNDM_EN_12 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 20. " IDMAC_BNDM_EN_20 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 21. " IDMAC_BNDM_EN_21 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 22. " IDMAC_BNDM_EN_22 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 25. " IDMAC_BNDM_EN_25 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 26. " IDMAC_BNDM_EN_26 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
width 16.
group.long 0x1f6c++0x3
    line.long 0x00 "IDMAC_BNDM_EN_2,IDMAC Band Mode Enable 2 Register"
        bitfld.long 0x00 13. " IDMAC_BNDM_EN_45 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 14. " IDMAC_BNDM_EN_46 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 15. " IDMAC_BNDM_EN_47 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 16. " IDMAC_BNDM_EN_48 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 17. " IDMAC_BNDM_EN_49 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
        textline "               "
        bitfld.long 0x00 18. " IDMAC_BNDM_EN_50 ,IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode." "0,1"
width 14.
group.long 0x1f70++0x3
    line.long 0x00 "IDMAC_SC_CORD,IDMAC Scroll Coordinations Register"
        hexmask.long.word 0x00 0.--11. 1. " SY0 ,Scroll Y coordination This field indicates the Y coordinate of the scroll."
        textline "             "
        hexmask.long.word 0x00 16.--28. 1. " SX0 ,Scroll X coordination This field indicates the X coordinate of the scroll."
width 16.
rgroup.long 0x1fa4++0x3
    line.long 0x00 "IDMAC_CH_BUSY_1,IDMAC Channel Busy 1 Register"
        bitfld.long 0x00 0. " IDMAC_CH_BUSY_0 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 1. " IDMAC_CH_BUSY_1 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 2. " IDMAC_CH_BUSY_2 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 3. " IDMAC_CH_BUSY_3 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 5. " IDMAC_CH_BUSY_5 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 8. " IDMAC_CH_BUSY_8 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 9. " IDMAC_CH_BUSY_9 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 10. " IDMAC_CH_BUSY_10 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 11. " IDMAC_CH_BUSY_11 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 12. " IDMAC_CH_BUSY_12 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 13. " IDMAC_CH_BUSY_13 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 14. " IDMAC_CH_BUSY_14 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 15. " IDMAC_CH_BUSY_15 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 17. " IDMAC_CH_BUSY_17 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 18. " IDMAC_CH_BUSY_18 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 20. " IDMAC_CH_BUSY_20 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 21. " IDMAC_CH_BUSY_21 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 22. " IDMAC_CH_BUSY_22 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 23. " IDMAC_CH_BUSY_23 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 24. " IDMAC_CH_BUSY_24 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 25. " IDMAC_CH_BUSY_25 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 26. " IDMAC_CH_BUSY_26 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 27. " IDMAC_CH_BUSY_27 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 28. " IDMAC_CH_BUSY_28 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 29. " IDMAC_CH_BUSY_29 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 31. " IDMAC_CH_BUSY ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
width 16.
rgroup.long 0x1fa8++0x3
    line.long 0x00 "IDMAC_CH_BUSY_2,IDMAC Channel Busy 2 Register"
        bitfld.long 0x00 1. " IDMAC_CH_BUSY_33 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 8. " IDMAC_CH_BUSY_40 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 9. " IDMAC_CH_BUSY_41 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 10. " IDMAC_CH_BUSY_42 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 11. " IDMAC_CH_BUSY_43 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 12. " IDMAC_CH_BUSY_44 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 13. " IDMAC_CH_BUSY_45 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 14. " IDMAC_CH_BUSY_46 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 15. " IDMAC_CH_BUSY_47 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 16. " IDMAC_CH_BUSY_48 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 17. " IDMAC_CH_BUSY_49 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 18. " IDMAC_CH_BUSY_50 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 19. " IDMAC_CH_BUSY_51 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
        textline "               "
        bitfld.long 0x00 20. " IDMAC_CH_BUSY_52 ,IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC." "0,1"
width 16.
group.long 0x800c++0x3
    line.long 0x00 "IDMAC_SEP_ALPHA,IDMAC Separate Alpha Indication Register"
        bitfld.long 0x00 14. " IDMAC_SEP_AL_14 ,IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers." "0,1"
        textline "               "
        bitfld.long 0x00 15. " IDMAC_SEP_AL_15 ,IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers." "0,1"
        textline "               "
        bitfld.long 0x00 23. " IDMAC_SEP_AL_23 ,IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers." "0,1"
        textline "               "
        bitfld.long 0x00 24. " IDMAC_SEP_AL_24 ,IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers." "0,1"
        textline "               "
        bitfld.long 0x00 25. " IDMAC_SEP_AL_25 ,IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers." "0,1"
        textline "               "
        bitfld.long 0x00 27. " IDMAC_SEP_AL_27 ,IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers." "0,1"
        textline "               "
        bitfld.long 0x00 29. " IDMAC_SEP_AL_29 ,IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers." "0,1"
width 14.
group.long 0x801c++0x3
    line.long 0x00 "IDMAC_WM_EN_1,IDMAC Channel Watermark Enable 1 Register"
        bitfld.long 0x00 0. " IDMAC_WM_EN_0 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 1. " IDMAC_WM_EN_1 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 2. " IDMAC_WM_EN_2 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 3. " IDMAC_WM_EN_3 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 8. " IDMAC_WM_EN_8 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 10. " IDMAC_WM_EN_10 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 12. " IDMAC_WM_EN_12 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 13. " IDMAC_WM_EN_13 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 14. " IDMAC_WM_EN_14 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 23. " IDMAC_WM_EN_23 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 24. " IDMAC_WM_EN_24 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 25. " IDMAC_WM_EN_25 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 26. " IDMAC_WM_EN_26 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 27. " IDMAC_WM_EN_27 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 28. " IDMAC_WM_EN_28 ,IDMAC Watermark enable bit [i]" "0,1"
        textline "             "
        bitfld.long 0x00 29. " IDMAC_WM_EN_29 ,IDMAC Watermark enable bit [i]" "0,1"
width 17.
group.long 0x802c++0x3
    line.long 0x00 "IDMAC_SUB_ADDR_0,IDMAC Channel Alternate Address 0 Register"
        hexmask.long.long 0x00 0.--32. 1. " IDMAC_SUB_ADDR_I ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
width 17.
group.long 0x803c++0x3
    line.long 0x00 "IDMAC_SUB_ADDR_4,IDMAC Channel Alternate Address 4 Register"
        hexmask.long.byte 0x00 0.--7. 1. " IDMAC_SUB_ADDR_28 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
        textline "                "
        hexmask.long.byte 0x00 8.--15. 1. " IDMAC_SUB_ADDR_8 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
        textline "                "
        hexmask.long.byte 0x00 16.--23. 1. " IDMAC_SUB_ADDR_21 ,The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR_i."
width 16.
group.long 0x804c++0x3
    line.long 0x00 "IDMAC_SC_CORD_1,IDMAC Scroll Coordinations Register 1"
        hexmask.long.word 0x00 0.--11. 1. " SY1 ,Scroll Y coordination (2nd set) This field indicates the Y coordinate of the scroll."
        textline "               "
        hexmask.long.word 0x00 16.--28. 1. " SX1 ,Scroll X coordination (2nd set) This field indicates the X coordinate of the scroll."
width 17.
group.long 0x18000++0x3
    line.long 0x00 "DP_COM_CONF_SYNC,DP Common Configuration Sync Flow Register"
        bitfld.long 0x00 0. " DP_FG_EN_SYNC ,FG_EN - partial plane Enable." "0,1"
        textline "                "
        bitfld.long 0x00 1. " DP_GWSEL_SYNC ,GWSEL - Graphic Window Select Select graphic window to be on partial plane or full plane." "0,1"
        textline "                "
        bitfld.long 0x00 2. " DP_GWAM_SYNC ,GWAM - Graphic Window Alpha Mode Select the use of Alpha to be global or local." "0,1"
        textline "                "
        bitfld.long 0x00 3. " DP_GWCKE_SYNC ,GWCKE - Graphic Window Color Keying Enable Enable or disable graphic window color keying." "0,1"
        textline "                "
        hexmask.long.byte 0x00 4.--7. 1. " DP_COC_SYNC ,COC - Cursor Operation Control Controls the format of the cursor and the type of arithmetic operations"
        textline "                "
        hexmask.long.byte 0x00 8.--10. 1. " DP_CSC_DEF_SYNC ,CSC_DEF Enable or disable Color Space Conversion."
        textline "                "
        bitfld.long 0x00 10. " DP_CSC_GAMUT_SAT_EN_SYNC ,CSC_GAMUT_SAT_EN Indicate if GAMUT saturation is enabled" "0,1"
        textline "                "
        bitfld.long 0x00 11. " DP_CSC_YUV_SAT_MODE_SYNC ,CSC_YUV_SAT_MODE YUV saturation mode for color space conversion" "0,1"
        textline "                "
        bitfld.long 0x00 12. " DP_GAMMA_EN_SYNC ,GAMMA_EN - Gamma correction block enable bit" "0,1"
        textline "                "
        bitfld.long 0x00 13. " DP_GAMMA_YUV_EN_SYNC ,GAMMA's YUV mode enable for sync flow" "0,1"
width 24.
group.long 0x18004++0x3
    line.long 0x00 "DP_GRAPH_WIND_CTRL_SYNC,DP Graphic Window Control Sync Flow Register"
        hexmask.long.byte 0x00 0.--8. 1. " DP_GWCKB_SYNC ,GWCKB - Graphic Window Color Keying Blue Component Defines the blue component of graphic window color keying."
        textline "                       "
        hexmask.long.byte 0x00 8.--16. 1. " DP_GWCKG_SYNC ,GWCKG - Graphic Window Color Keying Green Component Defines the green component of graphic window color keying."
        textline "                       "
        hexmask.long.byte 0x00 16.--24. 1. " DP_GWCKR_SYNC ,GWCKR - Graphic Window Color Keying Red Component Defines the red component of graphic window color keying."
        textline "                       "
        hexmask.long.byte 0x00 24.--32. 1. " DP_GWAV_SYNC ,GWAV - Graphic Window Alpha Value Defines the alpha value of graphic window used for alpha blending between graphic window and full plane."
width 15.
group.long 0x18008++0x3
    line.long 0x00 "DP_FG_POS_SYNC,DP Partial Plane Window Position Sync Flow Register"
        hexmask.long.word 0x00 0.--11. 1. " DP_FGYP_SYNC ,FGYP partial plane window Y position partial plane Window Y Position - Specifies the number of lines between the start of full plane windows Y position and the beginning of the first data."
        textline "              "
        hexmask.long.word 0x00 16.--27. 1. " DP_FGXP_SYNC ,FGXP partial plane Window X Position."
width 16.
group.long 0x1800c++0x3
    line.long 0x00 "DP_CUR_POS_SYNC,DP Cursor Position and Size Sync Flow Register"
        hexmask.long.word 0x00 0.--11. 1. " DP_CXW_SYNC ,CXW - Cursor Width."
        textline "               "
        hexmask.long.byte 0x00 11.--16. 1. " DP_CXP_SYNC ,CXP - Cursor X Position Represents the cursors horizontal starting position X in pixel count (from 0 to CXW)."
        textline "               "
        hexmask.long.word 0x00 16.--27. 1. " DP_CYH_SYNC ,CYH - Cursor Height Specifies the height of the hardware cursor in pixels."
        textline "               "
        hexmask.long.byte 0x00 27.--32. 1. " DP_CYP_SYNC ,CYP - Cursor Y Position Represents the cursors vertical starting position Y in pixel count (from 0 to CYH).Live View Resolution Mode."
width 16.
group.long 0x18010++0x3
    line.long 0x00 "DP_CUR_MAP_SYNC,DP Color Cursor Mapping Sync Flow Register"
        hexmask.long.byte 0x00 0.--8. 1. " DP_CUR_COL_R_SYNC ,CUR_COL_B - Cursor Red Field Defines the Red component of the cursor color in color mode"
        textline "               "
        hexmask.long.byte 0x00 8.--16. 1. " DP_CUR_COL_G_SYNC ,CUR_COL_G - Cursor Green Field Defines the Green component of the cursor color in color mode"
        textline "               "
        hexmask.long.byte 0x00 16.--24. 1. " DP_CUR_COL_B_SYNC ,CUR_COL_B - Cursor Blue Field Defines the Blue component of the cursor color in color mode"
width 18.
group.long 0x18014++0x3
    line.long 0x00 "DP_GAMMA_C_SYNC_I,DP Gamma Constants Sync Flow Register i"
        hexmask.long.word 0x00 0.--9. 1. " DP_GAMMA_C_SYNC_2I ,CONSTANTi parameter of Gamma Correction."
        textline "                 "
        hexmask.long.word 0x00 16.--25. 1. " DP_GAMMA_C_SYNC_2I_1 ,CONSTANTi+1 parameter of Gamma Correction."
width 18.
group.long 0x18034++0x3
    line.long 0x00 "DP_GAMMA_S_SYNC_I,DP Gamma Correction Slope Sync Flow Register i"
        hexmask.long.byte 0x00 0.--8. 1. " DP_GAMMA_S_SYNC_4I ,SLOPE<4*i> parameter of Gamma Correction."
        textline "                 "
        hexmask.long.byte 0x00 8.--16. 1. " DP_GAMMA_S_SYNC_4I_1 ,SLOPE<4*i+1> parameter of Gamma Correction."
        textline "                 "
        hexmask.long.byte 0x00 16.--24. 1. " DP_GAMMA_S_SYNC_4I_2 ,SLOPE<4*i+2> parameter of Gamma Correction."
        textline "                 "
        hexmask.long.byte 0x00 24.--32. 1. " DP_GAMMA_S_SYNC_4I_3 ,SLOPE<4*i+3> parameter of Gamma Correction."
width 15.
group.long 0x18044++0x3
    line.long 0x00 "DP_CSCA_SYNC_I,DP Color Space Conversion Control Sync Flow Registers"
        hexmask.long.word 0x00 0.--10. 1. " DP_CSC_A_SYNC_2I ,A<2*i> parameter of color conversion."
        textline "              "
        hexmask.long.word 0x00 16.--26. 1. " DP_CSC_A_SYNC_2I_1 ,A<2*i+1> parameter of color conversion"
width 14.
group.long 0x18054++0x3
    line.long 0x00 "DP_SCS_SYNC_0,DP Color Conversion Control Sync Flow Register 0"
        hexmask.long.word 0x00 0.--10. 1. " DP_CSC_A8_SYNC ,A9 parameter of color conversion."
        textline "             "
        hexmask.long.word 0x00 16.--30. 1. " DP_CSC_B0_SYNC ,B0 parameter of color conversion."
        textline "             "
        hexmask.long.byte 0x00 30.--32. 1. " DP_CSC_S0_SYNC ,S0 parameter of color conversion."
width 14.
group.long 0x18058++0x3
    line.long 0x00 "DP_SCS_SYNC_1,DP Color Conversion Control Sync Flow Register 1"
        hexmask.long.word 0x00 0.--14. 1. " DP_CSC_B1_SYNC ,B0 parameter of color conversion."
        textline "             "
        hexmask.long.byte 0x00 14.--16. 1. " DP_CSC_S1_SYNC ,S0 parameter of color conversion."
        textline "             "
        hexmask.long.word 0x00 16.--30. 1. " DP_CSC_B2_SYNC ,B0 parameter of color conversion."
        textline "             "
        hexmask.long.byte 0x00 30.--32. 1. " DP_CSC_S2_SYNC ,S0 parameter of color conversion."
width 15.
group.long 0x1805c++0x3
    line.long 0x00 "DP_CUR_POS_ALT,DP Cursor Position and Size Alternate Register"
        hexmask.long.word 0x00 0.--11. 1. " DP_CXW_SYNC_ALT ,CXW_ALT - Cursor Width."
        textline "              "
        hexmask.long.byte 0x00 11.--16. 1. " DP_CXP_SYNC_ALT ,CXP_ALT - Cursor X Position Represents the cursors horizontal starting position X in pixel count (from 0 to CXW) for the alternative flow."
        textline "              "
        hexmask.long.word 0x00 16.--27. 1. " DP_CYH_SYNC_ALT ,CYH_ALT - Cursor Height Specifies the height of the hardware cursor in pixels."
        textline "              "
        hexmask.long.byte 0x00 27.--32. 1. " DP_CYP_SYNC_ALT ,CYP_ALT - Cursor Y Position Represents the cursors vertical starting position Y in pixel count (from 0 to CYH).Live View Resolution Mode for the alternative flow."
width 19.
group.long 0x18060++0x3
    line.long 0x00 "DP_COM_CONF_ASYNC0,DP Common Configuration Async 0 Flow Register"
        bitfld.long 0x00 1. " DP_GWSEL_ASYNC0 ,GWSEL - Graphic Window Select Select graphic window to be on partial plane or full plane." "0,1"
        textline "                  "
        bitfld.long 0x00 2. " DP_GWAM_ASYNC0 ,GWAM - Graphic Window Alpha Mode Select the use of Alpha to be global or local." "0,1"
        textline "                  "
        bitfld.long 0x00 3. " DP_GWCKE_ASYNC0 ,GWCKE - Graphic Window Color Keying Enable Enable or disable graphic window color keying." "0,1"
        textline "                  "
        hexmask.long.byte 0x00 4.--7. 1. " DP_COC_ASYNC0 ,COC - Cursor Operation Control Controls the format of the cursor and the type of arithmetic operations"
        textline "                  "
        hexmask.long.byte 0x00 8.--10. 1. " DP_CSC_DEF_ASYNC0 ,CSC_DEF Enable or disable Color Space Conversion."
        textline "                  "
        bitfld.long 0x00 10. " DP_CSC_GAMUT_SAT_EN_ASYNC0 ,CSC_GAMUT_SAT_EN Indicate if GAMUT saturation is enabled" "0,1"
        textline "                  "
        bitfld.long 0x00 11. " DP_CSC_YUV_SAT_MODE_ASYNC0 ,CSC_YUV_SAT_MODE YUV saturation mode for color space conversion" "0,1"
        textline "                  "
        bitfld.long 0x00 12. " DP_GAMMA_EN_ASYNC0 ,GAMMA_EN - Gamma correction block enable bit" "0,1"
        textline "                  "
        bitfld.long 0x00 13. " DP_GAMMA_YUV_EN_ASYNC0 ,GAMMA's YUV mode enable for async flow 0" "0,1"
width 26.
group.long 0x18064++0x3
    line.long 0x00 "DP_GRAPH_WIND_CTRL_ASYNC0,DP Graphic Window Control Async 0 Flow Register"
        hexmask.long.byte 0x00 0.--8. 1. " DP_GWCKB_ASYNC0 ,GWCKB - Graphic Window Color Keying Blue Component Defines the blue component of graphic window color keying."
        textline "                         "
        hexmask.long.byte 0x00 8.--16. 1. " DP_GWCKG_ASYNC0 ,GWCKG - Graphic Window Color Keying Green Component Defines the green component of graphic window color keying."
        textline "                         "
        hexmask.long.byte 0x00 16.--24. 1. " DP_GWCKR_ASYNC0 ,GWCKR - Graphic Window Color Keying Red Component Defines the red component of graphic window color keying."
        textline "                         "
        hexmask.long.byte 0x00 24.--32. 1. " DP_GWAV_ASYNC0 ,GWAV - Graphic Window Alpha Value Defines the alpha value of graphic window used for alpha blending between graphic window and full plane."
width 17.
group.long 0x18068++0x3
    line.long 0x00 "DP_FG_POS_ASYNC0,DP Partial Plane Window Position Async 0 Flow Register"
        hexmask.long.word 0x00 0.--11. 1. " DP_FGYP_ASYNC0 ,FGYP partial plane window Y position partial plane Window Y Position - Specifies the number of lines between the start of full plane windows Y position and the beginning of the first data."
        textline "                "
        hexmask.long.word 0x00 16.--27. 1. " DP_FGXP_ASYNC0 ,FGXP partial plane Window X Position."
width 18.
group.long 0x1806c++0x3
    line.long 0x00 "DP_CUR_POS_ASYNC0,DP Cursor Position and Size Async 0 Flow Register"
        hexmask.long.word 0x00 0.--11. 1. " DP_CXW_ASYNC0 ,CXW - Cursor Width."
        textline "                 "
        hexmask.long.byte 0x00 11.--16. 1. " DP_CXP_ASYNC0 ,CXP - Cursor X Position Represents the cursors horizontal starting position X in pixel count (from 0 to CXW)."
        textline "                 "
        hexmask.long.word 0x00 16.--27. 1. " DP_CYH_ASYNC0 ,CYH - Cursor Height Specifies the height of the hardware cursor in pixels."
        textline "                 "
        hexmask.long.byte 0x00 27.--32. 1. " DP_CYP_ASYNC0 ,CYP - Cursor Y Position Represents the cursors vertical starting position Y in pixel count (from 0 to CYH).Live View Resolution Mode."
width 18.
group.long 0x18070++0x3
    line.long 0x00 "DP_CUR_MAP_ASYNC0,DP Color Cursor Mapping Async 0 Flow Register"
        hexmask.long.byte 0x00 0.--8. 1. " DP_CUR_COL_R_ASYNC0 ,CUR_COL_R - Cursor Red Field Defines the Red component of the cursor color in color mode"
        textline "                 "
        hexmask.long.byte 0x00 8.--16. 1. " DP_CUR_COL_G_ASYNC0 ,CUR_COL_G - Cursor Green Field Defines the Green component of the cursor color in color mode"
        textline "                 "
        hexmask.long.byte 0x00 16.--24. 1. " DP_CUR_COL_B_ASYNC0 ,CUR_COL_B - Cursor Blue Field Defines the Blue component of the cursor color in color mode"
width 20.
group.long 0x18074++0x3
    line.long 0x00 "DP_GAMMA_C_ASYNC0_I,DP Gamma Constant Async 0 Flow Register i"
        hexmask.long.word 0x00 0.--9. 1. " DP_GAMMA_C_ASYNC0_2I ,CONSTANTi parameter of Gamma Correction."
        textline "                   "
        hexmask.long.word 0x00 16.--28. 1. " DP_GAMMA_C_ASYNC0_2I_1 ,CONSTANTi+1 parameter of Gamma Correction."
width 20.
group.long 0x18094++0x3
    line.long 0x00 "DP_GAMMA_S_ASYNC0_I,DP Gamma Correction Slope Async 0 Flow Register i"
        hexmask.long.byte 0x00 0.--8. 1. " DP_GAMMA_S_ASYNC0_4I ,SLOPE<4*i> parameter of Gamma Correction."
        textline "                   "
        hexmask.long.byte 0x00 8.--16. 1. " DP_GAMMA_S_ASYNC0_4I_1 ,SLOPE<4*i+1> parameter of Gamma Correction."
        textline "                   "
        hexmask.long.byte 0x00 16.--24. 1. " DP_GAMMA_S_ASYNC0_4I_2 ,SLOPE<4*i+2> parameter of Gamma Correction."
        textline "                   "
        hexmask.long.byte 0x00 24.--32. 1. " DP_GAMMA_S_ASYNC0_4I_3 ,SLOPE<4*i+3> parameter of Gamma Correction."
width 17.
group.long 0x180a4++0x3
    line.long 0x00 "DP_CSCA_ASYNC0_I,DP Color Space Conversion Control Async 0 Flow Register i"
        hexmask.long.word 0x00 0.--10. 1. " DP_CSC_A_ASYNC0_2I ,A<2*i> parameter of color conversion."
        textline "                "
        hexmask.long.word 0x00 16.--26. 1. " DP_CSC_A_ASYNC0_2I_1 ,A<2*i+1> parameter of color conversion"
width 16.
group.long 0x180b4++0x3
    line.long 0x00 "DP_CSC_ASYNC0_0,DP Color Conversion Control Async 0 Flow Register 0"
        hexmask.long.word 0x00 0.--10. 1. " DP_CSC_A8_ASYNC0 ,A9 parameter of color conversion."
        textline "               "
        hexmask.long.word 0x00 16.--30. 1. " DP_CSC_B0_ASYNC0 ,B0 parameter of color conversion."
        textline "               "
        hexmask.long.byte 0x00 30.--32. 1. " DP_CSC_S0_ASYNC0 ,S0 parameter of color conversion."
width 15.
group.long 0x180b8++0x3
    line.long 0x00 "DP_CSC_ASYNC_1,DP Color Conversion Control Async 1 Flow Register"
        hexmask.long.word 0x00 0.--14. 1. " DP_CSC_B1_ASYNC0 ,B0 parameter of color conversion."
        textline "              "
        hexmask.long.byte 0x00 14.--16. 1. " DP_CSC_S1_ASYNC0 ,S0 parameter of color conversion."
        textline "              "
        hexmask.long.word 0x00 16.--30. 1. " DP_CSC_B2_ASYNC0 ,B0 parameter of color conversion."
        textline "              "
        hexmask.long.byte 0x00 30.--32. 1. " DP_CSC_S2_ASYNC0 ,S0 parameter of color conversion."
width 19.
group.long 0x180bc++0x3
    line.long 0x00 "DP_COM_CONF_ASYNC1,DP Common Configuration Async 1 Flow Register"
        bitfld.long 0x00 1. " DP_GWSEL_ASYNC1 ,GWSEL - Graphic Window Select Select graphic window to be on partial plane or full plane." "0,1"
        textline "                  "
        bitfld.long 0x00 2. " DP_GWAM_ASYNC1 ,GWAM - Graphic Window Alpha Mode Select the use of Alpha to be global or local." "0,1"
        textline "                  "
        bitfld.long 0x00 3. " DP_GWCKE_ASYNC1 ,GWCKE - Graphic Window Color Keying Enable Enable or disable graphic window color keying." "0,1"
        textline "                  "
        hexmask.long.byte 0x00 4.--7. 1. " DP_COC_ASYNC1 ,COC - Cursor Operation Control Controls the format of the cursor and the type of arithmetic operations"
        textline "                  "
        hexmask.long.byte 0x00 8.--10. 1. " DP_CSC_DEF_ASYNC1 ,CSC_DEF Enable or disable Color Space Conversion."
        textline "                  "
        bitfld.long 0x00 10. " DP_CSC_GAMUT_SAT_EN_ASYNC1 ,CSC_GAMUT_SAT_EN Indicate if GAMUT saturation is enabled" "0,1"
        textline "                  "
        bitfld.long 0x00 11. " DP_CSC_YUV_SAT_MODE_ASYNC1 ,CSC_YUV_SAT_MODE YUV saturation mode for color space conversion" "0,1"
        textline "                  "
        bitfld.long 0x00 12. " DP_GAMMA_EN_ASYNC1 ,GAMMA_EN - Gamma correction block enable bit" "0,1"
        textline "                  "
        bitfld.long 0x00 13. " DP_GAMMA_YUV_EN_ASYNC1 ,GAMMA's YUV mode enable for async flow 1" "0,1"
width 13.
group.long 0x180bc++0x3
    line.long 0x00 "DP_DEBUG_CNT,DP Debug Control Register"
        bitfld.long 0x00 0. " BRAKE_STATUS_EN_0 ,This bit enables the break/status unit #0" "0,1"
        textline "            "
        hexmask.long.byte 0x00 1.--4. 1. " BRAKE_CNT_0 ,The async flow can be broken multiple times."
        textline "            "
        bitfld.long 0x00 4. " BRAKE_STATUS_EN_1 ,This bit enables the break/status unit #1" "0,1"
        textline "            "
        hexmask.long.byte 0x00 5.--8. 1. " BRAKE_CNT_1 ,The async flow can be broken multiple times."
width 26.
group.long 0x180c0++0x3
    line.long 0x00 "DP_GRAPH_WIND_CTRL_ASYNC1,DP Graphic Window Control Async 1 Flow Register"
        hexmask.long.byte 0x00 0.--8. 1. " DP_GWCKB_ASYNC1 ,GWCKB - Graphic Window Color Keying Blue Component Defines the blue component of graphic window color keying."
        textline "                         "
        hexmask.long.byte 0x00 8.--16. 1. " DP_GWCKG_ASYNC1 ,GWCKG - Graphic Window Color Keying Green Component Defines the green component of graphic window color keying."
        textline "                         "
        hexmask.long.byte 0x00 16.--24. 1. " DP_GWCKR_ASYNC1 ,GWCKR - Graphic Window Color Keying Red Component Defines the red component of graphic window color keying."
        textline "                         "
        hexmask.long.byte 0x00 24.--32. 1. " DP_GWAV_ASYNC1 ,GWAV - Graphic Window Alpha Value Defines the alpha value of graphic window used for alpha blending between graphic window and full plane."
width 14.
rgroup.long 0x180c0++0x3
    line.long 0x00 "DP_DEBUG_STAT,DP Debug Status Register"
        hexmask.long.word 0x00 0.--11. 1. " V_CNT_OLD_0 ,The exact row where the async flow has been broken (This filed is relevant for debug unit #0)"
        textline "             "
        bitfld.long 0x00 11. " FG_ACTIVE_0 ,Displaying the partial frame has been started for async flow (This filed is relevant for debug unit #0)" "0,1"
        textline "             "
        bitfld.long 0x00 12. " COMBYP_EN_OLD_0 ,the async flow has been broken in the middle of combining (This filed is relevant for debug unit #0)" "0,1"
        textline "             "
        bitfld.long 0x00 13. " CYP_EN_OLD_0 ,The async flow has been broken in the middle of a cursor (This filed is relevant for debug unit #0)" "0,1"
        textline "             "
        hexmask.long.word 0x00 16.--27. 1. " V_CNT_OLD_1 ,The exact row where the async flow has been broken (This filed is relevant for debug unit #0)"
        textline "             "
        bitfld.long 0x00 27. " FG_ACTIVE_1 ,Displaying the partial frame has been started (This filed is relevant for debug unit #1)" "0,1"
        textline "             "
        bitfld.long 0x00 28. " COMBYP_EN_OLD_1 ,the async1 flow has been broken in the middle of combining (This filed is relevant for debug unit #1)" "0,1"
        textline "             "
        bitfld.long 0x00 29. " CYP_EN_OLD_1 ,The async flow has been broken in the middle of a cursor (This filed is relevant for debug unit #1)" "0,1"
width 17.
group.long 0x180c4++0x3
    line.long 0x00 "DP_FG_POS_ASYNC1,DP Partial Plane Window Position Async 1 Flow Register"
        hexmask.long.word 0x00 0.--11. 1. " DP_FGYP_ASYNC1 ,FGYP partial plane window Y position partial plane Window Y Position - Specifies the number of lines between the start of full plane windows Y position and the beginning of the first data."
        textline "                "
        hexmask.long.word 0x00 16.--27. 1. " DP_FGXP_ASYNC1 ,FGXP partial plane Window X Position."
width 18.
group.long 0x180c8++0x3
    line.long 0x00 "DP_CUR_POS_ASYNC1,DP Cursor Postion and Size Async 1 Flow Register"
        hexmask.long.word 0x00 0.--11. 1. " DP_CXW_ASYNC1 ,CXW - Cursor Width."
        textline "                 "
        hexmask.long.byte 0x00 11.--16. 1. " DP_CXP_ASYNC1 ,CXP - Cursor X Position Represents the cursors horizontal starting position X in pixel count (from 0 to CXW)."
        textline "                 "
        hexmask.long.word 0x00 16.--27. 1. " DP_CYH_ASYNC1 ,CYH - Cursor Height Specifies the height of the hardware cursor in pixels."
        textline "                 "
        hexmask.long.byte 0x00 27.--32. 1. " DP_CYP_ASYNC1 ,CYP - Cursor Y Position Represents the cursors vertical starting position Y in pixel count (from 0 to CYH).Live View Resolution Mode."
width 18.
group.long 0x180cc++0x3
    line.long 0x00 "DP_CUR_MAP_ASYNC1,DP Color Cursor Mapping Async 1 Flow Register"
        hexmask.long.byte 0x00 0.--8. 1. " DP_CUR_COL_R_ASYNC1 ,CUR_COL_R - Cursor Red Field Defines the Red component of the cursor color in color mode"
        textline "                 "
        hexmask.long.byte 0x00 8.--16. 1. " DP_CUR_COL_G_ASYNC1 ,CUR_COL_G - Cursor Green Field Defines the Green component of the cursor color in color mode"
        textline "                 "
        hexmask.long.byte 0x00 16.--24. 1. " DP_CUR_COL_B_ASYNC1 ,CUR_COL_B - Cursor Blue Field Defines the Blue component of the cursor color in color mode"
width 20.
group.long 0x180d0++0x3
    line.long 0x00 "DP_GAMMA_C_ASYNC1_I,DP Gamma Constants Async 1 Flow Register i"
        hexmask.long.word 0x00 0.--9. 1. " DP_GAMMA_C_ASYNC1_2I ,CONSTANTi parameter of Gamma Correction."
        textline "                   "
        hexmask.long.word 0x00 16.--25. 1. " DP_GAMMA_C_ASYNC1_2I_1 ,CONSTANTi+1 parameter of Gamma Correction."
width 19.
group.long 0x180f0++0x3
    line.long 0x00 "DP_GAMMA_S_ASYN1_I,DP Gamma Correction Slope Async 1 Flow Register i"
        hexmask.long.byte 0x00 0.--8. 1. " DP_GAMMA_S_ASYNC1_4I ,SLOPE<4*i> parameter of Gamma Correction."
        textline "                  "
        hexmask.long.byte 0x00 8.--16. 1. " DP_GAMMA_S_ASYNC1_4I_1 ,SLOPE<4*i+1> parameter of Gamma Correction."
        textline "                  "
        hexmask.long.byte 0x00 16.--24. 1. " DP_GAMMA_S_ASYNC1_4I_2 ,SLOPE<4*i+2> parameter of Gamma Correction."
        textline "                  "
        hexmask.long.byte 0x00 24.--32. 1. " DP_GAMMA_S_ASYNC1_4I_3 ,SLOPE<4*i+3> parameter of Gamma Correction."
width 17.
group.long 0x18100++0x3
    line.long 0x00 "DP_CSCA_ASYNC1_I,DP Color Space Converstion Control Async 1 Flow Register i"
        hexmask.long.word 0x00 0.--10. 1. " DP_CSC_A_ASYNC1_2I ,A<2*i> parameter of color conversion."
        textline "                "
        hexmask.long.word 0x00 16.--26. 1. " DP_CSC_A_ASYNC1_2I_1 ,A<2*i+1> parameter of color conversion."
width 16.
group.long 0x18110++0x3
    line.long 0x00 "DP_CSC_ASYNC1_0,DP Color Conversion Control Async 1 Flow Register 0"
        hexmask.long.word 0x00 0.--10. 1. " DP_CSC_A8_ASYNC1 ,A9 parameter of color conversion."
        textline "               "
        hexmask.long.word 0x00 16.--30. 1. " DP_CSC_B0_ASYNC1 ,B0 parameter of color conversion."
        textline "               "
        hexmask.long.byte 0x00 30.--32. 1. " DP_CSC_S0_ASYNC1 ,S0 parameter of color conversion."
width 16.
group.long 0x18114++0x3
    line.long 0x00 "DP_CSC_ASYNC1_1,DP Color Conversion Control Async 1 Flow Register 1"
        hexmask.long.word 0x00 0.--14. 1. " DP_CSC_B1_ASYNC1 ,B0 parameter of color conversion."
        textline "               "
        hexmask.long.byte 0x00 14.--16. 1. " DP_CSC_S1_ASYNC1 ,S0 parameter of color conversion."
        textline "               "
        hexmask.long.word 0x00 16.--30. 1. " DP_CSC_B2_ASYNC1 ,B0 parameter of color conversion."
        textline "               "
        hexmask.long.byte 0x00 30.--32. 1. " DP_CSC_S2_ASYNC1 ,S0 parameter of color conversion."
width 8.
group.long 0x20000++0x3
    line.long 0x00 "IC_CONF,IC Configuration Register"
        bitfld.long 0x00 0. " PRPENC_EN ,Preprocessing Task for encoding enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " PRPENC_CSC1 ,Preprocessing Task for encoding color conversion enable." "0,1"
        textline "       "
        bitfld.long 0x00 2. " PRPENC_ROT_EN ,Preprocessing Rotation Task for encoding enable." "0,1"
        textline "       "
        bitfld.long 0x00 8. " PRPVF_EN ,Preprocessing Task for View-Finder enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " PRPVF_CSC1 ,Pre-processing task for view-finder first color conversion enable." "0,1"
        textline "       "
        bitfld.long 0x00 10. " PRPVF_CSC2 ,Reserved" "0,1"
        textline "       "
        bitfld.long 0x00 11. " PRPVF_CMB ,Preprocessing Task for View-Finder combining enable." "0,1"
        textline "       "
        bitfld.long 0x00 12. " PRPVF_ROT_EN ,Preprocessing Rotation Task for viewfinder enable." "0,1"
        textline "       "
        bitfld.long 0x00 16. " PP_EN ,Post-Processing Task enable." "0,1"
        textline "       "
        bitfld.long 0x00 17. " PP_CSC1 ,Post-Processing Task color conversion YUV-->RGB enable." "0,1"
        textline "       "
        bitfld.long 0x00 18. " PP_CSC2 ,Post-Processing Task color conversion RGB-->YUV enable." "0,1"
        textline "       "
        bitfld.long 0x00 19. " PP_CMB ,Post-Processing Task combining enable." "0,1"
        textline "       "
        bitfld.long 0x00 20. " PP_ROT_EN ,Post-Processing Rotation Task enable." "0,1"
        textline "       "
        bitfld.long 0x00 28. " IC_GLB_LOC_A ,Global Alpha." "0,1"
        textline "       "
        bitfld.long 0x00 29. " IC_KEY_COLOR_EN ,Key Color enable." "0,1"
        textline "       "
        bitfld.long 0x00 30. " RWS_EN ,Raw sensor enable." "0,1"
        textline "       "
        bitfld.long 0x00 31. " CSI_MEM_WR_EN ,CSI direct memory write enable." "0,1"
width 15.
group.long 0x20004++0x3
    line.long 0x00 "IC_PRP_ENC_RSC,IC Preprocessing Encoder Resizing Coefficients Register"
        hexmask.long.word 0x00 0.--14. 1. " PRPENC_RS_R_H ,Preprocessing task for encoding Resizing horizontal Ratio."
        textline "              "
        hexmask.long.byte 0x00 14.--16. 1. " PRPENC_DS_R_H ,Preprocessing task for encoding Downsizing horizontal Ratio."
        textline "              "
        hexmask.long.word 0x00 16.--30. 1. " PRPENC_RS_R_V ,Preprocessing task for encoding Resizing vertical Ratio."
        textline "              "
        hexmask.long.byte 0x00 30.--32. 1. " PRPENC_DS_R_V ,Preprocessing task for encoding Downsizing vertical Ratio."
width 14.
group.long 0x20008++0x3
    line.long 0x00 "IC_PRP_VF_RSC,IC Preprocessing View-Finder Resizing Coefficients Register"
        hexmask.long.word 0x00 0.--14. 1. " PRPVF_RS_R_H ,Preprocessing task for view-finding resizing horizontal ratio."
        textline "             "
        hexmask.long.byte 0x00 14.--16. 1. " PRPVF_DS_R_H ,Preprocessing task for encoding Downsizing horizontal Ratio."
        textline "             "
        hexmask.long.word 0x00 16.--30. 1. " PRPVF_RS_R_V ,Preprocessing task for encoding Resizing vertical Ratio."
        textline "             "
        hexmask.long.byte 0x00 30.--32. 1. " PRPVF_DS_R_V ,Preprocessing task for encoding Downsizing vertical Ratio."
width 10.
group.long 0x2000c++0x3
    line.long 0x00 "IC_PP_RSC,IC Postprocessing Encoder Resizing Coefficients Register"
        hexmask.long.word 0x00 0.--14. 1. " PP_RS_R_H ,Post-Processing task Resizing horizontal Ratio."
        textline "         "
        hexmask.long.byte 0x00 14.--16. 1. " PP_DS_R_H ,Post-Processing task Downsizing horizontal Ratio."
        textline "         "
        hexmask.long.word 0x00 16.--30. 1. " PP_RS_R_V ,Post-Processing task Resizing vertical Ratio."
        textline "         "
        hexmask.long.byte 0x00 30.--32. 1. " PP_DS_R_V ,Post-Processing task Downsizing vertical Ratio."
width 10.
group.long 0x20010++0x3
    line.long 0x00 "IC_CMBP_1,IC Combining Parameters Register 1"
        hexmask.long.byte 0x00 0.--8. 1. " IC_PRPVF_ALPHA_V ,Preprocessing task for viewfinder Global Alpha."
        textline "         "
        hexmask.long.byte 0x00 8.--16. 1. " IC_PP_ALPHA_V ,Post-Processing task Global Alpha."
width 10.
group.long 0x20014++0x3
    line.long 0x00 "IC_CMBP_2,IC Combining Parameters Register 2"
        hexmask.long.byte 0x00 0.--8. 1. " IC_KEY_COLOR_B ,Key Color Blue."
        textline "         "
        hexmask.long.byte 0x00 8.--16. 1. " IC_KEY_COLOR_G ,Key Color Green."
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " IC_KEY_COLOR_R ,Key Color Red."
width 11.
group.long 0x20018++0x3
    line.long 0x00 "IC_IDMAC_1,IC IDMAC Parameters 1 Register"
        bitfld.long 0x00 0. " CB0_BURST_16 ,This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB0 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 1. " CB1_BURST_16 ,This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB1 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 2. " CB2_BURST_16 ,This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB2 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 3. " CB3_BURST_16 ,This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB3 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 4. " CB4_BURST_16 ,This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB4 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 5. " CB5_BURST_16 ,This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB5 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 6. " CB6_BURST_16 ,This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB6 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 7. " CB7_BURST_16 ,This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB7 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 11. " T1_ROT ,Rotation for Encoding (ENC) task The value of this field must be identical to the corresponding channel's ROT parameters in the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 12. " T1_FLIP_LR ,LEFT/RIGHT flip for Encoding (ENC) task; this bit affect the flipping done on the rotation unit The value of this field must be identical to the corresponding channel's HF parameter in the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 13. " T1_FLIP_UD ,UP/DOWN flip for Encoding (ENC) task The value of this field must be identical to the corresponding channel's VF parameters in the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 14. " T2_ROT ,Rotation for View Finder (VF) task The value of this field must be identical to the corresponding channel's ROT parameters in the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 15. " T2_FLIP_LR ,LEFT/RIGHT flip for View Finder (VF) task; this bit affect the flipping done on the rotation unit The value of this field must be identical to the corresponding channel's HF parameter in the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 16. " T2_FLIP_UD ,UP/DOWN flip for View Finder (VF) task The value of this field must be identical to the corresponding channel's VF parameters in the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 17. " T3_ROT ,Rotation for Post Processing (PP) task The value of this field must be identical to the corresponding channel's ROT parameters in the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 18. " T3_FLIP_LR ,LEFT/RIGHT flip for Post Processing (PP) task; this bit affect the flipping done on the rotation unit The value of this field must be identical to the corresponding channel's HF parameter in the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 19. " T3_FLIP_UD ,UP/DOWN flip for Post Processing (PP) task The value of this field must be identical to the corresponding channel's VF parameters in the IDMAC's CPMEM" "0,1"
        textline "          "
        bitfld.long 0x00 20. " T1_FLIP_RS ,LEFT/RIGHT flip for Encoding (ENC) task; this bit affect the flipping done on the resizing unit." "0,1"
        textline "          "
        bitfld.long 0x00 21. " T2_FLIP_RS ,LEFT/RIGHT flip for View Finder (VF) task; this bit affect the flipping done on the resizing unit." "0,1"
        textline "          "
        bitfld.long 0x00 22. " T3_FLIP_RS ,LEFT/RIGHT flip for Post Processing (PP) task; his bit affect the flipping done on the resizing unit." "0,1"
        textline "          "
        bitfld.long 0x00 24. " ALT_CB6_BURST_16 ,Reserved" "0,1"
        textline "          "
        bitfld.long 0x00 25. " ALT_CB7_BURST_16 ,Reserved" "0,1"
width 11.
group.long 0x2001c++0x3
    line.long 0x00 "IC_IDMAC_2,IC IDMAC Parameters 2 Register"
        hexmask.long.word 0x00 0.--10. 1. " T1_FR_HEIGHT ,Frame Height for Encoding (ENC) task The value of this field must be identical to corresponding FH channel's parameters in the IDMAC's CPMEM."
        textline "          "
        hexmask.long.word 0x00 10.--20. 1. " T2_FR_HEIGHT ,Frame Height for View Finder (VF) task The value of this field must be identical to the corresponding FH channel's parameters in the IDMAC's CPMEM."
        textline "          "
        hexmask.long.word 0x00 20.--30. 1. " T3_FR_HEIGHT ,Frame Height for Post Processing (PP) task The value of this field must be identical to the corresponding FH channel's parameters in the IDMAC's CPMEM."
width 11.
group.long 0x20020++0x3
    line.long 0x00 "IC_IDMAC_3,IC IDMAC Parameters 3Register"
        hexmask.long.word 0x00 0.--10. 1. " T1_FR_WIDTH ,Frame Width for Encoding (ENC) task The value of this field must be identical to corresponding FW channel's parameters in the IDMAC's CPMEM."
        textline "          "
        hexmask.long.word 0x00 10.--20. 1. " T2_FR_WIDTH ,Frame Width for View Finder (VF) task The value of this field must be identical to the corresponding FW channel's parameters in the IDMAC's CPMEM."
        textline "          "
        hexmask.long.word 0x00 20.--30. 1. " T3_FR_WIDTH ,Frame Width for Post Processing (PP) task The value of this field must be identical to the corresponding FW channel's parameters in the IDMAC's CPMEM."
width 11.
group.long 0x20024++0x3
    line.long 0x00 "IC_IDMAC_4,IC IDMAC Parameters 4 Register"
        hexmask.long.byte 0x00 0.--4. 1. " MPM_RW_BRDG_MAX_RQ ,MPM memory Bridge Max Requests between MPM's read and writes"
        textline "          "
        hexmask.long.byte 0x00 4.--8. 1. " MPM_DMFC_BRDG_MAX_RQ ,MPM memory Bridge Max Requests for the IC DMFC interface"
        textline "          "
        hexmask.long.byte 0x00 8.--12. 1. " IBM_BRDG_MAX_RQ ,IBM memory Bridge Max Requests"
        textline "          "
        hexmask.long.byte 0x00 12.--16. 1. " RM_BRDG_MAX_RQ ,RM memory Bridge Max Requests"
width 15.
group.long 0x30000++0x3
    line.long 0x00 "CSI0_SENS_CONF,CSI0 Sensor Configuration Register"
        bitfld.long 0x00 0. " CSI0_VSYNC_POL ,Invert IPP_IND_SENSB_VSYNC input." "0,1"
        textline "              "
        bitfld.long 0x00 1. " CSI0_HSYNC_POL ,Invert IPP_IND_SENSB_HSYNC input." "0,1"
        textline "              "
        bitfld.long 0x00 2. " CSI0_DATA_POL ,Invert data input." "0,1"
        textline "              "
        bitfld.long 0x00 3. " CSI0_SENS_PIX_CLK_POL ,Invert Pixel clock input." "0,1"
        textline "              "
        hexmask.long.byte 0x00 4.--7. 1. " CSI0_SENS_PRTCL ,Sensor Protocol."
        textline "              "
        bitfld.long 0x00 7. " CSI0_PACK_TIGHT ,CSI0 Pack Tight When the data format is YUV or RGB and the component's width is 9-16 bits, it can be sent to the memory in 2 different ways." "0,1"
        textline "              "
        hexmask.long.byte 0x00 8.--11. 1. " CSI0_SENS_DATA_FORMAT ,Data format from the sensor."
        textline "              "
        hexmask.long.byte 0x00 11.--15. 1. " CSI0_DATA_WIDTH ,Data width."
        textline "              "
        bitfld.long 0x00 15. " CSI0_EXT_VSYNC ,External VSYNC enable." "0,1"
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " CSI0_DIV_RATIO ,DIV Ratio Clock division ratio minus 1."
        textline "              "
        hexmask.long.byte 0x00 24.--27. 1. " CSI0_DATA_DEST ,These bits enable the destination of the data coming from the CSI."
        textline "              "
        bitfld.long 0x00 27. " CSI0_JPEG8_EN ,JPEG8 enable bit" "0,1"
        textline "              "
        bitfld.long 0x00 28. " CSI0_JPEG_MODE ,JPEG Mode - this bit defines the mode of the control signals when working in JPEG mode" "0,1"
        textline "              "
        bitfld.long 0x00 29. " CSI0_FORCE_EOF ,Force End of frame This is a self clear bit allowing the user to force an End-of-frame event; This bit can be used in cases where the frame sent by the sensor was not completed." "0,1"
        textline "              "
        bitfld.long 0x00 31. " CSI0_DATA_EN_POL ,Invert IPP_IND_SENSB_DATA_EN input." "0,1"
width 19.
group.long 0x30004++0x3
    line.long 0x00 "CSI0_SENS_FRM_SIZE,CSI0 Sense Frame Size Register"
        hexmask.long.word 0x00 0.--13. 1. " CSI0_SENS_FRM_WIDTH ,Sensor frame width minus 1."
        textline "                  "
        hexmask.long.word 0x00 16.--28. 1. " CSI0_SENS_FRM_HEIGHT ,Sensor frame height minus 1."
width 18.
group.long 0x30008++0x3
    line.long 0x00 "CSI0_ACT_FRM_SIZE,CSI0 Actual Frame Size Register"
        hexmask.long.word 0x00 0.--13. 1. " CSI0_ACT_FRM_WIDTH ,Actual frame width minus 1."
        textline "                 "
        hexmask.long.word 0x00 16.--28. 1. " CSI0_ACT_FRM_HEIGHT ,Actual frame height minus 1."
width 18.
group.long 0x3000c++0x3
    line.long 0x00 "CSI0_OUT_FRM_CTRL,CSI0 Output Control Register"
        hexmask.long.word 0x00 0.--12. 1. " CSI0_VSC ,Vertical skip."
        textline "                 "
        hexmask.long.word 0x00 16.--29. 1. " CSI0_HSC ,Horizontal skip."
        textline "                 "
        bitfld.long 0x00 30. " CSI0_VERT_DWNS ,Enable vertical downsizing (decimation) by 2." "0,1"
        textline "                 "
        bitfld.long 0x00 31. " CSI0_HORZ_DWNS ,Enable horizontal downsizing (decimation) by 2." "0,1"
width 14.
group.long 0x30010++0x3
    line.long 0x00 "CSI0_TST_CTRL,CSIO Test Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PG_R_VALUE ,Pattern generator R value."
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " PG_G_VALUE ,Pattern generator G value."
        textline "             "
        hexmask.long.byte 0x00 16.--24. 1. " PG_B_VALUE ,Pattern generator B value."
        textline "             "
        bitfld.long 0x00 24. " TEST_GEN_MODE ,Test generator mode." "0,1"
width 17.
group.long 0x30014++0x3
    line.long 0x00 "CSI0_CCIR_CODE_1,CSIO CCIR Code Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " CSI0_END_FLD0_BLNK_1ST ,End of field 0 first blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 3.--6. 1. " CSI0_STRT_FLD0_BLNK_1ST ,Start of field 0 first blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 6.--9. 1. " CSI0_END_FLD0_BLNK_2ND ,End of field 0 second blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 9.--12. 1. " CSI0_STRT_FLD0_BLNK_2ND ,Start of field 0 second blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 16.--19. 1. " CSI0_END_FLD0_ACTV ,End of field 0 active line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 19.--22. 1. " CSI0_STRT_FLD0_ACTV ,Start of field 0 active line command (interlaces mode)."
        textline "                "
        bitfld.long 0x00 24. " CSI0_CCIR_ERR_DET_EN ,Enable error detection and correction for CCIR interlaced mode with protection bit." "0,1"
width 17.
group.long 0x30018++0x3
    line.long 0x00 "CSI0_CCIR_CODE_2,CSIO CCIR Code Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " CSI0_END_FLD1_BLNK_1ST ,End of field 1 first blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 3.--6. 1. " CSI0_STRT_FLD1_BLNK_1ST ,Start of field 1 first blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 6.--9. 1. " CSI0_END_FLD1_BLNK_2ND ,End of field 1 second blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 9.--12. 1. " CSI0_STRT_FLD1_BLNK_2ND ,Start of field 1 second blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 16.--19. 1. " CSI0_END_FLD1_ACTV ,End of field 1 active line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 19.--22. 1. " CSI0_STRT_FLD1_ACTV ,Start of field 1 active line command (interlaces mode)."
width 17.
group.long 0x3001c++0x3
    line.long 0x00 "CSI0_CCIR_CODE_3,CSIO CCIR Code Register 3"
        hexmask.long.long 0x00 0.--30. 1. " CSI0_CCIR_PRECOM ,CCIR pre command."
width 8.
group.long 0x30020++0x3
    line.long 0x00 "CSI0_DI,CSI0 Data Identifier Register"
        hexmask.long.byte 0x00 0.--8. 1. " CSI0_MIPI_DI0 ,CSI0_MIPI_DI0 This field holds the Data Identifier #0 handled by the CSI; This is the main stream."
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " CSI0_MIPI_DI1 ,CSI0_MIPI_DI1 This field holds the Data Identifier #1 handled by the CSI"
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " CSI0_MIPI_DI2 ,CSI0_MIPI_DI2 This field holds the Data Identifier #2 handled by the CSI."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " CSI0_MIPI_DI3 ,CSI0_MIPI_DI3 This field holds the Data Identifier #3 handled by the CSI."
width 10.
group.long 0x30024++0x3
    line.long 0x00 "CSI0_SKIP,CSI0 SKIP Register"
        hexmask.long.byte 0x00 0.--3. 1. " CSI0_MAX_RATIO_SKIP_SMFC ,CSI0 Maximum Ratio Skip for SMFC These bits define the number of frames in a skipping set."
        textline "         "
        hexmask.long.byte 0x00 3.--8. 1. " CSI0_SKIP_SMFC ,CSI0 SKIP SMFC These 5 bits define the skipping pattern of the frames send to the SMFC."
        textline "         "
        hexmask.long.byte 0x00 8.--10. 1. " CSI0_ID_2_SKIP ,CSI0 to SMFC Skipping ID."
        textline "         "
        hexmask.long.byte 0x00 16.--19. 1. " CSI0_MAX_RATIO_SKIP_ISP ,Reserved"
        textline "         "
        hexmask.long.byte 0x00 19.--24. 1. " CSI0_SKIP_ISP ,Reserved"
width 14.
group.long 0x30028++0x3
    line.long 0x00 "CSIO_CPD_CTRL,CSI0 Compander Control Register"
        bitfld.long 0x00 0. " CSI0_GREEN_P_BEGIN ,Color of first component in the frame." "0,1"
        textline "             "
        bitfld.long 0x00 1. " CSI0_RED_ROW_BEGIN ,Color of first row in the frame." "0,1"
        textline "             "
        hexmask.long.byte 0x00 2.--5. 1. " CSI0_CPD ,CSI0_CPD These bits enable the compander in the path to different destination."
width 14.
group.long 0x3002c++0x3
    line.long 0x00 "CSIO_CPD_RC_I,CSI0 Red Component Compander Constants Register <i>"
        hexmask.long.word 0x00 0.--9. 1. " CSI0_CPD_RC_2I ,CONSTANT <2*i> parameter of Compander, Red component."
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " CSI0_CPD_RC_2I_1 ,CONSTANT <2*i+1> parameter of Compander, Red component."
width 14.
group.long 0x3004c++0x3
    line.long 0x00 "CSIO_CPD_RS_I,CSI0 Red Component Compander SLOPE Register <i>"
        hexmask.long.byte 0x00 0.--8. 1. " CSI0_CPD_RS_4I ,Reserved"
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " CSI0_CPD_RS_4I_1 ,Reserved"
        textline "             "
        hexmask.long.byte 0x00 16.--24. 1. " CSI0_CPD_RS_4I_2 ,Reserved"
        textline "             "
        hexmask.long.byte 0x00 24.--32. 1. " CSI0_CPD_RS_4I_3 ,Reserved"
width 15.
group.long 0x3005c++0x3
    line.long 0x00 "CSIO_CPD_GRC_I,CSI0 GR Component Compander Constants Register <i>"
        hexmask.long.word 0x00 0.--9. 1. " CSI0_CPD_GRC_2I ,Reserved"
        textline "              "
        hexmask.long.word 0x00 16.--25. 1. " CSI0_CPD_GRC_2I_1 ,Reserved"
width 15.
group.long 0x3007c++0x3
    line.long 0x00 "CSIO_CPD_GRS_I,CSI0 GR Component Compander SLOPE Register <i>"
        hexmask.long.byte 0x00 0.--8. 1. " CSI0_CPD_GRS_4I ,Reserved"
        textline "              "
        hexmask.long.byte 0x00 8.--16. 1. " CSI0_CPD_GRS_4I_1 ,Reserved"
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " CSI0_CPD_GRS_4I_2 ,Reserved"
        textline "              "
        hexmask.long.byte 0x00 24.--32. 1. " CSI0_CPD_GRS_4I_3 ,Reserved"
width 15.
group.long 0x3008c++0x3
    line.long 0x00 "CSIO_CPD_GBC_I,CSI0 GB Component Compander Constants Register <i>"
        hexmask.long.word 0x00 0.--9. 1. " CSI0_CPD_GBC_2I ,Reserved"
        textline "              "
        hexmask.long.word 0x00 16.--25. 1. " CSI0_CPD_GBC_2I_1 ,Reserved"
width 15.
group.long 0x300ac++0x3
    line.long 0x00 "CSIO_CPD_GBS_I,CSI0 GB Component Compander SLOPE Register <i>"
        hexmask.long.byte 0x00 0.--8. 1. " CSI0_CPD_GBS_4I ,Reserved"
        textline "              "
        hexmask.long.byte 0x00 8.--16. 1. " CSI0_CPD_GBS_4I_1 ,Reserved"
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " CSI0_CPD_GBS_4I_2 ,Reserved"
        textline "              "
        hexmask.long.byte 0x00 24.--32. 1. " CSI0_CPD_GBS_4I_3 ,Reserved"
width 14.
group.long 0x300bc++0x3
    line.long 0x00 "CSIO_CPD_BC_I,CSI0 Blue Component Compander Constants Register <i>"
        hexmask.long.word 0x00 0.--9. 1. " CSI0_CPD_BC_2I ,Reserved"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " CSI0_CPD_BC_2I_1 ,Reserved"
width 14.
group.long 0x300dc++0x3
    line.long 0x00 "CSIO_CPD_BS_I,CSI0 Blue Component Compander SLOPE Register <i>"
        hexmask.long.byte 0x00 0.--8. 1. " CSI0_CPD_BS_4I ,Reserved l"
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " CSI0_CPD_BS_4I_1 ,Reserved"
        textline "             "
        hexmask.long.byte 0x00 16.--24. 1. " CSI0_CPD_BS_4I_2 ,Reserved"
        textline "             "
        hexmask.long.byte 0x00 24.--32. 1. " CSI0_CPD_BS_4I_3 ,Reserved"
width 17.
group.long 0x300ec++0x3
    line.long 0x00 "CSI0_CPD_OFFSET1,CSI0 Compander Offset Register 1"
        hexmask.long.word 0x00 0.--10. 1. " CSI0_GR_OFFSET ,Reserved"
        textline "                "
        hexmask.long.word 0x00 10.--20. 1. " CSI0_GB_OFFSET ,Reserved"
        textline "                "
        hexmask.long.word 0x00 20.--30. 1. " CSI0_CPD_B_OFFSET ,Reserved"
width 17.
group.long 0x300f0++0x3
    line.long 0x00 "CSI0_CPD_OFFSET2,CSI0 Compander Offset Register 2"
        hexmask.long.word 0x00 0.--10. 1. " CSI0_CPD_R_OFFSET ,CSI0 Red component offset The value is between -512 to 511."
width 15.
group.long 0x38000++0x3
    line.long 0x00 "CSI1_SENS_CONF,CSI1 Sensor Configuration Register"
        bitfld.long 0x00 0. " CSI1_VSYNC_POL ,Invert IPP_IND_SENSB_VSYNC input." "0,1"
        textline "              "
        bitfld.long 0x00 1. " CSI1_HSYNC_POL ,Invert IPP_IND_SENSB_HSYNC input." "0,1"
        textline "              "
        bitfld.long 0x00 2. " CSI1_DATA_POL ,Invert data input." "0,1"
        textline "              "
        bitfld.long 0x00 3. " CSI1_SENS_PIX_CLK_POL ,Invert Pixel clock input." "0,1"
        textline "              "
        hexmask.long.byte 0x00 4.--7. 1. " CSI1_SENS_PRTCL ,Sensor Protocol."
        textline "              "
        bitfld.long 0x00 7. " CSI1_PACK_TIGHT ,CSI1 Pack Tight When the data format is YUV or RGB and the component's width is 9-16 bits, it can be sent to the memory in 2 different ways" "0,1"
        textline "              "
        hexmask.long.byte 0x00 8.--11. 1. " CSI1_SENS_DATA_FORMAT ,Data format from the sensor."
        textline "              "
        hexmask.long.byte 0x00 11.--15. 1. " CSI1_DATA_WIDTH ,Data width."
        textline "              "
        bitfld.long 0x00 15. " CSI1_EXT_VSYNC ,External VSYNC enable." "0,1"
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " CSI1_DIV_RATIO ,DIV Ratio Clock division ratio minus 1."
        textline "              "
        hexmask.long.byte 0x00 24.--27. 1. " CSI1_DATA_DEST ,These bits enable the destination of the data coming from the CSI."
        textline "              "
        bitfld.long 0x00 27. " CSI1_JPEG8_EN ,JPEG8 enable bit" "0,1"
        textline "              "
        bitfld.long 0x00 28. " CSI1_JPEG_MODE ,JPEG Mode - this bit defines the mode of the control signals when working in JPEG mode" "0,1"
        textline "              "
        bitfld.long 0x00 29. " CSI1_FORCE_EOF ,Force End of frame This is a self clear bit allowing the user to force an End-of-frame event; This bit can be used in cases where the frame sent by the sensor was not completed." "0,1"
        textline "              "
        bitfld.long 0x00 31. " CSI0_DATA_EN_POL ,Invert IPP_IND_SENSB_DATA_EN input." "0,1"
width 19.
group.long 0x38004++0x3
    line.long 0x00 "CSI1_SENS_FRM_SIZE,CSI1 Sense Frame Size Register"
        hexmask.long.word 0x00 0.--13. 1. " CSI1_SENS_FRM_WIDTH ,Sensor frame width minus 1."
        textline "                  "
        hexmask.long.word 0x00 16.--28. 1. " CSI1_SENS_FRM_HEIGHT ,Sensor frame height minus 1."
width 18.
group.long 0x38008++0x3
    line.long 0x00 "CSI1_ACT_FRM_SIZE,CSI1 Actual Frame Size Register"
        hexmask.long.word 0x00 0.--13. 1. " CSI1_ACT_FRM_WIDTH ,Actual frame width minus 1."
        textline "                 "
        hexmask.long.word 0x00 16.--28. 1. " CSI1_ACT_FRM_HEIGHT ,Actual frame height minus 1."
width 18.
group.long 0x3800c++0x3
    line.long 0x00 "CSI1_OUT_FRM_CTRL,CSI1 Output Control Register"
        hexmask.long.word 0x00 0.--12. 1. " CSI1_VSC ,Vertical skip."
        textline "                 "
        hexmask.long.word 0x00 16.--29. 1. " CSI1_HSC ,Horizontal skip."
        textline "                 "
        bitfld.long 0x00 30. " CSI1_VERT_DWNS ,Enable vertical downsizing (decimation) by 2." "0,1"
        textline "                 "
        bitfld.long 0x00 31. " CSI1_HORZ_DWNS ,Enable horizontal downsizing (decimation) by 2." "0,1"
width 14.
group.long 0x38010++0x3
    line.long 0x00 "CSI1_TST_CTRL,CSI1 Test Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PG_R_VALUE ,Pattern generator R value."
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " PG_G_VALUE ,Pattern generator G value."
        textline "             "
        hexmask.long.byte 0x00 16.--24. 1. " PG_B_VALUE ,Pattern generator B value."
        textline "             "
        bitfld.long 0x00 24. " TEST_GEN_MODE ,Test generator mode." "0,1"
width 17.
group.long 0x38014++0x3
    line.long 0x00 "CSI1_CCIR_CODE_1,CSI1 CCIR Code Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " CSI1_END_FLD0_BLNK_1ST ,End of field 0 first blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 3.--6. 1. " CSI1_STRT_FLD0_BLNK_1ST ,Start of field 0 first blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 6.--9. 1. " CSI1_END_FLD0_BLNK_2ND ,End of field 0 second blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 9.--12. 1. " CSI1_STRT_FLD0_BLNK_2ND ,Start of field 0 second blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 16.--19. 1. " CSI1_END_FLD0_ACTV ,End of field 0 active line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 19.--22. 1. " CSI1_STRT_FLD0_ACTV ,Start of field 0 active line command (interlaces mode)."
        textline "                "
        bitfld.long 0x00 24. " CSI1_CCIR_ERR_DET_EN ,Enable error detection and correction for CCIR interlaced mode with protection bit." "0,1"
width 17.
group.long 0x38018++0x3
    line.long 0x00 "CSI1_CCIR_CODE_2,CSI1 CCIR Code Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " CSI1_END_FLD1_BLNK_1ST ,End of field 1 first blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 3.--6. 1. " CSI1_STRT_FLD1_BLNK_1ST ,Start of field 1 first blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 6.--9. 1. " CSI1_END_FLD1_BLNK_2ND ,End of field 1 second blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 9.--12. 1. " CSI1_STRT_FLD1_BLNK_2ND ,Start of field 1 second blanking line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 16.--19. 1. " CSI1_END_FLD1_ACTV ,End of field 1 active line command (interlaces mode)."
        textline "                "
        hexmask.long.byte 0x00 19.--22. 1. " CSI1_STRT_FLD1_ACTV ,Start of field 1 active line command (interlaces mode)."
width 17.
group.long 0x3801c++0x3
    line.long 0x00 "CSI1_CCIR_CODE_3,CSI1 CCIR Code Register 3"
        hexmask.long.long 0x00 0.--30. 1. " CSI1_CCIR_PRECOM ,CCIR pre command."
width 8.
group.long 0x38020++0x3
    line.long 0x00 "CSI1_DI,CSI1 Data Identifier Register"
        hexmask.long.byte 0x00 0.--8. 1. " CSI1_MIPI_DI0 ,CSI1_MIPI_DI0 This field holds the Data Identifier #0 handled by the CSI; This is the main stream."
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " CSI0_MIPI_DI1 ,CSI1_MIPI_DI1 This field holds the Data Identifier #1 handled by the CSI"
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " CSI1_MIPI_DI2 ,CSI1_MIPI_DI2 This field holds the Data Identifier #2 handled by the CSI."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " CSI1_MIPI_DI3 ,CSI1_MIPI_DI3 This field holds the Data Identifier #3 handled by the CSI."
width 10.
group.long 0x38024++0x3
    line.long 0x00 "CSI1_SKIP,CSI1 SKIP Register"
        hexmask.long.byte 0x00 0.--3. 1. " CSI1_MAX_RATIO_SKIP_SMFC ,CSI1 Maximum Ratio Skip for SMFC These bits define the number of frames in a skipping set."
        textline "         "
        hexmask.long.byte 0x00 3.--8. 1. " CSI1_SKIP_SMFC ,CSI1 SKIP SMFC These 5 bits define the skipping pattern of the frames send to the SMFC."
        textline "         "
        hexmask.long.byte 0x00 8.--10. 1. " CSI1_ID_2_SKIP ,CSI1 to SMFC Skipping ID."
        textline "         "
        hexmask.long.byte 0x00 16.--19. 1. " CSI1_MAX_RATIO_SKIP_ISP ,Reserved"
        textline "         "
        hexmask.long.byte 0x00 19.--24. 1. " CSI1_SKIP_ISP ,Reserved"
width 14.
group.long 0x38028++0x3
    line.long 0x00 "CSI1_CPD_CTRL,CSI1 Compander Control Register"
width 14.
group.long 0x3802c++0x3
    line.long 0x00 "CSI1_CPD_RC_I,CSI1 Red Component Compander Constants Register <i>"
        hexmask.long.word 0x00 0.--9. 1. " CSI1_CPD_RC_2I ,CONSTANT <2*i> parameter of Compander, Red component."
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " CSI1_CPD_RC_2I_1 ,CONSTANT <2*i+1> parameter of Compander, Red component."
width 14.
group.long 0x3804c++0x3
    line.long 0x00 "CSI1_CPD_RS_I,CSI1 Red Component Compander SLOPE Register <i>"
        hexmask.long.byte 0x00 0.--8. 1. " CSI1_CPD_RS_4I ,SLOPE<4*i> parameter of Compander, Red component."
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " CSI1_CPD_RS_4I_1 ,SLOPE<4*i+1> parameter of Compander, Red component."
        textline "             "
        hexmask.long.byte 0x00 16.--24. 1. " CSI1_CPD_RS_4I_2 ,SLOPE<4*i+2> parameter of Compander, Red component."
        textline "             "
        hexmask.long.byte 0x00 24.--32. 1. " CSI1_CPD_RS_4I_3 ,SLOPE<4*i+3> parameter of Compander, Red component."
width 15.
group.long 0x3805c++0x3
    line.long 0x00 "CSI1_CPD_GRC_I,CSI1 GR Component Compander Constants Register <i>"
        hexmask.long.word 0x00 0.--9. 1. " CSI1_CPD_GRC_2I ,CONSTANT<2*i> parameter of Compander, GR component."
        textline "              "
        hexmask.long.word 0x00 16.--25. 1. " CSI1_CPD_GRC_2I_1 ,CONST<2*i+1> parameter of Compander, GR component."
width 15.
group.long 0x3807c++0x3
    line.long 0x00 "CSI1_CPD_GRS_I,CSI1 GR Component Compander SLOPE Register <i>"
        hexmask.long.byte 0x00 0.--8. 1. " CSI1_CPD_GRS_4I ,SLOPE<4*i> parameter of Compander, GR component."
        textline "              "
        hexmask.long.byte 0x00 8.--16. 1. " CSI1_CPD_GRS_4I_1 ,SLOPE<4*i+1> parameter of Compander, GR component."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " CSI1_CPD_GRS_4I_2 ,SLOPE<4*i+2> parameter of Compander, GR component."
        textline "              "
        hexmask.long.byte 0x00 24.--32. 1. " CSI1_CPD_GRS_4I_3 ,SLOPE<4*i+3> parameter of Compander, GR component."
width 15.
group.long 0x3808c++0x3
    line.long 0x00 "CSI1_CPD_GBC_I,CSI1 GB Component Compander Constants Register <i>"
        hexmask.long.word 0x00 0.--9. 1. " CSI1_CPD_GBC_2I ,CONSTANTi parameter of Compander, GB component."
        textline "              "
        hexmask.long.word 0x00 16.--25. 1. " CSI1_CPD_GBC_2I_1 ,CONSTi+1 parameter of Compander, GB component."
width 15.
group.long 0x380ac++0x3
    line.long 0x00 "CSI1_CPD_GBS_I,CSI1 GB Component Compander SLOPE Register <i>"
        hexmask.long.byte 0x00 0.--8. 1. " CSI1_CPD_GBS_4I ,SLOPE<4*i> parameter of Compander, GB component."
        textline "              "
        hexmask.long.byte 0x00 8.--16. 1. " CSI1_CPD_GBS_4I_1 ,SLOPE<4*i+1> parameter of Compander, GB component."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " CSI1_CPD_GBS_4I_2 ,SLOPE<4*i+2> parameter of Compander, GB component."
        textline "              "
        hexmask.long.byte 0x00 24.--32. 1. " CSI1_CPD_GBS_4I_3 ,SLOPE<4*i+3> parameter of Compander, GB component."
width 14.
group.long 0x380bc++0x3
    line.long 0x00 "CSI1_CPD_BC_I,CSI1 Blue Component Compander Constants Register <i>"
        hexmask.long.word 0x00 0.--9. 1. " CSI1_CPD_BC_2I ,CONSTANT<2*i> parameter of Compander, Blue component."
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " CSI1_CPD_BC_2I_1 ,CONSTANT<2*i+1> parameter of Compander, Blue component."
width 14.
group.long 0x380dc++0x3
    line.long 0x00 "CSI1_CPD_BS_I,CSI1 Blue Component Compander SLOPE Register <i>"
        hexmask.long.byte 0x00 0.--8. 1. " CSI1_CPD_BS_4I ,SLOPE<4*i> parameter of Compander, Blue component."
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " CSI1_CPD_BS_4I_1 ,SLOPE<4*i+1> parameter of Compander, Blue component."
        textline "             "
        hexmask.long.byte 0x00 16.--24. 1. " CSI1_CPD_BS_4I_2 ,SLOPE<4*i+2> parameter of Compander, Blue component."
        textline "             "
        hexmask.long.byte 0x00 24.--32. 1. " CSI1_CPD_BS_4I_3 ,SLOPE<4*i+3> parameter of Compander, Blue component."
width 17.
group.long 0x380ec++0x3
    line.long 0x00 "CSI1_CPD_OFFSET1,CSI1 Compander Offset Register 1"
        hexmask.long.word 0x00 0.--10. 1. " CSI1_CPD_GR_OFFSET ,CSI1 Green Red component offset The value is between -512 to 511."
        textline "                "
        hexmask.long.word 0x00 10.--20. 1. " CSI1_CPD_GB_OFFSET ,CSI1 Green Blue component offset The value is between -512 to 511."
        textline "                "
        hexmask.long.word 0x00 20.--30. 1. " CSI1_CPD_B_OFFSET ,CSI1 Blue component offset The value is between -512 to 511."
width 17.
group.long 0x380f0++0x3
    line.long 0x00 "CSI1_CPD_OFFSET2,CSI1 Compander Offset Register 2"
        hexmask.long.word 0x00 0.--10. 1. " CSI1_CPD_R_OFFSET ,CSI1 Red component offset The value is between -512 to 511."
width 12.
group.long 0x40000++0x3
    line.long 0x00 "DI0_GENERAL,DI0 General Register"
        hexmask.long.byte 0x00 0.--8. 1. " DI0_POLARITY_I_1 ,DI0 output pin's polarity This bits define the polarity of each of the DI's outputs."
        textline "           "
        bitfld.long 0x00 8. " DI0_POLARITY_CS0 ,DI0 Chip Select's 0 polarity This bits define the polarity of the DI's CS0." "0,1"
        textline "           "
        bitfld.long 0x00 9. " DI0_POLARITY_CS1 ,DI0 Chip Select's 1 polarity This bits define the polarity of the DI's CS1." "0,1"
        textline "           "
        bitfld.long 0x00 10. " DI0_ERM_VSYNC_SEL ,DI0 error recovery block's VSYNC source select The error recovery block detect a case where the DI's VSYNC is asserted before the EOF." "0,1"
        textline "           "
        bitfld.long 0x00 11. " DI0_ERR_TREATMENT ,In case of synchronous flow error there are 2 ways to handle the display" "0,1"
        textline "           "
        hexmask.long.byte 0x00 12.--16. 1. " DI0_SYNC_COUNT_SEL ,For synchronous flow error: selects synchronous flow synchronization counter in DI:"
        textline "           "
        bitfld.long 0x00 17. " DI0_POLARITY_DISP_CLK ,DI0 Output Clock's polarity This bits define the polarity of the DI0's clock." "0,1"
        textline "           "
        hexmask.long.byte 0x00 18.--20. 1. " DI0_WATCHDOG_MODE ,DI0 watchdog mode In case of a display error where the DI clock is stopped (defined at di0_err_treatment)."
        textline "           "
        bitfld.long 0x00 20. " DI0_CLK_EXT ,DI0 External Clock." "0,1"
        textline "           "
        bitfld.long 0x00 21. " DI0_VSYNC_EXT ,DI0 External VSYNC." "0,1"
        textline "           "
        bitfld.long 0x00 22. " DI0_MASK_SEL ,DI0 Mask select." "0,1"
        textline "           "
        bitfld.long 0x00 23. " DI0_DISP_CLOCK_INIT ,Display clock's initial mode For synchronization error conditions the display clock can be stopped on the next VSYNC" "0,1"
        textline "           "
        hexmask.long.byte 0x00 24.--28. 1. " DI0_CLOCK_STOP_MODE ,DI clock stop mode When performing a clock change."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " DI0_DISP_Y_SEL ,DI0 Display Vertical coordinate (Y) select."
        textline "           "
        bitfld.long 0x00 31. " DI0_PIN8_PIN15_SEL ,This bit routes PIN8 over PIN15" "0,1"
width 15.
group.long 0x40004++0x3
    line.long 0x00 "DI0_BS_CLKGEN0,DI0 Base Sync Clock Gen 0 Register"
        hexmask.long.word 0x00 0.--12. 1. " DI0_DISP_CLK_PERIOD ,DI0 Display Clock Period This field defines the Display interface clock period for display write access."
        textline "              "
        hexmask.long.word 0x00 16.--25. 1. " DI0_DISP_CLK_OFFSET ,DI0 Display Clock Offset The DI has the ability to delay the display's clock This field defines the amount of IPU's clock cycles added as delay on this clock."
width 15.
group.long 0x40008++0x3
    line.long 0x00 "DI0_BS_CLKGEN1,DI0 Base Sync Clock Gen 1 Register"
        hexmask.long.word 0x00 0.--9. 1. " DI0_DISP_CLK_UP ,DI0 display clock rising edge position This parameter contains an integer part (bits 8:1) and a fractional part (bit 0)."
        textline "              "
        hexmask.long.word 0x00 16.--25. 1. " DI0_DISP_CLK_DOWN ,DI0 display clock falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
width 14.
group.long 0x4000c++0x3
    line.long 0x00 "DI0_SW_GEN0_1,DI0 Sync Wave Gen 1 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI0_OFFSET_RESOLUTION_1 ,DI0 counter #1 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI0_OFFSET_VALUE_1 ,DI0 counter #1 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI0_RUN_RESOLUTION_1 ,DI0 counter #1 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI0_RUN_VALUE_M1_1 ,DI0 counter #1 pre defined value This fields defines the counter #1 pre defines value."
width 14.
group.long 0x40010++0x3
    line.long 0x00 "DI0_SW_GEN0_2,DI0 Sync Wave Gen 2 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI0_OFFSET_RESOLUTION_2 ,DI0 counter #2 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI0_OFFSET_VALUE_2 ,DI0 counter #2 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI0_RUN_RESOLUTION_2 ,DI0 counter #2 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI0_RUN_VALUE_M1_2 ,DI0 counter #2 pre defined value This fields defines the counter #2 pre defines value."
width 14.
group.long 0x40014++0x3
    line.long 0x00 "DI0_SW_GEN0_3,DI0 Sync Wave Gen 3 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI0_OFFSET_RESOLUTION_3 ,DI0 counter #3 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI0_OFFSET_VALUE_3 ,DI0 counter #3 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI0_RUN_RESOLUTION_3 ,DI0 counter #3 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI0_RUN_VALUE_M1_3 ,DI0 counter #3 pre defined value This fields defines the counter #3 pre defines value."
width 14.
group.long 0x40018++0x3
    line.long 0x00 "DI0_SW_GEN0_4,DI0 Sync Wave Gen 4 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI0_OFFSET_RESOLUTION_4 ,DI0 counter #4 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI0_OFFSET_VALUE_4 ,DI0 counter #4 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI0_RUN_RESOLUTION_4 ,DI0 counter #4 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI0_RUN_VALUE_M1_4 ,DI0 counter #4 pre defined value This fields defines the counter #4 pre defines value."
width 14.
group.long 0x4001c++0x3
    line.long 0x00 "DI0_SW_GEN0_5,DI0 Sync Wave Gen 5 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI0_OFFSET_RESOLUTION_5 ,DI0 counter #5 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI0_OFFSET_VALUE_5 ,DI0 counter #5 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI0_RUN_RESOLUTION_5 ,DI0 counter #5 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI0_RUN_VALUE_M1_5 ,DI0 counter #5 pre defined value This fields defines the counter #5 pre defines value."
width 14.
group.long 0x40020++0x3
    line.long 0x00 "DI0_SW_GEN0_6,DI0 Sync Wave Gen 6 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI0_OFFSET_RESOLUTION_6 ,DI0 counter #6 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI0_OFFSET_VALUE_6 ,DI0 counter #6 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI0_RUN_RESOLUTION_6 ,DI0 counter #6 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI0_RUN_VALUE_M1_6 ,DI0 counter #6 pre defined value This fields defines the counter #6 pre defines value."
width 14.
group.long 0x40024++0x3
    line.long 0x00 "DI0_SW_GEN0_7,DI0 Sync Wave Gen 7 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI0_OFFSET_RESOLUTION_1 ,DI0 counter #7 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI0_OFFSET_VALUE_7 ,DI0 counter #7 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI0_RUN_RESOLUTION_7 ,DI0 counter #1 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI0_RUN_VALUE_M1_7 ,DI0 counter #7 pre defined value This fields defines the counter #7 pre defines value."
width 14.
group.long 0x40028++0x3
    line.long 0x00 "DI0_SW_GEN0_8,DI0 Sync Wave Gen 8 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI0_OFFSET_RESOLUTION_8 ,DI0 counter #8 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI0_OFFSET_VALUE_8 ,DI0 counter #8 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI0_RUN_RESOLUTION_8 ,DI0 counter #8 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI0_RUN_VALUE_M1_8 ,DI0 counter #8 pre defined value This fields defines the counter #8 pre defines value."
width 14.
group.long 0x4002c++0x3
    line.long 0x00 "DI0_SW_GEN0_9,DI0 Sync Wave Gen 9 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI0_OFFSET_RESOLUTION_9 ,DI0 counter #9 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI0_OFFSET_VALUE_9 ,DI0 counter #9 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI0_RUN_RESOLUTION_9 ,DI0 counter #9 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI0_RUN_VALUE_M1_9 ,DI0 counter #9 pre defined value This fields defines the counter #9 pre defines value."
width 14.
group.long 0x40030++0x3
    line.long 0x00 "DI0_SW_GEN1_1,DI0 Sync Wave Gen 1 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI0_CNT_UP_1 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI0_CNT_POLARITY_CLR_SEL_1 ,DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI0_CNT_POLARITY_TRIGGER_SEL_1 ,DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_CNT_DOWN_1 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI0_CNT_CLR_SEL_1 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI0_CNT_AUTO_RELOAD_1 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI0_CNT_POLARITY_GEN_EN_1 ,DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x40034++0x3
    line.long 0x00 "DI0_SW_GEN1_2,DI0 Sync Wave Gen 2 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI0_CNT_UP_2 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI0_CNT_POLARITY_CLR_SEL_2 ,DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI0_CNT_POLARITY_TRIGGER_SEL_2 ,DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_CNT_DOWN_2 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI0_CNT_CLR_SEL_2 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI0_CNT_AUTO_RELOAD_2 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI0_CNT_POLARITY_GEN_EN_2 ,DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x40038++0x3
    line.long 0x00 "DI0_SW_GEN1_3,DI0 Sync Wave Gen 3 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI0_CNT_UP_3 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI0_CNT_POLARITY_CLR_SEL_3 ,DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI0_CNT_POLARITY_TRIGGER_SEL_3 ,DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_CNT_DOWN_3 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI0_CNT_CLR_SEL_3 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI0_CNT_AUTO_RELOAD_3 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI0_CNT_POLARITY_GEN_EN_3 ,DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x4003c++0x3
    line.long 0x00 "DI0_SW_GEN1_4,DI0 Sync Wave Gen 4 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI0_CNT_UP_4 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI0_CNT_POLARITY_CLR_SEL_4 ,DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI0_CNT_POLARITY_TRIGGER_SEL_4 ,DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_CNT_DOWN_4 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI0_CNT_CLR_SEL_4 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI0_CNT_AUTO_RELOAD_4 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI0_CNT_POLARITY_GEN_EN_4 ,DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x40040++0x3
    line.long 0x00 "DI0_SW_GEN1_5,DI0 Sync Wave Gen 5 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI0_CNT_UP_5 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI0_CNT_POLARITY_CLR_SEL_5 ,DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI0_CNT_POLARITY_TRIGGER_SEL_5 ,DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_CNT_DOWN_5 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI0_CNT_CLR_SEL_5 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI0_CNT_AUTO_RELOAD_5 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI0_CNT_POLARITY_GEN_EN_5 ,DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x40044++0x3
    line.long 0x00 "DI0_SW_GEN1_6,DI0 Sync Wave Gen 6 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI0_CNT_UP_6 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI0_CNT_POLARITY_CLR_SEL_6 ,DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI0_CNT_POLARITY_TRIGGER_SEL_6 ,DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_CNT_DOWN_6 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI0_CNT_CLR_SEL_6 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI0_CNT_AUTO_RELOAD_6 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI0_CNT_POLARITY_GEN_EN_6 ,DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x40048++0x3
    line.long 0x00 "DI0_SW_GEN1_7,DI0 Sync Wave Gen 7 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI0_CNT_UP_7 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI0_CNT_POLARITY_CLR_SEL_7 ,DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI0_CNT_POLARITY_TRIGGER_SEL_7 ,DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_CNT_DOWN_7 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI0_CNT_CLR_SEL_7 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI0_CNT_AUTO_RELOAD_7 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI0_CNT_POLARITY_GEN_EN_7 ,DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x4004c++0x3
    line.long 0x00 "DI0_SW_GEN1_8,DI0 Sync Wave Gen 8 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI0_CNT_UP_8 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI0_CNT_POLARITY_CLR_SEL_8 ,DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI0_CNT_POLARITY_TRIGGER_SEL_8 ,DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_CNT_DOWN_8 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI0_CNT_CLR_SEL_8 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI0_CNT_AUTO_RELOAD_8 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI0_CNT_POLARITY_GEN_EN_8 ,DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x40050++0x3
    line.long 0x00 "DI0_SW_GEN1_9,DI0 Sync Wave Gen 9 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI0_CNT_UP_9 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        bitfld.long 0x00 15. " DI0_TAG_SEL_9 ,Counter #9 can send a synchronous tag when counter #9 reach its predefined value or when it's triggering counter reaches its pre defined value." "0,1"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_CNT_DOWN_9 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI0_CNT_CLR_SEL_9 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI0_CNT_AUTO_RELOAD_9 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--32. 1. " DI0_GENTIME_SEL_9 ,Counter #9 main waveform select This field defines the counter that counter #9's auxiliary waveform will be attached too."
width 16.
group.long 0x40054++0x3
    line.long 0x00 "DI0_SYNC_AS_GEN,DI0 Sync Assistance Gen Register"
        hexmask.long.word 0x00 0.--12. 1. " DI0_SYNC_START ,DI0 Sync start This field defines the number of low (including blanking rows) on the which the DI0 starts preparing the data for the next frame."
        textline "               "
        hexmask.long.byte 0x00 13.--16. 1. " DI0_VSYNC_SEL ,VSYNC select This field defines which of the counters functions as VSYNC signal"
        textline "               "
        bitfld.long 0x00 28. " DI0_SYNC_START_EN ,di0_sync_start_en" "0,1"
width 13.
group.long 0x40058++0x3
    line.long 0x00 "DI0_DW_GEN_I,DI0 Data Wave Gen <i> Register"
        hexmask.long.byte 0x00 0.--2. 1. " DI0_PT_0_I ,DI0 PIN_11 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_11 pin."
        textline "            "
        hexmask.long.byte 0x00 2.--4. 1. " DI0_PT_1_I ,DI0 PIN_12 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_12 pin."
        textline "            "
        hexmask.long.byte 0x00 4.--6. 1. " DI0_PT_2_I ,DI0 PIN_13 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_13 pin."
        textline "            "
        hexmask.long.byte 0x00 6.--8. 1. " DI0_PT_3_I ,DI0 PIN_14 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_14 pin."
        textline "            "
        hexmask.long.byte 0x00 8.--10. 1. " DI0_PT_4_I ,DI0 PIN_15 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_15 pin."
        textline "            "
        hexmask.long.byte 0x00 10.--12. 1. " DI0_PT_5_I ,DI0 PIN_16 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_16 pin."
        textline "            "
        hexmask.long.byte 0x00 12.--14. 1. " DI0_PT_6_I ,DI0 PIN_17 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_17 pin."
        textline "            "
        hexmask.long.byte 0x00 14.--16. 1. " DI0_CST_I ,DI0 Chip Select pointer for waveform <i> This field points to a register that defines the waveform of the CS pin."
        textline "            "
        hexmask.long.byte 0x00 16.--24. 1. " DI0_COMPONNENT_SIZE_I ,DI0 component Size This field defines the amount of IPU cycles between any 2 components"
        textline "            "
        hexmask.long.byte 0x00 24.--32. 1. " DI0_ACCESS_SIZE_I ,DI0 Access Size <i> This field defines the amount of IPU cycles between any 2 accesses (an access may be a pixel or generic data that may have more one component)"
width 14.
group.long 0x40088++0x3
    line.long 0x00 "DI0_DW_SET0_I,DI0 Data Wave Set 0 <i> Register"
        hexmask.long.word 0x00 0.--9. 1. " DI0_DATA_CNT_UP0_I ,Waveform's rising edge position."
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_DATA_CNT_DOWN0_I ,Waveform's falling edge position."
width 14.
group.long 0x400b8++0x3
    line.long 0x00 "DI0_DW_SET1_I,DI0 Data Wave Set 1 <i> Register"
        hexmask.long.word 0x00 0.--9. 1. " DI0_DATA_CNT_UP1_I ,Waveform's rising edge position."
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_DATA_CNT_DOWN1_I ,Waveform's falling edge position."
width 14.
group.long 0x400e8++0x3
    line.long 0x00 "DI0_DW_SET2_I,DI0 Data Wave Set 2 <i> Register"
        hexmask.long.word 0x00 0.--9. 1. " DI0_DATA_CNT_UP2_I ,Waveform's rising edge position."
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_DATA_CNT_DOWN2_I ,Waveform's falling edge position."
width 14.
group.long 0x40118++0x3
    line.long 0x00 "DI0_DW_SET3_I,DI0 Data Wave Set 3 <i> Register"
        hexmask.long.word 0x00 0.--9. 1. " DI0_DATA_CNT_UP3_I ,Waveform's rising edge position."
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI0_DATA_CNT_DOWN3_I ,Waveform's falling edge position."
width 14.
group.long 0x40148++0x3
    line.long 0x00 "DI0_STP_REP_I,DI0 Step Repeat <i> Registers"
        hexmask.long.word 0x00 0.--12. 1. " DI0_STEP_REPEAT_2I_MINUS_1 ,Step Repeat <i> This fields defines the amount of repetitions that will be performed by the counter <i>"
        textline "             "
        hexmask.long.word 0x00 16.--28. 1. " DI0_STEP_REPEAT_2I ,Step Repeat <i> This fields defines the amount of repetitions that will be performed by the counter <i>"
width 14.
group.long 0x40158++0x3
    line.long 0x00 "DI0_STP_REP_9,DI0 Step Repeat 9 Registers"
        hexmask.long.word 0x00 0.--12. 1. " DI0_STEP_REPEAT_9 ,Step Repeat 9 This fields defines the amount of repetitions that will be performed by the counter 9"
width 13.
group.long 0x4015c++0x3
    line.long 0x00 "DI0_SER_CONF,DI0 Serial Display Control Register"
        bitfld.long 0x00 0. " DI0_WAIT4SERIAL ,Wait for Serial When the parallel display share pins with the serial port." "0,1"
        textline "            "
        bitfld.long 0x00 1. " DI0_SERIAL_CS_POLARITY ,Serial Chip Select Polarity The output polarity of the SER_CS pin" "0,1"
        textline "            "
        bitfld.long 0x00 2. " DI0_SERIAL_RS_POLARITY ,Serial RS Polarity The output polarity of the SER_RS pin" "0,1"
        textline "            "
        bitfld.long 0x00 3. " DI0_SERIAL_DATA_POLARITY ,Serial Data Polarity The output polarity of the SER_DATA pin" "0,1"
        textline "            "
        bitfld.long 0x00 4. " DI0_SER_CLK_POLARITY ,Serial Clock Polarity The output polarity of the SER_CLK pin" "0,1"
        textline "            "
        bitfld.long 0x00 5. " DI0_LLA_SER_ACCESS ,Direct Low Level Access to Serial display" "0,1"
        textline "            "
        hexmask.long.byte 0x00 8.--16. 1. " DI0_SERIAL_LATCH ,DI0 Serial Latch This field defines how many cycles to insert between serial read accesses start to data sampling in the"
        textline "            "
        hexmask.long.byte 0x00 16.--20. 1. " DI0_SERIAL_LLA_PNTR_RS_W_0 ,RS 0 waveform pointer for write low level access This pointer defines which waveform set will be chosen when the low level write access is targeted to RS group 0."
        textline "            "
        hexmask.long.byte 0x00 20.--24. 1. " DI0_SERIAL_LLA_PNTR_RS_W_1 ,RS 1 waveform pointer for write low level access This pointer defines which waveform set will be chosen when the low level write access is targeted to RS group 1."
        textline "            "
        hexmask.long.byte 0x00 24.--28. 1. " DI0_SERIAL_LLA_PNTR_RS_R_0 ,RS 2 waveform pointer for read low level access This pointer defines which waveform set will be chosen when the read low level access is targeted to RS group 0."
        textline "            "
        hexmask.long.byte 0x00 28.--32. 1. " DI0_SERIAL_LLA_PNTR_RS_R_1 ,RS 3 waveform pointer for read low level access This pointer defines which waveform set will be chosen when the read low level access is targeted to RS group 1."
width 8.
group.long 0x40160++0x3
    line.long 0x00 "DI0_SSC,DI0 Special Signals Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " DI0_BYTE_EN_PNTR ,Byte Enable Pointer This pointer selects the pin asserted along with the byte enables signals"
        textline "       "
        bitfld.long 0x00 3. " DI0_BYTE_EN_RD_IN ,Byte Enable Read In This bit selects the source of the byte enable pins" "0,1"
        textline "       "
        bitfld.long 0x00 5. " DI0_WAIT_ON ,Wait On This field defines the DC's response to WAIT signal" "0,1"
        textline "       "
        bitfld.long 0x00 16. " DI0_CS_ERM ,DI0 GLUELOGIC error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 17. " DI0_PIN11_ERM ,DI0 PIN11 error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 18. " DI0_PIN12_ERM ,DI0 PIN12 error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 19. " DI0_PIN13_ERM ,DI0 PIN13 error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 20. " DI0_PIN14_ERM ,DI0 PIN14 error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 21. " DI0_PIN15_ERM ,DI0 PIN15 error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 22. " DI0_PIN16_ERM ,DI0 PIN16 error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 23. " DI0_PIN17_ERM ,DI0 PIN17 error recovery mode." "0,1"
width 8.
group.long 0x40164++0x3
    line.long 0x00 "DI0_POL,DI0 Polarity Register"
        hexmask.long.byte 0x00 0.--7. 1. " DI0_DRDY_POLARITY ,DI0 output dynamic pin's polarity for synchronous access This bits define the polarity of each of the DI's outputs when synchronous display access is asserted The pins' default polarity is the same as defined in the di0_drdy_polarity bits"
        textline "       "
        bitfld.long 0x00 7. " DI0_DRDY_DATA_POLARITY ,Data Polarity associated with DRDY" "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--15. 1. " DI0_CS0_POLARITY ,DI0 output pin's polarity for CS1 This bits define the polarity of each of the DI's outputs when CS1 is asserted"
        textline "       "
        bitfld.long 0x00 15. " DI0_CS0_DATA_POLARITY ,Data Polarity associated with CS0" "0,1"
        textline "       "
        hexmask.long.byte 0x00 16.--23. 1. " DI0_CS1_POLARITY ,DI0 output pin's polarity for CS1 This bits define the polarity of each of the DI's outputs when CS1 is asserted"
        textline "       "
        bitfld.long 0x00 23. " DI0_CS1_DATA_POLARITY ,Data Polarity associated with CS1" "0,1"
        textline "       "
        bitfld.long 0x00 24. " DI0_CS0_BYTE_EN_POLARITY ,Byte Enable associated with CS0 polarity This bit defines the polarity of the byte enable signals to the display" "0,1"
        textline "       "
        bitfld.long 0x00 25. " DI0_CS1_BYTE_EN_POLARITY ,Byte Enable associated with CS1 polarity This bit defines the polarity of the byte enable signals to the display" "0,1"
        textline "       "
        bitfld.long 0x00 26. " DI0_WAIT_POLARITY ,WAIT polarity This bit defines the polarity of the wait signal input coming from the displa1" "0,1"
width 8.
group.long 0x40168++0x3
    line.long 0x00 "DI0_AW0,DI0 Active Window 0 Register"
        hexmask.long.word 0x00 0.--12. 1. " DI0_AW_HSTART ,This field defines the horizontal start of the active window DI0_AW_HSTART < DI0_AW_HEND"
        textline "       "
        hexmask.long.byte 0x00 12.--16. 1. " DI0_AW_HCOUNT_SEL ,GM: This field selects the counter that counts the horizontal position of the display's active window"
        textline "       "
        hexmask.long.word 0x00 16.--28. 1. " DI0_AW_HEND ,This field defines the horizontal end of the active window"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " DI0_AW_TRIG_SEL ,This field selects the trigger for sending data during the display's active window"
width 8.
group.long 0x4016c++0x3
    line.long 0x00 "DI0_AW1,DI0 Active Window 1 Register"
        hexmask.long.word 0x00 0.--12. 1. " DI0_AW_VSTART ,This field defines the vertical start of the active window DI0_AW_VSTART < DI0_AW_VEND"
        textline "       "
        hexmask.long.byte 0x00 12.--16. 1. " DI0_AW_VCOUNT_SEL ,This field selects the counter that counts the vertical position of the display's active window"
        textline "       "
        hexmask.long.word 0x00 16.--28. 1. " DI0_AW_VEND ,This field defines the vertical end of the active window"
width 13.
group.long 0x40170++0x3
    line.long 0x00 "DI0_SCR_CONF,DI0 Screen Configuration Register"
        hexmask.long.word 0x00 0.--12. 1. " DI0_SCREEN_HEIGHT ,This field defines the number of display rows (Number_of_ROWS = DI0_SCREEN_HEIGHT+1) This field is used for VSYNC calculation and for anti-tearing"
width 9.
rgroup.long 0x40174++0x3
    line.long 0x00 "DI0_STAT,DI0 Status Register"
        bitfld.long 0x00 0. " DI0_READ_FIFO_EMPTY ,This bit indicates an empty state of the DI0 FIFO when performing a read." "0,1"
        textline "        "
        bitfld.long 0x00 1. " DI0_READ_FIFO_FULL ,This bit indicates a full state of the DI0 FIFO when performing a read." "0,1"
        textline "        "
        bitfld.long 0x00 2. " DI0_READ_CNTR_EMPTY ,This bit indicates an empty state of the DI0 FIFO." "0,1"
        textline "        "
        bitfld.long 0x00 3. " DI0_CNTR_FIFO_FULL ,This bit indicates a full state of the DI0 FIFO." "0,1"
width 12.
group.long 0x48000++0x3
    line.long 0x00 "DI1_GENERAL,DI1General Register"
        hexmask.long.byte 0x00 0.--8. 1. " DI1_POLARITY_I_1 ,DI1 output pin's polarity This bits define the polarity of each of the DI's outputs."
        textline "           "
        bitfld.long 0x00 8. " DI1_POLARITY_CS0 ,DI1 Chip Select's 0 polarity This bits define the polarity of the DI's CS0." "0,1"
        textline "           "
        bitfld.long 0x00 9. " DI1_POLARITY_CS1 ,DI1 Chip Select's 1 polarity This bits define the polarity of the DI's CS1." "0,1"
        textline "           "
        bitfld.long 0x00 10. " DI1_ERM_VSYNC_SEL ,DI1 error recovery module's VSYNC source select The error recovery block detect a case where the DI's VSYNC is asserted before the EOF." "0,1"
        textline "           "
        bitfld.long 0x00 11. " DI1_ERR_TREATMENT ,In case of synchronous flow error there are 2 ways to handle the display" "0,1"
        textline "           "
        hexmask.long.byte 0x00 12.--16. 1. " DI1_SYNC_COUNT_SEL ,For synchronous flow error: selects synchronous flow synchronization counter in DI:"
        textline "           "
        bitfld.long 0x00 17. " DI1_POLARITY_DISP_CLK ,DI1 Output Clock's polarity This bits define the polarity of the DI's clock." "0,1"
        textline "           "
        hexmask.long.byte 0x00 18.--20. 1. " DI1_WATCHDOG_MODE ,DI1 watchdog mode In case of a display error where the DI clock is stopped (defined at di0_err_treatment)."
        textline "           "
        bitfld.long 0x00 20. " DI1_CLK_EXT ,DI1 External Clock." "0,1"
        textline "           "
        bitfld.long 0x00 21. " DI1_VSYNC_EXT ,DI1 External VSYNC." "0,1"
        textline "           "
        bitfld.long 0x00 22. " DI1_MASK_SEL ,DI1 Mask select." "0,1"
        textline "           "
        bitfld.long 0x00 23. " DI1_DISP_CLOCK_INIT ,Display clock's initial mode For synchronization error conditions the display clock can be stopped on the next VSYNC" "0,1"
        textline "           "
        hexmask.long.byte 0x00 24.--28. 1. " DI1_CLOCK_STOP_MODE ,DI clock stop mode When performing a clock change."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " DI1_DISP_Y_SEL ,DI1 Display Vertical coordinate (Y) select."
        textline "           "
        bitfld.long 0x00 31. " DI1_PIN8_PIN15_SEL ,This bit routes PIN8 over PIN15" "0,1"
width 15.
group.long 0x48004++0x3
    line.long 0x00 "DI1_BS_CLKGEN0,DI1 Base Sync Clock Gen 0 Register"
        hexmask.long.word 0x00 0.--12. 1. " DI1_DISP_CLK_PERIOD ,DI1 Display Clock Period This field defines the Display interface clock period for display write access."
        textline "              "
        hexmask.long.word 0x00 16.--25. 1. " DI1_DISP_CLK_OFFSET ,DI1 Display Clock Offset The DI has the ability to delay the display's clock This field defines the amount of IPU's clock cycles added as delay on this clock."
width 15.
group.long 0x48008++0x3
    line.long 0x00 "DI1_BS_CLKGEN1,DI1 Base Sync Clock Gen 1 Register"
        hexmask.long.word 0x00 0.--9. 1. " DI1_DISP_CLK_UP ,DI1 display clock rising edge position This parameter contains an integer part (bits 8:1) and a fractional part (bit 0)."
        textline "              "
        hexmask.long.word 0x00 16.--25. 1. " DI1_DISP_CLK_DOWN ,DI1 display clock falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
width 14.
group.long 0x4800c++0x3
    line.long 0x00 "DI1_SW_GEN0_1,DI1 Sync Wave Gen 1 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI1_OFFSET_RESOLUTION_1 ,DI1 counter #1 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI1_OFFSET_VALUE_1 ,DI1 counter #1 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI1_RUN_RESOLUTION_1 ,DI1 counter #1 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI1_RUN_VALUE_M1_1 ,DI1 counter #1 pre defined value This fields defines the counter #1 pre defines value."
width 14.
group.long 0x48010++0x3
    line.long 0x00 "DI1_SW_GEN0_2,DI1 Sync Wave Gen 2 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI1_OFFSET_RESOLUTION_2 ,DI1 counter #2 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI1_OFFSET_VALUE_2 ,DI1 counter #2 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI1_RUN_RESOLUTION_2 ,DI1 counter #2 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI1_RUN_VALUE_M1_2 ,DI1 counter #2 pre defined value This fields defines the counter #2 pre defines value."
width 14.
group.long 0x48014++0x3
    line.long 0x00 "DI1_SW_GEN0_3,DI1 Sync Wave Gen 3 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI1_OFFSET_RESOLUTION_3 ,DI1 counter #3 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI1_OFFSET_VALUE_3 ,DI1 counter #3 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI1_RUN_RESOLUTION_3 ,DI1 counter #3 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI1_RUN_VALUE_M1_3 ,DI1 counter #3 pre defined value This fields defines the counter #3 pre defines value."
width 14.
group.long 0x48018++0x3
    line.long 0x00 "DI1_SW_GEN0_4,DI1 Sync Wave Gen 4 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI1_OFFSET_RESOLUTION_4 ,DI1 counter #4 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI1_OFFSET_VALUE_4 ,DI1 counter #4 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI1_RUN_RESOLUTION_4 ,DI1 counter #4 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI1_RUN_VALUE_M1_4 ,DI1 counter #4 pre defined value This fields defines the counter #4 pre defines value."
width 14.
group.long 0x4801c++0x3
    line.long 0x00 "DI1_SW_GEN0_5,DI1 Sync Wave Gen 5 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI1_OFFSET_RESOLUTION_5 ,DI1 counter #5 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI1_OFFSET_VALUE_5 ,DI1 counter #5 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI1_RUN_RESOLUTION_5 ,DI1 counter #5 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI1_RUN_VALUE_M1_5 ,DI1 counter #5 pre defined value This fields defines the counter #5 pre defines value."
width 14.
group.long 0x48020++0x3
    line.long 0x00 "DI1_SW_GEN0_6,DI1 Sync Wave Gen 6 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI1_OFFSET_RESOLUTION_6 ,DI1 counter #6 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI1_OFFSET_VALUE_6 ,DI1 counter #6 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI1_RUN_RESOLUTION_6 ,DI1 counter #6 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI1_RUN_VALUE_M1_6 ,DI1 counter #6 pre defined value This fields defines the counter #6 pre defines value."
width 14.
group.long 0x48024++0x3
    line.long 0x00 "DI1_SW_GEN0_7,DI1 Sync Wave Gen 7 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI1_OFFSET_RESOLUTION_1 ,DI1 counter #7 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI1_OFFSET_VALUE_7 ,DI1 counter #7 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI1_RUN_RESOLUTION_7 ,DI1 counter #1 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI1_RUN_VALUE_M1_7 ,DI1 counter #7 pre defined value This fields defines the counter #7 pre defines value."
width 14.
group.long 0x48028++0x3
    line.long 0x00 "DI1_SW_GEN0_8,DI1 Sync Wave Gen 8 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI1_OFFSET_RESOLUTION_8 ,DI1 counter #8 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI1_OFFSET_VALUE_8 ,DI1 counter #8 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI1_RUN_RESOLUTION_8 ,DI1 counter #8 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI1_RUN_VALUE_M1_8 ,DI1 counter #8 pre defined value This fields defines the counter #8 pre defines value."
width 14.
group.long 0x4802c++0x3
    line.long 0x00 "DI1_SW_GEN0_9,DI1Sync Wave Gen 9 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " DI1_OFFSET_RESOLUTION_9 ,DI1 counter #9 offset Resolution This field defines the trigger causing the offset counter to increment"
        textline "             "
        hexmask.long.word 0x00 3.--15. 1. " DI1_OFFSET_VALUE_9 ,DI1 counter #9 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by"
        textline "             "
        hexmask.long.byte 0x00 16.--19. 1. " DI1_RUN_RESOLUTION_9 ,DI1 counter #9 Run Resolution This field defines the trigger causing the counter to increment."
        textline "             "
        hexmask.long.word 0x00 19.--31. 1. " DI1_RUN_VALUE_M1_9 ,DI1 counter #9 pre defined value This fields defines the counter #9 pre defines value."
width 14.
group.long 0x48030++0x3
    line.long 0x00 "DI1_SW_GEN1_1,DI1 Sync Wave Gen 1 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI1_CNT_UP_1 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI1_CNT_POLARITY_CLR_SEL_1 ,DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI1_CNT_POLARITY_TRIGGER_SEL_1 ,DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_CNT_DOWN_1 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI1_CNT_CLR_SEL_1 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI1_CNT_AUTO_RELOAD_1 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI1_CNT_POLARITY_GEN_EN_1 ,DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x48034++0x3
    line.long 0x00 "DI1_SW_GEN1_2,DI1 Sync Wave Gen 2 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI1_CNT_UP_2 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI1_CNT_POLARITY_CLR_SEL_2 ,DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI1_CNT_POLARITY_TRIGGER_SEL_2 ,DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_CNT_DOWN_2 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI1_CNT_CLR_SEL_2 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI1_CNT_AUTO_RELOAD_2 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI1_CNT_POLARITY_GEN_EN_2 ,DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x48038++0x3
    line.long 0x00 "DI1_SW_GEN1_3,DI1 Sync Wave Gen 3 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI1_CNT_UP_3 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI1_CNT_POLARITY_CLR_SEL_3 ,DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI1_CNT_POLARITY_TRIGGER_SEL_3 ,DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_CNT_DOWN_3 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI1_CNT_CLR_SEL_3 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI1_CNT_AUTO_RELOAD_3 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI1_CNT_POLARITY_GEN_EN_3 ,DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x4803c++0x3
    line.long 0x00 "DI1_SW_GEN1_4,DI1 Sync Wave Gen 4 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI1_CNT_UP_4 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI1_CNT_POLARITY_CLR_SEL_4 ,DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI1_CNT_POLARITY_TRIGGER_SEL_4 ,DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_CNT_DOWN_4 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI1_CNT_CLR_SEL_4 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI1_CNT_AUTO_RELOAD_4 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI1_CNT_POLARITY_GEN_EN_4 ,DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x48040++0x3
    line.long 0x00 "DI1_SW_GEN1_5,DI1 Sync Wave Gen 5 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI1_CNT_UP_5 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI1_CNT_POLARITY_CLR_SEL_5 ,DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI1_CNT_POLARITY_TRIGGER_SEL_5 ,DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_CNT_DOWN_5 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI1_CNT_CLR_SEL_5 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI1_CNT_AUTO_RELOAD_5 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI1_CNT_POLARITY_GEN_EN_5 ,DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x48044++0x3
    line.long 0x00 "DI1_SW_GEN1_6,DI1 Sync Wave Gen 6 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI1_CNT_UP_6 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI1_CNT_POLARITY_CLR_SEL_6 ,DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI1_CNT_POLARITY_TRIGGER_SEL_6 ,DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_CNT_DOWN_6 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI1_CNT_CLR_SEL_6 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI1_CNT_AUTO_RELOAD_6 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI1_CNT_POLARITY_GEN_EN_6 ,DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x48048++0x3
    line.long 0x00 "DI1_SW_GEN1_7,DI1Sync Wave Gen 7 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI1_CNT_UP_7 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI1_CNT_POLARITY_CLR_SEL_7 ,DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI1_CNT_POLARITY_TRIGGER_SEL_7 ,DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_CNT_DOWN_7 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI1_CNT_CLR_SEL_7 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI1_CNT_AUTO_RELOAD_7 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI1_CNT_POLARITY_GEN_EN_7 ,DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x4804c++0x3
    line.long 0x00 "DI1_SW_GEN1_8,DI1 Sync Wave Gen 8 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI1_CNT_UP_8 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 9.--12. 1. " DI1_CNT_POLARITY_CLR_SEL_8 ,DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output"
        textline "             "
        hexmask.long.byte 0x00 12.--15. 1. " DI1_CNT_POLARITY_TRIGGER_SEL_8 ,DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_CNT_DOWN_8 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI1_CNT_CLR_SEL_8 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI1_CNT_AUTO_RELOAD_8 ,Counter auto reload mode 1 The counter will automatically be reloaded forever, ignoring the value of the di1_step_repeat_<i> field 0 The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times defined on the di1_step_repeat_<i> field" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--31. 1. " DI1_CNT_POLARITY_GEN_EN_8 ,DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly."
width 14.
group.long 0x48050++0x3
    line.long 0x00 "DI1_SW_GEN1_9,DI1 Sync Wave Gen 9 Register 1"
        hexmask.long.word 0x00 0.--9. 1. " DI1_CNT_UP_9 ,Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        bitfld.long 0x00 15. " DI1_TAG_SEL_9 ,Counter #9 can send a synchronous tag when counter #9 reach its predefined value or when it's triggering counter reaches its pre defined value." "0,1"
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_CNT_DOWN_9 ,Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16)."
        textline "             "
        hexmask.long.byte 0x00 25.--28. 1. " DI1_CNT_CLR_SEL_9 ,Counter Clear select This field defines the source of the signals that clears the counter."
        textline "             "
        bitfld.long 0x00 28. " DI1_CNT_AUTO_RELOAD_9 ,Counter auto reload mode" "0,1"
        textline "             "
        hexmask.long.byte 0x00 29.--32. 1. " DI1_GENTIME_SEL_9 ,Counter #9 main waveform select This field defines the counter that counter #9's auxiliary waveform will be attached too."
width 16.
group.long 0x48054++0x3
    line.long 0x00 "DI1_SYNC_AS_GEN,DI1 Sync Assistance Gen Register"
        hexmask.long.word 0x00 0.--12. 1. " DI1_SYNC_START ,DI1 Sync start This field defines the number of low (including blanking rows) on the which the DI1 starts preparing the data for the next frame."
        textline "               "
        hexmask.long.byte 0x00 13.--16. 1. " DI1_VSYNC_SEL ,VSYNC select This field defines which of the counters functions as VSYNC signal"
        textline "               "
        bitfld.long 0x00 28. " DI1_SYNC_START_EN ,di1_sync_start_en" "0,1"
width 13.
group.long 0x48058++0x3
    line.long 0x00 "DI1_DW_GEN_I,DI1 Data Wave Gen <i> Register"
        hexmask.long.byte 0x00 0.--2. 1. " DI1_PT_0_I ,DI1 PIN_11 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_11 pin."
        textline "            "
        hexmask.long.byte 0x00 2.--4. 1. " DI1_PT_1_I ,DI1 PIN_12 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_12 pin."
        textline "            "
        hexmask.long.byte 0x00 4.--6. 1. " DI1_PT_2_I ,DI1 PIN_13 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_13 pin."
        textline "            "
        hexmask.long.byte 0x00 6.--8. 1. " DI1_PT_3_I ,DI1 PIN_14 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_14 pin."
        textline "            "
        hexmask.long.byte 0x00 8.--10. 1. " DI1_PT_4_I ,DI1 PIN_15 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_15 pin."
        textline "            "
        hexmask.long.byte 0x00 10.--12. 1. " DI1_PT_5_I ,DI1 PIN_16 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_16 pin."
        textline "            "
        hexmask.long.byte 0x00 12.--14. 1. " DI1_PT_6_I ,DI1 PIN_17 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_17 pin."
        textline "            "
        hexmask.long.byte 0x00 14.--16. 1. " DI1_CST_I ,DI1 Chip Select pointer for waveform <i> This field points to a register that defines the waveform of the CS pin."
        textline "            "
        hexmask.long.byte 0x00 16.--24. 1. " DI1_COMPONNENT_SIZE_I ,DI1 component Size This field defines the amount of IPU cycles between any 2 components"
        textline "            "
        hexmask.long.byte 0x00 24.--32. 1. " DI1_ACCESS_SIZE_I ,DI1 Access Size <i> This field defines the amount of IPU cycles between any 2 accesses (an access may be a pixel or generic data that may have more one component)"
width 14.
group.long 0x48088++0x3
    line.long 0x00 "DI1_DW_SET0_I,DI1 Data Wave Set 0 <i> Register"
        hexmask.long.word 0x00 0.--9. 1. " DI1_DATA_CNT_UP0_I ,Waveform's rising edge position."
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_DATA_CNT_DOWN0_I ,Waveform's falling edge position."
width 14.
group.long 0x480b8++0x3
    line.long 0x00 "DI1_DW_SET1_I,DI1 Data Wave Set 1 <i> Register"
        hexmask.long.word 0x00 0.--9. 1. " DI1_DATA_CNT_UP1_I ,Waveform's rising edge position."
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_DATA_CNT_DOWN1_I ,Waveform's falling edge position."
width 14.
group.long 0x480e8++0x3
    line.long 0x00 "DI1_DW_SET2_I,DI1 Data Wave Set 2 <i> Register"
        hexmask.long.word 0x00 0.--9. 1. " DI1_DATA_CNT_UP2_I ,Waveform's rising edge position."
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_DATA_CNT_DOWN2_I ,Waveform's falling edge position."
width 14.
group.long 0x48118++0x3
    line.long 0x00 "DI1_DW_SET3_I,DI1 Data Wave Set 3 <i> Register"
        hexmask.long.word 0x00 0.--9. 1. " DI1_DATA_CNT_UP3_I ,Waveform's rising edge position."
        textline "             "
        hexmask.long.word 0x00 16.--25. 1. " DI1_DATA_CNT_DOWN3_I ,Waveform's falling edge position."
width 13.
group.long 0x48148++0x3
    line.long 0x00 "D1_STP_REP_I,DI1 Step Repeat <i> Registers"
        hexmask.long.word 0x00 0.--12. 1. " DI1_STEP_REPEAT_2I_MINUS_1 ,Step Repeat <i> This fields defines the amount of repetitions that will be performed by the counter <i>"
        textline "            "
        hexmask.long.word 0x00 16.--28. 1. " DI1_STEP_REPEAT_2I ,Step Repeat <i> This fields defines the amount of repetitions that will be performed by the counter <i>"
width 14.
group.long 0x48158++0x3
    line.long 0x00 "DI1_STP_REP_9,DI1Step Repeat 9 Registers"
        hexmask.long.word 0x00 0.--12. 1. " DI1_STEP_REPEAT_9 ,Step Repeat 9 This fields defines the amount of repetitions that will be performed by the counter 9."
width 13.
group.long 0x4815c++0x3
    line.long 0x00 "DI1_SER_CONF,DI1 Serial Display Control Register"
        bitfld.long 0x00 0. " DI1_WAIT4SERIAL ,Wait for Serial When the parallel display share pins with the serial port." "0,1"
        textline "            "
        bitfld.long 0x00 1. " DI1_SERIAL_CS_POLARITY ,Serial Chip Select Polarity The output polarity of the SER_CS pin" "0,1"
        textline "            "
        bitfld.long 0x00 2. " DI1_SERIAL_RS_POLARITY ,Serial RS Polarity The output polarity of the SER_RS pin" "0,1"
        textline "            "
        bitfld.long 0x00 3. " DI1_SERIAL_DATA_POLARITY ,Serial Data Polarity The output polarity of the SER_DATA pin" "0,1"
        textline "            "
        bitfld.long 0x00 4. " DI1_SER_CLK_POLARITY ,Serial Clock Polarity The output polarity of the SER_CLK pin" "0,1"
        textline "            "
        bitfld.long 0x00 5. " DI1_LLA_SER_ACCESS ,Direct Low Level Access to Serial display" "0,1"
        textline "            "
        hexmask.long.byte 0x00 8.--16. 1. " DI1_SERIAL_LATCH ,DI1 Serial Latch This field defines how many cycles to insert between serial read accesses start to data sampling in the"
        textline "            "
        hexmask.long.byte 0x00 16.--20. 1. " DI1_SERIAL_LLA_PNTR_RS_W_0 ,RS 0 waveform pointer for write low level access This pointer defines which waveform set will be chosen when the write low level access is targeted to RS group 0."
        textline "            "
        hexmask.long.byte 0x00 20.--24. 1. " DI1_SERIAL_LLA_PNTR_RS_W_1 ,RS 1 waveform pointer for write low level access This pointer defines which waveform set will be chosen when the write low level access is targeted to RS group 1."
        textline "            "
        hexmask.long.byte 0x00 24.--28. 1. " DI1_SERIAL_LLA_PNTR_RS_R_0 ,RS 2 waveform pointer for low level access This pointer defines which waveform set will be chosen when the read low level access is targeted to RS group 0."
        textline "            "
        hexmask.long.byte 0x00 28.--32. 1. " DI1_SERIAL_LLA_PNTR_RS_R_1 ,RS 3 waveform pointer for read low level access This pointer defines which waveform set will be chosen when the read low level access is targeted to RS group 1."
width 8.
group.long 0x48160++0x3
    line.long 0x00 "DI1_SSC,DI1 Special Signals Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " DI1_BYTE_EN_PNTR ,Byte Enable Pointer This pointer selects the pin asserted along with the byte enables signals"
        textline "       "
        bitfld.long 0x00 3. " DI1_BYTE_EN_RD_IN ,Byte Enable Read In This bit selects the source of the byte enable pins" "0,1"
        textline "       "
        bitfld.long 0x00 4. " DI1_BYTE_EN_POLARITY ,Byte Enable polarity This bit defines the polarity of the byte enable signals to the display." "0,1"
        textline "       "
        bitfld.long 0x00 5. " DI1_WAIT_ON ,Wait On This field defines the DC's response to WAIT signal" "0,1"
        textline "       "
        bitfld.long 0x00 16. " DI1_CS_ERM ,DI1 GLUELOGIC error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 17. " DI1_PIN11_ERM ,DI1 PIN11 error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 18. " DI1_PIN12_ERM ,DI1 PIN12 error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 19. " DI1_PIN13_ERM ,DI1 PIN13 error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 20. " DI1_PIN14_ERM ,DI1 PIN14 error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 21. " DI1_PIN15_ERM ,DI1 PIN15 error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 22. " DI1_PIN16_ERM ,DI1 PIN16 error recovery mode." "0,1"
        textline "       "
        bitfld.long 0x00 23. " DI1_PIN17_ERM ,DI1 PIN17 error recovery mode." "0,1"
width 8.
group.long 0x48164++0x3
    line.long 0x00 "DI1_POL,DI1 Polarity Register"
        hexmask.long.byte 0x00 0.--7. 1. " DI1_DRDY_POLARITY ,DI1 output dynamic pin's polarity for synchronous access This bits define the polarity of each of the DI's outputs when synchronous display access is asserted The pins' default polarity is the same as defined in the di0_drdy_polarity bits"
        textline "       "
        bitfld.long 0x00 7. " DI1_DRDY_DATA_POLARITY ,Data Polarity associated with DRDY" "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--15. 1. " DI1_CS0_POLARITY ,DI1 output pin's polarity for CS1 This bits define the polarity of each of the DI's outputs when CS1 is asserted"
        textline "       "
        bitfld.long 0x00 15. " DI1_CS0_DATA_POLARITY ,Data Polarity associated with CS0" "0,1"
        textline "       "
        hexmask.long.byte 0x00 16.--23. 1. " DI1_CS1_POLARITY ,DI1 output pin's polarity for CS1 This bits define the polarity of each of the DI's outputs when CS1 is asserted"
        textline "       "
        bitfld.long 0x00 23. " DI1_CS1_DATA_POLARITY ,Data Polarity associated with CS1" "0,1"
        textline "       "
        bitfld.long 0x00 24. " DI1_CS0_BYTE_EN_POLARITY ,Byte Enable associated with CS0 polarity This bit defines the polarity of the byte enable signals to the display" "0,1"
        textline "       "
        bitfld.long 0x00 25. " DI1_CS1_BYTE_EN_POLARITY ,Byte Enable associated with CS1 polarity This bit defines the polarity of the byte enable signals to the display" "0,1"
        textline "       "
        bitfld.long 0x00 26. " DI1_WAIT_POLARITY ,WAIT polarity This bit defines the polarity of the wait signal input coming from the displa1" "0,1"
width 8.
group.long 0x48168++0x3
    line.long 0x00 "DI1_AW0,DI1Active Window 0 Register"
        hexmask.long.word 0x00 0.--12. 1. " DI1_AW_HSTART ,This field defines the horizontal start of the active window DI1_AW_HSTART < DI1_AW_HEND"
        textline "       "
        hexmask.long.byte 0x00 12.--16. 1. " DI1_AW_HCOUNT_SEL ,This field selects the counter that counts the horizontal position of the display's active window"
        textline "       "
        hexmask.long.word 0x00 16.--28. 1. " DI1_AW_HEND ,This field defines the horizontal end of the active window"
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " DI1_AW_TRIG_SEL ,This field selects the trigger for sending data during the display's active window"
width 8.
group.long 0x4816c++0x3
    line.long 0x00 "DI1_AW1,DI1 Active Window 1 Register"
        hexmask.long.word 0x00 0.--12. 1. " DI1_AW_VSTART ,This field defines the vertical start of the active window DI1_AW_VSTART < DI1_AW_VEND"
        textline "       "
        hexmask.long.byte 0x00 12.--16. 1. " DI1_AW_VCOUNT_SEL ,This field selects the counter that counts the vertical position of the display's active window"
        textline "       "
        hexmask.long.word 0x00 16.--28. 1. " DI1_AW_VEND ,This field defines the vertical end of the active window"
width 13.
group.long 0x48170++0x3
    line.long 0x00 "DI1_SCR_CONF,DI1 Screen Configuration Register"
        hexmask.long.word 0x00 0.--12. 1. " DI1_SCREEN_HEIGHT ,This field defines the number of display rows (Number_of_ROWS = DI1_SCREEN_HEIGHT+1) This field is used for VSYNC calculation and for anti-tearing"
width 9.
rgroup.long 0x48174++0x3
    line.long 0x00 "DI1_STAT,DI1 Status Register"
        bitfld.long 0x00 0. " DI1_READ_FIFO_EMPTY ,This bit indicates an empty state of the DI1 FIFO when performing a read." "0,1"
        textline "        "
        bitfld.long 0x00 1. " DI1_READ_FIFO_FULL ,This bit indicates a full state of the DI1 FIFO when performing a read." "0,1"
        textline "        "
        bitfld.long 0x00 2. " DI1_CNTR_FIFO_EMPTY ,This bit indicates an empty state of the DI1 FIFO." "0,1"
        textline "        "
        bitfld.long 0x00 3. " DI1_CNTR_FIFO_FULL ,This bit indicates a full state of the DI1 FIFO." "0,1"
width 9.
group.long 0x50000++0x3
    line.long 0x00 "SMFC_MAP,SMFC Mapping Register"
        hexmask.long.byte 0x00 0.--3. 1. " MAP_CH0 ,DMASMFC channel 0 mapping bits."
        textline "        "
        hexmask.long.byte 0x00 3.--6. 1. " MAP_CH1 ,DMASMFC channel 1 mapping bits."
        textline "        "
        hexmask.long.byte 0x00 6.--9. 1. " MAP_CH2 ,DMASMFC channel 2 mapping bits."
        textline "        "
        hexmask.long.byte 0x00 9.--12. 1. " MAP_CH3 ,DMASMFC channel 3mapping bits."
width 9.
group.long 0x50004++0x3
    line.long 0x00 "SMFC_WMC,SMFC Watermark Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " WM0_SET ,Watermark ""set"" level of DMASMFC channel 0."
        textline "        "
        hexmask.long.byte 0x00 3.--6. 1. " WM0_CLR ,Watermark ""clear"" level of DMASMFC channel 0."
        textline "        "
        hexmask.long.byte 0x00 6.--9. 1. " WM1_SET ,Watermark ""set"" level of DMASMFC channel 1."
        textline "        "
        hexmask.long.byte 0x00 9.--12. 1. " WM1_CLR ,Watermark ""clear"" level of DMASMFC channel 1."
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " WM2_SET ,Watermark ""set"" level of DMASMFC channel 2."
        textline "        "
        hexmask.long.byte 0x00 19.--22. 1. " WM2_CLR ,Watermark ""clear"" level of DMASMFC channel 2."
        textline "        "
        hexmask.long.byte 0x00 22.--25. 1. " WM3_SET ,Watermark ""set"" level of DMASMFC channel 3"
        textline "        "
        hexmask.long.byte 0x00 25.--28. 1. " WM3_CLR ,Watermark ""clear"" level of DMASMFC channel 3."
width 8.
group.long 0x50008++0x3
    line.long 0x00 "SMFC_BS,SMFC Burst Size Register"
        hexmask.long.byte 0x00 0.--4. 1. " BURST0_SIZE ,Burst Size of SMFCDMA channel 0."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " BURST1_SIZE ,Burst Size of SMFCDMA channel 1."
        textline "       "
        hexmask.long.byte 0x00 8.--12. 1. " BURST2_SIZE ,Burst Size of SMFCDMA channel 2."
        textline "       "
        hexmask.long.byte 0x00 12.--16. 1. " BURST3_SIZE ,Burst Size of SMFCDMA channel 3."
width 16.
group.long 0x58000++0x3
    line.long 0x00 "DC_READ_CH_CONF,DC Read Channel Configuration Register"
        bitfld.long 0x00 0. " RD_CHANNEL_EN ,This bit enables the read channel." "0,1"
        textline "               "
        bitfld.long 0x00 1. " PROG_DI_ID_0 ,This bit select the DI which a read transaction can be performed through" "0,1"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " PROG_DISP_ID_0 ,The field defines which one of the 4 displays can be read."
        textline "               "
        hexmask.long.byte 0x00 4.--6. 1. " W_SIZE_0 ,Word Size The data coming from the IDMAC is 32bit wide."
        textline "               "
        bitfld.long 0x00 6. " CHAN_MASK_DEFAULT_0 ,Event mask bit for the read channel When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event" "0,1"
        textline "               "
        bitfld.long 0x00 8. " CS_ID_0 ,This bit maps an asynchronous display to a chip select" "0,1"
        textline "               "
        bitfld.long 0x00 9. " CS_ID_1 ,This bit maps an asynchronous display to a chip select" "0,1"
        textline "               "
        bitfld.long 0x00 10. " CS_ID_2 ,This bit maps an asynchronous display to a chip select" "0,1"
        textline "               "
        bitfld.long 0x00 11. " CS_ID_3 ,This bit maps an asynchronous display to a chip select" "0,1"
        textline "               "
        hexmask.long.word 0x00 16.--32. 1. " TIME_OUT_VALUE ,Time out value."
width 16.
group.long 0x58004++0x3
    line.long 0x00 "DC_READ_SH_ADDR,DC Read Channel Start Address Register"
        hexmask.long.long 0x00 0.--29. 1. " ST_ADDR_0 ,This field defines the start address within the display's memory space where the read transactions will be done from."
width 12.
group.long 0x58008++0x3
    line.long 0x00 "DC_RL0_CH_0,DC Routine Link Register 0 Channel 0"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NF_PRIORITY_CHAN_0 ,This field defines the priority of the new frame (NF) event The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NF_START_CHAN_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new Frame event (NF) resides"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NL_PRIORITY_CHAN_0 ,This field defines the priority of the new line (NL) event The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NL_START_CHAN_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new line event (NL) resides"
width 12.
group.long 0x5800c++0x3
    line.long 0x00 "DC_RL1_CH_0,DC Routine Link Register 1 Channel 0"
        hexmask.long.byte 0x00 0.--4. 1. " COD_EOF_PRIORITY_CHAN_0 ,This field defines the priority of the end-of-frame event (EOF) event The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EOF_START_CHAN_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the end-of-frame event (EOF) resides"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NFIELD_PRIORITY_CHAN_0 ,This field defines the priority of the new field event The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NFIELD_START_CHAN_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new field event resides"
width 12.
group.long 0x58010++0x3
    line.long 0x00 "DC_RL2_CH_0,DC Routine Link Register2 Channel 0"
        hexmask.long.byte 0x00 0.--4. 1. " COD_EOL_PRIORITY_CHAN_0 ,This field defines the priority of the end-of-line event (EOL) event The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EOL_START_CHAN_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the end-of-line event (EOL) resides"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_EOFIELD_PRIORITY_CHAN_0 ,This field defines the priority of the end-of-field event The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_EOFIELD_START_CHAN_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the end-of-field event resides"
width 12.
group.long 0x58014++0x3
    line.long 0x00 "DC_RL3_CH_0,DC Routine Link Registe3 Channel 0"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_ADDR_PRIORITY_CHAN_0 ,This field defines the priority of the new address event The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_ADDR_START_CHAN_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NEW_CHAN_PRIORITY_CHAN_0 ,This field defines the priority of the new channel event The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_CHAN_START_CHAN_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides"
width 12.
group.long 0x58018++0x3
    line.long 0x00 "DC_RL4_CH_0,DC Routine Link Register 4 Channel 0"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_DATA_PRIORITY_CHAN_0 ,This field defines the priority of the new data event The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_DATA_START_CHAN_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides"
width 16.
group.long 0x5801c++0x3
    line.long 0x00 "DC_WR_CH_CONF_1,DC Write Channel 1 Configuration Register"
        hexmask.long.byte 0x00 0.--2. 1. " W_SIZE_1 ,Word Size associated with channel #1 The data coming from the IDMAC is 32bit wide."
        textline "               "
        bitfld.long 0x00 2. " PROG_DI_ID_1 ,This bit select the DI which a transaction associated with channel #1 can be performed to" "0,1"
        textline "               "
        hexmask.long.byte 0x00 3.--5. 1. " PROG_DISP_ID_1 ,The field defines which one of the 4 displays is associated with channel #1."
        textline "               "
        hexmask.long.byte 0x00 5.--8. 1. " PROG_CHAN_TYP_1 ,This field define the mode of operation of channel #1"
        textline "               "
        bitfld.long 0x00 8. " CHAN_MASK_DEFAULT_1 ,Event mask bit for channel #1 When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event" "0,1"
        textline "               "
        bitfld.long 0x00 9. " FIELD_MODE_1 ,Field mode bit for channel #1 This bit defines if the channel works in field mode or frame mode; This bit is relevant if the flow is sync flow" "0,1"
        textline "               "
        hexmask.long.word 0x00 16.--27. 1. " PROG_START_TIME_1 ,This field defines the delay between display 's vertical synchronization pulse and the start time point of DC's channel 1 window."
width 16.
group.long 0x58020++0x3
    line.long 0x00 "DC_WR_CH_ADDR_1,DC Write Channel 1 Address Configuration Register"
        hexmask.long.long 0x00 0.--29. 1. " ST_ADDR_1 ,This field defines the start address within the display's memory space where the write transactions will be done to for channel #1."
width 12.
group.long 0x58024++0x3
    line.long 0x00 "DC_RL0_CH_1,DC Routine Link Register 0 Channel 1"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NF_PRIORITY_CHAN_1 ,This field defines the priority of the new frame event (associated with channel #1) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NF_START_CHAN_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new frame event resides (associated with channel #1)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NL_PRIORITY_CHAN_1 ,This field defines the priority of the new line event (associated with channel #1) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NL_START_CHAN_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new line event resides (associated with channel #1)"
width 12.
group.long 0x58028++0x3
    line.long 0x00 "DC_RL1_CH_1,DC Routine Link Register 1 Channel 1"
        hexmask.long.byte 0x00 0.--4. 1. " COD_EOF_PRIORITY_CHAN_1 ,This field defines the priority of the end of frame event (associated with channel #1) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EOF_START_CHAN_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the end of frame event resides (associated with channel #1)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NFIELD_PRIORITY_CHAN_1 ,This field defines the priority of the new field event (associated with channel #1) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NFIELD_START_CHAN_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new field event resides (associated with channel #1)"
width 12.
group.long 0x58030++0x3
    line.long 0x00 "DC_RL2_CH_1,DC Routine Link Register 2 Channel 1"
        hexmask.long.byte 0x00 0.--4. 1. " COD_EOL_PRIORITY_CHAN_1 ,This field defines the priority of the end of line event (associated with channel #1) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EOL_START_CHAN_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the end of line event resides (associated with channel #1)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_EOFIELD_PRIORITY_CHAN_1 ,This field defines the priority of the end of field event (associated with channel #1) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_EOFIELD_START_CHAN_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the end of field event resides (associated with channel #1)"
width 12.
group.long 0x58032++0x3
    line.long 0x00 "DC_RL3_CH_1,DC Routine Link Register 3 Channel 1"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_ADDR_PRIORITY_CHAN_1 ,This field defines the priority of the new address event (associated with channel #1) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_ADDR_START_CHAN_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #1)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NEW_CHAN_PRIORITY_CHAN_1 ,This field defines the priority of the new channel event (associated with channel #1) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_CHAN_START_CHAN_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #1)"
width 12.
group.long 0x58034++0x3
    line.long 0x00 "DC_RL4_CH_1,DC Routine Link Register 4 Channel 1"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_DATA_PRIORITY_CHAN_1 ,This field defines the priority of the new data event (associated with channel #1) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_DATA_START_CHAN_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #1)"
width 16.
group.long 0x58038++0x3
    line.long 0x00 "DC_WR_CH_CONF_2,DC Write Channel 2 Configuration Register"
        hexmask.long.byte 0x00 0.--2. 1. " W_SIZE_2 ,Word Size The data coming from the IDMAC is 32bit wide."
        textline "               "
        bitfld.long 0x00 2. " PROG_DI_ID_2 ,This bit select the DI which a transaction associated with channel #2 can be performed to" "0,1"
        textline "               "
        hexmask.long.byte 0x00 3.--5. 1. " PROG_DISP_ID_2 ,The field defines which one of the 4 displays is associated with channel #2."
        textline "               "
        hexmask.long.byte 0x00 5.--8. 1. " PROG_CHAN_TYP_2 ,This field define the mode of operation of channel #2"
        textline "               "
        bitfld.long 0x00 8. " CHAN_MASK_DEFAULT_2 ,Event mask bit for channel #2 When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event" "0,1"
        textline "               "
        hexmask.long.word 0x00 16.--27. 1. " PROG_START_TIME_2 ,This field defines the delay between display 's vertical synchronization pulse and the start time point of DC's channel 2 window."
width 16.
group.long 0x5803c++0x3
    line.long 0x00 "DC_WR_CH_ADDR_2,DC Write Channel 2 Address Configuration Register"
        hexmask.long.long 0x00 0.--29. 1. " ST_ADDR_2 ,This field defines the start address within the display's memory space where the write transactions will be done to for channel #2."
width 12.
group.long 0x58040++0x3
    line.long 0x00 "DC_RL0_CH_2,DC Routine Link Register 0 Channel 2"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NF_PRIORITY_CHAN_2 ,This field defines the priority of the new frame event (associated with channel #2) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NF_START_CHAN_2 ,This field is a pointer to the address within the microcode memory where the routine that handles the new frame event resides (associated with channel #2)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NL_PRIORITY_CHAN_2 ,This field defines the priority of the new line event (associated with channel #2) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NL_START_CHAN_2 ,This field is a pointer to the address within the microcode memory where the routine that handles the new line event resides (associated with channel #2)"
width 12.
group.long 0x58044++0x3
    line.long 0x00 "DC_RL1_CH_2,DC Routine Link Register 1 Channel 2"
        hexmask.long.byte 0x00 0.--4. 1. " COD_EOF_PRIORITY_CHAN_2 ,This field defines the priority of the end of frame event (associated with channel #2) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EOF_START_CHAN_2 ,This field is a pointer to the address within the microcode memory where the routine that handles the end of frame event resides (associated with channel #2)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NFIELD_PRIORITY_CHAN_2 ,This field defines the priority of the new field event (associated with channel #2) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NFIELD_START_CHAN_2 ,This field is a pointer to the address within the microcode memory where the routine that handles the new field event resides (associated with channel #2)"
width 12.
group.long 0x58048++0x3
    line.long 0x00 "DC_RL2_CH_2,DC Routine Link Register 2 Channel 2"
        hexmask.long.byte 0x00 0.--4. 1. " COD_EOL_PRIORITY_CHAN_2 ,This field defines the priority of the end of line event (associated with channel #2) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EOL_START_CHAN_2 ,This field is a pointer to the address within the microcode memory where the routine that handles the end of line event resides (associated with channel #2)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_EOFIELD_PRIORITY_CHAN_2 ,This field defines the priority of the end of field event (associated with channel #2) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_EOFIELD_START_CHAN_2 ,This field is a pointer to the address within the microcode memory where the routine that handles the end of field event resides (associated with channel #2)"
width 12.
group.long 0x5804c++0x3
    line.long 0x00 "DC_RL3_CH_2,DC Routine Link Register 3 Channel 2"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_ADDR_PRIORITY_CHAN_2 ,This field defines the priority of the end of line event (associated with channel #2) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_ADDR_START_CHAN_2 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #2)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NEW_CHAN_PRIORITY_CHAN_2 ,This field defines the priority of the end of line event (associated with channel #2) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_CHAN_START_CHAN_2 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #2)"
width 12.
group.long 0x58050++0x3
    line.long 0x00 "DC_RL4_CH_2,DC Routine Link Register 4 Channel 2"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_DATA_PRIORITY_CHAN_2 ,This field defines the priority of the end of line event (associated with channel #2) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_DATA_START_CHAN_2 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #2)"
width 17.
group.long 0x58054++0x3
    line.long 0x00 "DC_CMD_CH_CONF_3,DC Command Channel 3 Configuration Register"
        hexmask.long.byte 0x00 0.--2. 1. " W_SIZE_3 ,Word Size associated with channel #3 The data coming from the IDMAC is 32bit wide."
        textline "                "
        hexmask.long.byte 0x00 8.--16. 1. " COD_CMND_START_CHAN_RS0_3 ,This field is a pointer to the address within the microcode memory where the routine that handles the command start event resides (associated with channel #3); This field is relevant when RS is equal to 0"
        textline "                "
        hexmask.long.byte 0x00 24.--32. 1. " COD_CMND_START_CHAN_RS1_3 ,This field is a pointer to the address within the microcode memory where the routine that handles the command start event resides (associated with channel #3); This field is relevant when RS is equal to 1"
width 17.
group.long 0x58058++0x3
    line.long 0x00 "DC_CMD_CH_CONF_4,DC Command Channel 4 Configuration Register"
        hexmask.long.byte 0x00 0.--2. 1. " W_SIZE_4 ,Word Size associated with channel #4 The data coming from the IDMAC is 32bit wide."
        textline "                "
        hexmask.long.byte 0x00 8.--16. 1. " COD_CMND_START_CHAN_RS0_4 ,This field is a pointer to the address within the microcode memory where the routine that handles the command start event resides (associated with channel #4); This field is relevant when RS is equal to 0"
        textline "                "
        hexmask.long.byte 0x00 24.--32. 1. " COD_CMND_START_CHAN_RS1_4 ,This field is a pointer to the address within the microcode memory where the routine that handles the command start event resides (associated with channel #4); This field is relevant when RS is equal to 1"
width 16.
group.long 0x5805c++0x3
    line.long 0x00 "DC_WR_CH_CONF_5,DC Write Channel 5Configuration Register"
        hexmask.long.byte 0x00 0.--2. 1. " W_SIZE_5 ,Word Size associated with channel #5 The data coming from the IDMAC is 32bit wide."
        textline "               "
        bitfld.long 0x00 2. " PROG_DI_ID_5 ,This bit select the DI which a transaction associated with channel #5 can be performed to." "0,1"
        textline "               "
        hexmask.long.byte 0x00 3.--5. 1. " PROG_DISP_ID_5 ,The field defines which one of the 4 displays is associated with channel #5."
        textline "               "
        hexmask.long.byte 0x00 5.--8. 1. " PROG_CHAN_TYP_5 ,This field define the mode of operation of channel #5"
        textline "               "
        bitfld.long 0x00 8. " CHAN_MASK_DEFAULT_5 ,Event mask bit for channel #5 When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event" "0,1"
        textline "               "
        bitfld.long 0x00 9. " FIELD_MODE_5 ,Field mode bit for channel #5 This bit defines if the channel works in field mode or frame mode; This bit is relevant if the flow is sync flow" "0,1"
        textline "               "
        hexmask.long.word 0x00 16.--27. 1. " PROG_START_TIME_5 ,This field defines the delay between display 's vertical synchronization pulse and the start time point of DC's channel 5 window."
width 16.
group.long 0x58060++0x3
    line.long 0x00 "DC_WR_CH_ADDR_5,DC Write Channel 5Address Configuration Register"
        hexmask.long.long 0x00 0.--29. 1. " ST_ADDR_5 ,This field defines the start address within the display's memory space where the write transactions will be done to for channel #5."
width 12.
group.long 0x58064++0x3
    line.long 0x00 "DC_RL0_CH_5,DC Routine Link Register 0 Channel 5"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NF_PRIORITY_CHAN_5 ,This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NF_START_CHAN_5 ,This field is a pointer to the address within the microcode memory where the routine that handles the new frame event resides (associated with channel #5)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NL_PRIORITY_CHAN_5 ,This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NL_START_CHAN_5 ,This field is a pointer to the address within the microcode memory where the routine that handles the new line event resides (associated with channel #5)"
width 12.
group.long 0x58068++0x3
    line.long 0x00 "DC_RL1_CH_5,DC Routine Link Register 1 Channel 5"
        hexmask.long.byte 0x00 0.--4. 1. " COD_EOF_PRIORITY_CHAN_5 ,This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EOF_START_CHAN_5 ,This field is a pointer to the address within the microcode memory where the routine that handles the end of frame event resides (associated with channel #5)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NFIELD_PRIORITY_CHAN_5 ,This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NFIELD_START_CHAN_5 ,This field is a pointer to the address within the microcode memory where the routine that handles the new field event resides (associated with channel #5)"
width 12.
group.long 0x5806c++0x3
    line.long 0x00 "DC_RL2_CH_5,DC Routine Link Register 2 Channel 5"
        hexmask.long.byte 0x00 0.--4. 1. " COD_EOL_PRIORITY_CHAN_5 ,This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EOL_START_CHAN_5 ,This field is a pointer to the address within the microcode memory where the routine that handles the end of line event resides (associated with channel #5)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_EOFIELD_PRIORITY_CHAN_5 ,This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_EOFIELD_START_CHAN_5 ,This field is a pointer to the address within the microcode memory where the routine that handles the end of field event resides (associated with channel #5)"
width 12.
group.long 0x58070++0x3
    line.long 0x00 "DC_RL3_CH_5,DC Routine Link Register3 Channel 5"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_ADDR_PRIORITY_CHAN_5 ,This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_ADDR_START_CHAN_5 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #5)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NEW_CHAN_PRIORITY_CHAN_5 ,This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_CHAN_START_CHAN_5 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #5)"
width 12.
group.long 0x58074++0x3
    line.long 0x00 "DC_RL4_CH_5,DC Routine Link Register 4 Channel 5"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_DATA_PRIORITY_CHAN_5 ,This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_DATA_START_CHAN_5 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #5)"
width 16.
group.long 0x58078++0x3
    line.long 0x00 "DC_WR_CH_CONF_6,DC Write Channel 6 Configuration Register"
        hexmask.long.byte 0x00 0.--2. 1. " W_SIZE_6 ,Word Size associated with channel #6 The data coming from the IDMAC is 32bit wide."
        textline "               "
        bitfld.long 0x00 2. " PROG_DI_ID_6 ,This bit select the DI which a transaction associated with channel #6 can be performed to" "0,1"
        textline "               "
        hexmask.long.byte 0x00 3.--5. 1. " PROG_DISP_ID_6 ,The field defines which one of the 4 displays is associated with channel #6."
        textline "               "
        hexmask.long.byte 0x00 5.--8. 1. " PROG_CHAN_TYP_6 ,This field define the mode of operation of channel #6"
        textline "               "
        bitfld.long 0x00 8. " CHAN_MASK_DEFAULT_6 ,Event mask bit for channel #6 When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event" "0,1"
        textline "               "
        hexmask.long.word 0x00 16.--27. 1. " PROG_START_TIME_6 ,This field defines the delay between display 's vertical synchronization pulse and the start time point of DC's channel 6 window."
width 16.
group.long 0x5807c++0x3
    line.long 0x00 "DC_WR_CH_ADDR_6,DC Write Channel 6 Address Configuration Register"
        hexmask.long.long 0x00 0.--29. 1. " ST_ADDR_6 ,This field defines the start address within the display's memory space where the write transactions will be done to for channel #6."
width 12.
group.long 0x58080++0x3
    line.long 0x00 "DC_RL0_CH_6,DC Routine Link Register 0Channel 6"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NF_PRIORITY_CHAN_6 ,This field defines the priority of the new frame event (associated with channel #6) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NF_START_CHAN_6 ,This field is a pointer to the address within the microcode memory where the routine that handles the new frame event resides (associated with channel #6)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NL_PRIORITY_CHAN_6 ,This field defines the priority of the new line event (associated with channel #6) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NL_START_CHAN_6 ,This field is a pointer to the address within the microcode memory where the routine that handles the new line event resides (associated with channel #6)"
width 12.
group.long 0x58084++0x3
    line.long 0x00 "DC_RL1_CH_6,DC Routine Link Register 1 Channel 6"
        hexmask.long.byte 0x00 0.--4. 1. " COD_EOF_PRIORITY_CHAN_6 ,This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EOF_START_CHAN_6 ,This field is a pointer to the address within the microcode memory where the routine that handles the end of frame event resides (associated with channel #6)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NFIELD_PRIORITY_CHAN_6 ,This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NFIELD_START_CHAN_6 ,This field is a pointer to the address within the microcode memory where the routine that handles the new field event resides (associated with channel #6)"
width 12.
group.long 0x58088++0x3
    line.long 0x00 "DC_RL2_CH_6,DC Routine Link Register 2 Channel 6"
        hexmask.long.byte 0x00 0.--4. 1. " COD_EOL_PRIORITY_CHAN_6 ,This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EOL_START_CHAN_6 ,This field is a pointer to the address within the microcode memory where the routine that handles the end of line event resides (associated with channel #6)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_EOFIELD_PRIORITY_CHAN_6 ,This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_EOFIELD_START_CHAN_6 ,This field is a pointer to the address within the microcode memory where the routine that handles the end of field event resides (associated with channel #6)"
width 12.
group.long 0x5808c++0x3
    line.long 0x00 "DC_RL3_CH_6,DC Routine Link Register 3 Channel 6"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_ADDR_PRIORITY_CHAN_6 ,This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_ADDR_START_CHAN_6 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #6)"
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " COD_NEW_CHAN_PRIORITY_CHAN_6 ,This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_CHAN_START_CHAN_6 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #6)"
width 12.
group.long 0x58090++0x3
    line.long 0x00 "DC_RL4_CH_6,DC Routine Link Register 4 Channel 6"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_DATA_PRIORITY_CHAN_6 ,This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_DATA_START_CHAN_6 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #6)"
width 17.
group.long 0x58094++0x3
    line.long 0x00 "DC_WR_CH_CONF1_8,DC Write Channel 8 Configuration 1Register"
        hexmask.long.byte 0x00 0.--2. 1. " W_SIZE_8 ,Word Size associated with channel #8 The data coming from the IDMAC is 32bit wide."
        textline "                "
        bitfld.long 0x00 2. " CHAN_MASK_DEFAULT_8 ,Event mask bit for channel #8 When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event" "0,1"
        textline "                "
        hexmask.long.byte 0x00 3.--5. 1. " MCU_DISP_ID_8 ,The field defines which one of the 4 displays is associated with channel #8."
width 17.
group.long 0x58098++0x3
    line.long 0x00 "DC_WR_CH_CONF2_8,DC Write Channel 8 Configuration 2 Register"
        hexmask.long.long 0x00 0.--29. 1. " NEW_ADDR_SPACE_SA_8 ,Channel #8 is used for ARM platform direct access to the display."
width 12.
group.long 0x5809c++0x3
    line.long 0x00 "DC_RL1_CH_8,DC Routine Link Register 1 Channel 8"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_ADDR_PRIORITY_CHAN_8 ,This field defines the priority of the new address event (associated with channel #8, both regions) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_ADDR_START_CHAN_W_8_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #8, first region)"
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_ADDR_START_CHAN_W_8_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #8, second region)"
width 12.
group.long 0x580a0++0x3
    line.long 0x00 "DC_RL2_CH_8,DC Routine Link Register 2 Channel 8"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_CHAN_PRIORITY_CHAN_8 ,This field defines the priority of the new address event (associated with channel #8, both regions) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_CHAN_START_CHAN_W_8_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #8, first region)"
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_CHAN_START_CHAN_W_8_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #8, second region)"
width 12.
group.long 0x580a4++0x3
    line.long 0x00 "DC_RL3_CH_8,DC Routine Link Register 3 Channel 8"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_DATA_PRIORITY_CHAN_8 ,This field defines the priority of the new address event (associated with channel #8, both regions) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_DATA_START_CHAN_W_8_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #8, first region)"
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_DATA_START_CHAN_W_8_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #8,second region)"
width 12.
group.long 0x580a8++0x3
    line.long 0x00 "DC_RL4_CH_8,DC Routine Link Register 4 Channel 8"
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_ADDR_START_CHAN_R_8_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #8, first region)"
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_ADDR_START_CHAN_R_8_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #8, second region)"
width 12.
group.long 0x580ac++0x3
    line.long 0x00 "DC_RL5_CH_8,DC Routine Link Register 5 Channel 8"
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_CHAN_START_CHAN_R_8_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #8, first region)"
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_CHAN_START_CHAN_R_8_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #8, second region)"
width 12.
group.long 0x580b0++0x3
    line.long 0x00 "DC_RL6_CH_8,DC Routine Link Register 6 Channel 8"
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_DATA_START_CHAN_R_8_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #8, first region)"
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_DATA_START_CHAN_R_8_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #8, second region)"
width 17.
group.long 0x580b4++0x3
    line.long 0x00 "DC_WR_CH_CONF1_9,DC Write Channel 9 Configuration 1Register"
        hexmask.long.byte 0x00 0.--2. 1. " W_SIZE_9 ,Word Size associated with channel #9 The data coming from the IDMAC is 32bit wide."
        textline "                "
        bitfld.long 0x00 2. " CHAN_MASK_DEFAULT_9 ,Event mask bit for channel #9 When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event" "0,1"
        textline "                "
        hexmask.long.byte 0x00 3.--5. 1. " MCU_DISP_ID_9 ,The field defines which one of the 4 displays is associated with channel #9."
width 17.
group.long 0x580b8++0x3
    line.long 0x00 "DC_WR_CH_CONF2_9,DC Write Channel 9Configuration 2Register"
        hexmask.long.long 0x00 0.--29. 1. " NEW_ADDR_SPACE_SA_9 ,Channel #8 is used for ARM platform direct access to the display."
width 12.
group.long 0x580bc++0x3
    line.long 0x00 "DC_RL1_CH_9,DC Routine Link Register 1 Channel 9"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_ADDR_PRIORITY_CHAN_9 ,This field defines the priority of the new address event (associated with channel #9, both regions) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_ADDR_START_CHAN_W_9_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #9, first region)"
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_ADDR_START_CHAN_W_9_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #9, second region)"
width 12.
group.long 0x580c0++0x3
    line.long 0x00 "DC_RL2_CH_9,DC Routine Link Register 2 Channel 9"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_CHAN_PRIORITY_CHAN_9 ,This field defines the priority of the new address event (associated with channel #9, both regions) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_CHAN_START_CHAN_W_9_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #9, first region)"
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_CHAN_START_CHAN_W_9_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #9, second region)"
width 12.
group.long 0x580c4++0x3
    line.long 0x00 "DC_RL3_CH_9,DC Routine Link Register 3Channel 9"
        hexmask.long.byte 0x00 0.--4. 1. " COD_NEW_DATA_PRIORITY_CHAN_9 ,This field defines the priority of the new address event (associated with channel #9, both regions) The priority between the events should be set to a unique value."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_DATA_START_CHAN_W_9_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #9, first region)"
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_DATA_START_CHAN_W_9_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #9, second region)"
width 12.
group.long 0x580c8++0x3
    line.long 0x00 "DC_RL4_CH_9,DC Routine Link Register 4 Channel 9"
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_ADDR_START_CHAN_R_9_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #9, first region)"
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_ADDR_START_CHAN_R_9_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #9, second region)"
width 12.
group.long 0x580cc++0x3
    line.long 0x00 "DC_RL5_CH_9,DC Routine Link Register 5 Channel 9"
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_CHAN_START_CHAN_R_9_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #9, first region)"
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_CHAN_START_CHAN_R_9_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #9, second region)"
width 12.
group.long 0x580d0++0x3
    line.long 0x00 "DC_RL6_CH_9,DC Routine Link Register 6 Channel 9"
        hexmask.long.byte 0x00 8.--16. 1. " COD_NEW_DATA_START_CHAN_R_9_0 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #9, first region)"
        textline "           "
        hexmask.long.byte 0x00 24.--32. 1. " COD_NEW_DATA_START_CHAN_R_9_1 ,This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #9, second region)"
width 7.
group.long 0x580d4++0x3
    line.long 0x00 "DC_GEN,DC General Register"
        hexmask.long.byte 0x00 1.--3. 1. " SYNC_1_6 ,This field"
        textline "      "
        bitfld.long 0x00 4. " MASK_EN ,Enable of the mask channel" "0,1"
        textline "      "
        bitfld.long 0x00 5. " MASK4CHAN_5 ,Sync flow can be associated with a mask channel." "0,1"
        textline "      "
        bitfld.long 0x00 6. " SYNC_PRIORITY_5 ,When 2 sync flows are running, this bit sets the priority of channel #5." "0,1"
        textline "      "
        bitfld.long 0x00 7. " SYNC_PRIORITY_1 ,When 2 sync flows are running, this bit sets the priority of channel #1." "0,1"
        textline "      "
        bitfld.long 0x00 8. " DC_CH5_TYPE ,Channel 5 is used for synchronous flow." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " DC_BKDIV ,Blinking Rate This field defines the blinking rate."
        textline "      "
        bitfld.long 0x00 24. " DC_BK_EN ,Cursor blinking enable" "0,1"
width 16.
group.long 0x580d8++0x3
    line.long 0x00 "DC_DISP_CONF1_0,DC Display Configuration 1 Register 0"
        hexmask.long.byte 0x00 0.--2. 1. " DISP_TYP_0 ,This field defines the type of the display"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " ADDR_INCREMENT_0 ,This field is the increment step for auto increment mode"
        textline "               "
        hexmask.long.byte 0x00 4.--6. 1. " ADDR_BE_L_INC_0 ,This bits define the increment mode when the latest access was done with some of the byte enable signals are low, in that case different increment should be done instead of the normal auto increment of the address IF MCU_ACC_LB_MASK_0 is 0 then only 00 and 10 values are allowed."
        textline "               "
        bitfld.long 0x00 6. " MCU_ACC_LB_MASK_0 ,The DC compares between the current access to the a calculated address." "0,1"
        textline "               "
        bitfld.long 0x00 7. " DISP_RD_VALUE_PTR_0 ,When the display works in wait for status mode." "0,1"
width 16.
group.long 0x580dc++0x3
    line.long 0x00 "DC_DISP_CONF1_1,DC Display Configuration 1 Register 1"
        hexmask.long.byte 0x00 0.--2. 1. " DISP_TYP_1 ,This field defines the type of the display"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " ADDR_INCREMENT_1 ,This field is the increment step for auto increment mode"
        textline "               "
        hexmask.long.byte 0x00 4.--6. 1. " ADDR_BE_L_INC_1 ,This bits define the increment mode when the latest access was done with some of the byte enable signals are low, in that case different increment should be done instead of the normal auto increment of the address IF MCU_ACC_LB_MASK_1 is 0 then only 00 and 10 values are allowed."
        textline "               "
        bitfld.long 0x00 6. " MCU_ACC_LB_MASK_1 ,The DC compares between the current access to the a calculated address." "0,1"
        textline "               "
        bitfld.long 0x00 7. " DISP_RD_VALUE_PTR_1 ,When the display works in wait for status mode." "0,1"
width 16.
group.long 0x580e0++0x3
    line.long 0x00 "DC_DISP_CONF1_2,DC Display Configuration 1 Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " DISP_TYP_2 ,This field defines the type of the display"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " ADDR_INCREMENT_2 ,This field is the increment step for auto increment mode"
        textline "               "
        hexmask.long.byte 0x00 4.--6. 1. " ADDR_BE_L_INC_2 ,This bits define the increment mode when the latest access was done with some of the byte enable signals are low, in that case different increment should be done instead of the normal auto increment of the address IF MCU_ACC_LB_MASK_2 is 0 then only 00 and 10 values are allowed."
        textline "               "
        bitfld.long 0x00 6. " MCU_ACC_LB_MASK_2 ,The DC compares between the current access to the a calculated address." "0,1"
        textline "               "
        bitfld.long 0x00 7. " DISP_RD_VALUE_PTR_2 ,When the display works in wait for status mode." "0,1"
width 16.
group.long 0x580e4++0x3
    line.long 0x00 "DC_DISP_CONF1_3,DC Display Configuration 1 Register 3"
        hexmask.long.byte 0x00 0.--2. 1. " DISP_TYP_3 ,This field defines the type of the display"
        textline "               "
        hexmask.long.byte 0x00 2.--4. 1. " ADDR_INCREMENT_3 ,This field is the increment step for auto increment mode"
        textline "               "
        hexmask.long.byte 0x00 4.--6. 1. " ADDR_BE_L_INC_3 ,This bits define the increment mode when the latest access was done with some of the byte enable signals are low, in that case different increment should be done instead of the normal auto increment of the address IF MCU_ACC_LB_MASK_3 is 0 then only 00 and 10 values are allowed."
        textline "               "
        bitfld.long 0x00 6. " MCU_ACC_LB_MASK_3 ,The DC compares between the current access to the a calculated address." "0,1"
        textline "               "
        bitfld.long 0x00 7. " DISP_RD_VALUE_PTR_3 ,When the display works in wait for status mode." "0,1"
width 16.
group.long 0x580e8++0x3
    line.long 0x00 "DC_DISP_CONF2_0,DC Display Configuration 2 Register 0"
        hexmask.long.long 0x00 0.--29. 1. " SL_0 ,Stride line of display 0"
width 16.
group.long 0x580ec++0x3
    line.long 0x00 "DC_DISP_CONF2_1,DC Display Configuration 2 Register 1"
        hexmask.long.long 0x00 0.--29. 1. " SL_1 ,Stride line of display 1"
width 16.
group.long 0x580f0++0x3
    line.long 0x00 "DC_DISP_CONF2_2,DC Display Configuration 2 Register 2"
        hexmask.long.long 0x00 0.--29. 1. " SL_2 ,Stride line of display 2"
width 16.
group.long 0x580f4++0x3
    line.long 0x00 "DC_DISP_CONF2_3,DC Display Configuration 2 Register 3"
        hexmask.long.long 0x00 0.--29. 1. " SL_3 ,Stride line of display 3"
width 14.
group.long 0x580f8++0x3
    line.long 0x00 "DC_DI0_CONF_1,DC DI0Configuration Register 1"
        hexmask.long.long 0x00 0.--32. 1. " DI_READ_DATA_MASK_0 ,This field defines the mask value of the data read from the display."
width 14.
group.long 0x580fc++0x3
    line.long 0x00 "DC_DI0_CONF_2,DC DI0Configuration Register 2"
        hexmask.long.long 0x00 0.--32. 1. " DI_READ_DATA_ACK_VALUE_0 ,This is the expected data to be read from the display."
width 14.
group.long 0x58100++0x3
    line.long 0x00 "DC_DI1_CONF_1,DC DI1Configuration Register 1"
        hexmask.long.long 0x00 0.--32. 1. " DI_READ_DATA_MASK_1 ,This field defines the mask value of the data read from the display."
width 14.
group.long 0x58104++0x3
    line.long 0x00 "DC_DI1_CONF_2,DC DI1Configuration Register 2"
        hexmask.long.long 0x00 0.--32. 1. " DI_READ_DATA_ACK_VALUE_1 ,This is the expected data to be read from the display."
width 14.
group.long 0x58108++0x3
    line.long 0x00 "DC_MAP_CONF_0,DC Mapping Configuration Register 0"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_0 ,Mapping pointer #0 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_0 ,Mapping pointer #0 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_0 ,Mapping pointer #0 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_1 ,Mapping pointer #1 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_1 ,Mapping pointer #1 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_1 ,Mapping pointer #1 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 14.
group.long 0x5810c++0x3
    line.long 0x00 "DC_MAP_CONF_1,DC Mapping Configuration Register 1"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_2 ,Mapping pointer #1 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_2 ,Mapping pointer #1 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_2 ,Mapping pointer #1 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_3 ,Mapping pointer #3 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_3 ,Mapping pointer #3 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_3 ,Mapping pointer #3 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 14.
group.long 0x58110++0x3
    line.long 0x00 "DC_MAP_CONF_2,DC Mapping Configuration Register 2"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_4 ,Mapping pointer #4 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_4 ,Mapping pointer #4 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_4 ,Mapping pointer #4 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_5 ,Mapping pointer #5 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_5 ,Mapping pointer #5 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_5 ,Mapping pointer #5 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 14.
group.long 0x58114++0x3
    line.long 0x00 "DC_MAP_CONF_3,DC Mapping Configuration Register 3"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_6 ,Mapping pointer #6 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_6 ,Mapping pointer #6 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_6 ,Mapping pointer #6 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_7 ,Mapping pointer #7 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_7 ,Mapping pointer #7 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_7 ,Mapping pointer #7 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 14.
group.long 0x58118++0x3
    line.long 0x00 "DC_MAP_CONF_4,DC Mapping Configuration Register 4"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_8 ,Mapping pointer #8 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_8 ,Mapping pointer #8 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_8 ,Mapping pointer #8 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_9 ,Mapping pointer #9 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_1 ,Mapping pointer #9 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_9 ,Mapping pointer #9 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 14.
group.long 0x5811c++0x3
    line.long 0x00 "DC_MAP_CONF_5,DC Mapping Configuration Register 5"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_10 ,Mapping pointer #10 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_10 ,Mapping pointer #10 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_10 ,Mapping pointer #10 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_11 ,Mapping pointer #11 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_11 ,Mapping pointer #11 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_11 ,Mapping pointer #11 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 14.
group.long 0x58120++0x3
    line.long 0x00 "DC_MAP_CONF_6,DC Mapping Configuration Register 6"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_12 ,Mapping pointer #12 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_12 ,Mapping pointer #12 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_12 ,Mapping pointer #12 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_13 ,Mapping pointer #13 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_13 ,Mapping pointer #13 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_13 ,Mapping pointer #13 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 14.
group.long 0x58124++0x3
    line.long 0x00 "DC_MAP_CONF_7,DC Mapping Configuration Register 7"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_14 ,Mapping pointer #14 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_14 ,Mapping pointer #14 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_14 ,Mapping pointer #14 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_15 ,Mapping pointer #15 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_15 ,Mapping pointer #15 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_15 ,Mapping pointer #15 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 14.
group.long 0x58128++0x3
    line.long 0x00 "DC_MAP_CONF_8,DC Mapping Configuration Register 8"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_16 ,Mapping pointer #16 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_16 ,Mapping pointer #16 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_16 ,Mapping pointer #16 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_17 ,Mapping pointer #17 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_17 ,Mapping pointer #17 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_17 ,Mapping pointer #17 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 14.
group.long 0x5812c++0x3
    line.long 0x00 "DC_MAP_CONF_9,DC Mapping Configuration Register 9"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_18 ,Mapping pointer #18 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_18 ,Mapping pointer #18 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_18 ,Mapping pointer #18 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_19 ,Mapping pointer #19 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "             "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_19 ,Mapping pointer #19 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "             "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_19 ,Mapping pointer #19 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 15.
group.long 0x58130++0x3
    line.long 0x00 "DC_MAP_CONF_10,DC Mapping Configuration Register 10"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_20 ,Mapping pointer #20 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "              "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_20 ,Mapping pointer #20 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "              "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_20 ,Mapping pointer #20 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "              "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_21 ,Mapping pointer #21 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "              "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_21 ,Mapping pointer #21 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "              "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_21 ,Mapping pointer #21 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 15.
group.long 0x58134++0x3
    line.long 0x00 "DC_MAP_CONF_11,DC Mapping Configuration Register 11"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_22 ,Mapping pointer #22 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "              "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_22 ,Mapping pointer #22 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "              "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_22 ,Mapping pointer #22 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "              "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_23 ,Mapping pointer #23 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "              "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_23 ,Mapping pointer #23 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "              "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_23 ,Mapping pointer #23 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 15.
group.long 0x58138++0x3
    line.long 0x00 "DC_MAP_CONF_12,DC Mapping Configuration Register 12"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_24 ,Mapping pointer #24 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "              "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_24 ,Mapping pointer #24 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "              "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_24 ,Mapping pointer #24 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "              "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_25 ,Mapping pointer #25 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "              "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_25 ,Mapping pointer #25 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "              "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_25 ,Mapping pointer #25 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 15.
group.long 0x5813c++0x3
    line.long 0x00 "DC_MAP_CONF_13,DC Mapping Configuration Register 13"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE0_26 ,Mapping pointer #26 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "              "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_26 ,Mapping pointer #26 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "              "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_26 ,Mapping pointer #26 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "              "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_27 ,Mapping pointer #27 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "              "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_27 ,Mapping pointer #27 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "              "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_27 ,Mapping pointer #27 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 15.
group.long 0x58140++0x3
    line.long 0x00 "DC_MAP_CONF_14,DC Mapping Configuration Register 14"
        hexmask.long.byte 0x00 0.--5. 1. " MAPPING_PNTR_BYTE2_28 ,Mapping pointer #28 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "              "
        hexmask.long.byte 0x00 5.--10. 1. " MAPPING_PNTR_BYTE1_28 ,Mapping pointer #28 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "              "
        hexmask.long.byte 0x00 10.--15. 1. " MAPPING_PNTR_BYTE2_28F ,Mapping pointer #28 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
        textline "              "
        hexmask.long.byte 0x00 16.--21. 1. " MAPPING_PNTR_BYTE0_29 ,Mapping pointer #29 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0"
        textline "              "
        hexmask.long.byte 0x00 21.--26. 1. " MAPPING_PNTR_BYTE1_29 ,Mapping pointer #29 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1"
        textline "              "
        hexmask.long.byte 0x00 26.--31. 1. " MAPPING_PNTR_BYTE2_29 ,Mapping pointer #29 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2"
width 15.
group.long 0x58144++0x3
    line.long 0x00 "DC_MAP_CONF_15,DC Mapping Configuration Register 15"
        hexmask.long.byte 0x00 0.--8. 1. " MD_MASK_0 ,Mapping unit's mask value #0 This field defines the mask value #0 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 8.--13. 1. " MD_OFFSET_0 ,Mapping unit's offset parameter #0 This field defines the offset parameter #0 within the 24bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " MD_MASK_1 ,Mapping unit's mask value #1 This field defines the mask value #1 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 24.--29. 1. " MD_OFFSET_1 ,Mapping unit's offset parameter #1 This field defines the offset parameter #1 within the 24bit word coming from the DC."
width 15.
group.long 0x58148++0x3
    line.long 0x00 "DC_MAP_CONF_16,DC Mapping Configuration Register 16"
        hexmask.long.byte 0x00 0.--8. 1. " MD_MASK_0 ,Mapping unit's mask value #2 This field defines the mask value #2 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 8.--13. 1. " MD_OFFSET_2 ,Mapping unit's offset parameter #2 This field defines the offset parameter #2 within the 24bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " MD_MASK_3 ,Mapping unit's mask value #3 This field defines the mask value #3 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 24.--29. 1. " MD_OFFSET_3 ,Mapping unit's offset parameter #3 This field defines the offset parameter #3 within the 24bit word coming from the DC."
width 15.
group.long 0x5814c++0x3
    line.long 0x00 "DC_MAP_CONF_17,DC Mapping Configuration Register 17"
        hexmask.long.byte 0x00 0.--8. 1. " MD_MASK_4 ,Mapping unit's mask value #4 This field defines the mask value #4 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 8.--13. 1. " MD_OFFSET_4 ,Mapping unit's offset parameter #4 This field defines the offset parameter #4 within the 24bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " MD_MASK_5 ,Mapping unit's mask value #5 This field defines the mask value #5 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 24.--29. 1. " MD_OFFSET_5 ,Mapping unit's offset parameter #5 This field defines the offset parameter #5 within the 24bit word coming from the DC."
width 15.
group.long 0x58150++0x3
    line.long 0x00 "DC_MAP_CONF_18,DC Mapping Configuration Register 18"
        hexmask.long.byte 0x00 0.--8. 1. " MD_MASK_6 ,Mapping unit's mask value #6 This field defines the mask value #6 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 8.--13. 1. " MD_OFFSET_6 ,Mapping unit's offset parameter #6 This field defines the offset parameter #6 within the 24bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " MD_MASK_7 ,Mapping unit's mask value #7 This field defines the mask value #7 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 24.--29. 1. " MD_OFFSET_7 ,Mapping unit's offset parameter #7 This field defines the offset parameter #7 within the 24bit word coming from the DC."
width 15.
group.long 0x58154++0x3
    line.long 0x00 "DC_MAP_CONF_19,DC Mapping Configuration Register 19"
        hexmask.long.byte 0x00 0.--8. 1. " MD_MASK_8 ,Mapping unit's mask value #8 This field defines the mask value #8 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 8.--13. 1. " MD_OFFSET_8 ,Mapping unit's offset parameter #8 This field defines the offset parameter #8 within the 24bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " MD_MASK_9 ,Mapping unit's mask value #9 This field defines the mask value #9 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 24.--29. 1. " MD_OFFSET_9 ,Mapping unit's offset parameter #9 This field defines the offset parameter #9 within the 24bit word coming from the DC."
width 15.
group.long 0x58158++0x3
    line.long 0x00 "DC_MAP_CONF_20,DC Mapping Configuration Register 20"
        hexmask.long.byte 0x00 0.--8. 1. " MD_MASK_10 ,Mapping unit's mask value #10 This field defines the mask value #10 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 8.--13. 1. " MD_OFFSET_10 ,Mapping unit's offset parameter #10 This field defines the offset parameter #10 within the 24bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " MD_MASK_11 ,Mapping unit's mask value #11 This field defines the mask value #11 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 24.--29. 1. " MD_OFFSET_11 ,Mapping unit's offset parameter #11 This field defines the offset parameter #11 within the 24bit word coming from the DC."
width 15.
group.long 0x5815c++0x3
    line.long 0x00 "DC_MAP_CONF_21,DC Mapping Configuration Register 21"
        hexmask.long.byte 0x00 0.--8. 1. " MD_MASK_12 ,Mapping unit's mask value #12 This field defines the mask value #12 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 8.--13. 1. " MD_OFFSET_12 ,Mapping unit's offset parameter #12 This field defines the offset parameter #12 within the 24bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " MD_MASK_13 ,Mapping unit's mask value #13 This field defines the mask value #13 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 24.--29. 1. " MD_OFFSET_13 ,Mapping unit's offset parameter #13 This field defines the offset parameter #13 within the 24bit word coming from the DC."
width 15.
group.long 0x58160++0x3
    line.long 0x00 "DC_MAP_CONF_22,DC Mapping Configuration Register 22"
        hexmask.long.byte 0x00 0.--8. 1. " MD_MASK_14 ,Mapping unit's mask value #14 This field defines the mask value #14 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 8.--13. 1. " MD_OFFSET_14 ,Mapping unit's offset parameter #14 This field defines the offset parameter #14 within the 24bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " MD_MASK_15 ,Mapping unit's mask value #15 This field defines the mask value #15 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 24.--29. 1. " MD_OFFSET_15 ,Mapping unit's offset parameter #15 This field defines the offset parameter #15 within the 24bit word coming from the DC."
width 15.
group.long 0x58164++0x3
    line.long 0x00 "DC_MAP_CONF_23,DC Mapping Configuration Register 23"
        hexmask.long.byte 0x00 0.--8. 1. " MD_MASK_16 ,Mapping unit's mask value #16 This field defines the mask value #16 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 8.--13. 1. " MD_OFFSET_16 ,Mapping unit's offset parameter #16 This field defines the offset parameter #16 within the 24bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " MD_MASK_17 ,Mapping unit's mask value #17 This field defines the mask value #17 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 24.--29. 1. " MD_OFFSET_17 ,Mapping unit's offset parameter #17 This field defines the offset parameter #17 within the 24bit word coming from the DC."
width 15.
group.long 0x58168++0x3
    line.long 0x00 "DC_MAP_CONF_24,DC Mapping Configuration Register 24"
        hexmask.long.byte 0x00 0.--8. 1. " MD_MASK_18 ,Mapping unit's mask value #18 This field defines the mask value #18 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 8.--13. 1. " MD_OFFSET_18 ,Mapping unit's offset parameter #18 This field defines the offset parameter #18 within the 24bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " MD_MASK_19 ,Mapping unit's mask value #19 This field defines the mask value #19 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 24.--29. 1. " MD_OFFSET_19 ,Mapping unit's offset parameter #19 This field defines the offset parameter #19 within the 24bit word coming from the DC."
width 15.
group.long 0x5816c++0x3
    line.long 0x00 "DC_MAP_CONF_25,DC Mapping Configuration Register 25"
        hexmask.long.byte 0x00 0.--8. 1. " MD_MASK_20 ,Mapping unit's mask value #20 This field defines the mask value #20 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 8.--13. 1. " MD_OFFSET_20 ,Mapping unit's offset parameter #20 This field defines the offset parameter #20 within the 24bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " MD_MASK_21 ,Mapping unit's mask value #21 This field defines the mask value #21 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 24.--29. 1. " MD_OFFSET_21 ,Mapping unit's offset parameter #21 This field defines the offset parameter #21 within the 24bit word coming from the DC."
width 15.
group.long 0x58170++0x3
    line.long 0x00 "DC_MAP_CONF_26,DC Mapping Configuration Register 26"
        hexmask.long.byte 0x00 0.--8. 1. " MD_MASK_22 ,Mapping unit's mask value #22 This field defines the mask value #22 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 8.--13. 1. " MD_OFFSET_22 ,Mapping unit's offset parameter #22 This field defines the offset parameter #22 within the 24bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " MD_MASK_23 ,Mapping unit's mask value #23 This field defines the mask value #23 within the 8bit word coming from the DC."
        textline "              "
        hexmask.long.byte 0x00 24.--29. 1. " MD_OFFSET_23 ,Mapping unit's offset parameter #23 This field defines the offset parameter #23 within the 24bit word coming from the DC."
width 11.
group.long 0x58174++0x3
    line.long 0x00 "DC_UGDE0_0,DC User General Data Event 0 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " ID_CODED_0 ,This field defines the number of DC channel number that user's general event #0 will be associated to."
        textline "          "
        hexmask.long.byte 0x00 3.--7. 1. " COD_EV_PRIORITY_0 ,This field defines the priority of the user general event #0 The priority between the events should be set to a unique value."
        textline "          "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EV_START_0 ,This field holds a pointer in the microcode holding the routine to be performed following the user general event #0."
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " COD_ODD_START_0 ,This field holds a pointer in the microcode holding the routine to be performed following the user general event #0."
        textline "          "
        bitfld.long 0x00 25. " ODD_EN_0 ,The user's general event #0 may be split into 2 internal signals." "0,1"
        textline "          "
        bitfld.long 0x00 26. " AUTORESTART_0 ,User's general event #0 auto restart mode" "0,1"
        textline "          "
        hexmask.long.byte 0x00 27.--29. 1. " NF_NL_0 ,the user may attach his general event #0 to New-line New-Frame and New-field events."
width 11.
group.long 0x58178++0x3
    line.long 0x00 "DC_UGDE0_1,DC User General Data Event 0 Register 1"
        hexmask.long.long 0x00 0.--29. 1. " STEP_0 ,This field holds the pre defined value that the counter counts too."
width 11.
group.long 0x5817c++0x3
    line.long 0x00 "DC_UGDE0_2,DC User General Data Event 0 Register2"
        hexmask.long.long 0x00 0.--29. 1. " OFFSET_DT_0 ,This field defines the offset value from which the counter of user general event #0 will start counting from"
width 11.
group.long 0x58180++0x3
    line.long 0x00 "DC_UGDE0_3,DC User General Data Event 0 Register 3"
        hexmask.long.long 0x00 0.--29. 1. " STEP_REPEAT_0 ,When auto reload mode is disabled this field defines the number of events that will be generated by the user general event #0 mechanism"
width 11.
group.long 0x58184++0x3
    line.long 0x00 "DC_UGDE1_0,DC User General Data Event 1Register0"
        hexmask.long.byte 0x00 0.--3. 1. " ID_CODED_1 ,This field defines the number of DC channel number that user's general event #1 will be associated to"
        textline "          "
        hexmask.long.byte 0x00 3.--7. 1. " COD_EV_PRIORITY_1 ,This field defines the priority of the user general event #1 The priority between the events should be set to a unique value."
        textline "          "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EV_START_1 ,This field holds a pointer in the microcode holding the routine to be performed following the user general event #1."
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " COD_ODD_START_1 ,This field holds a pointer in the microcode holding the routine to be performed following the user general event #1."
        textline "          "
        bitfld.long 0x00 25. " ODD_EN_1 ,The user's general event #1 may be split into 2 internal signals." "0,1"
        textline "          "
        bitfld.long 0x00 26. " AUTORESTART_1 ,User's general event #1 auto restart mode" "0,1"
        textline "          "
        hexmask.long.byte 0x00 27.--29. 1. " NF_NL_1 ,the user may attach his general event #1 to New-line New-Frame and New-field events."
width 11.
group.long 0x58188++0x3
    line.long 0x00 "DC_UGDE1_1,DC User General Data Event 1 Register 1"
        hexmask.long.long 0x00 0.--29. 1. " STEP_1 ,This field hold the pre defined value that the counter counts too"
width 11.
group.long 0x5818c++0x3
    line.long 0x00 "DC_UGDE1_2,DC User General Data Event 1Register 2"
        hexmask.long.long 0x00 0.--29. 1. " OFFSET_DT_1 ,This field defines the offset value from which the counter of user general event #1 will start counting from"
width 11.
group.long 0x58190++0x3
    line.long 0x00 "DC_UGDE1_3,DC User General Data Event 1Register 3"
        hexmask.long.long 0x00 0.--29. 1. " STEP_REPEAT_1 ,When auto reload mode is disabled this field defines the number of events that will be generated by the user general event #1 mechanism"
width 11.
group.long 0x58194++0x3
    line.long 0x00 "DC_UGDE2_0,DC User General Data Event 2 Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " ID_CODED_2 ,This field defines the number of DC channel number that user's general event #2 will be associated to"
        textline "          "
        hexmask.long.byte 0x00 3.--7. 1. " COD_EV_PRIORITY_2 ,This field defines the priority of the user general event #2 The priority between the events should be set to a unique value."
        textline "          "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EV_START_2 ,This field holds a pointer in the microcode holding the routine to be performed following the user general event #2."
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " COD_ODD_START_2 ,This field holds a pointer in the microcode holding the routine to be performed following the user general event #2 When ODD_MODE is enabled, only the odd events will use this pointer When ODD_MODE is disabled this field is ignored"
        textline "          "
        bitfld.long 0x00 25. " ODD_EN_2 ,The user's general event #2 may be split into 2 internal signals." "0,1"
        textline "          "
        bitfld.long 0x00 26. " AUTORESTART_2 ,User's general event #2 auto restart mode" "0,1"
        textline "          "
        hexmask.long.byte 0x00 27.--29. 1. " NF_NL_2 ,the user may attach his general event #2 to New-line New-Frame and New-field events."
width 11.
group.long 0x58198++0x3
    line.long 0x00 "DC_UGDE2_1,DC User General Data Event 2 Register 1"
        hexmask.long.long 0x00 0.--29. 1. " STEP_2 ,This field hold the pre defined value that the counter counts too"
width 11.
group.long 0x5819c++0x3
    line.long 0x00 "DC_UGDE2_2,DC User General Data Event 2Register 2"
        hexmask.long.long 0x00 0.--29. 1. " OFFSET_DT_2 ,This field defines the offset value from which the counter of user general event #2 will start counting from"
width 11.
group.long 0x581a0++0x3
    line.long 0x00 "DC_UGDE2_3,DC User General Data Event 2Register 3"
        hexmask.long.long 0x00 0.--29. 1. " STEP_REPEAT_2 ,When auto reload mode is disabled this field defines the number of events that will be generated by the user general event #2 mechanism"
width 11.
group.long 0x581a4++0x3
    line.long 0x00 "DC_UGDE3_0,DC User General Data Event 3Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " ID_CODED_3 ,This field defines the number of DC channel number that user's general event #3 will be associated to"
        textline "          "
        hexmask.long.byte 0x00 3.--7. 1. " COD_EV_PRIORITY_3 ,This field defines the priority of the user general event #3"
        textline "          "
        hexmask.long.byte 0x00 8.--16. 1. " COD_EV_START_3 ,This field holds a pointer in the microcode holding the routine to be performed following the user general event #3."
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " COD_ODD_START_3 ,This field holds a pointer in the microcode holding the routine to be performed following the user general event #3."
        textline "          "
        bitfld.long 0x00 25. " ODD_EN_3 ,The user's general event #3 may be split into 2 internal signals." "0,1"
        textline "          "
        bitfld.long 0x00 26. " AUTORESTART_3 ,User's general event #3 auto restart mode" "0,1"
        textline "          "
        hexmask.long.byte 0x00 27.--29. 1. " NF_NL_3 ,the user may attach his general event #3 to New-line New-Frame and New-field events."
width 11.
group.long 0x581a8++0x3
    line.long 0x00 "DC_UGDE3_1,DC User General Data Event 3Register 1"
        hexmask.long.long 0x00 0.--29. 1. " STEP_3 ,This field hold the pre defined value that the counter counts too"
width 11.
group.long 0x581ac++0x3
    line.long 0x00 "DC_UGDE3_2,DC User General Data Event 3Register 2"
        hexmask.long.long 0x00 0.--29. 1. " OFFSET_DT_3 ,This field defines the offset value from which the counter of user general event #3 will start counting from"
width 11.
group.long 0x581b0++0x3
    line.long 0x00 "DC_UGDE3_3,DC User General Data Event 3Register 2"
        hexmask.long.long 0x00 0.--29. 1. " STEP_REPEAT_3 ,When auto reload mode is disabled this field defines the number of events that will be generated by the user general event #3 mechanism"
width 8.
group.long 0x581b4++0x3
    line.long 0x00 "DC_LLA0,DC Low Level Access Control Register 0"
        hexmask.long.byte 0x00 0.--8. 1. " MCU_RS_0_0 ,This field holds a pointer in the microcode handling the RS_0 routine for the display defined at DISP_ID_8, when in Low level access mode,"
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " MCU_RS_1_0 ,This field holds a pointer in the microcode handling the RS_1 routine for the display defined at DISP_ID_8, when in Low level access mode,"
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MCU_RS_2_0 ,This field holds a pointer in the microcode handling the RS_2 routine for the display defined at DISP_ID_8, when in Low level access mode,"
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MCU_RS_3_0 ,This field holds a pointer in the microcode handling the RS_3 routine for the display defined at DISP_ID_8, when in Low level access mode,"
width 8.
group.long 0x581b8++0x3
    line.long 0x00 "DC_LLA1,DC Low Level Access Control Register 1"
        hexmask.long.byte 0x00 0.--8. 1. " MCU_RS_0_1 ,This field holds a pointer in the microcode handling the RS_0 routine for the display defined at DISP_ID_9, when in Low level access mode,"
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " MCU_RS_1_1 ,This field holds a pointer in the microcode handling the RS_1 routine for the display defined at DISP_ID_9, when in Low level access mode,"
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MCU_RS_2_1 ,This field holds a pointer in the microcode handling the RS_2 routine for the display defined at DISP_ID_9, when in Low level access mode,"
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MCU_RS_3_1 ,This field holds a pointer in the microcode handling the RS_3 routine for the display defined at DISP_ID_9, when in Low level access mode,"
width 10.
group.long 0x581bc++0x3
    line.long 0x00 "DC_R_LLA0,DC Read Low Level Read Access Control Register 0"
        hexmask.long.byte 0x00 0.--8. 1. " MCU_RS_R_0_0 ,This field holds a pointer in the microcode handling the RS_0 routine for the display defined at DISP_ID_8, when in Read Low level access mode,"
        textline "         "
        hexmask.long.byte 0x00 8.--16. 1. " MCU_RS_R_1_0 ,This field holds a pointer in the microcode handling the RS_1 routine for the display defined at DISP_ID_8, when in Read Low level access mode,"
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " MCU_RS_2_0 ,This field holds a pointer in the microcode handling the RS_2 routine for the display defined at DISP_ID_8, when in Read Low level access mode,"
        textline "         "
        hexmask.long.byte 0x00 24.--32. 1. " MCU_RS_3_0 ,This field holds a pointer in the microcode handling the RS_3 routine for the display defined at DISP_ID_8, when in Read Low level access mode,"
width 10.
group.long 0x581c0++0x3
    line.long 0x00 "DC_R_LLA1,DC Read Low Level Read Access Control Register1"
        hexmask.long.byte 0x00 0.--8. 1. " MCU_RS_R_0_1 ,This field holds a pointer in the microcode handling the RS_0 routine for the display defined at DISP_ID_9, when in Read Low level access mode,"
        textline "         "
        hexmask.long.byte 0x00 8.--16. 1. " MCU_RS_R_1_1 ,This field holds a pointer in the microcode handling the RS_1 routine for the display defined at DISP_ID_9, when in Read Low level access mode,"
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " MCU_RS_R_2_1 ,This field holds a pointer in the microcode handling the RS_2 routine for the display defined at DISP_ID_9, when in Read Low level access mode,"
        textline "         "
        hexmask.long.byte 0x00 24.--32. 1. " MCU_RS_R_3_1 ,This field holds a pointer in the microcode handling the RS_3 routine for the display defined at DISP_ID_9, when in Read Low level access mode,"
width 20.
group.long 0x581c4++0x3
    line.long 0x00 "DC_WR_CH_ADDR_5_ALT,DC Write Channel 5 Configuration Register"
        hexmask.long.long 0x00 0.--29. 1. " ST_ADDR_5_ALT ,This field defines the start address within the display's memory space where the write transactions will be done to for channel #5, when alternate flow is performed via channel #5"
width 8.
rgroup.long 0x581c8++0x3
    line.long 0x00 "DC_STAT,DC Status Register"
        bitfld.long 0x00 0. " DC_TRIPLE_BUF_CNT_FULL_0 ,This bit indicates a FIFO full state on the DC FIFO accessing DI0 when write to the display flow is used" "0,1"
        textline "       "
        bitfld.long 0x00 1. " DC_TRIPLE_BUF_CNT_EMPTY_0 ,This bit indicates a FIFO empty state on the DC FIFO accessing DI0 when write to the display flow is used" "0,1"
        textline "       "
        bitfld.long 0x00 2. " DC_TRIPLE_BUF_DATA_FULL_0 ,This bit indicates a FIFO full state on the DC FIFO accessing DI0 when read from the display flow is used" "0,1"
        textline "       "
        bitfld.long 0x00 3. " DC_TRIPLE_BUF_DATA_EMPTY_0 ,This bit indicates a FIFO empty state on the DC FIFO accessing DI0 when read from the display flow is used" "0,1"
        textline "       "
        bitfld.long 0x00 4. " DC_TRIPLE_BUF_CNT_FULL_1 ,This bit indicates a FIFO full state on the DC FIFO accessing DI1 when write to the display flow is used" "0,1"
        textline "       "
        bitfld.long 0x00 5. " DC_TRIPLE_BUF_CNT_EMPTY_1 ,This bit indicates a FIFO empty state on the DC FIFO accessing DI1 when write to the display flow is used" "0,1"
        textline "       "
        bitfld.long 0x00 6. " DC_TRIPLE_BUF_DATA_FULL_1 ,This bit indicates a FIFO empty state on the DC FIFO accessing DI1 when read from the display flow is used" "0,1"
        textline "       "
        bitfld.long 0x00 7. " DC_TRIPLE_BUF_DATA_EMPTY_1 ,This bit indicates a FIFO full state on the DC FIFO accessing DI1 when write to the display flow is used" "0,1"
width 13.
group.long 0x60000++0x3
    line.long 0x00 "DMFC_RD_CHAN,DMFC Read Channel Register"
        hexmask.long.byte 0x00 6.--8. 1. " DMFC_BURST_SIZE_0 ,Read burst Size This field defines the burst size of the DMFC's read accesses."
        textline "            "
        bitfld.long 0x00 17. " DMFC_WM_EN_0 ,Watermark enable." "0,1"
        textline "            "
        hexmask.long.byte 0x00 18.--21. 1. " DMFC_WM_SET_0 ,Watermark Set This field defines the watermark's level of the DMFC read FIFO."
        textline "            "
        hexmask.long.byte 0x00 21.--24. 1. " DMFC_WM_CLR_0 ,Watermark Clear This field defines the watermark's level of the DMFC read FIFO."
        textline "            "
        hexmask.long.byte 0x00 24.--26. 1. " DMFC_PPW_C ,Pixel Per Word coded."
width 13.
group.long 0x60004++0x3
    line.long 0x00 "DMFC_WR_CHAN,DMFC Write Channel Register"
        hexmask.long.byte 0x00 0.--3. 1. " DMFC_ST_ADDR_1 ,DMFC Start Address for IDMAC's channel 28 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 28."
        textline "            "
        hexmask.long.byte 0x00 3.--6. 1. " DMFC_FIFO_SIZE_1 ,DMFC FIFO size for IDMAC's channel 28 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 28"
        textline "            "
        hexmask.long.byte 0x00 6.--8. 1. " DMFC_BURST_SIZE_1 ,Burst size of IDMAC's channel 28 This field defines the burst size of the IDMAC's channel 28 write accesses."
        textline "            "
        hexmask.long.byte 0x00 8.--11. 1. " DMFC_ST_ADDR_2 ,DMFC Start Address for IDMAC's channel 41 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 41."
        textline "            "
        hexmask.long.byte 0x00 11.--14. 1. " DMFC_FIFO_SIZE_2 ,DMFC FIFO size for IDMAC's channel 41 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 41"
        textline "            "
        hexmask.long.byte 0x00 14.--16. 1. " DMFC_BURST_SIZE_2 ,Burst size of IDMAC's channel 41 This field defines the burst size of the IDMAC's channel 41 write accesses."
        textline "            "
        hexmask.long.byte 0x00 16.--19. 1. " DMFC_ST_ADDR_1C ,DMFC Start Address for IDMAC's channel 42 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 42."
        textline "            "
        hexmask.long.byte 0x00 19.--22. 1. " DMFC_FIFO_SIZE_1C ,DMFC FIFO size for IDMAC's channel 42 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 42"
        textline "            "
        hexmask.long.byte 0x00 22.--24. 1. " DMFC_BURST_SIZE_1C ,Burst size of IDMAC's channel 42 This field defines the burst size of the IDMAC's channel 42 write accesses."
        textline "            "
        hexmask.long.byte 0x00 24.--27. 1. " DMFC_ST_ADDR_2C ,DMFC Start Address for IDMAC's channel 43 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 43."
        textline "            "
        hexmask.long.byte 0x00 27.--30. 1. " DMFC_FIFO_SIZE_2C ,DMFC FIFO size for IDMAC's channel 43 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 43"
        textline "            "
        hexmask.long.byte 0x00 30.--32. 1. " DMFC_BURST_SIZE_2C ,Burst size of IDMAC's channel 43 This field defines the burst size of the IDMAC's channel 43 write accesses."
width 17.
group.long 0x60008++0x3
    line.long 0x00 "DMFC_WR_CHAN_DEF,DMFC Write Channel Definition Register"
        bitfld.long 0x00 1. " DMFC_WM_EN_1 ,Watermark enable." "0,1"
        textline "                "
        hexmask.long.byte 0x00 2.--5. 1. " DMFC_WM_SET_1 ,Watermark Set This field defines the watermark's level of the DMFC write FIFO."
        textline "                "
        hexmask.long.byte 0x00 5.--8. 1. " DMFC_WM_CLR_1 ,Watermark Clear This field defines the watermark's level of the DMFC's write FIFO."
        textline "                "
        bitfld.long 0x00 9. " DMFC_WM_EN_2 ,Watermark enable." "0,1"
        textline "                "
        hexmask.long.byte 0x00 10.--13. 1. " DMFC_WM_SET_2 ,Watermark Set This field defines the watermark's level of the DMFC write FIFO."
        textline "                "
        hexmask.long.byte 0x00 13.--16. 1. " DMFC_WM_CLR_2 ,Watermark Clear This field defines the watermark's level of the DMFC's write FIFO."
        textline "                "
        bitfld.long 0x00 17. " DMFC_WM_EN_1C ,Watermark enable." "0,1"
        textline "                "
        hexmask.long.byte 0x00 18.--21. 1. " DMFC_WM_SET_1C ,Watermark Set This field defines the watermark's level of the DMFC write FIFO."
        textline "                "
        hexmask.long.byte 0x00 21.--24. 1. " DMFC_WM_CLR_1C ,Watermark Clear This field defines the watermark's level of the DMFC's write FIFO."
        textline "                "
        bitfld.long 0x00 25. " DMFC_WM_EN_2C ,Watermark enable." "0,1"
        textline "                "
        hexmask.long.byte 0x00 26.--29. 1. " DMFC_WM_SET_2C ,Watermark Set This field defines the watermark's level of the DMFC write FIFO."
        textline "                "
        hexmask.long.byte 0x00 29.--32. 1. " DMFC_WM_CLR_2C ,Watermark Clear This field defines the watermark's level of the DMFC's write FIFO."
width 13.
group.long 0x6000c++0x3
    line.long 0x00 "DMFC_DP_CHAN,DMFC Display Processor Channel Register"
        hexmask.long.byte 0x00 0.--3. 1. " DMFC_ST_ADDR_5B ,DMFC Start Address for IDMAC's channel 23 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 23."
        textline "            "
        hexmask.long.byte 0x00 3.--6. 1. " DMFC_FIFO_SIZE_5B ,DMFC FIFO size for IDMAC's channel 23 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 23"
        textline "            "
        hexmask.long.byte 0x00 6.--8. 1. " DMFC_BURST_SIZE_5B ,Burst size of IDMAC's channel 23 This field defines the burst size of the IDMAC's channel 23 write accesses."
        textline "            "
        hexmask.long.byte 0x00 8.--11. 1. " DMFC_ST_ADDR_5F ,DMFC Start Address for IDMAC's channel 27 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 27."
        textline "            "
        hexmask.long.byte 0x00 11.--14. 1. " DMFC_FIFO_SIZE_5F ,DMFC FIFO size for IDMAC's channel 27 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 27"
        textline "            "
        hexmask.long.byte 0x00 14.--16. 1. " DMFC_BURST_SIZE_5F ,Burst size of IDMAC's channel 27 This field defines the burst size of the IDMAC's channel 27 write accesses."
        textline "            "
        hexmask.long.byte 0x00 16.--19. 1. " DMFC_ST_ADDR_6B ,DMFC Start Address for IDMAC's channel 24 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 24."
        textline "            "
        hexmask.long.byte 0x00 19.--22. 1. " DMFC_FIFO_SIZE_6B ,DMFC FIFO size for IDMAC's channel 24 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 24"
        textline "            "
        hexmask.long.byte 0x00 22.--24. 1. " DMFC_BURST_SIZE_6B ,Burst size of IDMAC's channel 24 This field defines the burst size of the IDMAC's channel 24 write accesses."
        textline "            "
        hexmask.long.byte 0x00 24.--27. 1. " DMFC_ST_ADDR_6F ,DMFC Start Address for IDMAC's channel 29 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 29."
        textline "            "
        hexmask.long.byte 0x00 27.--30. 1. " DMFC_FIFO_SIZE_6F ,DMFC FIFO size for IDMAC's channel 29 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 29"
        textline "            "
        hexmask.long.byte 0x00 30.--32. 1. " DMFC_BURST_SIZE_6F ,Burst size of IDMAC's channel 29 This field defines the burst size of the IDMAC's channel 29 write accesses."
width 17.
group.long 0x60010++0x3
    line.long 0x00 "DMFC_DP_CHAN_DEF,DMFC Display Processor Channel Definition Register"
        bitfld.long 0x00 1. " DMFC_WM_EN_5B ,Watermark enable." "0,1"
        textline "                "
        hexmask.long.byte 0x00 2.--5. 1. " DMFC_WM_SET_5B ,Watermark Set This field defines the watermark's level of the DMFC write FIFO."
        textline "                "
        hexmask.long.byte 0x00 5.--8. 1. " DMFC_WM_CLR_5B ,Watermark Clear This field defines the watermark's level of the DMFC's write FIFO."
        textline "                "
        bitfld.long 0x00 9. " DMFC_WM_EN_5F ,Watermark enable." "0,1"
        textline "                "
        hexmask.long.byte 0x00 10.--13. 1. " DMFC_WM_SET_5F ,Watermark Set This field defines the watermark's level of the DMFC write FIFO."
        textline "                "
        hexmask.long.byte 0x00 13.--16. 1. " DMFC_WM_CLR_5F ,Watermark Clear This field defines the watermark's level of the DMFC's write FIFO."
        textline "                "
        bitfld.long 0x00 17. " DMFC_WM_EN_6B ,Watermark enable." "0,1"
        textline "                "
        hexmask.long.byte 0x00 18.--21. 1. " DMFC_WM_SET_6B ,Watermark Set This field defines the watermark's level of the DMFC write FIFO."
        textline "                "
        hexmask.long.byte 0x00 21.--24. 1. " DMFC_WM_CLR_6B ,Watermark Clear This field defines the watermark's level of the DMFC's write FIFO."
        textline "                "
        bitfld.long 0x00 25. " DMFC_WM_EN_6F ,Watermark enable." "0,1"
        textline "                "
        hexmask.long.byte 0x00 26.--29. 1. " DMFC_WM_SET_6F ,Watermark Set This field defines the watermark's level of the DMFC write FIFO."
        textline "                "
        hexmask.long.byte 0x00 29.--32. 1. " DMFC_WM_CLR_6F ,Watermark Clear This field defines the watermark's level of the DMFC's write FIFO."
width 15.
group.long 0x60014++0x3
    line.long 0x00 "DMFC_GENERAL_1,DMFC General 1 Register"
        hexmask.long.byte 0x00 0.--2. 1. " DMFC_DCDP_SYNC_PR ,DMFC's memory access priority settings for simultaneous synchronous flows from DC & DP"
        textline "              "
        hexmask.long.byte 0x00 5.--7. 1. " DMFC_BURST_SIZE_9 ,Burst size of IDMAC's channel 44 This field defines the burst size of the IDMAC's channel 44 write accesses."
        textline "              "
        bitfld.long 0x00 9. " DMFC_WM_EN_9 ,Watermark enable." "0,1"
        textline "              "
        hexmask.long.byte 0x00 10.--13. 1. " DMFC_WM_SET_9 ,Watermark Set This field defines the watermark's level of the DMFC write FIFO."
        textline "              "
        hexmask.long.byte 0x00 13.--16. 1. " DMFC_WM_CLR_9 ,Watermark Clear This field defines the watermark's level of the DMFC's write FIFO."
        textline "              "
        bitfld.long 0x00 16. " WAIT4EOT_1 ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
        textline "              "
        bitfld.long 0x00 17. " WAIT4EOT_2 ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
        textline "              "
        bitfld.long 0x00 18. " WAIT4EOT_3 ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
        textline "              "
        bitfld.long 0x00 19. " WAIT4EOT_4 ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
        textline "              "
        bitfld.long 0x00 20. " WAIT4EOT_5B ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
        textline "              "
        bitfld.long 0x00 21. " WAIT4EOT_5F ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
        textline "              "
        bitfld.long 0x00 22. " WAIT4EOT_6B ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
        textline "              "
        bitfld.long 0x00 23. " WAIT4EOT_6F ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
        textline "              "
        bitfld.long 0x00 24. " WAIT4EOT_9 ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
width 15.
group.long 0x60018++0x3
    line.long 0x00 "DMFC_GENERAL_2,DMFC General 2 Register"
        hexmask.long.word 0x00 0.--13. 1. " DMFC_FRAME_WIDTH_RD ,Frame width for read channel from the display to the IDMAC; Units are pixels"
        textline "              "
        hexmask.long.word 0x00 16.--29. 1. " DMFC_FRAME_HEIGHT_RD ,Frame height for read channel from the display to the IDMAC; Units are pixels"
width 13.
group.long 0x6001c++0x3
    line.long 0x00 "DMFC_IC_CTRL,DMFC IC Interface Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " DMFC_IC_IN_PORT ,DMFC input port When data is coming from the IC, the IC channel replaces one of the IDMAC's channels connected to the DMFC."
        textline "            "
        hexmask.long.byte 0x00 4.--6. 1. " DMFC_IC_PPW_C ,Pixel Per Word coded from IC."
        textline "            "
        hexmask.long.word 0x00 6.--19. 1. " DMFC_IC_FRAME_WIDTH_RD ,Frame's width for the channel coming from IC."
        textline "            "
        hexmask.long.word 0x00 19.--32. 1. " DMFC_IC_FRAME_HEIGHT_RD ,Frame's height for the channel coming from IC."
width 17.
group.long 0x60020++0x3
    line.long 0x00 "DMFC_WR_CHAN_ALT,DMFC Write Channel Alternate Register"
        hexmask.long.byte 0x00 8.--11. 1. " DMFC_ST_ADDR_2_ALT ,DMFC Start Address for IDMAC's channel 41 (for alternate flow) This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 41."
        textline "                "
        hexmask.long.byte 0x00 11.--14. 1. " DMFC_FIFO_SIZE_2_ALT ,DMFC FIFO size for IDMAC's channel 41 (for alternate flow) This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 41"
        textline "                "
        hexmask.long.byte 0x00 14.--16. 1. " DMFC_BURST_SIZE_2_ALT ,Burst size of IDMAC's channel 41 (for alternate flow) This field defines the burst size of the IDMAC's channel 41 write accesses."
width 21.
group.long 0x60024++0x3
    line.long 0x00 "DMFC_WR_CHAN_DEF_ALT,DMFC Write Channel Definition Alternate Register"
        bitfld.long 0x00 9. " DMFC_WM_EN_2_ALT ,Watermark enable." "0,1"
        textline "                    "
        hexmask.long.byte 0x00 10.--13. 1. " DMFC_WM_SET_2_ALT ,Watermark Set (for alternate flow) This field defines the watermark's level of the DMFC write FIFO."
        textline "                    "
        hexmask.long.byte 0x00 13.--16. 1. " DMFC_WM_CLR_2_ALT ,Watermark Clear (for alternate flow) This field defines the watermark's level of the DMFC's write FIFO."
width 17.
group.long 0x60028++0x3
    line.long 0x00 "DMFC_DP_CHAN_ALT,DMFC MFC Display Processor Channel Alternate Register"
        hexmask.long.byte 0x00 0.--3. 1. " DMFC_ST_ADDR_5B_ALT ,DMFC Start Address for IDMAC's channel 23 (for alternate flow) This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 23."
        textline "                "
        hexmask.long.byte 0x00 3.--6. 1. " DMFC_FIFO_SIZE_5B_ALT ,DMFC FIFO size for IDMAC's channel 23 (for alternate flow) This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 23"
        textline "                "
        hexmask.long.byte 0x00 6.--8. 1. " DMFC_BURST_SIZE_5B_ALT ,Burst size of IDMAC's channel 23 (for alternate flow) This field defines the burst size of the IDMAC's channel 23 write accesses."
        textline "                "
        hexmask.long.byte 0x00 16.--19. 1. " DMFC_ST_ADDR_6B_ALT ,DMFC Start Address for IDMAC's channel 24 (for alternate flow) This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 24."
        textline "                "
        hexmask.long.byte 0x00 19.--22. 1. " DMFC_FIFO_SIZE_6B_ALT ,DMFC FIFO size for IDMAC's channel 24 (for alternate flow) This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 24"
        textline "                "
        hexmask.long.byte 0x00 22.--24. 1. " DMFC_BURST_SIZE_6B_ALT ,Burst size of IDMAC's channel 24 (for alternate flow) This field defines the burst size of the IDMAC's channel 24 write accesses."
        textline "                "
        hexmask.long.byte 0x00 24.--27. 1. " DMFC_ST_ADDR_6F_ALT ,DMFC Start Address for IDMAC's channel 29 (for alternate flow) This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 29."
        textline "                "
        hexmask.long.byte 0x00 27.--30. 1. " DMFC_FIFO_SIZE_6F_ALT ,DMFC FIFO size for IDMAC's channel 29 (for alternate flow) This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 29"
        textline "                "
        hexmask.long.byte 0x00 30.--32. 1. " DMFC_BURST_SIZE_6F_ALT ,Burst size of IDMAC's channel 29 (for alternate flow) This field defines the burst size of the IDMAC's channel 29 write accesses."
width 21.
group.long 0x6002c++0x3
    line.long 0x00 "DMFC_DP_CHAN_DEF_ALT,DMFC Display Channel Definition Alternate Register"
        bitfld.long 0x00 1. " DMFC_WM_EN_5B_ALT ,Watermark enable." "0,1"
        textline "                    "
        hexmask.long.byte 0x00 2.--5. 1. " DMFC_WM_SET_5B_ALT ,Watermark Set (for alternate flow) This field defines the watermark's level of the DMFC write FIFO."
        textline "                    "
        hexmask.long.byte 0x00 5.--8. 1. " DMFC_WM_CLR_5B_ALT ,Watermark Clear (for alternate flow) This field defines the watermark's level of the DMFC's write FIFO."
        textline "                    "
        bitfld.long 0x00 17. " DMFC_WM_EN_6B_ALT ,Watermark enable." "0,1"
        textline "                    "
        hexmask.long.byte 0x00 18.--21. 1. " DMFC_WM_SET_6B_ALT ,Watermark Set (for alternate flow) This field defines the watermark's level of the DMFC write FIFO."
        textline "                    "
        hexmask.long.byte 0x00 21.--24. 1. " DMFC_WM_CLR_6B_ALT ,Watermark Clear (for alternate flow) This field defines the watermark's level of the DMFC's write FIFO."
        textline "                    "
        bitfld.long 0x00 25. " DMFC_WM_EN_6F_ALT ,Watermark enable." "0,1"
        textline "                    "
        hexmask.long.byte 0x00 26.--29. 1. " DMFC_WM_SET_6F_ALT ,Watermark Set (for alternate flow) This field defines the watermark's level of the DMFC write FIFO."
        textline "                    "
        hexmask.long.byte 0x00 29.--32. 1. " DMFC_WM_CLR_6F_ALT ,Watermark Clear (for alternate flow) This field defines the watermark's level of the DMFC's write FIFO."
width 18.
group.long 0x60030++0x3
    line.long 0x00 "DMFC_GENERAL1_ALT,DMFC General 1 Alternate Register"
        bitfld.long 0x00 17. " WAIT4EOT_2_ALT ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
        textline "                 "
        bitfld.long 0x00 20. " WAIT4EOT_5B_ALT ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
        textline "                 "
        bitfld.long 0x00 22. " WAIT4EOT_6B_ALT ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
        textline "                 "
        bitfld.long 0x00 23. " WAIT4EOT_6F_ALT ,In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO." "0,1"
width 10.
rgroup.long 0x60034++0x3
    line.long 0x00 "DMFC_STAT,DMFC Status Register"
        hexmask.long.word 0x00 0.--12. 1. " DMFC_FIFO_FULL_I ,This bit indicates on a DMFC FIFO#<i> full condition."
        textline "         "
        hexmask.long.word 0x00 12.--24. 1. " DMFC_FIFO_EMPTY_I ,This bit indicates on a DMFC FIFO#<i> empty condition."
        textline "         "
        bitfld.long 0x00 24. " DMFC_IC_BUFFER_FULL ,This bit indicates on a IC FIFO, inside the DMFC, full condition." "0,1"
        textline "         "
        bitfld.long 0x00 25. " DMFC_IC_BUFFER_EMPTY ,This bit indicates on a IC FIFO, inside the DMFC, empty condition." "0,1"
width 10.
group.long 0x68000++0x3
    line.long 0x00 "VDI_FSIZE,VDI Field Size Register"
        hexmask.long.word 0x00 0.--11. 1. " VDI_FWIDTH ,Frame width."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " VDI_FHEIGHT ,Frame height The value to be written to this register is the frame's height minus 1."
width 6.
group.long 0x68004++0x3
    line.long 0x00 "VDI_C,VDI Control Register"
        bitfld.long 0x00 1. " VDI_CH_422 ,Chroma format at input and output of VDI C ." "0,1"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " VDI_MOT_SEL ,Motion select."
        textline "     "
        hexmask.long.byte 0x00 4.--8. 1. " VDI_BURST_SIZE1 ,Burst Size for channels 1 or 4 (channels 1 and 4 are not working simultaneously)."
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " VDI_BURST_SIZE2 ,Burst Size for channel 2."
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " VDI_BURST_SIZE3 ,Burst Size for channel 3."
        textline "     "
        hexmask.long.byte 0x00 16.--19. 1. " VDI_VWM1_SET ,VDI C WaterMark ""set"" level for channel 1 or channel 2 (channels 1 and 4 are not working simultaneously)."
        textline "     "
        hexmask.long.byte 0x00 19.--22. 1. " VDI_VWM1_CLR ,VDI C WaterMark ""clear"" level for channel 1 or channel 4 (channels 1 and 4 are not working simultaneously)."
        textline "     "
        hexmask.long.byte 0x00 22.--25. 1. " VDI_VWM3_SET ,VDI C WaterMark ""set"" level for channel 3."
        textline "     "
        hexmask.long.byte 0x00 25.--28. 1. " VDI_VWM3_CLR ,VDI C WaterMark ""clear"" level for channel 3."
width 7.
group.long 0x68008++0x3
    line.long 0x00 "VDI_C2,VDI Control Register 2"
        bitfld.long 0x00 0. " VDI_CMB_EN ,Combining enable" "0,1"
        textline "      "
        bitfld.long 0x00 1. " VDI_KEY_COLOR_EN ,Key Color Enable" "0,1"
        textline "      "
        bitfld.long 0x00 2. " VDI_GLB_A_EN ,Global alpha enable" "0,1"
        textline "      "
        bitfld.long 0x00 3. " VDI_PLANE_1_EN ,Plane 1 enable" "0,1"
width 11.
group.long 0x6800c++0x3
    line.long 0x00 "VDI_CMDP_1,VDI Combining Parameters Register 1"
        hexmask.long.byte 0x00 0.--8. 1. " VDI_KEY_COLOR_B ,Blue component of Key Color"
        textline "          "
        hexmask.long.byte 0x00 8.--16. 1. " VDI_KEY_COLOR_G ,Green component of Key Color"
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " VDI_KEY_COLOR_R ,Red component of Key Color"
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " VDI_ALPHA ,Global Alpha Actual value of the alpha is VDI_ALPHA + VDI_ALPHA[7]"
width 11.
group.long 0x68010++0x3
    line.long 0x00 "VDI_CMDP_2,VDI Combining Parameters Register 2"
        hexmask.long.byte 0x00 0.--8. 1. " VDI_KEY_COLOR_B ,Blue component of background Color"
        textline "          "
        hexmask.long.byte 0x00 8.--16. 1. " VDI_KEY_COLOR_G ,Green component of background Color"
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " VDI_KEY_COLOR_R ,Red component of background Color"
width 9.
group.long 0x68014++0x3
    line.long 0x00 "VDI_PS_1,VDI Plane Size Register 1"
        hexmask.long.word 0x00 0.--11. 1. " VDI_FWIDTH1 ,Plane 1 width."
        textline "        "
        hexmask.long.word 0x00 16.--27. 1. " VDI_FHEIGHT1 ,Plane 1 height The value to be written to this register is the plane's height minus 1."
width 9.
group.long 0x68018++0x3
    line.long 0x00 "VDI_PS_2,VDI Plane Size Register 2"
        hexmask.long.word 0x00 0.--11. 1. " VDI_OFFSET_HOR1 ,Horizontal offset of plane 1"
        textline "        "
        hexmask.long.word 0x00 16.--27. 1. " VDI_OFFSET_VER1 ,Vertical offset of plane 1"
width 9.
group.long 0x6801c++0x3
    line.long 0x00 "VDI_PS_3,VDI Plane Size Register 3"
        hexmask.long.word 0x00 0.--11. 1. " VDI_FWIDTH3 ,Plane 3 width."
        textline "        "
        hexmask.long.word 0x00 16.--27. 1. " VDI_FHEIGHT3 ,Plane 3 height The value to be written to this register is the plane's height minus 1."
width 9.
group.long 0x68020++0x3
    line.long 0x00 "VDI_PS_4,VDI Plane Size Register 4"
        hexmask.long.word 0x00 0.--11. 1. " VDI_OFFSET_HOR3 ,Horizontal offset of plane 3"
        textline "        "
        hexmask.long.word 0x00 16.--27. 1. " VDI_OFFSET_VER3 ,Vertical offset of plane 3"


tree.end



;--------------------------------------------------------------------------------
; KPP
;--------------------------------------------------------------------------------
tree "KPP"
    base ad:0x020b8000

width 5.
group.word 0x0++0x1
    line.word 0x00 "KPCR,Keypad Control Register"
        hexmask.word.byte 0x00 0.--8. 1. " KRE ,Keypad Row Enable."
        textline "    "
        hexmask.word.byte 0x00 8.--16. 1. " KCO ,Keypad Column Strobe Open-Drain Enable."
width 5.
group.word 0x2++0x1
    line.word 0x00 "KPSR,Keypad Status Register"
        bitfld.word 0x00 0. " KPKD ,Keypad Key Depress." "0,1"
        textline "    "
        bitfld.word 0x00 1. " KPKR ,Keypad Key Release." "0,1"
        textline "    "
        bitfld.word 0x00 2. " KDSC ,Key Depress Synchronizer Clear." "0,1"
        textline "    "
        bitfld.word 0x00 3. " KRSS ,Key Release Synchronizer Set." "0,1"
        textline "    "
        bitfld.word 0x00 8. " KDIE ,Keypad Key Depress Interrupt Enable." "0,1"
        textline "    "
        bitfld.word 0x00 9. " KRIE ,Keypad Release Interrupt Enable." "0,1"
width 5.
group.word 0x4++0x1
    line.word 0x00 "KDDR,Keypad Data Direction Register"
        hexmask.word.byte 0x00 0.--8. 1. " KRDD ,Keypad Row Data Direction."
        textline "    "
        hexmask.word.byte 0x00 8.--16. 1. " KCDD ,Keypad Column Data Direction Register."
width 5.
group.word 0x6++0x1
    line.word 0x00 "KPDR,Keypad Data Register"
        hexmask.word.byte 0x00 0.--8. 1. " KRD ,Keypad Row Data."
        textline "    "
        hexmask.word.byte 0x00 8.--16. 1. " KCD ,Keypad Column Data."


tree.end



;--------------------------------------------------------------------------------
; LDB
;--------------------------------------------------------------------------------
tree "LDB"
    base ad:0x020e0008

width 5.
group.long 0x0++0x3
    line.long 0x00 "CTRL,LDB Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " CH0_MODE ,LVDS channel 0 operation mode"
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " CH1_MODE ,LVDS channel 1 operation mode"
        textline "    "
        bitfld.long 0x00 4. " SPLIT_MODE_EN ,Enable split mode." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DATA_WIDTH_CH0 ,Data width for LVDS channel 0." "0,1"
        textline "    "
        bitfld.long 0x00 6. " BIT_MAPPING_CH0 ,Data mapping for LVDS channel 0." "0,1"
        textline "    "
        bitfld.long 0x00 7. " DATA_WIDTH_CH1 ,Data width for LVDS channel 1." "0,1"
        textline "    "
        bitfld.long 0x00 8. " BIT_MAPPING_CH1 ,Data mapping for LVDS channel 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " DI0_VS_POLARITY ,Vsync polarity for IPU's DI0 interface." "0,1"
        textline "    "
        bitfld.long 0x00 10. " DI1_VS_POLARITY ,Vsync polarity for IPU's DI1 interface." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--19. 1. " LVDS_CLK_SHIFT ,Shifts the LVDS output clock in relation to the data."
        textline "    "
        hexmask.long.byte 0x00 20.--22. 1. " COUNTER_RESET_VAL ,Reset value for the LDB counter which determines when the shift registers are loaded with data."


tree.end



;--------------------------------------------------------------------------------
; MIPI_CSI
;--------------------------------------------------------------------------------
tree "MIPI_CSI"
    base ad:0x021dc000

width 8.
rgroup.long 0x0++0x3
    line.long 0x00 "VERSION,Controller Version Identification Register"
        hexmask.long.long 0x00 0.--32. 1. " VERSION ,Version of the CSI-2 Host Controller Default Value: CSI_VERSION_ID"
width 8.
group.long 0x4++0x3
    line.long 0x00 "N_LANES,Number of Active Data Lanes"
        bitfld.long 0x00 0. " N_LANES ,Number of Active Data Lanes Can only be updated when the PHY lane is in stop state." "0,1"
width 14.
group.long 0x8++0x3
    line.long 0x00 "PHY_SHUTDOWNZ,Phy shutdown control"
        bitfld.long 0x00 0. " PHY_SHUTDOWNZ ,Shutdown input." "0,1"
width 10.
group.long 0xc++0x3
    line.long 0x00 "DPHY_RSTZ,Phy reset control"
        bitfld.long 0x00 0. " DPHY_RSTZ ,DPHY reset output." "0,1"
width 12.
group.long 0x10++0x3
    line.long 0x00 "CSI2_RESETN,CSI2 controller reset"
        bitfld.long 0x00 0. " CSI2_RESETN ,CSI-2 controller reset output." "0,1"
width 10.
rgroup.long 0x14++0x3
    line.long 0x00 "PHY_STATE,General settings for all blocks"
        bitfld.long 0x00 0. " PHY_RXULPSESC_0 ,Lane module 0 has entered the Ultra Low Power mode Default Value: 0" "0,1"
        textline "         "
        bitfld.long 0x00 1. " PHY_RXULPSESC_1 ,Lane module 1 has entered the Ultra Low Power mode Default Value: 0" "0,1"
        textline "         "
        bitfld.long 0x00 4. " PHY_STOPSTATEDATA_0 ,Data Lane 0 in Stop state Default Value: 0" "0,1"
        textline "         "
        bitfld.long 0x00 5. " PHY_STOPSTATEDATA_1 ,Data Lane 1 in Stop state Default Value: 0" "0,1"
        textline "         "
        bitfld.long 0x00 8. " PHY_RXCLKACTIVEHS ,Indicates that the clock lane is actively receiving a DDR clock Default Value: 0" "0,1"
        textline "         "
        bitfld.long 0x00 9. " PHY_RXULPSCLKNOT ,Active Low." "0,1"
        textline "         "
        bitfld.long 0x00 10. " PHY_STOPSTATECLK ,Clock Lane in Stop state Default Value: 0" "0,1"
        textline "         "
        bitfld.long 0x00 11. " BYPASS_2ECC_TST ,Payload Bypass test mode for double ECC errors Default Value: 0" "0,1"
width 11.
group.long 0x18++0x3
    line.long 0x00 "DATA_IDS_1,Data IDs for which IDI reports line boundary matching errors"
        hexmask.long.byte 0x00 0.--6. 1. " DI0_DT ,Data ID 0 Data Type Default Value: 0"
        textline "          "
        hexmask.long.byte 0x00 6.--8. 1. " DI0_VC ,Data ID 0 Virtual channel Default Value: 0"
        textline "          "
        hexmask.long.byte 0x00 8.--14. 1. " DI1_DT ,Data ID 1 Data Type Default Value: 0"
        textline "          "
        hexmask.long.byte 0x00 14.--16. 1. " DI1_VC ,Data ID 1 Virtual channel Default Value: 0"
        textline "          "
        hexmask.long.byte 0x00 16.--22. 1. " DI2_DT ,DATA ID 2 Data Type Default Value: 0"
        textline "          "
        hexmask.long.byte 0x00 22.--24. 1. " DI2_VC ,DATA ID 2 Virtual channel Default Value: 0"
        textline "          "
        hexmask.long.byte 0x00 24.--30. 1. " DI3_DT ,Data ID 3 Data Type Default Value: 0"
        textline "          "
        hexmask.long.byte 0x00 30.--32. 1. " DI3_VC ,Data ID 3 Virtual channel Default Value: 0"
width 5.
rgroup.long 0x20++0x3
    line.long 0x00 "ERR1,Error state register 1"
        bitfld.long 0x00 0. " PHY_ERRSOTSYNCHS_0 ,Start of Transmission Error on data lane 0 (no synchronization achieved) Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 1. " PHY_ERRSOTSYNCHS_1 ,Start of Transmission Error on data lane 1 (no synchronization achieved) Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 4. " ERR_F_BNDRY_MATCH_VC0 ,Error matching Frame Start with Frame End for Virtual Channel 0 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 5. " ERR_F_BNDRY_MATCH_VC1 ,Error matching Frame Start with Frame End for Virtual Channel 1 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 6. " ERR_F_BNDRY_MATCH_VC2 ,Error matching Frame Start with Frame End for Virtual Channel 2 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 7. " ERR_F_BNDRY_MATCH_VC3 ,Error matching Frame Start with Frame End for Virtual Channel 3 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 8. " ERR_F_SEQ_VC0 ,Incorrect Frame Sequence detected in Virtual Channel 0 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 9. " ERR_F_SEQ_VC1 ,Incorrect Frame Sequence detected in Virtual Channel 1 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 10. " ERR_F_SEQ_VC2 ,Incorrect Frame Sequence detected in Virtual Channel 2 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 11. " ERR_F_SEQ_VC3 ,Incorrect Frame Sequence detected in Virtual Channel 3 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 12. " ERR_FRAME_DATA_VC0 ,Last received frame, in Virtual Channel 0, had at least one CRC error Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 13. " ERR_FRAME_DATA_VC1 ,Last received frame, in Virtual Channel 1, had at least one CRC error Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR_FRAME_DATA_VC2 ,Last received frame, in Virtual Channel 2, had at least one CRC error Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 15. " ERR_FRAME_DATA_VC3 ,Last received frame, in Virtual Channel 3, had at least one CRC error Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 16. " ERR_L_BNDRY_MATCH_DI0 ,Error matching Line Start with Line End for vc0 and dt0 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 17. " ERR_L_BNDRY_MATCH_DI1 ,Error matching Line Start with Line End for vc1 and dt1 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 18. " ERR_L_BNDRY_MATCH_DI2 ,Error matching Line Start with Line End for vc2 and dt2 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 19. " ERR_L_BNDRY_MATCH_DI3 ,Error matching Line Start with Line End for vc3 and dt3 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 20. " ERR_L_SEQ_DI0 ,Error in the sequence of lines for vc0 and dt0 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 21. " ERR_L_SEQ_DI1 ,Error in the sequence of lines for vc1 and dt1 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 22. " ERR_L_SEQ_DI2 ,Error in the sequence of lines for vc2 and dt2 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 23. " ERR_L_SEQ_DI3 ,Error in the sequence of lines for vc3 and dt3 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 24. " VC0_ERR_CRC ,Checksum Error detected on Virtual Channel 0 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 25. " VC1_ERR_CRC ,Checksum Error detected on Virtual Channel 1 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 26. " VC2_ERR_CRC ,Checksum Error detected on Virtual Channel 2 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 27. " VC3_ERR_CRC ,Checksum Error detected on Virtual Channel 3 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 28. " ERR_ECC_DOUBLE ,Header ECC contains 2 errors." "0,1"
width 5.
rgroup.long 0x24++0x3
    line.long 0x00 "ERR2,Error state register 2"
        bitfld.long 0x00 0. " PHY_ERRESC_0 ,Escape Entry Error (ULPM) on data lane 0 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 1. " PHY_ERRESC_1 ,Escape Entry Error (ULPM) on data lane 1 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 4. " PHY_ERRSOTHS_0 ,Start of Transmission Error on data lane 0 (synchronization can still be achieved) Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 5. " PHY_ERRSOTHS_1 ,Start of Transmission Error on data lane 1 (synchronization can still be achieved) Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 8. " VC0_ERR_ECC_CORRECTED ,Header error detected and corrected on Virtual Channel 0 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 9. " VC1_ERR_ECC_CORRECTED ,Header error detected and corrected on Virtual Channel 1 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 10. " VC2_ERR_ECC_CORRECTED ,Header error detected and corrected on Virtual Channel 2 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 11. " VC3_ERR_ECC_CORRECTED ,Header error detected and corrected on Virtual Channel 3 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 12. " ERR_ID_VC0 ,Unrecognized or unimplemented data type detected in Virtual Channel 0 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 13. " ERR_ID_VC1 ,Unrecognized or unimplemented data type detected in Virtual Channel 1 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR_ID_VC2 ,Unrecognized or unimplemented data type detected in Virtual Channel 2 Default Value: 0" "0,1"
        textline "    "
        bitfld.long 0x00 15. " ERR_ID_VC3 ,Unrecognized or unimplemented data type detected in Virtual Channel 3 Default Value: 0" "0,1"
width 6.
group.long 0x2c++0x3
    line.long 0x00 "MASK2,Masks for errors 2"
        bitfld.long 0x00 0. " MASK_PHY_ERRESC_0 ,Mask for phy_erresc_0." "0,1"
        textline "     "
        bitfld.long 0x00 1. " MASK_PHY_ERRESC_1 ,Mask for phy_erresc_1." "0,1"
        textline "     "
        bitfld.long 0x00 4. " MASK_PHY_ERRSOTHS_0 ,Mask for phy_errsoths_0." "0,1"
        textline "     "
        bitfld.long 0x00 5. " MASK_PHY_ERRSOTHS_1 ,Mask for phy_errsoths_1." "0,1"
        textline "     "
        bitfld.long 0x00 8. " MASK_VC0_ERR_ECC_CORRECTED ,Mask for vc0_err_ecc_corrected." "0,1"
        textline "     "
        bitfld.long 0x00 9. " MASK_VC1_ERR_ECC_CORRECTED ,Mask for vc1_err_ecc_corrected." "0,1"
        textline "     "
        bitfld.long 0x00 10. " MASK_VC2_ERR_ECC_CORRECTED ,Mask for vc2_err_ecc_corrected." "0,1"
        textline "     "
        bitfld.long 0x00 11. " MASK_VC3_ERR_ECC_CORRECTED ,Mask for vc3_err_ecc_corrected." "0,1"
        textline "     "
        bitfld.long 0x00 12. " MASK_ERR_ID_VC0 ,Mask for err_id_vc0." "0,1"
        textline "     "
        bitfld.long 0x00 13. " MASK_ERR_ID_VC1 ,Mask for err_id_vc1." "0,1"
        textline "     "
        bitfld.long 0x00 14. " MASK_ERR_ID_VC2 ,Mask for err_id_vc2." "0,1"
        textline "     "
        bitfld.long 0x00 15. " MASK_ERR_ID_VC3 ,Mask for err_id_vc3." "0,1"
width 14.
group.long 0x30++0x3
    line.long 0x00 "PHY_TST_CRTL0,D-PHY Test interface control 0"
        bitfld.long 0x00 0. " PHY_TESTCLR ,PHY test interface clear." "0,1"
        textline "             "
        bitfld.long 0x00 1. " PHY_TESTCLK ,PHY test interface strobe signal." "0,1"
width 14.
group.long 0x34++0x3
    line.long 0x00 "PHY_TST_CTRL1,D-PHY Test interface control 1"
        hexmask.long.byte 0x00 0.--8. 1. " PHY_TESTDIN ,PHY test interface input 8-bit data bus for internal register programming and test functionalities access Default Value: 0"
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " PHY_TESTDOUT ,PHY output 8-bit data bus for read-back and internal probing functionalities."
        textline "             "
        bitfld.long 0x00 16. " PHY_TESTEN ,PHY test interface operation selector:" "0,1"


tree.end



;--------------------------------------------------------------------------------
; MIPI_DSI
;--------------------------------------------------------------------------------
tree "MIPI_DSI"
    base ad:0x021e0000

width 8.
rgroup.long 0x0++0x3
    line.long 0x00 "VERSION,Version of the DSI host ctrl"
        hexmask.long.long 0x00 0.--32. 1. " VERSION ,Version of the DSI host controller"
width 7.
group.long 0x4++0x3
    line.long 0x00 "PWR_UP,Core power up"
        bitfld.long 0x00 0. " SHUTDOWNZ ,Core power up" "0,1"
width 11.
group.long 0x8++0x3
    line.long 0x00 "CLKMGR_CFG,Number of active data lanes"
        hexmask.long.byte 0x00 0.--8. 1. " TX_ESC_CLK_DIVIDSION ,Division factor for TX ESCAPE clock source (lanebyteclk pin), values 0 and 1 stop TX_ESC clock generation."
        textline "          "
        hexmask.long.byte 0x00 8.--16. 1. " TO_CLK_DIVIDSION ,Division factor for Time Out clock used as timing unit in the configuration of HS to LP and LP to HS transition error."
width 8.
group.long 0xc++0x3
    line.long 0x00 "DPI_CFG,DPI interface configuration"
        hexmask.long.byte 0x00 0.--2. 1. " DPI_VID ,Configures the DPI Virtual Channel ID that will be indexed to the Video mode packets."
        textline "       "
        hexmask.long.byte 0x00 2.--5. 1. " DPI_COLOR_CODING ,DPI color coding."
        textline "       "
        bitfld.long 0x00 5. " DATAEN_ACTIVE_LOW ,Set to configure Data enable pin (dpidaten) as Active low" "0,1"
        textline "       "
        bitfld.long 0x00 6. " VSYNC_ACTIVE_LOW ,Set to configure Vertical Synchronism pin (dpivsync) as Active low" "0,1"
        textline "       "
        bitfld.long 0x00 7. " HSYNC_ACTIVE_LOW ,Set to configure Horizontal Synchronism pin (dpihsync) as Active low" "0,1"
        textline "       "
        bitfld.long 0x00 8. " SHUTD_ACTIVE_LOW ,Set to configure Shut Down pin (dpishutdn) as Active low" "0,1"
        textline "       "
        bitfld.long 0x00 9. " COLORM_ACTIVE_LOW ,Set to configure Color Mode pin (dpicolcorm) as Active low" "0,1"
        textline "       "
        bitfld.long 0x00 10. " EN18_LOOSELY ,Enable 18 loosely packet pixel stream." "0,1"
width 8.
group.long 0x10++0x3
    line.long 0x00 "DBI_CFG,DBI interface configuration"
        hexmask.long.byte 0x00 0.--2. 1. " DBI_VID ,Configures the DBI Virtual Channel ID that will be indexed to the DCS packets."
        textline "       "
        hexmask.long.byte 0x00 2.--6. 1. " IN_DBI_CONF ,Configures DBI input pixel data configuration;"
        textline "       "
        hexmask.long.byte 0x00 6.--8. 1. " LUT_SIZE_CONF ,Configures the size used to transport Write Lut commands;"
        textline "       "
        bitfld.long 0x00 8. " PARTITIONING_EN ,Enables write memory continue through input command (system needs to ensure correct partitioning of Long Write commands)" "0,1"
        textline "       "
        hexmask.long.byte 0x00 9.--13. 1. " OUT_DBI_CONF ,Configures the DBI output pixel data configuration;"
width 13.
group.long 0x14++0x3
    line.long 0x00 "DBIS_CMDSIZE,DBI command size configuration"
        hexmask.long.word 0x00 0.--16. 1. " WR_CMD_SIZE ,Configures the size of the DCS write memory commands."
        textline "            "
        hexmask.long.word 0x00 16.--32. 1. " ALLOWED_CMD_SIZE ,Configures the maximum allowed size of a DCS write memory command."
width 11.
group.long 0x18++0x3
    line.long 0x00 "PCKHDL_CFG,Packet handler configuration"
        bitfld.long 0x00 0. " EN_EOTP_TX ,Enables EOTp transmission" "0,1"
        textline "          "
        bitfld.long 0x00 1. " EN_EOTN_RX ,Enables EOTp reception" "0,1"
        textline "          "
        bitfld.long 0x00 2. " EN_BTA ,Enables Bus Turn-Around request" "0,1"
        textline "          "
        bitfld.long 0x00 3. " EN_ECC_RX ,Enables ECC reception, error correction and reporting" "0,1"
        textline "          "
        bitfld.long 0x00 4. " EN_CRC_RX ,Enables CRC reception and error reporting" "0,1"
        textline "          "
        hexmask.long.byte 0x00 5.--7. 1. " GEN_VID_RX ,Generic interface read-back Virtual Channel identification"
width 13.
group.long 0x1c++0x3
    line.long 0x00 "VID_MODE_CFG,Video Mode Configuration"
        bitfld.long 0x00 0. " EN_VIDEO_MODE ,Enables DPI Video mode transmission" "0,1"
        textline "            "
        hexmask.long.byte 0x00 1.--3. 1. " VID_MODE_TYPE ,Selects video mode transmission type."
        textline "            "
        bitfld.long 0x00 3. " EN_LP_VSA ,Enables return to Low Power inside VSA period when timing allows" "0,1"
        textline "            "
        bitfld.long 0x00 4. " EN_LP_VBP ,Enables return to Low Power inside VBP period when timing allows" "0,1"
        textline "            "
        bitfld.long 0x00 5. " EN_LP_VFP ,Enables return to Low Power inside VFP period when timing allows" "0,1"
        textline "            "
        bitfld.long 0x00 6. " EN_LP_VACT ,Enables return to Low Power inside VACT period when timing allows" "0,1"
        textline "            "
        bitfld.long 0x00 7. " EN_LP_HBP ,Enables return to Low Power inside HBP period when timing allows" "0,1"
        textline "            "
        bitfld.long 0x00 8. " EN_LP_HFP ,Enables return to Low Power inside HFP period when timing allows" "0,1"
        textline "            "
        bitfld.long 0x00 9. " EN_MULTI_PKT ,Enables the tranmission of multi video packets in the HACT period" "0,1"
        textline "            "
        bitfld.long 0x00 10. " EN_NULL_PKT ,Enables the tranmission of null packets in the HACT period" "0,1"
        textline "            "
        bitfld.long 0x00 11. " FRAME_BTA_ACK ,Enables the request for an acknowledge response at the end of a frame" "0,1"
width 12.
group.long 0x20++0x3
    line.long 0x00 "VID_PKT_CFG,Video packet configuration"
        hexmask.long.word 0x00 0.--11. 1. " VID_PKT_SIZE ,Configures the number of pixel on a single video packet."
        textline "           "
        hexmask.long.word 0x00 11.--21. 1. " NUM_CHUNKS ,Configures the number of chunks to be transmitted during a Line period."
        textline "           "
        hexmask.long.word 0x00 21.--31. 1. " NULL_PKT_SIZE ,Configures the number of bytes in a null packet"
width 13.
group.long 0x24++0x3
    line.long 0x00 "CMD_MODE_CFG,Command mode configuration"
        bitfld.long 0x00 0. " EN_CMD_MODE ,Enables the Command Mode Protocol for transmissions." "0,1"
        textline "            "
        bitfld.long 0x00 1. " GEN_SW_0P_TX ,Configures the Generic Short Write Packet with 0 Parameters command transmission type." "0,1"
        textline "            "
        bitfld.long 0x00 2. " GEN_SW_1P_TX ,Configures the Generic Short Write Packet with 1 Parameters command transmission type." "0,1"
        textline "            "
        bitfld.long 0x00 3. " GEN_SW_2P_TX ,Configures the Generic Short Write Packet with 2 Parameters command transmission type." "0,1"
        textline "            "
        bitfld.long 0x00 4. " GEN_SR_0P_TX ,Configures the Generic Short Read Packet with 0 Parameters command transmission type." "0,1"
        textline "            "
        bitfld.long 0x00 5. " GEN_SR_1P_TX ,Configures the Generic Short Read Packet with 1 Parameters command transmission type." "0,1"
        textline "            "
        bitfld.long 0x00 6. " GEN_SR_2P_TX ,Configures the Generic Short Read Packet with 2 Parameters command transmission type." "0,1"
        textline "            "
        bitfld.long 0x00 7. " DCS_SW_0P_TX ,Configures the DCS Short Write Packet with 0 Parameters command transmission type." "0,1"
        textline "            "
        bitfld.long 0x00 8. " DCS_SW_1P_TX ,Configures the DCS Short Write Packet with 1 Parameters command transmission type." "0,1"
        textline "            "
        bitfld.long 0x00 9. " DCS_SW_2P_TX ,Configures the DCS Short Write Packet with 2 Parameters command transmission type." "0,1"
        textline "            "
        bitfld.long 0x00 10. " MAX_RD_PKT_SIZE ,Configures the Maximum Read Packet Size command transmission type." "0,1"
        textline "            "
        bitfld.long 0x00 11. " GEN_LW_TX ,Configures the Generic Long Write Packet command transmission type." "0,1"
        textline "            "
        bitfld.long 0x00 12. " DCS_LW_TX ,Configures the DCS Long Write Packet command transmission type." "0,1"
        textline "            "
        bitfld.long 0x00 13. " EN_ACK_RQST ,Enables the acknowledge request after each packet transmission" "0,1"
        textline "            "
        bitfld.long 0x00 14. " EN_TEAR_FX ,Enables the tearing effect acknowledge request" "0,1"
width 13.
group.long 0x28++0x3
    line.long 0x00 "TMR_LINE_CFG,Line timer configuration"
        hexmask.long.word 0x00 0.--9. 1. " HSA_TIME ,Configures the Horizontal Synchronism Active period in lane byte clock cycles"
        textline "            "
        hexmask.long.word 0x00 9.--18. 1. " HBP_TIME ,Configures the Horizontal Back Porch period in lane byte clock cycles"
        textline "            "
        hexmask.long.word 0x00 18.--32. 1. " HLINE_TIME ,Configures the size of the total line counted in lane byte cycles"
width 12.
group.long 0x2c++0x3
    line.long 0x00 "VTIMING_CFG,Vertical timing configuration"
        hexmask.long.byte 0x00 0.--4. 1. " VSA_LINES ,Configures the Vertical Synchronism Active period measured in horizontal lines"
        textline "           "
        hexmask.long.byte 0x00 4.--10. 1. " VBP_LINES ,Configures the Vertical Back Porch period measured in horizontal lines"
        textline "           "
        hexmask.long.byte 0x00 10.--16. 1. " VFP_LINES ,Configures the Vertical Front Porch period measured in horizontal lines"
        textline "           "
        hexmask.long.word 0x00 16.--27. 1. " V_ACTIVE_LINES ,Configures the Vertical Active period measured in horizontal lines"
width 12.
group.long 0x30++0x3
    line.long 0x00 "PHY_TMR_CFG,D-PHY timing configuration"
        hexmask.long.word 0x00 0.--12. 1. " BTA_TIME ,Configures the maximum time required to perform the Bus Turn Around operation measured in lane byte clock cycles"
        textline "           "
        hexmask.long.byte 0x00 12.--20. 1. " PHY_LP2HS_TIME ,Configures the maximum time that the PHY takes to go from Low Power to High Speed transmission measured in lane byte clock cycles"
        textline "           "
        hexmask.long.byte 0x00 20.--28. 1. " PHY_HS2LP_TIME ,Configures the maximum time that the PHY takes to go from High Speed to Low Power transmission measured in lane byte clock cycles"
width 8.
group.long 0x34++0x3
    line.long 0x00 "GEN_HDR,Generic packet Header configuration"
        hexmask.long.byte 0x00 0.--8. 1. " GEN_HTYPE ,Configures the packet type to be transmitted through the generic interface."
        textline "       "
        hexmask.long.word 0x00 8.--24. 1. " GEN_HDATA ,Configures the packet data to be transmitted through the generic interface"
width 13.
group.long 0x38++0x3
    line.long 0x00 "GEN_PLD_DATA,Generic payload data in/out"
        hexmask.long.long 0x00 0.--32. 1. " GEN_PLD_DATA ,This register contains the input/output generic packet data."
width 15.
group.long 0x3c++0x3
    line.long 0x00 "CMD_PKT_STATUS,Command packet status"
        bitfld.long 0x00 0. " GEN_CMD_EMPTY ,Reports the empty status of the generic command FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 1. " GEN_CMD_FULL ,Reports the full status of the generic command FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 2. " GEN_PLD_W_EMPTY ,Reports the empty status of the generic write payload FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 3. " GEN_PLD_W_FULL ,Reports the full status of the generic write payload FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 4. " GEN_PLD_R_EMPTY ,Reports the empty status of the generic read payload FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 5. " GEN_PLD_R_FULL ,Reports the full status of the generic read payload FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 6. " GEN_RD_CMD_BUSY ,Set when a read command is issued and cleared once the entire response is stored in the FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 8. " DBI_CMD_EMPTY ,Reports the empty status of the DBI command FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 9. " DBI_CMD_FULL ,Reports the full status of the DBI command FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 10. " DBI_PLD_W_EMPTY ,Reports the empty status of the DBI write payload FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 11. " DBI_PLD_W_FULL ,Reports the full status of the DBI write payload FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 12. " DBI_PLD_R_EMPTY ,Reports the empty status of the DBI read payload FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 13. " DBI_PLD_R_FULL ,Reports the full status of the DBI read payload FIFO" "0,1"
        textline "              "
        bitfld.long 0x00 14. " DBI_RD_CMD_BUSY ,Set when a read command is issued and cleared once the entire response is stored in the FIFO" "0,1"
width 12.
group.long 0x40++0x3
    line.long 0x00 "TO_CNT_CFG0,Time Out timers configuration"
        hexmask.long.word 0x00 0.--16. 1. " HSTX_TO_CNT ,Configures the time out counter that will trigger a High Speed Transmission Time Out Contention Detection (Measured in TO_CLK_DIVISION cycles)"
        textline "           "
        hexmask.long.word 0x00 16.--32. 1. " LPRX_TO_CNT ,Configures the time out counter that will trigger a Low Power Reception Time Out Contention Detection."
width 10.
group.long 0x44++0x3
    line.long 0x00 "ERROR_ST0,Interrupt status register 0"
        bitfld.long 0x00 0. " ACK_WITH_ERR_0 ,Retrieves SoT Error from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 1. " ACK_WITH_ERR_1 ,Retrieves SoT Sync Error from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 2. " ACK_WITH_ERR_2 ,Retrieves EoT Sync Error from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 3. " ACK_WITH_ERR_3 ,Retrieves Escape Mode Entry Command Error from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 4. " ACK_WITH_ERR_4 ,Retrieves Low-Power Transmit Sync Error from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 5. " ACK_WITH_ERR_5 ,Retrieves HS Receive Timeout Error from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 6. " ACK_WITH_ERR_6 ,Retrieves False Control Error from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 7. " ACK_WITH_ERR_7 ,Retrieves Reserved (specific to device) from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 8. " ACK_WITH_ERR_8 ,Retrieves ECC Error, single-bit (detected and corrected) from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 9. " ACK_WITH_ERR_9 ,Retrieves ECC Error, multi-bit (detected, not corrected) from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 10. " ACK_WITH_ERR_10 ,Retrieves Checksum Error (Long packet only) from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 11. " ACK_WITH_ERR_11 ,Retrieves DSI Data Type Not Recognized from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 12. " ACK_WITH_ERR_12 ,Retrieves DSI VC ID Invalid from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 13. " ACK_WITH_ERR_13 ,Retrieves Invalid Transmission Length from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 14. " ACK_WITH_ERR_14 ,Retrieves Reserved (specific to device) from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 15. " ACK_WITH_ERR_15 ,Retrieves DSI Protocol Violation from Display Acknowledge Error Report" "0,1"
        textline "         "
        bitfld.long 0x00 16. " DPHY_ERRORS_0 ,ErrEsc Escape Entry Error from Lane 0" "0,1"
        textline "         "
        bitfld.long 0x00 17. " DPHY_ERRORS_1 ,ErrSyncEsc Low-Power Data Transmission Synchronization Error from Lane 0" "0,1"
        textline "         "
        bitfld.long 0x00 18. " DPHY_ERRORS_2 ,ErrControl Control Error from Lane 0" "0,1"
        textline "         "
        bitfld.long 0x00 19. " DPHY_ERRORS_3 ,ErrContentionLP0 LP0 Contention Error from Lane 0" "0,1"
        textline "         "
        bitfld.long 0x00 20. " DPHY_ERRORS_4 ,ErrContentionLP1 LP1 Contention Error from Lane 0" "0,1"
width 10.
group.long 0x48++0x3
    line.long 0x00 "ERROR_ST1,Interrupt status register 1"
        bitfld.long 0x00 0. " TO_HS_TX ,High Speed Transmission Time Out Counter reached the end and Contention Detection as been detected" "0,1"
        textline "         "
        bitfld.long 0x00 1. " TO_LP_RX ,Low Power Reception Time Out Counter reached the end and Contention Detection as been detected" "0,1"
        textline "         "
        bitfld.long 0x00 2. " ECC_SINLGE_ERR ,ECC single error was detected and corrected in a received packet" "0,1"
        textline "         "
        bitfld.long 0x00 3. " ECC_MULTI_ERR ,ECC multiple error was detected in a received packet" "0,1"
        textline "         "
        bitfld.long 0x00 4. " CRC_ERR ,CRC error was detected in the received packet payload" "0,1"
        textline "         "
        bitfld.long 0x00 5. " PKT_SIZE_ERR ,Packet size error was detected during packet reception" "0,1"
        textline "         "
        bitfld.long 0x00 6. " EOPT_ERR ,EOTp Packet not received at the end of the incoming peripheral transmission" "0,1"
        textline "         "
        bitfld.long 0x00 7. " DPI_PLD_WR_ERR ,During a DPI pixel line storage the payload FIFO went full and data stored is corrupted" "0,1"
        textline "         "
        bitfld.long 0x00 8. " GEN_CMD_WR_ERR ,System tried to write a command through the generic interface and FIFO was full, therefore the command was not written" "0,1"
        textline "         "
        bitfld.long 0x00 9. " GEN_PLD_WR_ERR ,System tried to write a payload data through the generic interface and FIFO was full, therefore the payload was not written" "0,1"
        textline "         "
        bitfld.long 0x00 10. " GEN_PLD_SEND_ERR ,During a generic interface packet build, the payload FIFO went empty and data was sent corrupted" "0,1"
        textline "         "
        bitfld.long 0x00 11. " GEN_PLD_RD_ERR ,During a DCS read data, the payload FIFO went empty and data was send to the interface corrupted" "0,1"
        textline "         "
        bitfld.long 0x00 12. " GEN_PLD_RECV_ERR ,During a generic interface packet read back, the payload FIFO went full and received data was corrupted" "0,1"
        textline "         "
        bitfld.long 0x00 13. " DBI_CMD_WR_ERR ,System tried to write a command through the DBI but the command FIFO was full, therefore the command was not written" "0,1"
        textline "         "
        bitfld.long 0x00 14. " DBI_PLD_WR_ERR ,System tried to write payload data through the DBI interface and the FIFO was full, therefore the Command was not written" "0,1"
        textline "         "
        bitfld.long 0x00 15. " DBI_PLD_RD_ERR ,During a DCS read data, the payload FIFO went empty and data was send to the interface corrupted" "0,1"
        textline "         "
        bitfld.long 0x00 16. " DBI_PLD_RECV_ERR ,During a DBI read back packet, the payload FIFO went full and received data was corrupted" "0,1"
        textline "         "
        bitfld.long 0x00 17. " DBI_ILLEGAL_COMM_ERR ,Attempt to write an illegal command on the DPI interface and core blocked by transmission" "0,1"
width 11.
group.long 0x4c++0x3
    line.long 0x00 "ERROR_MSK0,Masks Interrupt generation trigged by ERROR_ST0 register"
        bitfld.long 0x00 0. " ACK_WITH_ERR_0 ,Masks SoT Error from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 1. " ACK_WITH_ERR_1 ,Masks SoT Sync Error from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 2. " ACK_WITH_ERR_2 ,Masks EoT Sync Error from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 3. " ACK_WITH_ERR_3 ,Masks Escape Mode Entry Command Error from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 4. " ACK_WITH_ERR_4 ,Masks Low-Power Transmit Sync Error from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 5. " ACK_WITH_ERR_5 ,Masks HS Receive Timeout Error from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 6. " ACK_WITH_ERR_6 ,Masks False Control Error from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 7. " ACK_WITH_ERR_7 ,Masks Reserved (specific to device) from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 8. " ACK_WITH_ERR_8 ,Masks ECC Error, single-bit (detected and corrected) from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 9. " ACK_WITH_ERR_9 ,Masks ECC Error, multi-bit (detected, not corrected) from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 10. " ACK_WITH_ERR_10 ,Masks Checksum Error (Long packet only) from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 11. " ACK_WITH_ERR_11 ,Masks DSI Data Type Not Recognized from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 12. " ACK_WITH_ERR_12 ,Masks DSI VC ID Invalid from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 13. " ACK_WITH_ERR_13 ,Masks Invalid Transmission Length from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 14. " ACK_WITH_ERR_14 ,Masks Reserved (specific to device) from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 15. " ACK_WITH_ERR_15 ,Masks DSI Protocol Violation from Display Acknowledge Error Report" "0,1"
        textline "          "
        bitfld.long 0x00 16. " DPHY_ERRORS_0 ,ErrEsc Escape Entry Error from Lane 0" "0,1"
        textline "          "
        bitfld.long 0x00 17. " DPHY_ERRORS_1 ,ErrSyncEsc Low-Power Data Transmission Synchronization Error from Lane 0" "0,1"
        textline "          "
        bitfld.long 0x00 18. " DPHY_ERRORS_2 ,ErrControl Control Error from Lane 0" "0,1"
        textline "          "
        bitfld.long 0x00 19. " DPHY_ERRORS_3 ,ErrContentionLP0 LP0 Contention Error from Lane 0" "0,1"
        textline "          "
        bitfld.long 0x00 20. " DPHY_ERRORS_4 ,ErrContentionLP1 LP1 Contention Error from Lane 0" "0,1"
width 11.
group.long 0x50++0x3
    line.long 0x00 "ERROR_MSK1,Masks Interrupt generation trigged by ERROR_ST1 register"
        bitfld.long 0x00 0. " TO_HS_TX ,Masks High Speed Transmission Time Out Counter error" "0,1"
        textline "          "
        bitfld.long 0x00 1. " TO_LP_RX ,Masks Low Power Reception Time Out Counter error" "0,1"
        textline "          "
        bitfld.long 0x00 2. " ECC_SINLGE_ERR ,Masks ECC single error" "0,1"
        textline "          "
        bitfld.long 0x00 3. " ECC_MULTI_ERR ,Masks ECC multiple error" "0,1"
        textline "          "
        bitfld.long 0x00 4. " CRC_ERR ,Masks CRC error" "0,1"
        textline "          "
        bitfld.long 0x00 5. " PKT_SIZE_ERR ,Masks Packet size error" "0,1"
        textline "          "
        bitfld.long 0x00 6. " EOPT_ERR ,Masks EOTp Packet not received error" "0,1"
        textline "          "
        bitfld.long 0x00 7. " DPI_PLD_WR_ERR ,Masks DPI pixel line payload FIFO full error" "0,1"
        textline "          "
        bitfld.long 0x00 8. " GEN_CMD_WR_ERR ,Masks command FIFO of generic interface full error" "0,1"
        textline "          "
        bitfld.long 0x00 9. " GEN_PLD_WR_ERR ,Masks payload data FIFO of generic interface full error" "0,1"
        textline "          "
        bitfld.long 0x00 10. " GEN_PLD_SEND_ERR ,Masks generic interface packet build FIFO empty error" "0,1"
        textline "          "
        bitfld.long 0x00 11. " GEN_PLD_RD_ERR ,Masks DCS read data payload FIFO empty error" "0,1"
        textline "          "
        bitfld.long 0x00 12. " GEN_PLD_RECV_ERR ,Masks generic interface packet read back FIFO full error" "0,1"
        textline "          "
        bitfld.long 0x00 13. " DBI_CMD_WR_ERR ,Masks DBI command FIFO full error" "0,1"
        textline "          "
        bitfld.long 0x00 14. " DBI_PLD_WR_ERR ,Masks write payload data DBI FIFO full error" "0,1"
        textline "          "
        bitfld.long 0x00 15. " DBI_PLD_RD_ERR ,Masks payload DBI FIFO empty error" "0,1"
        textline "          "
        bitfld.long 0x00 16. " DBI_PLD_RECV_ERR ,Masks DBI read back packet payload FIFO full error" "0,1"
        textline "          "
        bitfld.long 0x00 17. " DBI_ILLEGAL_COMM_ERR ,Masks error attempt to write an illegal command on DPI" "0,1"
width 9.
group.long 0x54++0x3
    line.long 0x00 "PHY_RSTZ,D-PHY reset control"
        bitfld.long 0x00 0. " PHY_SHUTDOWNZ ,D-PHY Shutdown disable when 1, used to place the complete D-PHY macro in power down" "0,1"
        textline "        "
        bitfld.long 0x00 1. " PHY_RSTZ ,D-PHY Reset disable when 1, used to place the digital section of D-PHY in reset state" "0,1"
        textline "        "
        bitfld.long 0x00 2. " PHY_ENABLECLK ,Enables D-PHY Clock Lane Module when 1" "0,1"
width 11.
group.long 0x58++0x3
    line.long 0x00 "PHY_IF_CFG,D-PHY interface configuration"
        hexmask.long.byte 0x00 0.--2. 1. " N_LANES ,Number of active data lanes."
        textline "          "
        hexmask.long.byte 0x00 2.--10. 1. " PHY_STOP_WAIT_TIME ,Configures minimum wait period to request an HS transmission after the stop state accounted in clock lane cycles"
width 12.
group.long 0x5c++0x3
    line.long 0x00 "PHY_IF_CTRL,D-PHY PPI interface control"
        bitfld.long 0x00 0. " PHY_TXREQUESTCLKHS ,Controls D-PHY PPI txrequestclkHS" "0,1"
        textline "           "
        bitfld.long 0x00 1. " PHY_TXREQULPSCLK ,ULPS mode Request on Clock Lane" "0,1"
        textline "           "
        bitfld.long 0x00 2. " PHY_TXEXITULPSCLK ,ULPS mode Exit on Clock Lane" "0,1"
        textline "           "
        bitfld.long 0x00 3. " PHY_TXREQULPSLAN ,ULPS mode Request on all active data lanes" "0,1"
        textline "           "
        bitfld.long 0x00 4. " PHY_TXEXITULPSLAN ,ULPS mode Exit on on all active data lanes" "0,1"
        textline "           "
        hexmask.long.byte 0x00 5.--9. 1. " PHY_TX_TRIGGERS ,Controls the trigger transmissions"
width 11.
group.long 0x60++0x3
    line.long 0x00 "PHY_STATUS,D-PHY PPI status interface"
        bitfld.long 0x00 0. " PHYLOCK ,Reports status of phylock D-PHY pin" "0,1"
        textline "          "
        bitfld.long 0x00 1. " PHYDIRECTION ,Reports status of phydirection D-PHY pin" "0,1"
        textline "          "
        bitfld.long 0x00 2. " PHYSTOPSTATECLKLANE ,Reports status of phystopstateclklane D-PHY pin" "0,1"
        textline "          "
        bitfld.long 0x00 3. " PHYRXULPSCLKNOT ,Reports status of phyrxulpsclknot D-PHY pin" "0,1"
        textline "          "
        bitfld.long 0x00 4. " PHYSTOPSTATE0LANE ,Reports status of phystopstate0lane D-PHY pin" "0,1"
        textline "          "
        bitfld.long 0x00 5. " ULPSACTIVENOT0LANE ,Reports status of ulpsactivenot0lane D-PHY pin" "0,1"
        textline "          "
        bitfld.long 0x00 6. " RXULPSESC0LANE ,Reports status of rxulpsEsc0lane D-PHY pin" "0,1"
        textline "          "
        bitfld.long 0x00 7. " PHYSTOPSTATE1LANE ,Reports status of phystopstate1lane D-PHY pin" "0,1"
        textline "          "
        bitfld.long 0x00 8. " ULPSACTIVENOT1LANE ,Reports status of ulpsactivenot1lane D-PHY pin" "0,1"
        textline "          "
        bitfld.long 0x00 9. " PHYSTOPSTATE2LANE ,Reports status of phystopstate2lane D-PHY pin" "0,1"
        textline "          "
        bitfld.long 0x00 10. " ULPSACTIVENOT2LANE ,Reports status of ulpsactivenot2lane D-PHY pin" "0,1"
        textline "          "
        bitfld.long 0x00 11. " PHYSTOPSTATE3LANE ,Reports status of phystopstate3lane D-PHY pin" "0,1"
        textline "          "
        bitfld.long 0x00 12. " ULPSACTIVENOT3LANE ,Reports status of ulpsactivenot3lane D-PHY pin" "0,1"
width 14.
group.long 0x64++0x3
    line.long 0x00 "PHY_TST_CTRL0,D-PHY Test interface control 0"
        bitfld.long 0x00 0. " PHY_TESTCLR ,PHY test interface clear." "0,1"
        textline "             "
        bitfld.long 0x00 1. " PHY_TESTCLK ,PHY test interface strobe signal." "0,1"
width 14.
group.long 0x68++0x3
    line.long 0x00 "PHY_TST_CTRL1,D-PHY Test interface control 1"
        hexmask.long.byte 0x00 0.--8. 1. " PHY_TESTDIN ,PHY test interface input 8-bit data bus for internal register programming and test functionalities access"
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " PHY_TESTDOUT ,PHY output 8-bit data bus for read-back and internal probing functionalities"
        textline "             "
        bitfld.long 0x00 16. " PHY_TESTEN ,PHY test interface operation selector: when 1 configures address write operation on the falling edge of TESTCLK; when 0 configures a data write operation on the rising edge of TESTCLK" "0,1"


tree.end



;--------------------------------------------------------------------------------
; MIPI_HSI
;--------------------------------------------------------------------------------
tree "MIPI_HSI"
    base ad:0x02208000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CTRL,HSI Control Register"
        hexmask.long.byte 0x00 0.--4. 1. " TX_CLK_DIVISOR ,This register holds the divisor of the base clock (tx_refclk) frequency for HSI Tx clock (internal clock used to drive Transmitter interface)."
        textline "    "
        bitfld.long 0x00 4. " TX_BREAK ,Seeting this bit to one trigger a transmission break at HSI Tx." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--12. 1. " DATA_TIMEOUT_CNT ,This value determines the interval by which DATA timeouts are detected."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " RX_TAIL_BIT_CNT ,The value determines the length of the Tailing bit counter."
        textline "    "
        hexmask.long.byte 0x00 16.--24. 1. " RX_FRAME_BRST_CNT ,This value is to limit the continous Frame transmission count in Pipelined Data flow."
        textline "    "
        hexmask.long.byte 0x00 24.--27. 1. " RX_DLY_SEL ,These values denote the tap delay values for reception of data and flag."
        textline "    "
        bitfld.long 0x00 27. " DMA_DISABLE ,This bit must be set to zero for any DMA operation." "0,1"
        textline "    "
        bitfld.long 0x00 30. " CLKGATE ,This bit must be set to zero for normal operation." "0,1"
        textline "    "
        bitfld.long 0x00 31. " SFTRST ,Set this bit to zero to enable normal HSI operation." "0,1"
width 8.
group.long 0x4++0x3
    line.long 0x00 "TX_CONF,HSI Tx Config Register"
        bitfld.long 0x00 0. " TRANS_MODE ," "0,1"
        textline "       "
        bitfld.long 0x00 1. " WAKEUP ,When this bit gets set to one, HSI transmitter sends HSI_TX_WAKE signal to Rx of other device." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--12. 1. " TIMEOUT_CNT ,"
        textline "       "
        bitfld.long 0x00 16. " CH0_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 17. " CH1_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 18. " CH2_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 19. " CH3_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 20. " CH4_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 21. " CH5_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 22. " CH6_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 23. " CH7_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 24. " CH8_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 25. " CH9_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 26. " CH10_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 27. " CH11_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 28. " CH12_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 29. " CH13_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 30. " CH14_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 31. " CH15_EN ," "0,1"
width 8.
group.long 0x8++0x3
    line.long 0x00 "RX_CONF,HSI Rx Config Register"
        hexmask.long.byte 0x00 0.--2. 1. " DATA_FLOW ,"
        textline "       "
        bitfld.long 0x00 2. " WAKE ," "0,1"
        textline "       "
        bitfld.long 0x00 3. " REC_MODE ," "0,1"
        textline "       "
        bitfld.long 0x00 4. " TAIL_BIT_CNT_EN ," "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--15. 1. " TIMEOUT_CNT ,Receive Frame Timeout Counter: The counter shall be started when the first bit of the Frame has been found."
        textline "       "
        bitfld.long 0x00 16. " CH0_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 17. " CH1_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 18. " CH2_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 19. " CH3_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 20. " CH4_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 21. " CH5_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 22. " CH6_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 23. " CH7_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 24. " CH8_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 25. " CH9_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 26. " CH10_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 27. " CH11_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 28. " CH12_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 29. " CH13_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 30. " CH14_EN ," "0,1"
        textline "       "
        bitfld.long 0x00 31. " CH15_EN ," "0,1"
width 4.
rgroup.long 0xc++0x3
    line.long 0x00 "CAP,HSI Capability Register"
        hexmask.long.byte 0x00 0.--4. 1. " TX_CH_NU_SUPPORTE ,"
        textline "   "
        hexmask.long.byte 0x00 4.--8. 1. " RX_CH_NU_SUPPORTE ,"
        textline "   "
        hexmask.long.byte 0x00 8.--13. 1. " DMA_CH_NU_SUPPORT ,"
        textline "   "
        bitfld.long 0x00 16. " TX_DMA_SUPPORT ," "0,1"
        textline "   "
        bitfld.long 0x00 17. " RX_DMA_SUPPORT ," "0,1"
        textline "   "
        bitfld.long 0x00 18. " WAKEUP_EVENT ," "0,1"
width 8.
group.long 0x10++0x3
    line.long 0x00 "TX_WML0,HSI Tx Water Mark Level 0 Register"
        hexmask.long.byte 0x00 0.--4. 1. " CH8 ,This value denotes the WML of Tx Channel 8."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " CH9 ,This value denotes the WML of Tx Channel 9."
        textline "       "
        hexmask.long.byte 0x00 8.--12. 1. " CH10 ,This value denotes the WML of Tx Channel 10."
        textline "       "
        hexmask.long.byte 0x00 12.--16. 1. " CH11 ,This value denotes the WML of Tx Channel 11."
        textline "       "
        hexmask.long.byte 0x00 16.--20. 1. " CH12 ,This value denotes the WML of Tx Channel 12."
        textline "       "
        hexmask.long.byte 0x00 20.--24. 1. " CH13 ,This value denotes the WML of Tx Channel 13."
        textline "       "
        hexmask.long.byte 0x00 24.--28. 1. " CH14 ,This value denotes the WML of Tx Channel 14."
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " CH15 ,This value denotes the WML of Tx Channel 15."
width 8.
group.long 0x14++0x3
    line.long 0x00 "TX_TML1,HSI Tx Water Mark Level 1 Register"
        hexmask.long.byte 0x00 0.--4. 1. " CH0 ,This value denotes the WML of Tx Channel 0."
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " CH1 ,This value denotes the WML of Tx Channel 1."
        textline "       "
        hexmask.long.byte 0x00 8.--12. 1. " CH2 ,This value denotes the WML of Tx Channel 2."
        textline "       "
        hexmask.long.byte 0x00 12.--16. 1. " CH3 ,This value denotes the WML of Tx Channel 3."
        textline "       "
        hexmask.long.byte 0x00 16.--20. 1. " CH4 ,This value denotes the WML of Tx Channel 4."
        textline "       "
        hexmask.long.byte 0x00 20.--24. 1. " CH5 ,This value denotes the WML of Tx Channel 5."
        textline "       "
        hexmask.long.byte 0x00 24.--28. 1. " CH6 ,This value denotes the WML of Tx Channel 6."
        textline "       "
        hexmask.long.byte 0x00 28.--32. 1. " CH7 ,This value denotes the WML of Tx Channel 7."
width 12.
group.long 0x18++0x3
    line.long 0x00 "TX_ARB_PRI0,HSI Tx Arbiter Priority 0 Register"
        hexmask.long.byte 0x00 0.--4. 1. " CH0 ,This value denotes the priority of Tx Channel 0."
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " CH1 ,This value denotes the priority of Tx Channel 1."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " CH2 ,This value denotes the priority of Tx Channel 2."
        textline "           "
        hexmask.long.byte 0x00 12.--16. 1. " CH3 ,This value denotes the priority of Tx Channel 3."
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " CH4 ,This value denotes the priority of Tx Channel 4."
        textline "           "
        hexmask.long.byte 0x00 20.--24. 1. " CH5 ,This value denotes the priority of Tx Channel 5."
        textline "           "
        hexmask.long.byte 0x00 24.--28. 1. " CH6 ,This value denotes the priority of Tx Channel 6."
        textline "           "
        hexmask.long.byte 0x00 28.--32. 1. " CH7 ,This value denotes the priority of Tx Channel 7."
width 12.
group.long 0x1c++0x3
    line.long 0x00 "TX_ARB_PRI1,HSI Tx Arbiter Priority 1 Register"
        hexmask.long.byte 0x00 0.--4. 1. " CH8 ,This value denotes the priority of Tx Channel 8."
        textline "           "
        hexmask.long.byte 0x00 4.--8. 1. " CH9 ,This value denotes the priority of Tx Channel 9."
        textline "           "
        hexmask.long.byte 0x00 8.--12. 1. " CH10 ,This value denotes the priority of Tx Channel 10."
        textline "           "
        hexmask.long.byte 0x00 12.--16. 1. " CH11 ,This value denotes the priority of Tx Channel 11."
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " CH12 ,This value denotes the priority of Tx Channel 12."
        textline "           "
        hexmask.long.byte 0x00 20.--24. 1. " CH13 ,This value denotes the priority of Tx Channel 13."
        textline "           "
        hexmask.long.byte 0x00 24.--28. 1. " CH14 ,This value denotes the priority of Tx Channel 14."
        textline "           "
        hexmask.long.byte 0x00 28.--32. 1. " CH15 ,This value denotes the priority of Tx Channel 15."
width 8.
rgroup.long 0x20++0x3
    line.long 0x00 "LINE_ST,HSI Line Status Register"
        bitfld.long 0x00 0. " TX_DATA_STATUS ,This field reflects the tx_data pin(only for debug)." "0,1"
        textline "       "
        bitfld.long 0x00 1. " TX_FLAG_STATUS ,This field reflects the tx_flag pin(only for debug)." "0,1"
        textline "       "
        bitfld.long 0x00 2. " TX_READY_STATUS ,This field reflects the tx_ready pin(only for debug)." "0,1"
        textline "       "
        bitfld.long 0x00 3. " TX_WAKEUP_STATUS ,This field reflects the tx_wake pin(only for debug)." "0,1"
        textline "       "
        bitfld.long 0x00 4. " RX_DATA_STATUS ,This field reflects the rx_data pin(only for debug)." "0,1"
        textline "       "
        bitfld.long 0x00 5. " RX_FLAG_STATUS ,This field reflects the rx_flag pin(only for debug)." "0,1"
        textline "       "
        bitfld.long 0x00 6. " RX_READY_STATUS ,This field reflects the rx_rdy pin(only for debug)." "0,1"
        textline "       "
        bitfld.long 0x00 7. " RX_WAKEUP_STATUS ,This field reflects the rx_wake pin(only for debug)." "0,1"
width 7.
group.long 0x24++0x3
    line.long 0x00 "ID_BIT,HSI ID Bits Register"
        hexmask.long.byte 0x00 0.--3. 1. " TX_CH ,This bit sets the number of channel ID bits per frame or stream for a transmit operation."
        textline "      "
        hexmask.long.byte 0x00 4.--7. 1. " RX_CH ,This bit sets the number of channel ID bits per frame or stream for a Receive operation."
width 14.
group.long 0x28++0x3
    line.long 0x00 "FIFO_THR_CONF,Tx and Rx Fif0 Threshold Configuration Register"
        bitfld.long 0x00 0. " RX_CH0 ," "0,1"
        textline "             "
        bitfld.long 0x00 1. " RX_CH1 ," "0,1"
        textline "             "
        bitfld.long 0x00 2. " RX_CH2 ," "0,1"
        textline "             "
        bitfld.long 0x00 3. " RX_CH3 ," "0,1"
        textline "             "
        bitfld.long 0x00 4. " RX_CH4 ," "0,1"
        textline "             "
        bitfld.long 0x00 5. " RX_CH5 ," "0,1"
        textline "             "
        bitfld.long 0x00 6. " RX_CH6 ," "0,1"
        textline "             "
        bitfld.long 0x00 7. " RX_CH7 ," "0,1"
        textline "             "
        bitfld.long 0x00 8. " RX_CH8 ," "0,1"
        textline "             "
        bitfld.long 0x00 9. " RX_CH9 ," "0,1"
        textline "             "
        bitfld.long 0x00 10. " RX_CH10 ," "0,1"
        textline "             "
        bitfld.long 0x00 11. " RX_CH11 ," "0,1"
        textline "             "
        bitfld.long 0x00 12. " RX_CH12 ," "0,1"
        textline "             "
        bitfld.long 0x00 13. " RX_CH13 ," "0,1"
        textline "             "
        bitfld.long 0x00 14. " RX_CH14 ," "0,1"
        textline "             "
        bitfld.long 0x00 15. " RX_CH15 ," "0,1"
        textline "             "
        bitfld.long 0x00 16. " TX_CH0 ," "0,1"
        textline "             "
        bitfld.long 0x00 17. " TX_CH1 ," "0,1"
        textline "             "
        bitfld.long 0x00 18. " TX_CH2 ," "0,1"
        textline "             "
        bitfld.long 0x00 19. " TX_CH3 ," "0,1"
        textline "             "
        bitfld.long 0x00 20. " TX_CH4 ," "0,1"
        textline "             "
        bitfld.long 0x00 21. " TX_CH5 ," "0,1"
        textline "             "
        bitfld.long 0x00 22. " TX_CH6 ," "0,1"
        textline "             "
        bitfld.long 0x00 23. " TX_CH7 ," "0,1"
        textline "             "
        bitfld.long 0x00 24. " TX_CH8 ," "0,1"
        textline "             "
        bitfld.long 0x00 25. " TX_CH9 ," "0,1"
        textline "             "
        bitfld.long 0x00 26. " TX_CH10 ," "0,1"
        textline "             "
        bitfld.long 0x00 27. " TX_CH11 ," "0,1"
        textline "             "
        bitfld.long 0x00 28. " TX_CH12 ," "0,1"
        textline "             "
        bitfld.long 0x00 29. " TX_CH13 ," "0,1"
        textline "             "
        bitfld.long 0x00 30. " TX_CH14 ," "0,1"
        textline "             "
        bitfld.long 0x00 31. " TX_CH15 ," "0,1"
width 10.
wgroup.long 0x2c++0x3
    line.long 0x00 "CH_SFTRST,Tx and Rx Channel Soft Reset Register"
        bitfld.long 0x00 0. " RX_CH0 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 1. " RX_CH1 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 2. " RX_CH2 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 3. " RX_CH3 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 4. " RX_CH4 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 5. " RX_CH5 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 6. " RX_CH6 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 7. " RX_CH7 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 8. " RX_CH8 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 9. " RX_CH9 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 10. " RX_CH10 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 11. " RX_CH11 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 12. " RX_CH12 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 13. " RX_CH13 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 14. " RX_CH14 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 15. " RX_CH15 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 16. " TX_CH0 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 17. " TX_CH1 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 18. " TX_CH2 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 19. " TX_CH3 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 20. " TX_CH4 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 21. " TX_CH5 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 22. " TX_CH6 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 23. " TX_CH7 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 24. " TX_CH8 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 25. " TX_CH9 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 26. " TX_CH10 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 27. " TX_CH11 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 28. " TX_CH12 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 29. " TX_CH13 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 30. " TX_CH14 ,Set this bit to zero to enable normal HSI operation." "0,1"
        textline "         "
        bitfld.long 0x00 31. " TX_CH15 ,Set this bit to zero to enable normal HSI operation." "0,1"
width 8.
group.long 0x30++0x3
    line.long 0x00 "IRQSTAT,HSI Interrupt Status Register"
        bitfld.long 0x00 0. " FIFO_THRESHOLD_INT ," "0,1"
        textline "       "
        bitfld.long 0x00 1. " RX_WAKEUP_INT ," "0,1"
        textline "       "
        bitfld.long 0x00 2. " RX_TIMEOUT_INT ,If any bit in the HSI Error Interrupt Status Register is set, then this bit is set." "0,1"
        textline "       "
        bitfld.long 0x00 3. " DMA_INT ,This bit is set when a Transmit or Receive Operation is completed for DMA." "0,1"
        textline "       "
        bitfld.long 0x00 4. " DMA_ERR_INT ,If any bit in the DMA Error Interrupt Status Register is set, then this bit is set." "0,1"
        textline "       "
        bitfld.long 0x00 5. " TX_TIMEOUT_ERR_INT ," "0,1"
        textline "       "
        bitfld.long 0x00 6. " RX_ERROR_INT ," "0,1"
        textline "       "
        bitfld.long 0x00 7. " RX_BREAK_INT ," "0,1"
        textline "       "
        bitfld.long 0x00 8. " TX_EMPTY_INT ," "0,1"
width 11.
group.long 0x34++0x3
    line.long 0x00 "IRQSTAT_EN,HSI Interrupt Status Enable Register"
        bitfld.long 0x00 0. " FIFO_THRESHOLD_INT ," "0,1"
        textline "          "
        bitfld.long 0x00 1. " RX_WAKEUP_INT ," "0,1"
        textline "          "
        bitfld.long 0x00 2. " RX_TIMEOUT_INT ," "0,1"
        textline "          "
        bitfld.long 0x00 3. " DMA_INT ," "0,1"
        textline "          "
        bitfld.long 0x00 4. " DMA_ERR_INT ," "0,1"
        textline "          "
        bitfld.long 0x00 5. " TX_TIMEOUT_ERR_INT ," "0,1"
        textline "          "
        bitfld.long 0x00 6. " RX_ERROR_INT ," "0,1"
        textline "          "
        bitfld.long 0x00 7. " RX_BREAK_INT ," "0,1"
        textline "          "
        bitfld.long 0x00 8. " TX_EMPTY_INT ," "0,1"
width 10.
group.long 0x38++0x3
    line.long 0x00 "IRQSIG_EN,HSI Interrupt Signal Enable Register"
        bitfld.long 0x00 0. " FIFO_THRESHOLD_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "         "
        bitfld.long 0x00 1. " RX_WAKEUP_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "         "
        bitfld.long 0x00 2. " RX_TIMEOUT_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "         "
        bitfld.long 0x00 3. " DMA_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "         "
        bitfld.long 0x00 4. " DMA_ERR_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "         "
        bitfld.long 0x00 5. " TX_TIMEOUT_ERR_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "         "
        bitfld.long 0x00 6. " RX_ERROR_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "         "
        bitfld.long 0x00 7. " RX_BREAK_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "         "
        bitfld.long 0x00 8. " TX_EMPTY_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
width 17.
rgroup.long 0x3c++0x3
    line.long 0x00 "FIFO_THR_IRQSTAT,HSI FIFO Threshold Interrupt Status Register"
        bitfld.long 0x00 0. " RX_CH0_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 1. " RX_CH1_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 2. " RX_CH2_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 3. " RX_CH3_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 4. " RX_CH4_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 5. " RX_CH5_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 6. " RX_CH6_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 7. " RX_CH7_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 8. " RX_CH8_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 9. " RX_CH9_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 10. " RX_CH10_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 11. " RX_CH11_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 12. " RX_CH12_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 13. " RX_CH13_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 14. " RX_CH14_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 15. " RX_CH15_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 16. " TX_CH0_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 17. " TX_CH1_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 18. " TX_CH2_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 19. " TX_CH3_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 20. " TX_CH4_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 21. " TX_CH5_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 22. " TX_CH6_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 23. " TX_CH7_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 24. " TX_CH8_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 25. " TX_CH9_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 26. " TX_CH10_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 27. " TX_CH11_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 28. " TX_CH12_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 29. " TX_CH13_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 30. " TX_CH14_INT ," "0,1"
        textline "                "
        bitfld.long 0x00 31. " TX_CH15_INT ," "0,1"
width 20.
group.long 0x40++0x3
    line.long 0x00 "FIFO_THR_IRQSTAT_EN,HSI FIFO Threshold Interrupt Status Enable Register"
        bitfld.long 0x00 0. " RX_CH0_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 1. " RX_CH1_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 2. " RX_CH2_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 3. " RX_CH3_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 4. " RX_CH4_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 5. " RX_CH5_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 6. " RX_CH6_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 7. " RX_CH7_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 8. " RX_CH8_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 9. " RX_CH9_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 10. " RX_CH10_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 11. " RX_CH11_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 12. " RX_CH12_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 13. " RX_CH13_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 14. " RX_CH14_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 15. " RX_CH15_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 16. " TX_CH0_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 17. " TX_CH1_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 18. " TX_CH2_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 19. " TX_CH3_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 20. " TX_CH4_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 21. " TX_CH5_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 22. " TX_CH6_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 23. " TX_CH7_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 24. " TX_CH8_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 25. " TX_CH9_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 26. " TX_CH10_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 27. " TX_CH11_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 28. " TX_CH12_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 29. " TX_CH13_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 30. " TX_CH14_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                   "
        bitfld.long 0x00 31. " TX_CH15_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
width 19.
group.long 0x44++0x3
    line.long 0x00 "FIFO_THR_IRQSIG_EN,HSI FIFO Threshold Interrupt Signal Enable Register"
        bitfld.long 0x00 0. " RX_CH0_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 1. " RX_CH1_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 2. " RX_CH2_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 3. " RX_CH3_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 4. " RX_CH4_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 5. " RX_CH5_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 6. " RX_CH6_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 7. " RX_CH7_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 8. " RX_CH8_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 9. " RX_CH9_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 10. " RX_CH10_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 11. " RX_CH11_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 12. " RX_CH12_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 13. " RX_CH13_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 14. " RX_CH14_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 15. " RX_CH15_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 16. " TX_CH0_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 17. " TX_CH1_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 18. " TX_CH2_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 19. " TX_CH3_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 20. " TX_CH4_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 21. " TX_CH5_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 22. " TX_CH6_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 23. " TX_CH7_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 24. " TX_CH8_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 25. " TX_CH9_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 26. " TX_CH10_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 27. " TX_CH11_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 28. " TX_CH12_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 29. " TX_CH13_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 30. " TX_CH14_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "                  "
        bitfld.long 0x00 31. " TX_CH15_INT ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
width 10.
group.long 0x50++0x3
    line.long 0x00 "TX_CH0_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 10.
group.long 0x54++0x3
    line.long 0x00 "TX_CH1_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 10.
group.long 0x58++0x3
    line.long 0x00 "TX_CH2_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 10.
group.long 0x5c++0x3
    line.long 0x00 "TX_CH3_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 10.
group.long 0x60++0x3
    line.long 0x00 "TX_CH4_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 10.
group.long 0x64++0x3
    line.long 0x00 "TX_CH5_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 10.
group.long 0x68++0x3
    line.long 0x00 "TX_CH6_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 10.
group.long 0x6c++0x3
    line.long 0x00 "TX_CH7_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 10.
group.long 0x70++0x3
    line.long 0x00 "TX_CH8_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 10.
group.long 0x74++0x3
    line.long 0x00 "TX_CH9_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 11.
group.long 0x78++0x3
    line.long 0x00 "TX_CH10_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 11.
group.long 0x7c++0x3
    line.long 0x00 "TX_CH11_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 11.
group.long 0x80++0x3
    line.long 0x00 "TX_CH12_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 11.
group.long 0x84++0x3
    line.long 0x00 "TX_CH13_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 11.
group.long 0x88++0x3
    line.long 0x00 "TX_CH14_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 11.
group.long 0x8c++0x3
    line.long 0x00 "TX_CH15_DP,Tx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Tx Channel n."
width 10.
group.long 0x90++0x3
    line.long 0x00 "RX_CH0_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 10.
group.long 0x94++0x3
    line.long 0x00 "RX_CH1_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 10.
group.long 0x98++0x3
    line.long 0x00 "RX_CH2_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 10.
group.long 0x9c++0x3
    line.long 0x00 "RX_CH3_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 10.
group.long 0xa0++0x3
    line.long 0x00 "RX_CH4_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 10.
group.long 0xa4++0x3
    line.long 0x00 "RX_CH5_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 10.
group.long 0xa8++0x3
    line.long 0x00 "RX_CH6_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 10.
group.long 0xac++0x3
    line.long 0x00 "RX_CH7_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 10.
group.long 0xb0++0x3
    line.long 0x00 "RX_CH8_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 10.
group.long 0xb4++0x3
    line.long 0x00 "RX_CH9_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 11.
group.long 0xb8++0x3
    line.long 0x00 "RX_CH10_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 11.
group.long 0xbc++0x3
    line.long 0x00 "RX_CH11_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 11.
group.long 0xc0++0x3
    line.long 0x00 "RX_CH12_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 11.
group.long 0xc4++0x3
    line.long 0x00 "RX_CH13_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 11.
group.long 0xc8++0x3
    line.long 0x00 "RX_CH14_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 11.
group.long 0xcc++0x3
    line.long 0x00 "RX_CH15_DP,Rx Channel n Data Port Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Software could Write/Read this bits to access Rx Channel n."
width 12.
rgroup.long 0xd0++0x3
    line.long 0x00 "ERR_IRQSTAT,HSI Error Interrupt Status Register"
        bitfld.long 0x00 16. " RX_CH0_TIMEOUT_INT ,This status bit is set when data timeout counter for ch0 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 17. " RX_CH1_TIMEOUT_INT ,This status bit is set when data timeout counter for ch1 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 18. " RX_CH2_TIMEOUT_INT ,This status bit is set when data timeout counter for ch2 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 19. " RX_CH3_TIMEOUT_INT ,This status bit is set when data timeout counter for ch3 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 20. " RX_CH4_TIMEOUT_INT ,This status bit is set when data timeout counter for ch4 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 21. " RX_CH5_TIMEOUT_INT ,This status bit is set when data timeout counter for ch5 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 22. " RX_CH6_TIMEOUT_INT ,This status bit is set when data timeout counter for ch6 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 23. " RX_CH7_TIMEOUT_INT ,This status bit is set when data timeout counter for ch7 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 24. " RX_CH8_TIMEOUT_INT ,This status bit is set when data timeout counter for ch8 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 25. " RX_CH9_TIMEOUT_INT ,This status bit is set when data timeout counter for ch9 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 26. " RX_CH10_TIMEOUT_INT ,This status bit is set when data timeout counter for ch10 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 27. " RX_CH11_TIMEOUT_INT ,This status bit is set when data timeout counter for ch11 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 28. " RX_CH12_TIMEOUT_INT ,This status bit is set when data timeout counter for ch12 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 29. " RX_CH13_TIMEOUT_INT ,This status bit is set when data timeout counter for ch13 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 30. " RX_CH14_TIMEOUT_INT ,This status bit is set when data timeout counter for ch14 reaches the data timeout counter value." "0,1"
        textline "           "
        bitfld.long 0x00 31. " RX_CH15_TIMEOUT_INT ,This status bit is set when data timeout counter for ch15 reaches thedata timeout counter value." "0,1"
width 15.
group.long 0xd4++0x3
    line.long 0x00 "ERR_IRQSTAT_EN,HSI Error Interrupt Status Enable Register"
        bitfld.long 0x00 16. " RX_CH0_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 17. " RX_CH1_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 18. " RX_CH2_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 19. " RX_CH3_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 20. " RX_CH4_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 21. " RX_CH5_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 22. " RX_CH6_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 23. " RX_CH7_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 24. " RX_CH8_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 25. " RX_CH9_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 26. " RX_CH10_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 27. " RX_CH11_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 28. " RX_CH12_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 29. " RX_CH13_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 30. " RX_CH14_TIMEOUT_INT_EN ," "0,1"
        textline "              "
        bitfld.long 0x00 31. " RX_CH15_TIMEOUT_INT_EN ," "0,1"
width 14.
group.long 0xd8++0x3
    line.long 0x00 "ERR_IRQSIG_EN,HSI Error Interrupt Signal Enable Register"
        bitfld.long 0x00 16. " RX_CH0_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 17. " RX_CH1_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 18. " RX_CH2_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 19. " RX_CH3_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 20. " RX_CH4_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 21. " RX_CH5_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 22. " RX_CH6_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 23. " RX_CH7_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 24. " RX_CH8_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 25. " RX_CH9_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 26. " RX_CH10_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 27. " RX_CH11_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 28. " RX_CH12_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 29. " RX_CH13_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 30. " RX_CH14_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
        textline "             "
        bitfld.long 0x00 31. " RX_CH15_TIMEOUT_INT_EN ,Setting this bit will enable interrupt generation on interrupt line." "0,1"
width 11.
group.long 0xdc++0x3
    line.long 0x00 "TDMA0_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 11.
group.long 0xe0++0x3
    line.long 0x00 "TDMA1_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 11.
group.long 0xe4++0x3
    line.long 0x00 "TDMA2_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 11.
group.long 0xe8++0x3
    line.long 0x00 "TDMA3_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 11.
group.long 0xec++0x3
    line.long 0x00 "TDMA4_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 11.
group.long 0xf0++0x3
    line.long 0x00 "TDMA5_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 11.
group.long 0xf4++0x3
    line.long 0x00 "TDMA6_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 11.
group.long 0xf8++0x3
    line.long 0x00 "TDMA7_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 11.
group.long 0xfc++0x3
    line.long 0x00 "TDMA8_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 11.
group.long 0x100++0x3
    line.long 0x00 "TDMA9_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 12.
group.long 0x104++0x3
    line.long 0x00 "TDMA10_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "           "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "           "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 12.
group.long 0x108++0x3
    line.long 0x00 "TDMA11_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "           "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "           "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 12.
group.long 0x10c++0x3
    line.long 0x00 "TDMA12_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "           "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "           "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 12.
group.long 0x110++0x3
    line.long 0x00 "TDMA13_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "           "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "           "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 12.
group.long 0x114++0x3
    line.long 0x00 "TDMA14_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "           "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "           "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 12.
group.long 0x118++0x3
    line.long 0x00 "TDMA15_CONF,Tx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Tx DMA channel n."
        textline "           "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Tx DMA channel n."
        textline "           "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Tx DMA channel n." "0,1"
width 11.
group.long 0x11c++0x3
    line.long 0x00 "RDMA0_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 11.
group.long 0x120++0x3
    line.long 0x00 "RDMA1_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 11.
group.long 0x124++0x3
    line.long 0x00 "RDMA2_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 11.
group.long 0x128++0x3
    line.long 0x00 "RDMA3_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 11.
group.long 0x12c++0x3
    line.long 0x00 "RDMA4_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 11.
group.long 0x130++0x3
    line.long 0x00 "RDMA5_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 11.
group.long 0x134++0x3
    line.long 0x00 "RDMA6_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 11.
group.long 0x138++0x3
    line.long 0x00 "RDMA7_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 11.
group.long 0x13c++0x3
    line.long 0x00 "RDMA8_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 11.
group.long 0x140++0x3
    line.long 0x00 "RDMA9_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "          "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "          "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 12.
group.long 0x144++0x3
    line.long 0x00 "RDMA10_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "           "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "           "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 12.
group.long 0x148++0x3
    line.long 0x00 "RDMA11_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "           "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "           "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 12.
group.long 0x14c++0x3
    line.long 0x00 "RDMA12_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "           "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "           "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 12.
group.long 0x150++0x3
    line.long 0x00 "RDMA13_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "           "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "           "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 12.
group.long 0x154++0x3
    line.long 0x00 "RDMA14_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "           "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "           "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 12.
group.long 0x158++0x3
    line.long 0x00 "RDMA15_CONF,Rx DMA Channel n Configuration Register"
        hexmask.long.long 0x00 5.--25. 1. " TRANS_LENGTH ,Transfer data length for Rx DMA channel 0."
        textline "           "
        hexmask.long.byte 0x00 25.--29. 1. " BURST_SIZE ,Burst size for Rx DMA channel n."
        textline "           "
        bitfld.long 0x00 31. " ENABLE ,Setting this bit enables the inernal Rx DMA channel n." "0,1"
width 15.
group.long 0x15c++0x3
    line.long 0x00 "TDMA0_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 15.
group.long 0x160++0x3
    line.long 0x00 "TDMA1_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 15.
group.long 0x164++0x3
    line.long 0x00 "TDMA2_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 15.
group.long 0x168++0x3
    line.long 0x00 "TDMA3_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 15.
group.long 0x16c++0x3
    line.long 0x00 "TDMA4_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 15.
group.long 0x170++0x3
    line.long 0x00 "TDMA5_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 15.
group.long 0x174++0x3
    line.long 0x00 "TDMA6_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 15.
group.long 0x178++0x3
    line.long 0x00 "TDMA7_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 15.
group.long 0x17c++0x3
    line.long 0x00 "TDMA8_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 15.
group.long 0x180++0x3
    line.long 0x00 "TDMA9_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 16.
group.long 0x184++0x3
    line.long 0x00 "TDMA10_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 16.
group.long 0x188++0x3
    line.long 0x00 "TDMA11_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 16.
group.long 0x18c++0x3
    line.long 0x00 "TDMA12_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 16.
group.long 0x190++0x3
    line.long 0x00 "TDMA13_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 16.
group.long 0x194++0x3
    line.long 0x00 "TDMA14_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 16.
group.long 0x198++0x3
    line.long 0x00 "TDMA15_STA_ADDR,Tx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Tx DMA Channel n."
width 15.
group.long 0x19c++0x3
    line.long 0x00 "RDMA0_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 15.
group.long 0x1a0++0x3
    line.long 0x00 "RDMA1_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 15.
group.long 0x1a4++0x3
    line.long 0x00 "RDMA2_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 15.
group.long 0x1a8++0x3
    line.long 0x00 "RDMA3_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 15.
group.long 0x1ac++0x3
    line.long 0x00 "RDMA4_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 15.
group.long 0x1b0++0x3
    line.long 0x00 "RDMA5_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 15.
group.long 0x1b4++0x3
    line.long 0x00 "RDMA6_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 15.
group.long 0x1b8++0x3
    line.long 0x00 "RDMA7_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 15.
group.long 0x1bc++0x3
    line.long 0x00 "RDMA8_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 15.
group.long 0x1c0++0x3
    line.long 0x00 "RDMA9_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 16.
group.long 0x1c4++0x3
    line.long 0x00 "RDMA10_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 16.
group.long 0x1c8++0x3
    line.long 0x00 "RDMA11_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 16.
group.long 0x1cc++0x3
    line.long 0x00 "RDMA12_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 16.
group.long 0x1d0++0x3
    line.long 0x00 "RDMA13_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 16.
group.long 0x1d4++0x3
    line.long 0x00 "RDMA14_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 16.
group.long 0x1d8++0x3
    line.long 0x00 "RDMA15_STA_ADDR,Rx DMA Channel n Start Address Register"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,The Physical Start Address for Rx DMA Channel n."
width 12.
rgroup.long 0x1dc++0x3
    line.long 0x00 "DMA_IRQSTAT,DMA Interrupt Status Register"
        bitfld.long 0x00 0. " RDMA0 ,RDMA Channel 0 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 1. " RDMA1 ,RDMA Channel 1 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 2. " RDMA2 ,RDMA Channel 2 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 3. " RDMA3 ,RDMA Channel 3 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 4. " RDMA4 ,RDMA Channel 4 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 5. " RDMA5 ,RDMA Channel 5 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 6. " RDMA6 ,RDMA Channel 6 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 7. " RDMA7 ,RDMA Channel 7 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 8. " RDMA8 ,RDMA Channel 8 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 9. " RDMA9 ,RDMA Channel 9 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 10. " RDMA10 ,RDMA Channel 10 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 11. " RDMA11 ,RDMA Channel 11 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 12. " RDMA12 ,RDMA Channel 12 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 13. " RDMA13 ,RDMA Channel 13 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 14. " RDMA14 ,RDMA Channel 14 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 15. " RDMA15 ,RDMA Channel 15 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 16. " TDMA0 ,TDMA Channel 0 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 17. " TDMA1 ,TDMA Channel 1 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 18. " TDMA2 ,TDMA Channel 2 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 19. " TDMA3 ,TDMA Channel 3 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 20. " TDMA4 ,TDMA Channel 4 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 21. " TDMA5 ,TDMA Channel 5 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 22. " TDMA6 ,TDMA Channel 6 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 23. " TDMA7 ,TDMA Channel 7 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 24. " TDMA8 ,TDMA Channel 8 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 25. " TDMA9 ,TDMA Channel 9 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 26. " TDMA10 ,TDMA Channel 10 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 27. " TDMA11 ,TDMA Channel 11 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 28. " TDMA12 ,TDMA Channel 12 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 29. " TDMA13 ,TDMA Channel 13 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 30. " TDMA14 ,TDMA Channel 14 interrupt status" "0,1"
        textline "           "
        bitfld.long 0x00 31. " TDMA15 ,TDMA Channel 15 interrupt status" "0,1"
width 15.
group.long 0x1e0++0x3
    line.long 0x00 "DMA_IRQSTAT_EN,DMA Interrupt Enable Register"
        bitfld.long 0x00 0. " RDMA0 ,RDMA Channel 0 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 1. " RDMA1 ,RDMA Channel 1 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 2. " RDMA2 ,RDMA Channel 2 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 3. " RDMA3 ,RDMA Channel 3 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 4. " RDMA4 ,RDMA Channel 4 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 5. " RDMA5 ,RDMA Channel 5 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 6. " RDMA6 ,RDMA Channel 6 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 7. " RDMA7 ,RDMA Channel 7 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 8. " RDMA8 ,RDMA Channel 8 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 9. " RDMA9 ,RDMA Channel 9 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 10. " RDMA10 ,RDMA Channel 10 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 11. " RDMA11 ,RDMA Channel 11 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 12. " RDMA12 ,RDMA Channel 12 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 13. " RDMA13 ,RDMA Channel 13 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 14. " RDMA14 ,RDMA Channel 14 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 15. " RDMA15 ,RDMA Channel 15 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 16. " TDMA0 ,TDMA Channel 0 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 17. " TDMA1 ,TDMA Channel 1 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 18. " TDMA2 ,TDMA Channel 2 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 19. " TDMA3 ,TDMA Channel 3 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 20. " TDMA4 ,TDMA Channel 4 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 21. " TDMA5 ,TDMA Channel 5 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 22. " TDMA6 ,TDMA Channel 6 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 23. " TDMA7 ,TDMA Channel 7 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 24. " TDMA8 ,TDMA Channel 8 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 25. " TDMA9 ,TDMA Channel 9 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 26. " TDMA10 ,TDMA Channel 10 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 27. " TDMA11 ,TDMA Channel 11 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 28. " TDMA12 ,TDMA Channel 12 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 29. " TDMA13 ,TDMA Channel 13 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 30. " TDMA14 ,TDMA Channel 14 interrupt Enable" "0,1"
        textline "              "
        bitfld.long 0x00 31. " TDMA15 ,TDMA Channel 15 interrupt Enable" "0,1"
width 14.
group.long 0x1e4++0x3
    line.long 0x00 "DMA_IRQSIG_EN,DMA Interrupt Status Signal Enable Register"
        bitfld.long 0x00 0. " RDMA0 ,RDMA Channel 0 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 1. " RDMA1 ,RDMA Channel 1 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 2. " RDMA2 ,RDMA Channel 2 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 3. " RDMA3 ,RDMA Channel 3 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 4. " RDMA4 ,RDMA Channel 4 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 5. " RDMA5 ,RDMA Channel 5 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 6. " RDMA6 ,RDMA Channel 6 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 7. " RDMA7 ,RDMA Channel 7 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 8. " RDMA8 ,RDMA Channel 8 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 9. " RDMA9 ,RDMA Channel 9 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 10. " RDMA10 ,RDMA Channel 10 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 11. " RDMA11 ,RDMA Channel 11 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 12. " RDMA12 ,RDMA Channel 12 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 13. " RDMA13 ,RDMA Channel 13 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " RDMA14 ,RDMA Channel 14 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 15. " RDMA15 ,RDMA Channel 15 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " TDMA0 ,TDMA Channel 0 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 17. " TDMA1 ,TDMA Channel 1 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 18. " TDMA2 ,TDMA Channel 2 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 19. " TDMA3 ,TDMA Channel 3 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 20. " TDMA4 ,TDMA Channel 4 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 21. " TDMA5 ,TDMA Channel 5 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 22. " TDMA6 ,TDMA Channel 6 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 23. " TDMA7 ,TDMA Channel 7 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 24. " TDMA8 ,TDMA Channel 8 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 25. " TDMA9 ,TDMA Channel 9 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TDMA10 ,TDMA Channel 10 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 27. " TDMA11 ,TDMA Channel 11 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 28. " TDMA12 ,TDMA Channel 12 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 29. " TDMA13 ,TDMA Channel 13 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 30. " TDMA14 ,TDMA Channel 14 interrupt status enable" "0,1"
        textline "             "
        bitfld.long 0x00 31. " TDMA15 ,TDMA Channel 15 interrupt status enable" "0,1"
width 16.
rgroup.long 0x1e8++0x3
    line.long 0x00 "DMA_ERR_IRQSTAT,DMA Error Interrupt Status Register"
        bitfld.long 0x00 0. " RDMA0 ,RDMA Channel 0 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 1. " RDMA1 ,RDMA Channel 1 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 2. " RDMA2 ,RDMA Channel 2 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 3. " RDMA3 ,RDMA Channel 3 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 4. " RDMA4 ,RDMA Channel 4 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 5. " RDMA5 ,RDMA Channel 5 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 6. " RDMA6 ,RDMA Channel 6 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 7. " RDMA7 ,RDMA Channel 7 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 8. " RDMA8 ,RDMA Channel 8 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 9. " RDMA9 ,RDMA Channel 9 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 10. " RDMA10 ,RDMA Channel 10 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 11. " RDMA11 ,RDMA Channel 11 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 12. " RDMA12 ,RDMA Channel 12 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 13. " RDMA13 ,RDMA Channel 13 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 14. " RDMA14 ,RDMA Channel 14 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 15. " RDMA15 ,RDMA Channel 15 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 16. " TDMA0 ,TDMA Channel 0 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 17. " TDMA1 ,TDMA Channel 1 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 18. " TDMA2 ,TDMA Channel 2 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 19. " TDMA3 ,TDMA Channel 3 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 20. " TDMA4 ,TDMA Channel 4 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 21. " TDMA5 ,TDMA Channel 5 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 22. " TDMA6 ,TDMA Channel 6 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 23. " TDMA7 ,TDMA Channel 7 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 24. " TDMA8 ,TDMA Channel 8 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 25. " TDMA9 ,TDMA Channel 9 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 26. " TDMA10 ,TDMA Channel 10 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 27. " TDMA11 ,TDMA Channel 11 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 28. " TDMA12 ,TDMA Channel 12 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 29. " TDMA13 ,TDMA Channel 13 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 30. " TDMA14 ,TDMA Channel 14 error interrupt status" "0,1"
        textline "               "
        bitfld.long 0x00 31. " TDMA15 ,TDMA Channel 15 error interrupt status" "0,1"
width 19.
group.long 0x1ec++0x3
    line.long 0x00 "DMA_ERR_IRQSTAT_EN,DMA Error Interrupt Enable Register"
        bitfld.long 0x00 0. " RDMA0 ,RDMA Channel 0 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 1. " RDMA1 ,RDMA Channel 1 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 2. " RDMA2 ,RDMA Channel 2 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 3. " RDMA3 ,RDMA Channel 3 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 4. " RDMA4 ,RDMA Channel 4 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 5. " RDMA5 ,RDMA Channel 5 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 6. " RDMA6 ,RDMA Channel 6 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 7. " RDMA7 ,RDMA Channel 7 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 8. " RDMA8 ,RDMA Channel 8 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 9. " RDMA9 ,RDMA Channel 9 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 10. " RDMA10 ,RDMA Channel 10 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 11. " RDMA11 ,RDMA Channel 11 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 12. " RDMA12 ,RDMA Channel 12 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 13. " RDMA13 ,RDMA Channel 13 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 14. " RDMA14 ,RDMA Channel 14 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 15. " RDMA15 ,RDMA Channel 15 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 16. " TDMA0 ,TDMA Channel 0 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 17. " TDMA1 ,TDMA Channel 1 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 18. " TDMA2 ,TDMA Channel 2 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 19. " TDMA3 ,TDMA Channel 3 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 20. " TDMA4 ,TDMA Channel 4 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 21. " TDMA5 ,TDMA Channel 5 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 22. " TDMA6 ,TDMA Channel 6 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 23. " TDMA7 ,TDMA Channel 7 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 24. " TDMA8 ,TDMA Channel 8 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 25. " TDMA9 ,TDMA Channel 9 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 26. " TDMA10 ,TDMA Channel 10 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 27. " TDMA11 ,TDMA Channel 11 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 28. " TDMA12 ,TDMA Channel 12 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 29. " TDMA13 ,TDMA Channel 13 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 30. " TDMA14 ,TDMA Channel 14 error interrupt enable" "0,1"
        textline "                  "
        bitfld.long 0x00 31. " TDMA15 ,TDMA Channel 15 error interrupt enable" "0,1"
width 18.
group.long 0x1f0++0x3
    line.long 0x00 "DMA_ERR_IRQSIG_EN,DMA Error Interrupt Signal Enable Register"
        bitfld.long 0x00 0. " RDMA0 ,RDMA Channel 0 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 1. " RDMA1 ,RDMA Channel 1 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 2. " RDMA2 ,RDMA Channel 2 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 3. " RDMA3 ,RDMA Channel 3 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 4. " RDMA4 ,RDMA Channel 4 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 5. " RDMA5 ,RDMA Channel 5 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 6. " RDMA6 ,RDMA Channel 6 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 7. " RDMA7 ,RDMA Channel 7 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 8. " RDMA8 ,RDMA Channel 8 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 9. " RDMA9 ,RDMA Channel 9 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 10. " RDMA10 ,RDMA Channel 10 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 11. " RDMA11 ,RDMA Channel 11 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 12. " RDMA12 ,RDMA Channel 12 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 13. " RDMA13 ,RDMA Channel 13 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 14. " RDMA14 ,RDMA Channel 14 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 15. " RDMA15 ,RDMA Channel 15 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 16. " TDMA0 ,TDMA Channel 0 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 17. " TDMA1 ,TDMA Channel 1 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 18. " TDMA2 ,TDMA Channel 2 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 19. " TDMA3 ,TDMA Channel 3 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 20. " TDMA4 ,TDMA Channel 4 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 21. " TDMA5 ,TDMA Channel 5 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 22. " TDMA6 ,TDMA Channel 6 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 23. " TDMA7 ,TDMA Channel 7 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 24. " TDMA8 ,TDMA Channel 8 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 25. " TDMA9 ,TDMA Channel 9 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 26. " TDMA10 ,TDMA Channel 10 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 27. " TDMA11 ,TDMA Channel 11 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 28. " TDMA12 ,TDMA Channel 12 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 29. " TDMA13 ,TDMA Channel 13 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 30. " TDMA14 ,TDMA Channel 14 error interrupt status enable" "0,1"
        textline "                 "
        bitfld.long 0x00 31. " TDMA15 ,TDMA Channel 15 error interrupt status enable" "0,1"
width 18.
rgroup.long 0x1f4++0x3
    line.long 0x00 "DMA_SINGLE_REQ_EN,DMA Single Request Enable Register"
        bitfld.long 0x00 0. " RDMA0 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 0, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 1. " RDMA1 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 1, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 2. " RDMA2 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 2, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 3. " RDMA3 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 3, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 4. " RDMA4 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 4, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 5. " RDMA5 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 5, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 6. " RDMA6 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 6, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 7. " RDMA7 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 7, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 8. " RDMA8 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 8, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 9. " RDMA9 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 9, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 10. " RDMA10 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 10, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 11. " RDMA11 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 11, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 12. " RDMA12 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 12, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 13. " RDMA13 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 13, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 14. " RDMA14 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 14, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 15. " RDMA15 ,When the remain DMA data less than one DMA burst size in Rx Dma Channle 15, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 16. " TDMA0 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 0, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 17. " TDMA1 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 1, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 18. " TDMA2 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 2, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 19. " TDMA3 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 3, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 20. " TDMA4 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 4, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 21. " TDMA5 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 5, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 22. " TDMA6 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 6, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 23. " TDMA7 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 7, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 24. " TDMA8 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 8, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 25. " TDMA9 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 9, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 26. " TDMA10 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 10, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 27. " TDMA11 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 11, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 28. " TDMA12 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 12, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 29. " TDMA13 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 13, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 30. " TDMA14 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 14, this bit will be set automatically" "0,1"
        textline "                 "
        bitfld.long 0x00 31. " TDMA15 ,When the remain DMA data less than one DMA burst size in Tx Dma Channle 15, this bit will be set automatically" "0,1"
width 19.
group.long 0x200++0x3
    line.long 0x00 "TX_FIFO_SIZE_CONF0,Tx Fifo Size Configuration Register 0"
        hexmask.long.byte 0x00 0.--4. 1. " CH8 ,This field is used to set the buffer size for channel 8."
        textline "                  "
        hexmask.long.byte 0x00 4.--8. 1. " CH9 ,This field is used to set the buffer size for channel 9."
        textline "                  "
        hexmask.long.byte 0x00 8.--12. 1. " CH10 ,This field is used to set the buffer size for channel 10."
        textline "                  "
        hexmask.long.byte 0x00 12.--16. 1. " CH11 ,This field is used to set the buffer size for channel 11."
        textline "                  "
        hexmask.long.byte 0x00 16.--20. 1. " CH12 ,This field is used to set the buffer size for channel 12."
        textline "                  "
        hexmask.long.byte 0x00 20.--24. 1. " CH13 ,This field is used to set the buffer size for channel 13."
        textline "                  "
        hexmask.long.byte 0x00 24.--28. 1. " CH14 ,This field is used to set the buffer size for channel 14."
        textline "                  "
        hexmask.long.byte 0x00 28.--32. 1. " CH15 ,This field is used to set the buffer size for channel 15."
width 19.
group.long 0x204++0x3
    line.long 0x00 "TX_FIFO_SIZE_CONF1,Tx Fifo Size Configuration Register 1"
        hexmask.long.byte 0x00 0.--4. 1. " CH0 ,This field is used to set the buffer size for channel 0."
        textline "                  "
        hexmask.long.byte 0x00 4.--8. 1. " CH1 ,This field is used to set the buffer size for channel 1."
        textline "                  "
        hexmask.long.byte 0x00 8.--12. 1. " CH2 ,This field is used to set the buffer size for channel 2."
        textline "                  "
        hexmask.long.byte 0x00 12.--16. 1. " CH3 ,This field is used to set the buffer size for channel 3."
        textline "                  "
        hexmask.long.byte 0x00 16.--20. 1. " CH4 ,This field is used to set the buffer size for channel 4."
        textline "                  "
        hexmask.long.byte 0x00 20.--24. 1. " CH5 ,This field is used to set the buffer size for channel 5."
        textline "                  "
        hexmask.long.byte 0x00 24.--28. 1. " CH6 ,This field is used to set the buffer size for channel 6."
        textline "                  "
        hexmask.long.byte 0x00 28.--32. 1. " CH7 ,This field is used to set the buffer size for channel 7."
width 19.
group.long 0x208++0x3
    line.long 0x00 "RX_FIFO_SIZE_CONF0,Rx Fifo Size Configuration Register 0"
        hexmask.long.byte 0x00 0.--4. 1. " CH8 ,This field is used to set the buffer size for channel 8."
        textline "                  "
        hexmask.long.byte 0x00 4.--8. 1. " CH9 ,This field is used to set the buffer size for channel 9."
        textline "                  "
        hexmask.long.byte 0x00 8.--12. 1. " CH10 ,This field is used to set the buffer size for channel 10."
        textline "                  "
        hexmask.long.byte 0x00 12.--16. 1. " CH11 ,This field is used to set the buffer size for channel 11."
        textline "                  "
        hexmask.long.byte 0x00 16.--20. 1. " CH12 ,This field is used to set the buffer size for channel 12."
        textline "                  "
        hexmask.long.byte 0x00 20.--24. 1. " CH13 ,This field is used to set the buffer size for channel 13."
        textline "                  "
        hexmask.long.byte 0x00 24.--28. 1. " CH14 ,This field is used to set the buffer size for channel 14."
        textline "                  "
        hexmask.long.byte 0x00 28.--32. 1. " CH15 ,This field is used to set the buffer size for channel 15."
width 19.
group.long 0x20c++0x3
    line.long 0x00 "RX_FIFO_SIZE_CONF1,Rx Fifo Size Configuration Register 1"
        hexmask.long.byte 0x00 0.--4. 1. " CH0 ,This field is used to set the buffer size for channel 0."
        textline "                  "
        hexmask.long.byte 0x00 4.--8. 1. " CH1 ,This field is used to set the buffer size for channel 1."
        textline "                  "
        hexmask.long.byte 0x00 8.--12. 1. " CH2 ,This field is used to set the buffer size for channel 2."
        textline "                  "
        hexmask.long.byte 0x00 12.--16. 1. " CH3 ,This field is used to set the buffer size for channel 3."
        textline "                  "
        hexmask.long.byte 0x00 16.--20. 1. " CH4 ,This field is used to set the buffer size for channel 4."
        textline "                  "
        hexmask.long.byte 0x00 20.--24. 1. " CH5 ,This field is used to set the buffer size for channel 5."
        textline "                  "
        hexmask.long.byte 0x00 24.--28. 1. " CH6 ,This field is used to set the buffer size for channel 6."
        textline "                  "
        hexmask.long.byte 0x00 28.--32. 1. " CH7 ,This field is used to set the buffer size for channel 7."
width 13.
rgroup.long 0x210++0x3
    line.long 0x00 "TX_FIFO_STAT,Tx Fifo Status Register"
        hexmask.long.byte 0x00 0.--2. 1. " CH0 ,"
        textline "            "
        hexmask.long.byte 0x00 2.--4. 1. " CH1 ,"
        textline "            "
        hexmask.long.byte 0x00 4.--6. 1. " CH2 ,"
        textline "            "
        hexmask.long.byte 0x00 6.--8. 1. " CH3 ,"
        textline "            "
        hexmask.long.byte 0x00 8.--10. 1. " CH4 ,"
        textline "            "
        hexmask.long.byte 0x00 10.--12. 1. " CH5 ,"
        textline "            "
        hexmask.long.byte 0x00 12.--14. 1. " CH6 ,"
        textline "            "
        hexmask.long.byte 0x00 14.--16. 1. " CH7 ,"
        textline "            "
        hexmask.long.byte 0x00 16.--18. 1. " CH8 ,"
        textline "            "
        hexmask.long.byte 0x00 18.--20. 1. " CH9 ,"
        textline "            "
        hexmask.long.byte 0x00 20.--22. 1. " CH10 ,"
        textline "            "
        hexmask.long.byte 0x00 22.--24. 1. " CH11 ,"
        textline "            "
        hexmask.long.byte 0x00 24.--26. 1. " CH12 ,"
        textline "            "
        hexmask.long.byte 0x00 26.--28. 1. " CH13 ,"
        textline "            "
        hexmask.long.byte 0x00 28.--30. 1. " CH14 ,"
        textline "            "
        hexmask.long.byte 0x00 30.--32. 1. " CH15 ,"
width 13.
rgroup.long 0x214++0x3
    line.long 0x00 "RX_FIFO_STAT,Rx Fifo Status Register"
        hexmask.long.byte 0x00 0.--2. 1. " CH0 ,"
        textline "            "
        hexmask.long.byte 0x00 2.--4. 1. " CH1 ,"
        textline "            "
        hexmask.long.byte 0x00 4.--6. 1. " CH2 ,"
        textline "            "
        hexmask.long.byte 0x00 6.--8. 1. " CH3 ,"
        textline "            "
        hexmask.long.byte 0x00 8.--10. 1. " CH4 ,"
        textline "            "
        hexmask.long.byte 0x00 10.--12. 1. " CH5 ,"
        textline "            "
        hexmask.long.byte 0x00 12.--14. 1. " CH6 ,"
        textline "            "
        hexmask.long.byte 0x00 14.--16. 1. " CH7 ,"
        textline "            "
        hexmask.long.byte 0x00 16.--18. 1. " CH8 ,"
        textline "            "
        hexmask.long.byte 0x00 18.--20. 1. " CH9 ,"
        textline "            "
        hexmask.long.byte 0x00 20.--22. 1. " CH10 ,"
        textline "            "
        hexmask.long.byte 0x00 22.--24. 1. " CH11 ,"
        textline "            "
        hexmask.long.byte 0x00 24.--26. 1. " CH12 ,"
        textline "            "
        hexmask.long.byte 0x00 26.--28. 1. " CH13 ,"
        textline "            "
        hexmask.long.byte 0x00 28.--30. 1. " CH14 ,"
        textline "            "
        hexmask.long.byte 0x00 30.--32. 1. " CH15 ,"
width 16.
group.long 0x228++0x3
    line.long 0x00 "AHB_MASTER_CONF,Ahb Master Config Register"
        hexmask.long.byte 0x00 0.--4. 1. " DMA_INSERT_IDLE_NUM ,These bits used to set the number of ""IDLE"" cycles when DMA_MODE == 2'b0x."
        textline "               "
        hexmask.long.byte 0x00 4.--6. 1. " DMA_MODE ,"
        textline "               "
        hexmask.long.byte 0x00 6.--10. 1. " DP_HOLD_CYCLE ,These bits used to set the number of cycles for DP access fifo."
width 13.
group.long 0x22c++0x3
    line.long 0x00 "TX_BREAK_LEN,TX Break Length Register"
        hexmask.long.byte 0x00 0.--6. 1. " COUNT ,The tx break length count."


tree.end



;--------------------------------------------------------------------------------
; MLB150
;--------------------------------------------------------------------------------
tree "MLB150"
    base ad:0x0218c000

width 6.
group.long 0x0++0x3
    line.long 0x00 "MLBC0,MediaLB Control 0 Register"
        bitfld.long 0x00 0. " MLBEN ,MediaLB enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 2.--5. 1. " MLBCLK_2_0 ,MLB_CLK (MediaLB clock) speed select."
        textline "     "
        bitfld.long 0x00 5. " MLBPEN ,MediaLB 6-pin enable." "0,1"
        textline "     "
        bitfld.long 0x00 7. " MLBLK ,MediaLB lock status." "0,1"
        textline "     "
        bitfld.long 0x00 12. " ASYRETRY ,Asynchronous Tx packet retry." "0,1"
        textline "     "
        bitfld.long 0x00 14. " CTLRETRY ,Control Tx packet retry." "0,1"
        textline "     "
        hexmask.long.byte 0x00 15.--18. 1. " FCNT ,The number of frames per sub-buffer for synchronous channels."
width 7.
group.long 0x8++0x3
    line.long 0x00 "MLBPC0,MediaLB 6-pin Control 0 Register"
        bitfld.long 0x00 11. " MCLKHYS ,MediaLB (6-pin) hysteresis enable." "0,1"
width 4.
rgroup.long 0xc++0x3
    line.long 0x00 "MS0,MediaLB Channel Status 0 Register"
        hexmask.long.long 0x00 0.--32. 1. " MCS_31_0 ,MediaLB channel status."
width 7.
rgroup.long 0xd++0x3
    line.long 0x00 "MLBPC2,MediaLB 6-pin Control 2 Register"
        bitfld.long 0x00 0. " SDOPC ,MLB 3-pin interface: Signal/Data output phase control." "0,1"
        textline "      "
        hexmask.long.byte 0x00 1.--3. 1. " SDRTO ,MLB 6-pin interface: Signal/Data receiver threshold offset control."
        textline "      "
        hexmask.long.byte 0x00 8.--15. 1. " MORCD ,Divider factor of MLB output reference clock.MLB output reference clock is divided by MLB bus clock, the divider factor can be choose between 1 to 128."
        textline "      "
        bitfld.long 0x00 15. " MORCE ,Output reference clock (for SPDIF and ASRC) enable." "0,1"
width 4.
rgroup.long 0x14++0x3
    line.long 0x00 "MS1,MediaLB Channel Status1 Register"
        hexmask.long.long 0x00 0.--32. 1. " MCS_63_32 ,MediaLB channel status."
width 4.
rgroup.long 0x20++0x3
    line.long 0x00 "MSS,MediaLB System Status Register"
        bitfld.long 0x00 0. " RSTSYSCMD ,Reset system command detected (in the system quadlet)." "0,1"
        textline "   "
        bitfld.long 0x00 1. " LKSYSCMD ,Network lock system command detected (in the system quadlet)." "0,1"
        textline "   "
        bitfld.long 0x00 2. " ULKSYSCMD ,Network unlock system command detected (in the system quadlet)." "0,1"
        textline "   "
        bitfld.long 0x00 3. " CSSYSCMD ,Channel scan system command detected (in the system quadlet)." "0,1"
        textline "   "
        bitfld.long 0x00 4. " SWSYSCMD ,Software system command detected (in the system quadlet)." "0,1"
        textline "   "
        bitfld.long 0x00 5. " SERVREQ ,Service request enabled." "0,1"
width 4.
rgroup.long 0x24++0x3
    line.long 0x00 "MSD,MediaLB System Data Register"
        hexmask.long.byte 0x00 0.--8. 1. " SD0_7_0 ,System data (byte 0)."
        textline "   "
        hexmask.long.byte 0x00 8.--16. 1. " SD1_7_0 ,System data (byte 1)."
        textline "   "
        hexmask.long.byte 0x00 16.--24. 1. " SD2_7_0 ,System data (byte 2)."
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " SD3_7_0 ,System data (byte 3)."
width 5.
group.long 0x2c++0x3
    line.long 0x00 "MIEN,MediaLB Interrupt Enable Register"
        bitfld.long 0x00 0. " ISOC_PE ,Isochronous Rx protocol error enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ISOC_BUFO ,Isochronous Rx buffer overflow enable." "0,1"
        textline "    "
        bitfld.long 0x00 16. " SYNC_PE ,Synchronous protocol error enable." "0,1"
        textline "    "
        bitfld.long 0x00 17. " ARX_DONE ,Asynchronous Rx done enable." "0,1"
        textline "    "
        bitfld.long 0x00 18. " ARX_PE ,Asynchronous Rx protocol error enable." "0,1"
        textline "    "
        bitfld.long 0x00 19. " ARX_BREAK ,Asynchronous Rx break enable." "0,1"
        textline "    "
        bitfld.long 0x00 20. " ATX_DONE ,Asynchronous Tx packet done enable." "0,1"
        textline "    "
        bitfld.long 0x00 21. " ATX_PE ,Asynchronous Tx protocol error enable." "0,1"
        textline "    "
        bitfld.long 0x00 22. " ATX_BREAK ,Asynchronous Tx break enable." "0,1"
        textline "    "
        bitfld.long 0x00 24. " CRX_DONE ,Control Rx packet done enable." "0,1"
        textline "    "
        bitfld.long 0x00 25. " CRX_PE ,Control Rx protocol error enable." "0,1"
        textline "    "
        bitfld.long 0x00 26. " CRX_BREAK ,Control Rx break enable." "0,1"
        textline "    "
        bitfld.long 0x00 27. " CTX_DONE ,Control Tx packet done enable." "0,1"
        textline "    "
        bitfld.long 0x00 28. " CTX_PE ,Control Tx protocol error enable." "0,1"
        textline "    "
        bitfld.long 0x00 29. " CTX_BREAK ,Control Tx break enable." "0,1"
width 7.
group.long 0x38++0x3
    line.long 0x00 "MLBPC1,MediaLB 6-pin Control 1 Register"
        hexmask.long.byte 0x00 0.--4. 1. " SDRCVBIAS_3_0 ,Signal/Data receiver bias control (for MediaLB 6-pin interface)."
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " SDXMTBIAS_3_0 ,Signal/Data transmitter bias control (for MediaLB 6-pin interface)."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " CKRCVBIAS_3_0 ,Clock receiver bias control (for MediaLB 6-pin interface)."
width 6.
rgroup.long 0x3c++0x3
    line.long 0x00 "MLBC1,MediaLB Control 1 Register"
        bitfld.long 0x00 6. " LOCK ,MediaLB lock error status." "0,1"
        textline "     "
        bitfld.long 0x00 7. " CLKM ,MediaLB clock missing status." "0,1"
        textline "     "
        hexmask.long.byte 0x00 8.--16. 1. " NDA_7_0 ,Node device address."
width 5.
group.long 0x80++0x3
    line.long 0x00 "HCTL,HBI Control Register"
        bitfld.long 0x00 0. " RST0 ,AGU0 software reset" "0,1"
        textline "    "
        bitfld.long 0x00 1. " RST1 ,AGU1 software reset" "0,1"
        textline "    "
        bitfld.long 0x00 15. " EN ,HBI enable" "0,1"
width 6.
group.long 0x88++0x3
    line.long 0x00 "HCMR0,HBI Channel Mask 0 Register"
        hexmask.long.long 0x00 0.--32. 1. " CHM_31_0_P ,Bitwise channel mask bit"
width 6.
group.long 0x8c++0x3
    line.long 0x00 "HCMR1,HBI Channel Mask 1 Register"
        hexmask.long.long 0x00 0.--32. 1. " CHM_63_32 ,Bitwise channel mask bit"
width 6.
rgroup.long 0x90++0x3
    line.long 0x00 "HCER0,HBI Channel Error 0 Register"
        hexmask.long.long 0x00 0.--32. 1. " CERR_31_0 ,Bitwise channel error bit"
width 6.
rgroup.long 0x94++0x3
    line.long 0x00 "HCER1,HBI Channel Error 1 Register"
        hexmask.long.long 0x00 0.--32. 1. " CERR_63_32 ,Bitwise channel error bit"
width 6.
rgroup.long 0x98++0x3
    line.long 0x00 "HCBR0,HBI Channel Busy 0 Register"
        hexmask.long.long 0x00 0.--32. 1. " CHB_31_0 ,Bitwise channel busy bit"
width 6.
rgroup.long 0x9c++0x3
    line.long 0x00 "HCBR1,HBI Channel Busy 1 Register"
        hexmask.long.long 0x00 0.--32. 1. " CHB_63_32 ,Bitwise channel busy bit"
width 6.
group.long 0xc0++0x3
    line.long 0x00 "MDAT0,MIF Data 0 Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA_31_0 ,CTR data - bits[31:0] of 128-bit entry or DBR data - bits[7:0] of 8-bit entry"
width 6.
group.long 0xc4++0x3
    line.long 0x00 "MDAT1,MIF Data 1 Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA_63_32 ,CTR data - bits[63:32] of 128-bit entry"
width 6.
group.long 0xc8++0x3
    line.long 0x00 "MDAT2,MIF Data 2 Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA_95_64 ,CTR data - bits[95:64] of 128-bit entry"
width 6.
group.long 0xcc++0x3
    line.long 0x00 "MDAT3,MIF Data 3 Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA_127_96 ,CTR data - bits[127:96] of 128-bit entry"
width 6.
group.long 0xd0++0x3
    line.long 0x00 "MDWE0,MIF Data Write Enable 0 Register"
        hexmask.long.long 0x00 0.--32. 1. " MASK_31_0 ,Bitwise write enable for CTR data - bits[31:0]"
width 6.
group.long 0xd4++0x3
    line.long 0x00 "MDWE1,MIF Data Write Enable 1 Register"
        hexmask.long.long 0x00 0.--32. 1. " MASK_63_32 ,Bitwise write enable for CTR data - bits[63:32]"
width 6.
group.long 0xd8++0x3
    line.long 0x00 "MDWE2,MIF Data Write Enable 2 Register"
        hexmask.long.long 0x00 0.--32. 1. " MASK_95_64 ,Bitwise write enable for CTR data - bits[95:64]"
width 6.
group.long 0xdc++0x3
    line.long 0x00 "MDWE3,MIF Data Write Enable 3 Register"
        hexmask.long.long 0x00 0.--32. 1. " MASK_127_96 ,Bitwise write enable for CTR data - bits[127:96]"
width 5.
rgroup.long 0xe0++0x3
    line.long 0x00 "MCTL,MIF Control Register"
        bitfld.long 0x00 0. " XCMP ,Transfer complete (write 0 to clear)" "0,1"
width 5.
group.long 0xe4++0x3
    line.long 0x00 "MADR,MIF Address Register"
        hexmask.long.byte 0x00 0.--8. 1. " ADDR_7_0 ,CTR address of 128-bit entry or DBR address of 8-bit entry - bits[7:0]"
        textline "    "
        hexmask.long.byte 0x00 8.--14. 1. " ADDR_13_8 ,DBR address of 8-bit entry - bits[13:8]"
        textline "    "
        bitfld.long 0x00 30. " TB ,Target location bit" "0,1"
        textline "    "
        bitfld.long 0x00 31. " WNR ,Write-Not-Read selection" "0,1"
width 5.
group.long 0x3c0++0x3
    line.long 0x00 "ACTL,AHB Control Register"
        bitfld.long 0x00 0. " SCE ,Software clear enable:" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SMX ,AHB interrupt mux enable:" "0,1"
        textline "    "
        bitfld.long 0x00 2. " DMA_MODE ,DMA Mode:" "0,1"
        textline "    "
        bitfld.long 0x00 4. " MPB ,DMA Packet buffering mode." "0,1"
width 6.
rgroup.long 0x3d0++0x3
    line.long 0x00 "ACSR0,AHB Channel Status 0 Register"
        hexmask.long.long 0x00 0.--32. 1. " CHS ,Interrupt status for logical channels 31 to 0:"
width 6.
rgroup.long 0x3d4++0x3
    line.long 0x00 "ACSR1,AHB Channel Status 1 Register"
        hexmask.long.long 0x00 0.--32. 1. " CHS ,Interrupt status for logical channels 63 to 32:"
width 6.
group.long 0x3d8++0x3
    line.long 0x00 "ACMR0,AHB Channel Mask 0 Register"
        hexmask.long.long 0x00 0.--32. 1. " CHM_31_0 ,Bitwise channel mask bit:"
width 6.
group.long 0x3dc++0x3
    line.long 0x00 "ACMR1,AHB Channel Mask 1 Register"
        hexmask.long.long 0x00 0.--32. 1. " CHM ,Bitwise channel mask bit:"


tree.end



;--------------------------------------------------------------------------------
; MMDC
;--------------------------------------------------------------------------------
tree.open "MMDC"
    tree "MMDC1"
        base ad:0x021b0000

width 6.
group.long 0x0++0x3
    line.long 0x00 "MDCTL,MMDC Core Control Register"
        hexmask.long.byte 0x00 16.--18. 1. " DSIZ ,DDR data bus size."
        textline "     "
        bitfld.long 0x00 19. " BL ,Burst Length." "0,1"
        textline "     "
        hexmask.long.byte 0x00 20.--23. 1. " COL ,Column Address Width."
        textline "     "
        hexmask.long.byte 0x00 24.--27. 1. " ROW ,Row Address Width."
        textline "     "
        bitfld.long 0x00 30. " SDE_1 ,MMDC Enable CS1." "0,1"
        textline "     "
        bitfld.long 0x00 31. " SDE_0 ,MMDC Enable CS0." "0,1"
width 6.
group.long 0x4++0x3
    line.long 0x00 "MDPDC,MMDC Core Power Down Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " TCKSRE ,Valid clock cycles after self-refresh entry."
        textline "     "
        hexmask.long.byte 0x00 3.--6. 1. " TCKSRX ,Valid clock cycles before self-refresh exit."
        textline "     "
        bitfld.long 0x00 6. " BOTH_CS_PD ,Parallel power down entry to both chip selects." "0,1"
        textline "     "
        bitfld.long 0x00 7. " SLOW_PD ,Slow/fast power down." "0,1"
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " PWDT_0 ,Power Down Timer - Chip Select 0."
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " PWDT_1 ,Power Down Timer - Chip Select 1."
        textline "     "
        hexmask.long.byte 0x00 16.--19. 1. " TCKE ,CKE minimum pulse width."
        textline "     "
        hexmask.long.byte 0x00 24.--27. 1. " PRCT_0 ,Precharge Timer - Chip Select 0."
        textline "     "
        hexmask.long.byte 0x00 28.--31. 1. " PRCT_1 ,Precharge Timer - Chip Select 1."
width 6.
group.long 0x8++0x3
    line.long 0x00 "MDOTC,MMDC Core ODT Timing Control Register"
        hexmask.long.byte 0x00 4.--9. 1. " TODT_IDLE_OFF ,ODT turn off latency."
        textline "     "
        hexmask.long.byte 0x00 12.--15. 1. " TODTLON ,ODT turn on latency."
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " TAXPD ,Asynchronous ODT to power down exit delay."
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " TANPD ,Asynchronous ODT to power down entry delay."
        textline "     "
        hexmask.long.byte 0x00 24.--27. 1. " TAONPD ,Asynchronous RTT turn-on delay (power down with DLL frozen)."
        textline "     "
        hexmask.long.byte 0x00 27.--30. 1. " TAOFPD ,Asynchronous RTT turn-off delay (power down with DLL frozen)."
width 7.
group.long 0xc++0x3
    line.long 0x00 "MDCFG0,MMDC Core Timing Configuration Register 0"
        hexmask.long.byte 0x00 0.--4. 1. " TCL ,CAS Read Latency."
        textline "      "
        hexmask.long.byte 0x00 4.--9. 1. " TFAW ,Four Active Window (all banks)."
        textline "      "
        hexmask.long.byte 0x00 9.--13. 1. " TXPDLL ,Exit precharge power down with DLL frozen to commands requiring DLL."
        textline "      "
        hexmask.long.byte 0x00 13.--16. 1. " TXP ,Exit power down with DLL-on to any valid command."
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " TXS ,Exit self refresh to non READ command."
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " TRFC ,Refresh command to Active or Refresh command time."
width 7.
group.long 0x10++0x3
    line.long 0x00 "MDCFG1,MMDC Core Timing Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " TCWL ,CAS Write Latency."
        textline "      "
        hexmask.long.byte 0x00 5.--9. 1. " TMRD ,Mode Register Set command cycle (all banks)."
        textline "      "
        hexmask.long.byte 0x00 9.--12. 1. " TWR ,WRITE recovery time (same bank)."
        textline "      "
        bitfld.long 0x00 15. " TRPA ,Precharge-all command period." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--21. 1. " TRAS ,Active to Precharge command period (same bank)."
        textline "      "
        hexmask.long.byte 0x00 21.--26. 1. " TRC ,Active to Active or Refresh command period (same bank)."
        textline "      "
        hexmask.long.byte 0x00 26.--29. 1. " TRP ,Precharge command period (same bank)."
        textline "      "
        hexmask.long.byte 0x00 29.--32. 1. " TRCD ,Active command to internal read or write delay time (same bank)."
width 7.
group.long 0x14++0x3
    line.long 0x00 "MDCFG2,MMDC Core Timing Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " TRRD ,Active to Active command period (all banks)."
        textline "      "
        hexmask.long.byte 0x00 3.--6. 1. " TWTR ,Internal WRITE to READ command delay (same bank)."
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " TRTP ,Internal READ command to Precharge command delay (same bank)."
        textline "      "
        hexmask.long.word 0x00 16.--25. 1. " TDLLK ,DLL locking time."
width 7.
group.long 0x18++0x3
    line.long 0x00 "MDMISC,MMDC Core Miscellaneous Register"
        bitfld.long 0x00 1. " RST ,Software Reset." "0,1"
        textline "      "
        bitfld.long 0x00 2. " LPDDR2_2CH ,LPDDR2 2-channels mode." "0,1"
        textline "      "
        hexmask.long.byte 0x00 3.--5. 1. " DDR_TYPE ,DDR TYPE."
        textline "      "
        bitfld.long 0x00 5. " DDR_4_BANK ,Number of banks per DDR device." "0,1"
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " RALAT ,Read Additional Latency."
        textline "      "
        hexmask.long.byte 0x00 9.--11. 1. " MIF3_MODE ,Command prediction working mode."
        textline "      "
        bitfld.long 0x00 11. " LPDDR2_S2 ,LPDDR2 S2 device type indication." "0,1"
        textline "      "
        bitfld.long 0x00 12. " BI_ON ,Bank Interleaving On." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " WALAT ,Write Additional latency."
        textline "      "
        bitfld.long 0x00 18. " LHD ,Latency hiding disable." "0,1"
        textline "      "
        bitfld.long 0x00 19. " ADDR_MIRROR ,Address mirroring." "0,1"
        textline "      "
        bitfld.long 0x00 20. " CALIB_PER_CS ,Number of chip-select for calibration process." "0,1"
        textline "      "
        bitfld.long 0x00 30. " CS1_RDY ,External status device on CS1." "0,1"
        textline "      "
        bitfld.long 0x00 31. " CS0_RDY ,External status device on CS0." "0,1"
width 6.
group.long 0x1c++0x3
    line.long 0x00 "MDSCR,MMDC Core Special Command Register"
        hexmask.long.byte 0x00 0.--3. 1. " CMD_BA ,Bank Address."
        textline "     "
        bitfld.long 0x00 3. " CMD_CS ,Chip Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 4.--7. 1. " CMD ,Command."
        textline "     "
        bitfld.long 0x00 9. " WL_EN ,DQS pads direction." "0,1"
        textline "     "
        bitfld.long 0x00 10. " MRR_READ_DATA_VALID ,MRR read data valid." "0,1"
        textline "     "
        bitfld.long 0x00 14. " CON_ACK ,Configuration acknowledge." "0,1"
        textline "     "
        bitfld.long 0x00 15. " CON_REQ ,Configuration request." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--24. 1. " CMD_ADDR_LSB_MR_ADDR ,Command/Address LSB."
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " CMD_ADDR_MSB_MR_OP ,Command/Address MSB."
width 6.
group.long 0x20++0x3
    line.long 0x00 "MDREF,MMDC Core Refresh Control Register"
        bitfld.long 0x00 0. " START_REF ,Manual start of refresh cycle." "0,1"
        textline "     "
        hexmask.long.byte 0x00 11.--14. 1. " REFR ,Refresh Rate."
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " REF_SEL ,Refresh Selector."
        textline "     "
        hexmask.long.word 0x00 16.--32. 1. " REF_CNT ,Refresh Counter at DDR clock period If REF_SEL equals '2' a refresh cycle will begin every amount of DDR cycles configured in this field."
width 6.
group.long 0x2c++0x3
    line.long 0x00 "MDRWD,MMDC Core Read/Write Command Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RTR_DIFF ,Read to read delay for different chip-select."
        textline "     "
        hexmask.long.byte 0x00 3.--6. 1. " RTW_DIFF ,Read to write delay for different chip-select."
        textline "     "
        hexmask.long.byte 0x00 6.--9. 1. " WTW_DIFF ,Write to write delay for different chip-select."
        textline "     "
        hexmask.long.byte 0x00 9.--12. 1. " WTR_DIFF ,Write to read delay for different chip-select."
        textline "     "
        hexmask.long.byte 0x00 12.--15. 1. " RTW_SAME ,Read to write delay for the same chip-select."
        textline "     "
        hexmask.long.word 0x00 16.--29. 1. " TDAI ,Device auto initialization period.(maximum) This field is relevant only to LPDDR2 mode"
width 5.
group.long 0x30++0x3
    line.long 0x00 "MDOR,MMDC Core Out of Reset Delays Register"
        hexmask.long.byte 0x00 0.--6. 1. " RST_TO_CKE ,DDR3: Time from SDE enable to CKE rise."
        textline "    "
        hexmask.long.byte 0x00 8.--14. 1. " SDE_TO_RST ,DDR3: Time from SDE enable until DDR reset# is high."
        textline "    "
        hexmask.long.byte 0x00 16.--24. 1. " TXPR ,DDR2/ DDR3: CKE HIGH to a valid command."
width 6.
rgroup.long 0x34++0x3
    line.long 0x00 "MDMRR,MMDC Core MRR Data Register"
        hexmask.long.byte 0x00 0.--8. 1. " MRR_READ_DATA0 ,MRR DATA that arrived on DQ[7:0]"
        textline "     "
        hexmask.long.byte 0x00 8.--16. 1. " MRR_READ_DATA1 ,MRR DATA that arrived on DQ[15:8]"
        textline "     "
        hexmask.long.byte 0x00 16.--24. 1. " MRR_READ_DATA2 ,MRR DATA that arrived on DQ[23:16]"
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " MRR_READ_DATA3 ,MRR DATA that arrived on DQ[31:24]"
width 9.
group.long 0x38++0x3
    line.long 0x00 "MDCFG3LP,MMDC Core Timing Configuration Register 3"
        hexmask.long.byte 0x00 0.--4. 1. " TRPAB_LP ,Precharge (all banks) command period."
        textline "        "
        hexmask.long.byte 0x00 4.--8. 1. " TRPPB_LP ,Precharge (per bank) command period (same bank)."
        textline "        "
        hexmask.long.byte 0x00 8.--12. 1. " TRCD_LP ,Active command to internal read or write delay time (same bank)."
        textline "        "
        hexmask.long.byte 0x00 16.--22. 1. " RC_LP ,Active to Active or Refresh command period (same bank)."
width 6.
group.long 0x3c++0x3
    line.long 0x00 "MDMR4,MMDC Core MR4 Derating Register"
        bitfld.long 0x00 0. " UPDATE_DE_REQ ,Update Derated Values Request." "0,1"
        textline "     "
        bitfld.long 0x00 1. " UPDATE_DE_ACK ,Update Derated Values Acknowledge." "0,1"
        textline "     "
        bitfld.long 0x00 4. " TRCD_DE ,tRCD derating value." "0,1"
        textline "     "
        bitfld.long 0x00 5. " TRC_DE ,tRC derating value." "0,1"
        textline "     "
        bitfld.long 0x00 6. " TRAS_DE ,tRAS derating value." "0,1"
        textline "     "
        bitfld.long 0x00 7. " TRP_DE ,tRP derating value." "0,1"
        textline "     "
        bitfld.long 0x00 8. " TRRD_DE ,tRRD derating value." "0,1"
width 6.
group.long 0x40++0x3
    line.long 0x00 "MDASP,MMDC Core Address Space Partition Register"
        hexmask.long.byte 0x00 0.--7. 1. " CS0_END ,CS0_END."
width 7.
group.long 0x400++0x3
    line.long 0x00 "MAARCR,MMDC Core AXI Reordering Control Regsiter"
        hexmask.long.byte 0x00 0.--4. 1. " ARCR_GUARD ,ARCR Guard."
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " ARCR_DYN_MAX ,ARCR Dynamic Maximum."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " ARCR_DYN_JMP ,ARCR Dynamic Jump."
        textline "      "
        hexmask.long.byte 0x00 16.--19. 1. " ARCR_ACC_HIT ,ARCR Access Hit Rate."
        textline "      "
        hexmask.long.byte 0x00 20.--23. 1. " ARCR_PAG_HIT ,ARCR Page Hit Rate."
        textline "      "
        bitfld.long 0x00 24. " ARCR_RCH_EN ,This bit defines whether Real time channel is activated and bypassed all other pending accesses, So accesses with QoS=='F' will be granted the highest prioritiy in the optimization/reordering mechanism Default value is 0x1 - encoding 1 (Enabled)" "0,1"
        textline "      "
        bitfld.long 0x00 28. " ARCR_EXC_ERR_EN ,This bit defines whether exclusive read/write access violation of AXI 6.2.4 rule result in SLV Error response or in OKAY response Default value is 0x1 - encoding 1(response is SLV Error)" "0,1"
        textline "      "
        bitfld.long 0x00 30. " ARCR_SEC_ERR_EN ,This bit defines whether security read/write access violation result in SLV Error response or in OKAY response Default value is 0x1 - encoding 1(response is SLV Error, rresp/bresp=2'b10)" "0,1"
        textline "      "
        bitfld.long 0x00 31. " ARCR_SEC_ERR_LOCK ,Once set, this bit locks ARCR_SEC_ERR_EN and prevents from its updating." "0,1"
width 6.
group.long 0x404++0x3
    line.long 0x00 "MAPSR,MMDC Core Power Saving Control and Status Register"
        bitfld.long 0x00 0. " PSD ,Automatic Power Saving Disable." "0,1"
        textline "     "
        bitfld.long 0x00 4. " PSS ,Power Saving Status." "0,1"
        textline "     "
        bitfld.long 0x00 5. " RIS ,Read Idle Status.This read only bit indicates whether read request buffer is idle (empty) or not." "0,1"
        textline "     "
        bitfld.long 0x00 6. " WIS ,Write Idle Status.This read only bit indicates whether write request buffer is idle (empty) or not." "0,1"
        textline "     "
        hexmask.long.byte 0x00 8.--16. 1. " PST ,Automatic Power saving timer."
        textline "     "
        bitfld.long 0x00 20. " LPMD ,General LPMD request." "0,1"
        textline "     "
        bitfld.long 0x00 21. " DVFS ,General DVFS request." "0,1"
        textline "     "
        bitfld.long 0x00 24. " LPACK ,General low-power acknowledge." "0,1"
        textline "     "
        bitfld.long 0x00 25. " DVACK ,General DVFS acknowledge." "0,1"
width 9.
group.long 0x408++0x3
    line.long 0x00 "MAEXIDR0,MMDC Core Exclusive ID Monitor Register0"
        hexmask.long.word 0x00 0.--16. 1. " EXC_ID_MONITOR0 ,This feild defines ID for Exclusive monitor#0."
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " EXC_ID_MONITOR1 ,This feild defines ID for Exclusive monitor#1."
width 9.
group.long 0x40c++0x3
    line.long 0x00 "MAEXIDR1,MMDC Core Exclusive ID Monitor Register1"
        hexmask.long.word 0x00 0.--16. 1. " EXC_ID_MONITOR2 ,This feild defines ID for Exclusive monitor#2."
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " EXC_ID_MONITOR3 ,This feild defines ID for Exclusive monitor#3."
width 8.
group.long 0x410++0x3
    line.long 0x00 "MADPCR0,MMDC Core Debug and Profiling Control Register 0"
        bitfld.long 0x00 0. " DBG_EN ,Debug and Profiling Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " DBG_RST ,Debug and Profiling Reset." "0,1"
        textline "       "
        bitfld.long 0x00 2. " PRF_FRZ ,Profiling freeze." "0,1"
        textline "       "
        bitfld.long 0x00 3. " CYC_OVF ,Total Profiling Cycles Count Overflow." "0,1"
        textline "       "
        bitfld.long 0x00 8. " SBS_EN ,Step By Step debug Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " SBS ,Step By Step trigger." "0,1"
width 8.
group.long 0x414++0x3
    line.long 0x00 "MADPCR1,MMDC Core Debug and Profiling Control Register 1"
        hexmask.long.word 0x00 0.--16. 1. " PRF_AXI_ID ,Profiling AXI ID."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " PRF_AXI_ID_MASK ,Profiling AXI ID Mask."
width 8.
rgroup.long 0x418++0x3
    line.long 0x00 "MADPSR0,MMDC Core Debug and Profiling Status Register 0"
        hexmask.long.long 0x00 0.--32. 1. " CYC_COUNT ,Total Profiling cycle Count."
width 8.
rgroup.long 0x41c++0x3
    line.long 0x00 "MADPSR1,MMDC Core Debug and Profiling Status Register 1"
        hexmask.long.long 0x00 0.--32. 1. " BUSY_COUNT ,Profiling Busy Cycles Count."
width 8.
rgroup.long 0x420++0x3
    line.long 0x00 "MADPSR2,MMDC Core Debug and Profiling Status Register 2"
        hexmask.long.long 0x00 0.--32. 1. " RD_ACC_COUNT ,Profiling Read Access Count."
width 8.
rgroup.long 0x424++0x3
    line.long 0x00 "MADPSR3,MMDC Core Debug and Profiling Status Register 3"
        hexmask.long.long 0x00 0.--32. 1. " WR_ACC_COUNT ,Profiling Write Access Count."
width 8.
rgroup.long 0x428++0x3
    line.long 0x00 "MADPSR4,MMDC Core Debug and Profiling Status Register 4"
        hexmask.long.long 0x00 0.--32. 1. " RD_BYTES_COUNT ,Profiling Read Bytes Count."
width 8.
rgroup.long 0x42c++0x3
    line.long 0x00 "MADPSR5,MMDC Core Debug and Profiling Status Register 5"
        hexmask.long.long 0x00 0.--32. 1. " WR_BYTES_COUNT ,Profiling Write Bytes Count."
width 7.
rgroup.long 0x430++0x3
    line.long 0x00 "MASBS0,MMDC Core Step By Step Address Register"
        hexmask.long.long 0x00 0.--32. 1. " SBS_ADDR ,Step By Step Address."
width 7.
rgroup.long 0x434++0x3
    line.long 0x00 "MASBS1,MMDC Core Step By Step Address Attributes Register"
        bitfld.long 0x00 0. " SBS_VLD ,Step By Step Valid." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SBS_TYPE ,Step By Step Request Type." "0,1"
        textline "      "
        hexmask.long.byte 0x00 2.--4. 1. " SBS_LOCK ,Step By Step Lock."
        textline "      "
        hexmask.long.byte 0x00 4.--7. 1. " SBS_PROT ,Step By Step Protection."
        textline "      "
        hexmask.long.byte 0x00 7.--10. 1. " SBS_SIZE ,Step By Step Size."
        textline "      "
        hexmask.long.byte 0x00 10.--12. 1. " SBS_BURST ,Step By Step Burst."
        textline "      "
        bitfld.long 0x00 12. " SBS_BUFF ,Step By Step Buffered." "0,1"
        textline "      "
        hexmask.long.byte 0x00 13.--16. 1. " SBS_LEN ,Step By Step Length."
        textline "      "
        hexmask.long.word 0x00 16.--32. 1. " SBS_AXI_ID ,Step By Step AXI ID."
width 7.
group.long 0x440++0x3
    line.long 0x00 "MAGENP,MMDC Core General Purpose Register"
        hexmask.long.long 0x00 0.--32. 1. " GP31_GP0 ,General purpose read/write bits."
width 11.
group.long 0x800++0x3
    line.long 0x00 "MPZQHWCTRL,MMDC PHY ZQ HW control register"
        hexmask.long.byte 0x00 0.--2. 1. " ZQ_MODE ,ZQ calibration mode:"
        textline "          "
        hexmask.long.byte 0x00 2.--6. 1. " ZQ_HW_PER ,ZQ periodic calibration time."
        textline "          "
        hexmask.long.byte 0x00 6.--11. 1. " ZQ_HW_PU_RES ,ZQ automatic calibration pull-up result."
        textline "          "
        hexmask.long.byte 0x00 11.--16. 1. " ZQ_HW_PD_RES ,ZQ HW calibration pull-down result."
        textline "          "
        bitfld.long 0x00 16. " ZQ_HW_FOR ,Force ZQ automatic calibration process with the i.MX ZQ calibration pad." "0,1"
        textline "          "
        hexmask.long.byte 0x00 17.--20. 1. " TZQ_INIT ,Device ZQ long/init time."
        textline "          "
        hexmask.long.byte 0x00 20.--23. 1. " TZQ_OPER ,Device ZQ long/oper time."
        textline "          "
        hexmask.long.byte 0x00 23.--26. 1. " TZQ_CS ,Device ZQ short time."
        textline "          "
        hexmask.long.byte 0x00 27.--32. 1. " ZQ_EARLY_COMPARATOR_EN_TIMER ,ZQ early comparator enable timer."
width 11.
group.long 0x804++0x3
    line.long 0x00 "MPZQSWCTRL,MMDC PHY ZQ SW control register"
        bitfld.long 0x00 0. " ZQ_SW_FOR ,ZQ SW calibration enable." "0,1"
        textline "          "
        bitfld.long 0x00 1. " ZQ_SW_RES ,ZQ software calibration result." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--7. 1. " ZQ_SW_PU_VAL ,ZQ software pull-up resistence.This field determines the value of the PU resistor during SW ZQ calibration."
        textline "          "
        hexmask.long.byte 0x00 7.--12. 1. " ZQ_SW_PD_VAL ,ZQ software pull-down resistence.This field determines the value of the PD resistor during SW ZQ calibration."
        textline "          "
        bitfld.long 0x00 12. " ZQ_SW_PD ,ZQ software PU/PD calibration." "0,1"
        textline "          "
        bitfld.long 0x00 13. " USE_ZQ_SW_VAL ,Use SW ZQ configured value for I/O pads resistor controls." "0,1"
        textline "          "
        hexmask.long.byte 0x00 16.--18. 1. " ZQ_CMP_OUT_SMP ,Defines the amount of cycles between driving the ZQ signals to the ZQ pad and till sampling the comparator enable output while performing ZQ calibration process with the i.MX ZQ calibration pad"
width 8.
group.long 0x808++0x3
    line.long 0x00 "MPWLGCR,MMDC PHY Write Leveling Configuration and Error Status Register"
        bitfld.long 0x00 0. " HW_WL_EN ,Write-Leveling HW (automatic) enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SW_WL_EN ,Write-Leveling SW enable." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SW_WL_CNT_EN ,SW write-leveling count down enable.This bit when asserted set a certain delay of (25+15) cycles from the setting of SW_WL_EN and before driving the DQS to the DDR device.This bit should be asserted before the first SW write-leveling request and after issuing the write leveling MRS command" "0,1"
        textline "       "
        bitfld.long 0x00 4. " WL_SW_RES0 ,Byte0 write-leveling software result." "0,1"
        textline "       "
        bitfld.long 0x00 5. " WL_SW_RES1 ,Byte1 write-leveling software result." "0,1"
        textline "       "
        bitfld.long 0x00 6. " WL_SW_RES2 ,Byte2 write-leveling software result." "0,1"
        textline "       "
        bitfld.long 0x00 7. " WL_SW_RES3 ,Byte3 write-leveling software result." "0,1"
        textline "       "
        bitfld.long 0x00 8. " WL_HW_ERR0 ,Byte0 write-leveling HW calibration error." "0,1"
        textline "       "
        bitfld.long 0x00 9. " WL_HW_ERR1 ,Byte1 write-leveling HW calibration error." "0,1"
        textline "       "
        bitfld.long 0x00 10. " WL_HW_ERR2 ,Byte2 write-leveling HW calibration error." "0,1"
        textline "       "
        bitfld.long 0x00 11. " WL_HW_ERR3 ,Byte3 write-leveling HW calibration error." "0,1"
width 12.
group.long 0x80c++0x3
    line.long 0x00 "MPWLDECTRL0,MMDC PHY Write Leveling Delay Control Register 0"
        hexmask.long.byte 0x00 0.--7. 1. " WL_DL_ABS_OFFSET0 ,Absolute write-leveling delay offset for Byte 0."
        textline "           "
        bitfld.long 0x00 8. " WL_HC_DEL0 ,Write leveling half cycle delay for Byte 0." "0,1"
        textline "           "
        hexmask.long.byte 0x00 9.--11. 1. " WL_CYC_DEL0 ,Write leveling cycle delay for Byte 0."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " WL_DL_ABS_OFFSET1 ,Absolute write-leveling delay offset for Byte 1."
        textline "           "
        bitfld.long 0x00 24. " WL_HC_DEL1 ,Write leveling half cycle delay for Byte 1." "0,1"
        textline "           "
        hexmask.long.byte 0x00 25.--27. 1. " WL_CYC_DEL1 ,Write leveling cycle delay for Byte 1."
width 12.
group.long 0x810++0x3
    line.long 0x00 "MPWLDECTRL1,MMDC PHY Write Leveling Delay Control Register 1"
        hexmask.long.byte 0x00 0.--7. 1. " WL_DL_ABS_OFFSET2 ,Absolute write-leveling delay offset for Byte 2."
        textline "           "
        bitfld.long 0x00 8. " WL_HC_DEL2 ,Write leveling half cycle delay for Byte 2." "0,1"
        textline "           "
        hexmask.long.byte 0x00 9.--11. 1. " WL_CYC_DEL2 ,Write leveling cycle delay for Byte 2."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " WL_DL_ABS_OFFSET3 ,Absolute write-leveling delay offset for Byte 3."
        textline "           "
        bitfld.long 0x00 24. " WL_HC_DEL3 ,Write leveling half cycle delay for Byte 3." "0,1"
        textline "           "
        hexmask.long.byte 0x00 25.--27. 1. " WL_CYC_DEL3 ,Write leveling cycle delay for Byte 3."
width 9.
rgroup.long 0x814++0x3
    line.long 0x00 "MPWLDLST,MMDC PHY Write Leveling delay-line Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " WL_DL_UNIT_NUM0 ,This field reflects the number of delay units that are actually used by write leveling delay-line 0."
        textline "        "
        hexmask.long.byte 0x00 8.--15. 1. " WL_DL_UNIT_NUM1 ,This field reflects the number of delay units that are actually used by write leveling delay-line 1."
        textline "        "
        hexmask.long.byte 0x00 16.--23. 1. " WL_DL_UNIT_NUM2 ,This field reflects the number of delay units that are actually used by write leveling delay-line 2."
        textline "        "
        hexmask.long.byte 0x00 24.--31. 1. " WL_DL_UNIT_NUM3 ,This field reflects the number of delay units that are actually used by write leveling delay-line 3."
width 10.
group.long 0x818++0x3
    line.long 0x00 "MPODTCTRL,MMDC PHY ODT control register"
        bitfld.long 0x00 0. " ODT_WR_PAS_EN ,Inactive write CS ODT enable." "0,1"
        textline "         "
        bitfld.long 0x00 1. " ODT_WR_ACT_EN ,Active write CS ODT enable." "0,1"
        textline "         "
        bitfld.long 0x00 2. " ODT_RD_PAS_EN ,Inactive read CS ODT enable." "0,1"
        textline "         "
        bitfld.long 0x00 3. " ODT_RD_ACT_EN ,Active read CS ODT enable." "0,1"
        textline "         "
        hexmask.long.byte 0x00 4.--7. 1. " ODT0_INT_RES ,On chip ODT byte0 resistor - This field determines the Rtt_Nom of the on chip ODT byte0 resistor during read accesses."
        textline "         "
        hexmask.long.byte 0x00 8.--11. 1. " ODT1_INT_RES ,On chip ODT byte1 resistor - This field determines the Rtt_Nom of the on chip ODT byte1 resistor during read accesses."
        textline "         "
        hexmask.long.byte 0x00 12.--15. 1. " ODT2_INT_RES ,On chip ODT byte2 resistor - This field determines the Rtt_Nom of the on chip ODT byte2 resistor during read accesses."
        textline "         "
        hexmask.long.byte 0x00 16.--19. 1. " ODT3_INT_RES ,On chip ODT byte3 resistor - This field determines the Rtt_Nom of the on chip ODT byte3 resistor during read accesses."
width 12.
group.long 0x81c++0x3
    line.long 0x00 "MPRDDQBY0DL,MMDC PHY Read DQ Byte0 Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RD_DQ0_DEL ,Read dqs0 to dq0 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--7. 1. " RD_DQ1_DEL ,Read dqs0 to dq1 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--11. 1. " RD_DQ2_DEL ,Read dqs0 to dq2 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--15. 1. " RD_DQ3_DEL ,Read dqs0 to dq3 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " RD_DQ4_DEL ,Read dqs0 to dq4 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " RD_DQ5_DEL ,Read dqs0 to dq5 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--27. 1. " RD_DQ6_DEL ,Read dqs0 to dq6 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQ7_DEL ,Read dqs0 to dq7 delay fine-tuning."
width 12.
group.long 0x820++0x3
    line.long 0x00 "MPRDDQBY1DL,MMDC PHY Read DQ Byte1 Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RD_DQ8_DEL ,Read dqs1 to dq8 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--7. 1. " RD_DQ9_DEL ,Read dqs1 to dq9 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--11. 1. " RD_DQ10_DEL ,Read dqs1 to dq10 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--15. 1. " RD_DQ11_DEL ,Read dqs1 to dq11 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " RD_DQ12_DEL ,Read dqs1 to dq12 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " RD_DQ13_DEL ,Read dqs1 to dq13 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--27. 1. " RD_DQ14_DEL ,Read dqs1 to dq14 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQ15_DEL ,Read dqs1 to dq15 delay fine-tuning."
width 12.
group.long 0x824++0x3
    line.long 0x00 "MPRDDQBY2DL,MMDC PHY Read DQ Byte2 Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RD_DQ16_DEL ,Read dqs2 to dq16 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--7. 1. " RD_DQ17_DEL ,Read dqs2 to dq17 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--11. 1. " RD_DQ18_DEL ,Read dqs2 to dq18 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--15. 1. " RD_DQ19_DEL ,Read dqs2 to dq19 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " RD_DQ20_DEL ,Read dqs2 to dq20 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " RD_DQ21_DEL ,Read dqs2 to dq21 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--27. 1. " RD_DQ22_DEL ,Read dqs2 to dq22 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQ23_DEL ,Read dqs2 to dq23 delay fine-tuning."
width 12.
group.long 0x828++0x3
    line.long 0x00 "MPRDDQBY3DL,MMDC PHY Read DQ Byte3 Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RD_DQ24_DEL ,Read dqs3 to dq24 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--7. 1. " RD_DQ25_DEL ,Read dqs3 to dq25 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--11. 1. " RD_DQ26_DEL ,Read dqs3 to dq26 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--15. 1. " RD_DQ27_DEL ,Read dqs3 to dq27 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " RD_DQ28_DEL ,Read dqs3 to dq28 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " RD_DQ29_DEL ,Read dqs3 to dq29 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--27. 1. " RD_DQ30_DEL ,Read dqs3 to dq30 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQ31_DEL ,Read dqs3 to dq31 delay fine-tuning."
width 12.
group.long 0x82c++0x3
    line.long 0x00 "MPWRDQBY0DL,MMDC PHY Write DQ Byte0 Delay Register"
        hexmask.long.byte 0x00 0.--2. 1. " WR_DQ0_DEL ,Write dq0 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " WR_DQ1_DEL ,Write dq1 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " WR_DQ2_DEL ,Write dq2 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--14. 1. " WR_DQ3_DEL ,Write dq3 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--18. 1. " WR_DQ4_DEL ,Write dq4 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--22. 1. " WR_DQ5_DEL ,Write dq5 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--26. 1. " WR_DQ6_DEL ,Write dq6 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--30. 1. " WR_DQ7_DEL ,Write dq7 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " WR_DM0_DEL ,Write dm0 delay fine-tuning."
width 12.
group.long 0x830++0x3
    line.long 0x00 "MPWRDQBY1DL,MMDC PHY Write DQ Byte1 Delay Register"
        hexmask.long.byte 0x00 0.--2. 1. " WR_DQ8_DEL ,Write dq8 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " WR_DQ9_DEL ,Write dq9 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " WR_DQ10_DEL ,Write dq10 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--14. 1. " WR_DQ11_DEL ,Write dq11 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--18. 1. " WR_DQ12_DEL ,Write dq12 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--22. 1. " WR_DQ13_DEL ,Write dq13 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--26. 1. " WR_DQ14_DEL ,Write dq14 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--30. 1. " WR_DQ15_DEL ,Write dq15 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " WR_DM1_DEL ,Write dm1 delay fine-tuning."
width 12.
group.long 0x834++0x3
    line.long 0x00 "MPWRDQBY2DL,MMDC PHY Write DQ Byte2 Delay Register"
        hexmask.long.byte 0x00 0.--2. 1. " WR_DQ16_DEL ,Write dq16 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " WR_DQ17_DEL ,Write dq17 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " WR_DQ18_DEL ,Write dq18 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--14. 1. " WR_DQ19_DEL ,Write dq19 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--18. 1. " WR_DQ20_DEL ,Write dq20 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--22. 1. " WR_DQ21_DEL ,Write dq21 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--26. 1. " WR_DQ22_DEL ,Write dq22 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--30. 1. " WR_DQ23_DEL ,Write dq23 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " WR_DM2_DEL ,Write dm2 delay fine-tuning."
width 12.
group.long 0x838++0x3
    line.long 0x00 "MPWRDQBY3DL,MMDC PHY Write DQ Byte3 Delay Register"
        hexmask.long.byte 0x00 0.--2. 1. " WR_DQ24_DEL ,Write dq24 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " WR_DQ25_DEL ,Write dq25 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " WR_DQ26_DEL ,Write dq26 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--14. 1. " WR_DQ27_DEL ,Write dq27 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--18. 1. " WR_DQ28_DEL ,Write dq28 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--22. 1. " WR_DQ29_DEL ,Write dq29 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--26. 1. " WR_DQ30_DEL ,Write dq30 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--30. 1. " WR_DQ31_DEL ,Write dq31 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " WR_DM3_DEL ,Write dm3 delay fine tuning."
width 10.
group.long 0x83c++0x3
    line.long 0x00 "MPDGCTRL0,MMDC PHY Read DQS Gating Control Register 0"
        hexmask.long.byte 0x00 0.--7. 1. " DG_DL_ABS_OFFSET0 ,Absolute read DQS gating delay offset for Byte0."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " DG_HC_DEL0 ,Read DQS gating half cycles delay for Byte0 (Channel 0 register) and Byte4 in 64-bit mode (Channel 1 register) ."
        textline "         "
        bitfld.long 0x00 12. " HW_DG_ERR ,HW DQS gating error." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " DG_DL_ABS_OFFSET1 ,Absolute read DQS gating delay offset for Byte1."
        textline "         "
        bitfld.long 0x00 23. " DG_EXT_UP ,DG extend upper boundary." "0,1"
        textline "         "
        hexmask.long.byte 0x00 24.--28. 1. " DG_HC_DEL1 ,Read DQS gating half cycles delay for Byte1 (channel 0 register) and Byte5 in 64-bit mode (channel 1 register) ."
        textline "         "
        bitfld.long 0x00 28. " HW_DG_EN ,Enable automatic read DQS gating calibration." "0,1"
        textline "         "
        bitfld.long 0x00 29. " DG_DIS ,Read DQS gating disable." "0,1"
        textline "         "
        bitfld.long 0x00 30. " DG_CMP_CYC ,Read DQS gating sample cycle." "0,1"
        textline "         "
        bitfld.long 0x00 31. " RST_RD_FIFO ,Reset Read Data FIFO and associated pointers." "0,1"
width 10.
group.long 0x840++0x3
    line.long 0x00 "MPDGCTRL1,MMDC PHY Read DQS Gating Control Register 1"
        hexmask.long.byte 0x00 0.--7. 1. " DG_DL_ABS_OFFSET2 ,Absolute read DQS gating delay offset for Byte2."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " DG_HC_DEL2 ,Read DQS gating half cycles delay for Byte2 (Channel 0 register) and Byte6 for 64-bit mode(channel 1 register) ."
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " DG_DL_ABS_OFFSET3 ,Absolute read DQS gating delay offset for Byte3."
        textline "         "
        hexmask.long.byte 0x00 24.--28. 1. " DG_HC_DEL3 ,Read DQS gating half cycles delay for Byte3 (Channel 0 register) and Byte7 for 64-bit data (Channel 1 register) ."
width 10.
rgroup.long 0x844++0x3
    line.long 0x00 "MPDGDLST0,MMDC PHY Read DQS Gating delay-line Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " DG_DL_UNIT_NUM0 ,This field reflects the number of delay units that are actually used by read DQS gating delay-line 0."
        textline "         "
        hexmask.long.byte 0x00 8.--15. 1. " DG_DL_UNIT_NUM1 ,This field reflects the number of delay units that are actually used by read DQS gating delay-line 1."
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " DG_DL_UNIT_NUM2 ,This field reflects the number of delay units that are actually used by read DQS gating delay-line 2."
        textline "         "
        hexmask.long.byte 0x00 24.--31. 1. " DG_DL_UNIT_NUM3 ,This field reflects the number of delay units that are actually used by read DQS gating delay-line 3."
width 10.
group.long 0x848++0x3
    line.long 0x00 "MPRDDLCTL,MMDC PHY Read delay-lines Configuration Register"
        hexmask.long.byte 0x00 0.--7. 1. " RD_DL_ABS_OFFSET0 ,Absolute read delay offset for Byte0."
        textline "         "
        hexmask.long.byte 0x00 8.--15. 1. " RD_DL_ABS_OFFSET1 ,Absolute read delay offset for Byte1."
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " RD_DL_ABS_OFFSET2 ,Absolute read delay offset for Byte2."
        textline "         "
        hexmask.long.byte 0x00 24.--31. 1. " RD_DL_ABS_OFFSET3 ,Absolute read delay offset for Byte3."
width 9.
rgroup.long 0x84c++0x3
    line.long 0x00 "MPRDDLST,MMDC PHY Read delay-lines Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " RD_DL_UNIT_NUM0 ,This field reflects the number of delay units that are actually used by read delay-line 0."
        textline "        "
        hexmask.long.byte 0x00 8.--15. 1. " RD_DL_UNIT_NUM1 ,This field reflects the number of delay units that are actually used by read delay-line 1."
        textline "        "
        hexmask.long.byte 0x00 16.--23. 1. " RD_DL_UNIT_NUM2 ,This field reflects the number of delay units that are actually used by read delay-line 2."
        textline "        "
        hexmask.long.byte 0x00 24.--31. 1. " RD_DL_UNIT_NUM3 ,This field reflects the number of delay units that are actually used by read delay-line 3."
width 10.
group.long 0x850++0x3
    line.long 0x00 "MPWRDLCTL,MMDC PHY Write delay-lines Configuration Register"
        hexmask.long.byte 0x00 0.--7. 1. " WR_DL_ABS_OFFSET0 ,Absolute write delay offset for Byte0."
        textline "         "
        hexmask.long.byte 0x00 8.--15. 1. " WR_DL_ABS_OFFSET1 ,Absolute write delay offset for Byte1."
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " WR_DL_ABS_OFFSET2 ,Absolute write delay offset for Byte2."
        textline "         "
        hexmask.long.byte 0x00 24.--31. 1. " WR_DL_ABS_OFFSET3 ,Absolute write delay offset for Byte3."
width 9.
rgroup.long 0x854++0x3
    line.long 0x00 "MPWRDLST,MMDC PHY Write delay-lines Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " WR_DL_UNIT_NUM0 ,This field reflects the number of delay units that are actually used by write delay-line 0."
        textline "        "
        hexmask.long.byte 0x00 8.--15. 1. " WR_DL_UNIT_NUM1 ,This field reflects the number of delay units that are actually used by write delay-line 1."
        textline "        "
        hexmask.long.byte 0x00 16.--23. 1. " WR_DL_UNIT_NUM2 ,This field reflects the number of delay units that are actually used by write delay-line 2."
        textline "        "
        hexmask.long.byte 0x00 24.--31. 1. " WR_DL_UNIT_NUM3 ,This field reflects the number of delay units that are actually used by write delay-line 3."
width 9.
group.long 0x858++0x3
    line.long 0x00 "MPSDCTRL,MMDC PHY CK Control Register"
        hexmask.long.byte 0x00 8.--10. 1. " SDCLK0_DEL ,DDR clock0 delay fine tuning."
width 11.
group.long 0x85c++0x3
    line.long 0x00 "MPZQLP2CTL,MMDC ZQ LPDDR2 HW Control Register"
        hexmask.long.word 0x00 0.--9. 1. " ZQ_LP2_HW_ZQINIT ,This register defines the period in cycles that it takes the memory device to perform a Init ZQ calibration."
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " ZQ_LP2_HW_ZQCL ,This register defines the period in cycles that it takes the memory device to perform a long ZQ calibration."
        textline "          "
        hexmask.long.byte 0x00 24.--31. 1. " ZQ_LP2_HW_ZQCS ,This register defines the period in cycles that it takes the memory device to perform a Short ZQ calibration."
width 12.
group.long 0x860++0x3
    line.long 0x00 "MPRDDLHWCTL,MMDC PHY Read Delay HW Calibration Control Register"
        bitfld.long 0x00 0. " HW_RD_DL_ERR0 ,Automatic (HW) read calibration error of Byte0." "0,1"
        textline "           "
        bitfld.long 0x00 1. " HW_RD_DL_ERR1 ,Automatic (HW) read calibration error of Byte1." "0,1"
        textline "           "
        bitfld.long 0x00 2. " HW_RD_DL_ERR2 ,Automatic (HW) read calibration error of Byte2." "0,1"
        textline "           "
        bitfld.long 0x00 3. " HW_RD_DL_ERR3 ,Automatic (HW) read calibration error of Byte3." "0,1"
        textline "           "
        bitfld.long 0x00 4. " HW_RD_DL_EN ,Enable automatic (HW) read calibration." "0,1"
        textline "           "
        bitfld.long 0x00 5. " HW_RD_DL_CMP_CYC ,Automatic (HW) read sample cycle." "0,1"
width 12.
group.long 0x864++0x3
    line.long 0x00 "MPWRDLHWCTL,MMDC PHY Write Delay HW Calibration Control Register"
        bitfld.long 0x00 0. " HW_WR_DL_ERR0 ,Automatic (HW) write calibration error of Byte0." "0,1"
        textline "           "
        bitfld.long 0x00 1. " HW_WR_DL_ERR1 ,Automatic (HW) write calibration error of Byte1." "0,1"
        textline "           "
        bitfld.long 0x00 2. " HW_WR_DL_ERR2 ,Automatic (HW) write calibration error of Byte2." "0,1"
        textline "           "
        bitfld.long 0x00 3. " HW_WR_DL_ERR3 ,Automatic (HW) write calibration error of Byte3." "0,1"
        textline "           "
        bitfld.long 0x00 4. " HW_WR_DL_EN ,Enable automatic (HW) write calibration." "0,1"
        textline "           "
        bitfld.long 0x00 5. " HW_WR_DL_CMP_CYC ,Write sample cycle." "0,1"
width 12.
rgroup.long 0x868++0x3
    line.long 0x00 "MPRDDLHWST0,MMDC PHY Read Delay HW Calibration Status Register 0"
        hexmask.long.byte 0x00 0.--7. 1. " HW_RD_DL_LOW0 ,Automatic (HW) read calibration result of the lower boundary of Byte0."
        textline "           "
        hexmask.long.byte 0x00 8.--15. 1. " HW_RD_DL_UP0 ,Automatic (HW) read calibration result of the upper boundary of Byte0."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " HW_RD_DL_LOW1 ,Automatic (HW) read calibration result of the lower boundary of Byte1."
        textline "           "
        hexmask.long.byte 0x00 24.--31. 1. " HW_RD_DL_UP1 ,Automatic (HW) read calibration result of the upper boundary of Byte1."
width 12.
rgroup.long 0x86c++0x3
    line.long 0x00 "MPRDDLHWST1,MMDC PHY Read Delay HW Calibration Status Register 1"
        hexmask.long.byte 0x00 0.--7. 1. " HW_RD_DL_LOW2 ,Automatic (HW) read calibration result of the lower boundary of Byte2."
        textline "           "
        hexmask.long.byte 0x00 8.--15. 1. " HW_RD_DL_UP2 ,Automatic (HW) read calibration result of the upper boundary of Byte2."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " HW_RD_DL_LOW3 ,Automatic (HW) read calibration result of the lower boundary of Byte3."
        textline "           "
        hexmask.long.byte 0x00 24.--31. 1. " HW_RD_DL_UP3 ,Automatic (HW) read calibration result of the upper boundary of Byte3."
width 12.
rgroup.long 0x870++0x3
    line.long 0x00 "MPWRDLHWST0,MMDC PHY Write Delay HW Calibration Status Register 0"
        hexmask.long.byte 0x00 0.--7. 1. " HW_WR_DL_LOW0 ,Automatic (HW) write calibration result of the lower boundary of Byte0."
        textline "           "
        hexmask.long.byte 0x00 8.--15. 1. " HW_WR_DL_UP0 ,Automatic (HW) write calibration result of the upper boundary of Byte0."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " HW_WR_DL_LOW1 ,Automatic (HW) write calibration result of the lower boundary of Byte1."
        textline "           "
        hexmask.long.byte 0x00 24.--31. 1. " HW_WR_DL_UP1 ,Aautomatic (HW) write utomatic (HW) write calibration result of the upper boundary of Byte1."
width 12.
rgroup.long 0x874++0x3
    line.long 0x00 "MPWRDLHWST1,MMDC PHY Write Delay HW Calibration Status Register 1"
        hexmask.long.byte 0x00 0.--7. 1. " HW_WR_DL_LOW2 ,Automatic (HW) write calibration result of the lower boundary of Byte2."
        textline "           "
        hexmask.long.byte 0x00 8.--15. 1. " HW_WR_DL_UP2 ,Automatic (HW) write calibration result of the upper boundary of Byte2."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " HW_WR_DL_LOW3 ,Automatic (HW) write calibration result of the lower boundary of Byte3."
        textline "           "
        hexmask.long.byte 0x00 24.--31. 1. " HW_WR_DL_UP3 ,Automatic (HW) write calibration result of the upper boundary of Byte3."
width 10.
group.long 0x878++0x3
    line.long 0x00 "MPWLHWERR,MMDC PHY Write Leveling HW Error Register"
        hexmask.long.byte 0x00 0.--8. 1. " HW_WL0_DQ ,HW write-leveling calibration result of Byte0."
        textline "         "
        hexmask.long.byte 0x00 8.--16. 1. " HW_WL1_DQ ,HW write-leveling calibration result of Byte1."
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " HW_WL2_DQ ,HW write-leveling calibration result of Byte2."
        textline "         "
        hexmask.long.byte 0x00 24.--32. 1. " HW_WL3_DQ ,HW write-leveling calibration result of Byte3."
width 10.
rgroup.long 0x87c++0x3
    line.long 0x00 "MPDGHWST0,MMDC PHY Read DQS Gating HW Status Register 0"
        hexmask.long.word 0x00 0.--11. 1. " HW_DG_LOW0 ,HW DQS gating calibration result of the lower boundary of Byte0."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " HW_DG_UP0 ,HW DQS gating calibration result of the upper boundary of Byte0."
width 10.
rgroup.long 0x880++0x3
    line.long 0x00 "MPDGHWST1,MMDC PHY Read DQS Gating HW Status Register 1"
        hexmask.long.word 0x00 0.--11. 1. " HW_DG_LOW1 ,HW DQS gating calibration result of the lower boundary of Byte1."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " HW_DG_UP1 ,HW DQS gating calibration result of the upper boundary of Byte1."
width 10.
rgroup.long 0x884++0x3
    line.long 0x00 "MPDGHWST2,MMDC PHY Read DQS Gating HW Status Register 2"
        hexmask.long.word 0x00 0.--11. 1. " HW_DG_LOW2 ,HW DQS gating calibration result of the lower boundary of Byte2."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " HW_DG_UP2 ,HW DQS gating calibration result of the upper boundary of Byte2."
width 10.
rgroup.long 0x888++0x3
    line.long 0x00 "MPDGHWST3,MMDC PHY Read DQS Gating HW Status Register 3"
        hexmask.long.word 0x00 0.--11. 1. " HW_DG_LOW3 ,HW DQS gating calibration result of the lower boundary of Byte3."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " HW_DG_UP3 ,HW DQS gating calibration result of the upper boundary of Byte3."
width 10.
group.long 0x88c++0x3
    line.long 0x00 "MPPDCMPR1,MMDC PHY Pre-defined Compare Register 1"
        hexmask.long.word 0x00 0.--16. 1. " PDV1 ,MMDC Pre defined comapre value2."
        textline "         "
        hexmask.long.word 0x00 16.--32. 1. " PDV2 ,MMDC Pre defined comapre value2."
width 10.
group.long 0x890++0x3
    line.long 0x00 "MPPDCMPR2,MMDC PHY Pre-defined Compare and CA delay-line Configuration Register"
        bitfld.long 0x00 0. " MPR_CMP ,MPR(DDR3)/DQ calibration (LPDDR2) comapre enable." "0,1"
        textline "         "
        bitfld.long 0x00 1. " MPR_FULL_CMP ,MPR(DDR3)/DQ calibration (LPDDR2) full compare enable." "0,1"
        textline "         "
        bitfld.long 0x00 2. " READ_LEVEL_PATTERN ,MPR(DDR3)/DQ calibration(LPDDR2) read compare pattern." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " CA_DL_ABS_OFFSET ,Absolute CA (Command/Address of LPDDRR2) offset."
        textline "         "
        hexmask.long.byte 0x00 24.--31. 1. " PHY_CA_DL_UNIT ,This field reflects the number of delay units that are actually used by CA (Command/Address of LPDDR2) delay-line"
width 9.
group.long 0x894++0x3
    line.long 0x00 "MPSWDAR0,MMDC PHY SW Dummy Access Register"
        bitfld.long 0x00 0. " SW_DUMMY_WR ,SW dummy write." "0,1"
        textline "        "
        bitfld.long 0x00 1. " SW_DUMMY_RD ,SW dummy read." "0,1"
        textline "        "
        bitfld.long 0x00 2. " SW_DUM_CMP0 ,SW dummy read byte0 compare results." "0,1"
        textline "        "
        bitfld.long 0x00 3. " SW_DUM_CMP1 ,SW dummy read byte1 compare results." "0,1"
        textline "        "
        bitfld.long 0x00 4. " SW_DUM_CMP2 ,SW dummy read byte2 compare results." "0,1"
        textline "        "
        bitfld.long 0x00 5. " SW_DUM_CMP3 ,SW dummy read byte3 compare results." "0,1"
width 10.
rgroup.long 0x898++0x3
    line.long 0x00 "MPSWDRDR0,MMDC PHY SW Dummy Read Data Register 0"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD0 ,Dummy read data0."
width 10.
rgroup.long 0x89c++0x3
    line.long 0x00 "MPSWDRDR1,MMDC PHY SW Dummy Read Data Register 1"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD1 ,Dummy read data1."
width 10.
rgroup.long 0x8a0++0x3
    line.long 0x00 "MPSWDRDR2,MMDC PHY SW Dummy Read Data Register 2"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD2 ,Dummy read data2."
width 10.
rgroup.long 0x8a4++0x3
    line.long 0x00 "MPSWDRDR3,MMDC PHY SW Dummy Read Data Register 3"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD3 ,Dummy read data3."
width 10.
rgroup.long 0x8a8++0x3
    line.long 0x00 "MPSWDRDR4,MMDC PHY SW Dummy Read Data Register 4"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD4 ,Dummy read data4."
width 10.
rgroup.long 0x8ac++0x3
    line.long 0x00 "MPSWDRDR5,MMDC PHY SW Dummy Read Data Register 5"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD5 ,Dummy read data5."
width 10.
rgroup.long 0x8b0++0x3
    line.long 0x00 "MPSWDRDR6,MMDC PHY SW Dummy Read Data Register 6"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD6 ,Dummy read data6."
width 10.
rgroup.long 0x8b4++0x3
    line.long 0x00 "MPSWDRDR7,MMDC PHY SW Dummy Read Data Register 7"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD7 ,Dummy read data7."
width 7.
group.long 0x8b8++0x3
    line.long 0x00 "MPMUR0,MMDC PHY Measure Unit Register"
        hexmask.long.word 0x00 0.--10. 1. " MU_BYP_VAL ,Number of delay units for measurement bypass."
        textline "      "
        bitfld.long 0x00 10. " MU_BYP_EN ,Measure unit bypass enable." "0,1"
        textline "      "
        bitfld.long 0x00 11. " FRC_MSR ,Force measuement on delay-lines." "0,1"
        textline "      "
        hexmask.long.word 0x00 16.--26. 1. " MU_UNIT_DEL_NUM ,Number of delay units measured per cycle."
width 9.
group.long 0x8bc++0x3
    line.long 0x00 "MPWRCADL,MMDC Write CA delay-line controller"
        hexmask.long.byte 0x00 0.--2. 1. " WR_CA0_DEL ,CA (Command/Address LPDDR2 bus) bit 0 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 2.--4. 1. " WR_CA1_DEL ,CA (Command/Address LPDDR2 bus) bit 1 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 4.--6. 1. " WR_CA2_DEL ,CA (Command/Address LPDDR2 bus) bit 2 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 6.--8. 1. " WR_CA3_DEL ,CA (Command/Address LPDDR2 bus) bit 3 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 8.--10. 1. " WR_CA4_DEL ,CA (Command/Address LPDDR2 bus) bit 4 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 10.--12. 1. " WR_CA5_DEL ,CA (Command/Address LPDDR2 bus) bit 5 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 12.--14. 1. " WR_CA6_DEL ,CA (Command/Address LPDDR2 bus) bit 6 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 14.--16. 1. " WR_CA7_DEL ,CA (Command/Address LPDDR2 bus) bit 7 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 16.--18. 1. " WR_CA8_DEL ,CA (Command/Address LPDDR2 bus) bit 8 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 18.--20. 1. " WR_CA9_DEL ,CA (Command/Address LPDDR2 bus) bit 9 delay fine tuning."
width 7.
rgroup.long 0x8c0++0x3
    line.long 0x00 "MPDCCR,MMDC Duty Cycle Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " WR_DQS0_FT_DCC ,Write DQS duty cycle fine tuning control of Byte0."
        textline "      "
        hexmask.long.byte 0x00 3.--6. 1. " WR_DQS1_FT_DCC ,Write DQS duty cycle fine tuning control of Byte1."
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " WR_DQS2_FT_DCC ,Write DQS duty cycle fine tuning control of Byte1."
        textline "      "
        hexmask.long.byte 0x00 9.--12. 1. " WR_DQS3_FT_DCC ,Write DQS duty cycle fine tuning control of Byte0."
        textline "      "
        hexmask.long.byte 0x00 12.--15. 1. " CK_FT0_DCC ,Primary duty cycle fine tuning control of DDR clock."
        textline "      "
        hexmask.long.byte 0x00 16.--19. 1. " CK_FT1_DCC ,Secondary duty cycle fine tuning control of DDR clock."
        textline "      "
        hexmask.long.byte 0x00 19.--22. 1. " RD_DQS0_FT_DCC ,Read DQS duty cycle fine tuning control of Byte0."
        textline "      "
        hexmask.long.byte 0x00 22.--25. 1. " RD_DQS1_FT_DCC ,Read DQS duty cycle fine tuning control of Byte1."
        textline "      "
        hexmask.long.byte 0x00 25.--28. 1. " RD_DQS2_FT_DCC ,Read DQS duty cycle fine tuning control of Byte2."
        textline "      "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQS3_FT_DCC ,Read DQS duty cycle fine tuning control of Byte3."


    tree.end
    tree "MMDC2"
        base ad:0x021b4000

width 6.
group.long 0x0++0x3
    line.long 0x00 "MDCTL,MMDC Core Control Register"
        hexmask.long.byte 0x00 16.--18. 1. " DSIZ ,DDR data bus size."
        textline "     "
        bitfld.long 0x00 19. " BL ,Burst Length." "0,1"
        textline "     "
        hexmask.long.byte 0x00 20.--23. 1. " COL ,Column Address Width."
        textline "     "
        hexmask.long.byte 0x00 24.--27. 1. " ROW ,Row Address Width."
        textline "     "
        bitfld.long 0x00 30. " SDE_1 ,MMDC Enable CS1." "0,1"
        textline "     "
        bitfld.long 0x00 31. " SDE_0 ,MMDC Enable CS0." "0,1"
width 6.
group.long 0x4++0x3
    line.long 0x00 "MDPDC,MMDC Core Power Down Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " TCKSRE ,Valid clock cycles after self-refresh entry."
        textline "     "
        hexmask.long.byte 0x00 3.--6. 1. " TCKSRX ,Valid clock cycles before self-refresh exit."
        textline "     "
        bitfld.long 0x00 6. " BOTH_CS_PD ,Parallel power down entry to both chip selects." "0,1"
        textline "     "
        bitfld.long 0x00 7. " SLOW_PD ,Slow/fast power down." "0,1"
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " PWDT_0 ,Power Down Timer - Chip Select 0."
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " PWDT_1 ,Power Down Timer - Chip Select 1."
        textline "     "
        hexmask.long.byte 0x00 16.--19. 1. " TCKE ,CKE minimum pulse width."
        textline "     "
        hexmask.long.byte 0x00 24.--27. 1. " PRCT_0 ,Precharge Timer - Chip Select 0."
        textline "     "
        hexmask.long.byte 0x00 28.--31. 1. " PRCT_1 ,Precharge Timer - Chip Select 1."
width 6.
group.long 0x8++0x3
    line.long 0x00 "MDOTC,MMDC Core ODT Timing Control Register"
        hexmask.long.byte 0x00 4.--9. 1. " TODT_IDLE_OFF ,ODT turn off latency."
        textline "     "
        hexmask.long.byte 0x00 12.--15. 1. " TODTLON ,ODT turn on latency."
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " TAXPD ,Asynchronous ODT to power down exit delay."
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " TANPD ,Asynchronous ODT to power down entry delay."
        textline "     "
        hexmask.long.byte 0x00 24.--27. 1. " TAONPD ,Asynchronous RTT turn-on delay (power down with DLL frozen)."
        textline "     "
        hexmask.long.byte 0x00 27.--30. 1. " TAOFPD ,Asynchronous RTT turn-off delay (power down with DLL frozen)."
width 7.
group.long 0xc++0x3
    line.long 0x00 "MDCFG0,MMDC Core Timing Configuration Register 0"
        hexmask.long.byte 0x00 0.--4. 1. " TCL ,CAS Read Latency."
        textline "      "
        hexmask.long.byte 0x00 4.--9. 1. " TFAW ,Four Active Window (all banks)."
        textline "      "
        hexmask.long.byte 0x00 9.--13. 1. " TXPDLL ,Exit precharge power down with DLL frozen to commands requiring DLL."
        textline "      "
        hexmask.long.byte 0x00 13.--16. 1. " TXP ,Exit power down with DLL-on to any valid command."
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " TXS ,Exit self refresh to non READ command."
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " TRFC ,Refresh command to Active or Refresh command time."
width 7.
group.long 0x10++0x3
    line.long 0x00 "MDCFG1,MMDC Core Timing Configuration Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " TCWL ,CAS Write Latency."
        textline "      "
        hexmask.long.byte 0x00 5.--9. 1. " TMRD ,Mode Register Set command cycle (all banks)."
        textline "      "
        hexmask.long.byte 0x00 9.--12. 1. " TWR ,WRITE recovery time (same bank)."
        textline "      "
        bitfld.long 0x00 15. " TRPA ,Precharge-all command period." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--21. 1. " TRAS ,Active to Precharge command period (same bank)."
        textline "      "
        hexmask.long.byte 0x00 21.--26. 1. " TRC ,Active to Active or Refresh command period (same bank)."
        textline "      "
        hexmask.long.byte 0x00 26.--29. 1. " TRP ,Precharge command period (same bank)."
        textline "      "
        hexmask.long.byte 0x00 29.--32. 1. " TRCD ,Active command to internal read or write delay time (same bank)."
width 7.
group.long 0x14++0x3
    line.long 0x00 "MDCFG2,MMDC Core Timing Configuration Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " TRRD ,Active to Active command period (all banks)."
        textline "      "
        hexmask.long.byte 0x00 3.--6. 1. " TWTR ,Internal WRITE to READ command delay (same bank)."
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " TRTP ,Internal READ command to Precharge command delay (same bank)."
        textline "      "
        hexmask.long.word 0x00 16.--25. 1. " TDLLK ,DLL locking time."
width 7.
group.long 0x18++0x3
    line.long 0x00 "MDMISC,MMDC Core Miscellaneous Register"
        bitfld.long 0x00 1. " RST ,Software Reset." "0,1"
        textline "      "
        bitfld.long 0x00 2. " LPDDR2_2CH ,LPDDR2 2-channels mode." "0,1"
        textline "      "
        hexmask.long.byte 0x00 3.--5. 1. " DDR_TYPE ,DDR TYPE."
        textline "      "
        bitfld.long 0x00 5. " DDR_4_BANK ,Number of banks per DDR device." "0,1"
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " RALAT ,Read Additional Latency."
        textline "      "
        hexmask.long.byte 0x00 9.--11. 1. " MIF3_MODE ,Command prediction working mode."
        textline "      "
        bitfld.long 0x00 11. " LPDDR2_S2 ,LPDDR2 S2 device type indication." "0,1"
        textline "      "
        bitfld.long 0x00 12. " BI_ON ,Bank Interleaving On." "0,1"
        textline "      "
        hexmask.long.byte 0x00 16.--18. 1. " WALAT ,Write Additional latency."
        textline "      "
        bitfld.long 0x00 18. " LHD ,Latency hiding disable." "0,1"
        textline "      "
        bitfld.long 0x00 19. " ADDR_MIRROR ,Address mirroring." "0,1"
        textline "      "
        bitfld.long 0x00 20. " CALIB_PER_CS ,Number of chip-select for calibration process." "0,1"
        textline "      "
        bitfld.long 0x00 30. " CS1_RDY ,External status device on CS1." "0,1"
        textline "      "
        bitfld.long 0x00 31. " CS0_RDY ,External status device on CS0." "0,1"
width 6.
group.long 0x1c++0x3
    line.long 0x00 "MDSCR,MMDC Core Special Command Register"
        hexmask.long.byte 0x00 0.--3. 1. " CMD_BA ,Bank Address."
        textline "     "
        bitfld.long 0x00 3. " CMD_CS ,Chip Select." "0,1"
        textline "     "
        hexmask.long.byte 0x00 4.--7. 1. " CMD ,Command."
        textline "     "
        bitfld.long 0x00 9. " WL_EN ,DQS pads direction." "0,1"
        textline "     "
        bitfld.long 0x00 10. " MRR_READ_DATA_VALID ,MRR read data valid." "0,1"
        textline "     "
        bitfld.long 0x00 14. " CON_ACK ,Configuration acknowledge." "0,1"
        textline "     "
        bitfld.long 0x00 15. " CON_REQ ,Configuration request." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--24. 1. " CMD_ADDR_LSB_MR_ADDR ,Command/Address LSB."
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " CMD_ADDR_MSB_MR_OP ,Command/Address MSB."
width 6.
group.long 0x20++0x3
    line.long 0x00 "MDREF,MMDC Core Refresh Control Register"
        bitfld.long 0x00 0. " START_REF ,Manual start of refresh cycle." "0,1"
        textline "     "
        hexmask.long.byte 0x00 11.--14. 1. " REFR ,Refresh Rate."
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " REF_SEL ,Refresh Selector."
        textline "     "
        hexmask.long.word 0x00 16.--32. 1. " REF_CNT ,Refresh Counter at DDR clock period If REF_SEL equals '2' a refresh cycle will begin every amount of DDR cycles configured in this field."
width 6.
group.long 0x2c++0x3
    line.long 0x00 "MDRWD,MMDC Core Read/Write Command Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RTR_DIFF ,Read to read delay for different chip-select."
        textline "     "
        hexmask.long.byte 0x00 3.--6. 1. " RTW_DIFF ,Read to write delay for different chip-select."
        textline "     "
        hexmask.long.byte 0x00 6.--9. 1. " WTW_DIFF ,Write to write delay for different chip-select."
        textline "     "
        hexmask.long.byte 0x00 9.--12. 1. " WTR_DIFF ,Write to read delay for different chip-select."
        textline "     "
        hexmask.long.byte 0x00 12.--15. 1. " RTW_SAME ,Read to write delay for the same chip-select."
        textline "     "
        hexmask.long.word 0x00 16.--29. 1. " TDAI ,Device auto initialization period.(maximum) This field is relevant only to LPDDR2 mode"
width 5.
group.long 0x30++0x3
    line.long 0x00 "MDOR,MMDC Core Out of Reset Delays Register"
        hexmask.long.byte 0x00 0.--6. 1. " RST_TO_CKE ,DDR3: Time from SDE enable to CKE rise."
        textline "    "
        hexmask.long.byte 0x00 8.--14. 1. " SDE_TO_RST ,DDR3: Time from SDE enable until DDR reset# is high."
        textline "    "
        hexmask.long.byte 0x00 16.--24. 1. " TXPR ,DDR2/ DDR3: CKE HIGH to a valid command."
width 6.
rgroup.long 0x34++0x3
    line.long 0x00 "MDMRR,MMDC Core MRR Data Register"
        hexmask.long.byte 0x00 0.--8. 1. " MRR_READ_DATA0 ,MRR DATA that arrived on DQ[7:0]"
        textline "     "
        hexmask.long.byte 0x00 8.--16. 1. " MRR_READ_DATA1 ,MRR DATA that arrived on DQ[15:8]"
        textline "     "
        hexmask.long.byte 0x00 16.--24. 1. " MRR_READ_DATA2 ,MRR DATA that arrived on DQ[23:16]"
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " MRR_READ_DATA3 ,MRR DATA that arrived on DQ[31:24]"
width 9.
group.long 0x38++0x3
    line.long 0x00 "MDCFG3LP,MMDC Core Timing Configuration Register 3"
        hexmask.long.byte 0x00 0.--4. 1. " TRPAB_LP ,Precharge (all banks) command period."
        textline "        "
        hexmask.long.byte 0x00 4.--8. 1. " TRPPB_LP ,Precharge (per bank) command period (same bank)."
        textline "        "
        hexmask.long.byte 0x00 8.--12. 1. " TRCD_LP ,Active command to internal read or write delay time (same bank)."
        textline "        "
        hexmask.long.byte 0x00 16.--22. 1. " RC_LP ,Active to Active or Refresh command period (same bank)."
width 6.
group.long 0x3c++0x3
    line.long 0x00 "MDMR4,MMDC Core MR4 Derating Register"
        bitfld.long 0x00 0. " UPDATE_DE_REQ ,Update Derated Values Request." "0,1"
        textline "     "
        bitfld.long 0x00 1. " UPDATE_DE_ACK ,Update Derated Values Acknowledge." "0,1"
        textline "     "
        bitfld.long 0x00 4. " TRCD_DE ,tRCD derating value." "0,1"
        textline "     "
        bitfld.long 0x00 5. " TRC_DE ,tRC derating value." "0,1"
        textline "     "
        bitfld.long 0x00 6. " TRAS_DE ,tRAS derating value." "0,1"
        textline "     "
        bitfld.long 0x00 7. " TRP_DE ,tRP derating value." "0,1"
        textline "     "
        bitfld.long 0x00 8. " TRRD_DE ,tRRD derating value." "0,1"
width 6.
group.long 0x40++0x3
    line.long 0x00 "MDASP,MMDC Core Address Space Partition Register"
        hexmask.long.byte 0x00 0.--7. 1. " CS0_END ,CS0_END."
width 7.
group.long 0x400++0x3
    line.long 0x00 "MAARCR,MMDC Core AXI Reordering Control Regsiter"
        hexmask.long.byte 0x00 0.--4. 1. " ARCR_GUARD ,ARCR Guard."
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " ARCR_DYN_MAX ,ARCR Dynamic Maximum."
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " ARCR_DYN_JMP ,ARCR Dynamic Jump."
        textline "      "
        hexmask.long.byte 0x00 16.--19. 1. " ARCR_ACC_HIT ,ARCR Access Hit Rate."
        textline "      "
        hexmask.long.byte 0x00 20.--23. 1. " ARCR_PAG_HIT ,ARCR Page Hit Rate."
        textline "      "
        bitfld.long 0x00 24. " ARCR_RCH_EN ,This bit defines whether Real time channel is activated and bypassed all other pending accesses, So accesses with QoS=='F' will be granted the highest prioritiy in the optimization/reordering mechanism Default value is 0x1 - encoding 1 (Enabled)" "0,1"
        textline "      "
        bitfld.long 0x00 28. " ARCR_EXC_ERR_EN ,This bit defines whether exclusive read/write access violation of AXI 6.2.4 rule result in SLV Error response or in OKAY response Default value is 0x1 - encoding 1(response is SLV Error)" "0,1"
        textline "      "
        bitfld.long 0x00 30. " ARCR_SEC_ERR_EN ,This bit defines whether security read/write access violation result in SLV Error response or in OKAY response Default value is 0x1 - encoding 1(response is SLV Error, rresp/bresp=2'b10)" "0,1"
        textline "      "
        bitfld.long 0x00 31. " ARCR_SEC_ERR_LOCK ,Once set, this bit locks ARCR_SEC_ERR_EN and prevents from its updating." "0,1"
width 6.
group.long 0x404++0x3
    line.long 0x00 "MAPSR,MMDC Core Power Saving Control and Status Register"
        bitfld.long 0x00 0. " PSD ,Automatic Power Saving Disable." "0,1"
        textline "     "
        bitfld.long 0x00 4. " PSS ,Power Saving Status." "0,1"
        textline "     "
        bitfld.long 0x00 5. " RIS ,Read Idle Status.This read only bit indicates whether read request buffer is idle (empty) or not." "0,1"
        textline "     "
        bitfld.long 0x00 6. " WIS ,Write Idle Status.This read only bit indicates whether write request buffer is idle (empty) or not." "0,1"
        textline "     "
        hexmask.long.byte 0x00 8.--16. 1. " PST ,Automatic Power saving timer."
        textline "     "
        bitfld.long 0x00 20. " LPMD ,General LPMD request." "0,1"
        textline "     "
        bitfld.long 0x00 21. " DVFS ,General DVFS request." "0,1"
        textline "     "
        bitfld.long 0x00 24. " LPACK ,General low-power acknowledge." "0,1"
        textline "     "
        bitfld.long 0x00 25. " DVACK ,General DVFS acknowledge." "0,1"
width 9.
group.long 0x408++0x3
    line.long 0x00 "MAEXIDR0,MMDC Core Exclusive ID Monitor Register0"
        hexmask.long.word 0x00 0.--16. 1. " EXC_ID_MONITOR0 ,This feild defines ID for Exclusive monitor#0."
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " EXC_ID_MONITOR1 ,This feild defines ID for Exclusive monitor#1."
width 9.
group.long 0x40c++0x3
    line.long 0x00 "MAEXIDR1,MMDC Core Exclusive ID Monitor Register1"
        hexmask.long.word 0x00 0.--16. 1. " EXC_ID_MONITOR2 ,This feild defines ID for Exclusive monitor#2."
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " EXC_ID_MONITOR3 ,This feild defines ID for Exclusive monitor#3."
width 8.
group.long 0x410++0x3
    line.long 0x00 "MADPCR0,MMDC Core Debug and Profiling Control Register 0"
        bitfld.long 0x00 0. " DBG_EN ,Debug and Profiling Enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " DBG_RST ,Debug and Profiling Reset." "0,1"
        textline "       "
        bitfld.long 0x00 2. " PRF_FRZ ,Profiling freeze." "0,1"
        textline "       "
        bitfld.long 0x00 3. " CYC_OVF ,Total Profiling Cycles Count Overflow." "0,1"
        textline "       "
        bitfld.long 0x00 8. " SBS_EN ,Step By Step debug Enable." "0,1"
        textline "       "
        bitfld.long 0x00 9. " SBS ,Step By Step trigger." "0,1"
width 8.
group.long 0x414++0x3
    line.long 0x00 "MADPCR1,MMDC Core Debug and Profiling Control Register 1"
        hexmask.long.word 0x00 0.--16. 1. " PRF_AXI_ID ,Profiling AXI ID."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " PRF_AXI_ID_MASK ,Profiling AXI ID Mask."
width 8.
rgroup.long 0x418++0x3
    line.long 0x00 "MADPSR0,MMDC Core Debug and Profiling Status Register 0"
        hexmask.long.long 0x00 0.--32. 1. " CYC_COUNT ,Total Profiling cycle Count."
width 8.
rgroup.long 0x41c++0x3
    line.long 0x00 "MADPSR1,MMDC Core Debug and Profiling Status Register 1"
        hexmask.long.long 0x00 0.--32. 1. " BUSY_COUNT ,Profiling Busy Cycles Count."
width 8.
rgroup.long 0x420++0x3
    line.long 0x00 "MADPSR2,MMDC Core Debug and Profiling Status Register 2"
        hexmask.long.long 0x00 0.--32. 1. " RD_ACC_COUNT ,Profiling Read Access Count."
width 8.
rgroup.long 0x424++0x3
    line.long 0x00 "MADPSR3,MMDC Core Debug and Profiling Status Register 3"
        hexmask.long.long 0x00 0.--32. 1. " WR_ACC_COUNT ,Profiling Write Access Count."
width 8.
rgroup.long 0x428++0x3
    line.long 0x00 "MADPSR4,MMDC Core Debug and Profiling Status Register 4"
        hexmask.long.long 0x00 0.--32. 1. " RD_BYTES_COUNT ,Profiling Read Bytes Count."
width 8.
rgroup.long 0x42c++0x3
    line.long 0x00 "MADPSR5,MMDC Core Debug and Profiling Status Register 5"
        hexmask.long.long 0x00 0.--32. 1. " WR_BYTES_COUNT ,Profiling Write Bytes Count."
width 7.
rgroup.long 0x430++0x3
    line.long 0x00 "MASBS0,MMDC Core Step By Step Address Register"
        hexmask.long.long 0x00 0.--32. 1. " SBS_ADDR ,Step By Step Address."
width 7.
rgroup.long 0x434++0x3
    line.long 0x00 "MASBS1,MMDC Core Step By Step Address Attributes Register"
        bitfld.long 0x00 0. " SBS_VLD ,Step By Step Valid." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SBS_TYPE ,Step By Step Request Type." "0,1"
        textline "      "
        hexmask.long.byte 0x00 2.--4. 1. " SBS_LOCK ,Step By Step Lock."
        textline "      "
        hexmask.long.byte 0x00 4.--7. 1. " SBS_PROT ,Step By Step Protection."
        textline "      "
        hexmask.long.byte 0x00 7.--10. 1. " SBS_SIZE ,Step By Step Size."
        textline "      "
        hexmask.long.byte 0x00 10.--12. 1. " SBS_BURST ,Step By Step Burst."
        textline "      "
        bitfld.long 0x00 12. " SBS_BUFF ,Step By Step Buffered." "0,1"
        textline "      "
        hexmask.long.byte 0x00 13.--16. 1. " SBS_LEN ,Step By Step Length."
        textline "      "
        hexmask.long.word 0x00 16.--32. 1. " SBS_AXI_ID ,Step By Step AXI ID."
width 7.
group.long 0x440++0x3
    line.long 0x00 "MAGENP,MMDC Core General Purpose Register"
        hexmask.long.long 0x00 0.--32. 1. " GP31_GP0 ,General purpose read/write bits."
width 11.
group.long 0x800++0x3
    line.long 0x00 "MPZQHWCTRL,MMDC PHY ZQ HW control register"
        hexmask.long.byte 0x00 0.--2. 1. " ZQ_MODE ,ZQ calibration mode:"
        textline "          "
        hexmask.long.byte 0x00 2.--6. 1. " ZQ_HW_PER ,ZQ periodic calibration time."
        textline "          "
        hexmask.long.byte 0x00 6.--11. 1. " ZQ_HW_PU_RES ,ZQ automatic calibration pull-up result."
        textline "          "
        hexmask.long.byte 0x00 11.--16. 1. " ZQ_HW_PD_RES ,ZQ HW calibration pull-down result."
        textline "          "
        bitfld.long 0x00 16. " ZQ_HW_FOR ,Force ZQ automatic calibration process with the i.MX ZQ calibration pad." "0,1"
        textline "          "
        hexmask.long.byte 0x00 17.--20. 1. " TZQ_INIT ,Device ZQ long/init time."
        textline "          "
        hexmask.long.byte 0x00 20.--23. 1. " TZQ_OPER ,Device ZQ long/oper time."
        textline "          "
        hexmask.long.byte 0x00 23.--26. 1. " TZQ_CS ,Device ZQ short time."
        textline "          "
        hexmask.long.byte 0x00 27.--32. 1. " ZQ_EARLY_COMPARATOR_EN_TIMER ,ZQ early comparator enable timer."
width 11.
group.long 0x804++0x3
    line.long 0x00 "MPZQSWCTRL,MMDC PHY ZQ SW control register"
        bitfld.long 0x00 0. " ZQ_SW_FOR ,ZQ SW calibration enable." "0,1"
        textline "          "
        bitfld.long 0x00 1. " ZQ_SW_RES ,ZQ software calibration result." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--7. 1. " ZQ_SW_PU_VAL ,ZQ software pull-up resistence.This field determines the value of the PU resistor during SW ZQ calibration."
        textline "          "
        hexmask.long.byte 0x00 7.--12. 1. " ZQ_SW_PD_VAL ,ZQ software pull-down resistence.This field determines the value of the PD resistor during SW ZQ calibration."
        textline "          "
        bitfld.long 0x00 12. " ZQ_SW_PD ,ZQ software PU/PD calibration." "0,1"
        textline "          "
        bitfld.long 0x00 13. " USE_ZQ_SW_VAL ,Use SW ZQ configured value for I/O pads resistor controls." "0,1"
        textline "          "
        hexmask.long.byte 0x00 16.--18. 1. " ZQ_CMP_OUT_SMP ,Defines the amount of cycles between driving the ZQ signals to the ZQ pad and till sampling the comparator enable output while performing ZQ calibration process with the i.MX ZQ calibration pad"
width 8.
group.long 0x808++0x3
    line.long 0x00 "MPWLGCR,MMDC PHY Write Leveling Configuration and Error Status Register"
        bitfld.long 0x00 0. " HW_WL_EN ,Write-Leveling HW (automatic) enable." "0,1"
        textline "       "
        bitfld.long 0x00 1. " SW_WL_EN ,Write-Leveling SW enable." "0,1"
        textline "       "
        bitfld.long 0x00 2. " SW_WL_CNT_EN ,SW write-leveling count down enable.This bit when asserted set a certain delay of (25+15) cycles from the setting of SW_WL_EN and before driving the DQS to the DDR device.This bit should be asserted before the first SW write-leveling request and after issuing the write leveling MRS command" "0,1"
        textline "       "
        bitfld.long 0x00 4. " WL_SW_RES0 ,Byte0 write-leveling software result." "0,1"
        textline "       "
        bitfld.long 0x00 5. " WL_SW_RES1 ,Byte1 write-leveling software result." "0,1"
        textline "       "
        bitfld.long 0x00 6. " WL_SW_RES2 ,Byte2 write-leveling software result." "0,1"
        textline "       "
        bitfld.long 0x00 7. " WL_SW_RES3 ,Byte3 write-leveling software result." "0,1"
        textline "       "
        bitfld.long 0x00 8. " WL_HW_ERR0 ,Byte0 write-leveling HW calibration error." "0,1"
        textline "       "
        bitfld.long 0x00 9. " WL_HW_ERR1 ,Byte1 write-leveling HW calibration error." "0,1"
        textline "       "
        bitfld.long 0x00 10. " WL_HW_ERR2 ,Byte2 write-leveling HW calibration error." "0,1"
        textline "       "
        bitfld.long 0x00 11. " WL_HW_ERR3 ,Byte3 write-leveling HW calibration error." "0,1"
width 12.
group.long 0x80c++0x3
    line.long 0x00 "MPWLDECTRL0,MMDC PHY Write Leveling Delay Control Register 0"
        hexmask.long.byte 0x00 0.--7. 1. " WL_DL_ABS_OFFSET0 ,Absolute write-leveling delay offset for Byte 0."
        textline "           "
        bitfld.long 0x00 8. " WL_HC_DEL0 ,Write leveling half cycle delay for Byte 0." "0,1"
        textline "           "
        hexmask.long.byte 0x00 9.--11. 1. " WL_CYC_DEL0 ,Write leveling cycle delay for Byte 0."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " WL_DL_ABS_OFFSET1 ,Absolute write-leveling delay offset for Byte 1."
        textline "           "
        bitfld.long 0x00 24. " WL_HC_DEL1 ,Write leveling half cycle delay for Byte 1." "0,1"
        textline "           "
        hexmask.long.byte 0x00 25.--27. 1. " WL_CYC_DEL1 ,Write leveling cycle delay for Byte 1."
width 12.
group.long 0x810++0x3
    line.long 0x00 "MPWLDECTRL1,MMDC PHY Write Leveling Delay Control Register 1"
        hexmask.long.byte 0x00 0.--7. 1. " WL_DL_ABS_OFFSET2 ,Absolute write-leveling delay offset for Byte 2."
        textline "           "
        bitfld.long 0x00 8. " WL_HC_DEL2 ,Write leveling half cycle delay for Byte 2." "0,1"
        textline "           "
        hexmask.long.byte 0x00 9.--11. 1. " WL_CYC_DEL2 ,Write leveling cycle delay for Byte 2."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " WL_DL_ABS_OFFSET3 ,Absolute write-leveling delay offset for Byte 3."
        textline "           "
        bitfld.long 0x00 24. " WL_HC_DEL3 ,Write leveling half cycle delay for Byte 3." "0,1"
        textline "           "
        hexmask.long.byte 0x00 25.--27. 1. " WL_CYC_DEL3 ,Write leveling cycle delay for Byte 3."
width 9.
rgroup.long 0x814++0x3
    line.long 0x00 "MPWLDLST,MMDC PHY Write Leveling delay-line Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " WL_DL_UNIT_NUM0 ,This field reflects the number of delay units that are actually used by write leveling delay-line 0."
        textline "        "
        hexmask.long.byte 0x00 8.--15. 1. " WL_DL_UNIT_NUM1 ,This field reflects the number of delay units that are actually used by write leveling delay-line 1."
        textline "        "
        hexmask.long.byte 0x00 16.--23. 1. " WL_DL_UNIT_NUM2 ,This field reflects the number of delay units that are actually used by write leveling delay-line 2."
        textline "        "
        hexmask.long.byte 0x00 24.--31. 1. " WL_DL_UNIT_NUM3 ,This field reflects the number of delay units that are actually used by write leveling delay-line 3."
width 10.
group.long 0x818++0x3
    line.long 0x00 "MPODTCTRL,MMDC PHY ODT control register"
        bitfld.long 0x00 0. " ODT_WR_PAS_EN ,Inactive write CS ODT enable." "0,1"
        textline "         "
        bitfld.long 0x00 1. " ODT_WR_ACT_EN ,Active write CS ODT enable." "0,1"
        textline "         "
        bitfld.long 0x00 2. " ODT_RD_PAS_EN ,Inactive read CS ODT enable." "0,1"
        textline "         "
        bitfld.long 0x00 3. " ODT_RD_ACT_EN ,Active read CS ODT enable." "0,1"
        textline "         "
        hexmask.long.byte 0x00 4.--7. 1. " ODT0_INT_RES ,On chip ODT byte0 resistor - This field determines the Rtt_Nom of the on chip ODT byte0 resistor during read accesses."
        textline "         "
        hexmask.long.byte 0x00 8.--11. 1. " ODT1_INT_RES ,On chip ODT byte1 resistor - This field determines the Rtt_Nom of the on chip ODT byte1 resistor during read accesses."
        textline "         "
        hexmask.long.byte 0x00 12.--15. 1. " ODT2_INT_RES ,On chip ODT byte2 resistor - This field determines the Rtt_Nom of the on chip ODT byte2 resistor during read accesses."
        textline "         "
        hexmask.long.byte 0x00 16.--19. 1. " ODT3_INT_RES ,On chip ODT byte3 resistor - This field determines the Rtt_Nom of the on chip ODT byte3 resistor during read accesses."
width 12.
group.long 0x81c++0x3
    line.long 0x00 "MPRDDQBY0DL,MMDC PHY Read DQ Byte0 Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RD_DQ0_DEL ,Read dqs0 to dq0 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--7. 1. " RD_DQ1_DEL ,Read dqs0 to dq1 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--11. 1. " RD_DQ2_DEL ,Read dqs0 to dq2 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--15. 1. " RD_DQ3_DEL ,Read dqs0 to dq3 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " RD_DQ4_DEL ,Read dqs0 to dq4 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " RD_DQ5_DEL ,Read dqs0 to dq5 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--27. 1. " RD_DQ6_DEL ,Read dqs0 to dq6 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQ7_DEL ,Read dqs0 to dq7 delay fine-tuning."
width 12.
group.long 0x820++0x3
    line.long 0x00 "MPRDDQBY1DL,MMDC PHY Read DQ Byte1 Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RD_DQ8_DEL ,Read dqs1 to dq8 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--7. 1. " RD_DQ9_DEL ,Read dqs1 to dq9 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--11. 1. " RD_DQ10_DEL ,Read dqs1 to dq10 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--15. 1. " RD_DQ11_DEL ,Read dqs1 to dq11 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " RD_DQ12_DEL ,Read dqs1 to dq12 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " RD_DQ13_DEL ,Read dqs1 to dq13 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--27. 1. " RD_DQ14_DEL ,Read dqs1 to dq14 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQ15_DEL ,Read dqs1 to dq15 delay fine-tuning."
width 12.
group.long 0x824++0x3
    line.long 0x00 "MPRDDQBY2DL,MMDC PHY Read DQ Byte2 Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RD_DQ16_DEL ,Read dqs2 to dq16 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--7. 1. " RD_DQ17_DEL ,Read dqs2 to dq17 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--11. 1. " RD_DQ18_DEL ,Read dqs2 to dq18 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--15. 1. " RD_DQ19_DEL ,Read dqs2 to dq19 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " RD_DQ20_DEL ,Read dqs2 to dq20 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " RD_DQ21_DEL ,Read dqs2 to dq21 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--27. 1. " RD_DQ22_DEL ,Read dqs2 to dq22 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQ23_DEL ,Read dqs2 to dq23 delay fine-tuning."
width 12.
group.long 0x828++0x3
    line.long 0x00 "MPRDDQBY3DL,MMDC PHY Read DQ Byte3 Delay Register"
        hexmask.long.byte 0x00 0.--3. 1. " RD_DQ24_DEL ,Read dqs3 to dq24 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--7. 1. " RD_DQ25_DEL ,Read dqs3 to dq25 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--11. 1. " RD_DQ26_DEL ,Read dqs3 to dq26 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--15. 1. " RD_DQ27_DEL ,Read dqs3 to dq27 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--19. 1. " RD_DQ28_DEL ,Read dqs3 to dq28 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--23. 1. " RD_DQ29_DEL ,Read dqs3 to dq29 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--27. 1. " RD_DQ30_DEL ,Read dqs3 to dq30 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQ31_DEL ,Read dqs3 to dq31 delay fine-tuning."
width 12.
group.long 0x82c++0x3
    line.long 0x00 "MPWRDQBY0DL,MMDC PHY Write DQ Byte0 Delay Register"
        hexmask.long.byte 0x00 0.--2. 1. " WR_DQ0_DEL ,Write dq0 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " WR_DQ1_DEL ,Write dq1 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " WR_DQ2_DEL ,Write dq2 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--14. 1. " WR_DQ3_DEL ,Write dq3 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--18. 1. " WR_DQ4_DEL ,Write dq4 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--22. 1. " WR_DQ5_DEL ,Write dq5 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--26. 1. " WR_DQ6_DEL ,Write dq6 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--30. 1. " WR_DQ7_DEL ,Write dq7 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " WR_DM0_DEL ,Write dm0 delay fine-tuning."
width 12.
group.long 0x830++0x3
    line.long 0x00 "MPWRDQBY1DL,MMDC PHY Write DQ Byte1 Delay Register"
        hexmask.long.byte 0x00 0.--2. 1. " WR_DQ8_DEL ,Write dq8 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " WR_DQ9_DEL ,Write dq9 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " WR_DQ10_DEL ,Write dq10 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--14. 1. " WR_DQ11_DEL ,Write dq11 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--18. 1. " WR_DQ12_DEL ,Write dq12 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--22. 1. " WR_DQ13_DEL ,Write dq13 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--26. 1. " WR_DQ14_DEL ,Write dq14 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--30. 1. " WR_DQ15_DEL ,Write dq15 delay fine-tuning."
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " WR_DM1_DEL ,Write dm1 delay fine-tuning."
width 12.
group.long 0x834++0x3
    line.long 0x00 "MPWRDQBY2DL,MMDC PHY Write DQ Byte2 Delay Register"
        hexmask.long.byte 0x00 0.--2. 1. " WR_DQ16_DEL ,Write dq16 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " WR_DQ17_DEL ,Write dq17 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " WR_DQ18_DEL ,Write dq18 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--14. 1. " WR_DQ19_DEL ,Write dq19 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--18. 1. " WR_DQ20_DEL ,Write dq20 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--22. 1. " WR_DQ21_DEL ,Write dq21 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--26. 1. " WR_DQ22_DEL ,Write dq22 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--30. 1. " WR_DQ23_DEL ,Write dq23 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " WR_DM2_DEL ,Write dm2 delay fine-tuning."
width 12.
group.long 0x838++0x3
    line.long 0x00 "MPWRDQBY3DL,MMDC PHY Write DQ Byte3 Delay Register"
        hexmask.long.byte 0x00 0.--2. 1. " WR_DQ24_DEL ,Write dq24 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 4.--6. 1. " WR_DQ25_DEL ,Write dq25 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 8.--10. 1. " WR_DQ26_DEL ,Write dq26 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 12.--14. 1. " WR_DQ27_DEL ,Write dq27 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 16.--18. 1. " WR_DQ28_DEL ,Write dq28 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 20.--22. 1. " WR_DQ29_DEL ,Write dq29 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 24.--26. 1. " WR_DQ30_DEL ,Write dq30 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 28.--30. 1. " WR_DQ31_DEL ,Write dq31 delay fine tuning."
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " WR_DM3_DEL ,Write dm3 delay fine tuning."
width 10.
group.long 0x83c++0x3
    line.long 0x00 "MPDGCTRL0,MMDC PHY Read DQS Gating Control Register 0"
        hexmask.long.byte 0x00 0.--7. 1. " DG_DL_ABS_OFFSET0 ,Absolute read DQS gating delay offset for Byte0."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " DG_HC_DEL0 ,Read DQS gating half cycles delay for Byte0 (Channel 0 register) and Byte4 in 64-bit mode (Channel 1 register) ."
        textline "         "
        bitfld.long 0x00 12. " HW_DG_ERR ,HW DQS gating error." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " DG_DL_ABS_OFFSET1 ,Absolute read DQS gating delay offset for Byte1."
        textline "         "
        bitfld.long 0x00 23. " DG_EXT_UP ,DG extend upper boundary." "0,1"
        textline "         "
        hexmask.long.byte 0x00 24.--28. 1. " DG_HC_DEL1 ,Read DQS gating half cycles delay for Byte1 (channel 0 register) and Byte5 in 64-bit mode (channel 1 register) ."
        textline "         "
        bitfld.long 0x00 28. " HW_DG_EN ,Enable automatic read DQS gating calibration." "0,1"
        textline "         "
        bitfld.long 0x00 29. " DG_DIS ,Read DQS gating disable." "0,1"
        textline "         "
        bitfld.long 0x00 30. " DG_CMP_CYC ,Read DQS gating sample cycle." "0,1"
        textline "         "
        bitfld.long 0x00 31. " RST_RD_FIFO ,Reset Read Data FIFO and associated pointers." "0,1"
width 10.
group.long 0x840++0x3
    line.long 0x00 "MPDGCTRL1,MMDC PHY Read DQS Gating Control Register 1"
        hexmask.long.byte 0x00 0.--7. 1. " DG_DL_ABS_OFFSET2 ,Absolute read DQS gating delay offset for Byte2."
        textline "         "
        hexmask.long.byte 0x00 8.--12. 1. " DG_HC_DEL2 ,Read DQS gating half cycles delay for Byte2 (Channel 0 register) and Byte6 for 64-bit mode(channel 1 register) ."
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " DG_DL_ABS_OFFSET3 ,Absolute read DQS gating delay offset for Byte3."
        textline "         "
        hexmask.long.byte 0x00 24.--28. 1. " DG_HC_DEL3 ,Read DQS gating half cycles delay for Byte3 (Channel 0 register) and Byte7 for 64-bit data (Channel 1 register) ."
width 10.
rgroup.long 0x844++0x3
    line.long 0x00 "MPDGDLST0,MMDC PHY Read DQS Gating delay-line Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " DG_DL_UNIT_NUM0 ,This field reflects the number of delay units that are actually used by read DQS gating delay-line 0."
        textline "         "
        hexmask.long.byte 0x00 8.--15. 1. " DG_DL_UNIT_NUM1 ,This field reflects the number of delay units that are actually used by read DQS gating delay-line 1."
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " DG_DL_UNIT_NUM2 ,This field reflects the number of delay units that are actually used by read DQS gating delay-line 2."
        textline "         "
        hexmask.long.byte 0x00 24.--31. 1. " DG_DL_UNIT_NUM3 ,This field reflects the number of delay units that are actually used by read DQS gating delay-line 3."
width 10.
group.long 0x848++0x3
    line.long 0x00 "MPRDDLCTL,MMDC PHY Read delay-lines Configuration Register"
        hexmask.long.byte 0x00 0.--7. 1. " RD_DL_ABS_OFFSET0 ,Absolute read delay offset for Byte0."
        textline "         "
        hexmask.long.byte 0x00 8.--15. 1. " RD_DL_ABS_OFFSET1 ,Absolute read delay offset for Byte1."
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " RD_DL_ABS_OFFSET2 ,Absolute read delay offset for Byte2."
        textline "         "
        hexmask.long.byte 0x00 24.--31. 1. " RD_DL_ABS_OFFSET3 ,Absolute read delay offset for Byte3."
width 9.
rgroup.long 0x84c++0x3
    line.long 0x00 "MPRDDLST,MMDC PHY Read delay-lines Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " RD_DL_UNIT_NUM0 ,This field reflects the number of delay units that are actually used by read delay-line 0."
        textline "        "
        hexmask.long.byte 0x00 8.--15. 1. " RD_DL_UNIT_NUM1 ,This field reflects the number of delay units that are actually used by read delay-line 1."
        textline "        "
        hexmask.long.byte 0x00 16.--23. 1. " RD_DL_UNIT_NUM2 ,This field reflects the number of delay units that are actually used by read delay-line 2."
        textline "        "
        hexmask.long.byte 0x00 24.--31. 1. " RD_DL_UNIT_NUM3 ,This field reflects the number of delay units that are actually used by read delay-line 3."
width 10.
group.long 0x850++0x3
    line.long 0x00 "MPWRDLCTL,MMDC PHY Write delay-lines Configuration Register"
        hexmask.long.byte 0x00 0.--7. 1. " WR_DL_ABS_OFFSET0 ,Absolute write delay offset for Byte0."
        textline "         "
        hexmask.long.byte 0x00 8.--15. 1. " WR_DL_ABS_OFFSET1 ,Absolute write delay offset for Byte1."
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " WR_DL_ABS_OFFSET2 ,Absolute write delay offset for Byte2."
        textline "         "
        hexmask.long.byte 0x00 24.--31. 1. " WR_DL_ABS_OFFSET3 ,Absolute write delay offset for Byte3."
width 9.
rgroup.long 0x854++0x3
    line.long 0x00 "MPWRDLST,MMDC PHY Write delay-lines Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " WR_DL_UNIT_NUM0 ,This field reflects the number of delay units that are actually used by write delay-line 0."
        textline "        "
        hexmask.long.byte 0x00 8.--15. 1. " WR_DL_UNIT_NUM1 ,This field reflects the number of delay units that are actually used by write delay-line 1."
        textline "        "
        hexmask.long.byte 0x00 16.--23. 1. " WR_DL_UNIT_NUM2 ,This field reflects the number of delay units that are actually used by write delay-line 2."
        textline "        "
        hexmask.long.byte 0x00 24.--31. 1. " WR_DL_UNIT_NUM3 ,This field reflects the number of delay units that are actually used by write delay-line 3."
width 9.
group.long 0x858++0x3
    line.long 0x00 "MPSDCTRL,MMDC PHY CK Control Register"
        hexmask.long.byte 0x00 8.--10. 1. " SDCLK0_DEL ,DDR clock0 delay fine tuning."
width 11.
group.long 0x85c++0x3
    line.long 0x00 "MPZQLP2CTL,MMDC ZQ LPDDR2 HW Control Register"
        hexmask.long.word 0x00 0.--9. 1. " ZQ_LP2_HW_ZQINIT ,This register defines the period in cycles that it takes the memory device to perform a Init ZQ calibration."
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " ZQ_LP2_HW_ZQCL ,This register defines the period in cycles that it takes the memory device to perform a long ZQ calibration."
        textline "          "
        hexmask.long.byte 0x00 24.--31. 1. " ZQ_LP2_HW_ZQCS ,This register defines the period in cycles that it takes the memory device to perform a Short ZQ calibration."
width 12.
group.long 0x860++0x3
    line.long 0x00 "MPRDDLHWCTL,MMDC PHY Read Delay HW Calibration Control Register"
        bitfld.long 0x00 0. " HW_RD_DL_ERR0 ,Automatic (HW) read calibration error of Byte0." "0,1"
        textline "           "
        bitfld.long 0x00 1. " HW_RD_DL_ERR1 ,Automatic (HW) read calibration error of Byte1." "0,1"
        textline "           "
        bitfld.long 0x00 2. " HW_RD_DL_ERR2 ,Automatic (HW) read calibration error of Byte2." "0,1"
        textline "           "
        bitfld.long 0x00 3. " HW_RD_DL_ERR3 ,Automatic (HW) read calibration error of Byte3." "0,1"
        textline "           "
        bitfld.long 0x00 4. " HW_RD_DL_EN ,Enable automatic (HW) read calibration." "0,1"
        textline "           "
        bitfld.long 0x00 5. " HW_RD_DL_CMP_CYC ,Automatic (HW) read sample cycle." "0,1"
width 12.
group.long 0x864++0x3
    line.long 0x00 "MPWRDLHWCTL,MMDC PHY Write Delay HW Calibration Control Register"
        bitfld.long 0x00 0. " HW_WR_DL_ERR0 ,Automatic (HW) write calibration error of Byte0." "0,1"
        textline "           "
        bitfld.long 0x00 1. " HW_WR_DL_ERR1 ,Automatic (HW) write calibration error of Byte1." "0,1"
        textline "           "
        bitfld.long 0x00 2. " HW_WR_DL_ERR2 ,Automatic (HW) write calibration error of Byte2." "0,1"
        textline "           "
        bitfld.long 0x00 3. " HW_WR_DL_ERR3 ,Automatic (HW) write calibration error of Byte3." "0,1"
        textline "           "
        bitfld.long 0x00 4. " HW_WR_DL_EN ,Enable automatic (HW) write calibration." "0,1"
        textline "           "
        bitfld.long 0x00 5. " HW_WR_DL_CMP_CYC ,Write sample cycle." "0,1"
width 12.
rgroup.long 0x868++0x3
    line.long 0x00 "MPRDDLHWST0,MMDC PHY Read Delay HW Calibration Status Register 0"
        hexmask.long.byte 0x00 0.--7. 1. " HW_RD_DL_LOW0 ,Automatic (HW) read calibration result of the lower boundary of Byte0."
        textline "           "
        hexmask.long.byte 0x00 8.--15. 1. " HW_RD_DL_UP0 ,Automatic (HW) read calibration result of the upper boundary of Byte0."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " HW_RD_DL_LOW1 ,Automatic (HW) read calibration result of the lower boundary of Byte1."
        textline "           "
        hexmask.long.byte 0x00 24.--31. 1. " HW_RD_DL_UP1 ,Automatic (HW) read calibration result of the upper boundary of Byte1."
width 12.
rgroup.long 0x86c++0x3
    line.long 0x00 "MPRDDLHWST1,MMDC PHY Read Delay HW Calibration Status Register 1"
        hexmask.long.byte 0x00 0.--7. 1. " HW_RD_DL_LOW2 ,Automatic (HW) read calibration result of the lower boundary of Byte2."
        textline "           "
        hexmask.long.byte 0x00 8.--15. 1. " HW_RD_DL_UP2 ,Automatic (HW) read calibration result of the upper boundary of Byte2."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " HW_RD_DL_LOW3 ,Automatic (HW) read calibration result of the lower boundary of Byte3."
        textline "           "
        hexmask.long.byte 0x00 24.--31. 1. " HW_RD_DL_UP3 ,Automatic (HW) read calibration result of the upper boundary of Byte3."
width 12.
rgroup.long 0x870++0x3
    line.long 0x00 "MPWRDLHWST0,MMDC PHY Write Delay HW Calibration Status Register 0"
        hexmask.long.byte 0x00 0.--7. 1. " HW_WR_DL_LOW0 ,Automatic (HW) write calibration result of the lower boundary of Byte0."
        textline "           "
        hexmask.long.byte 0x00 8.--15. 1. " HW_WR_DL_UP0 ,Automatic (HW) write calibration result of the upper boundary of Byte0."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " HW_WR_DL_LOW1 ,Automatic (HW) write calibration result of the lower boundary of Byte1."
        textline "           "
        hexmask.long.byte 0x00 24.--31. 1. " HW_WR_DL_UP1 ,Aautomatic (HW) write utomatic (HW) write calibration result of the upper boundary of Byte1."
width 12.
rgroup.long 0x874++0x3
    line.long 0x00 "MPWRDLHWST1,MMDC PHY Write Delay HW Calibration Status Register 1"
        hexmask.long.byte 0x00 0.--7. 1. " HW_WR_DL_LOW2 ,Automatic (HW) write calibration result of the lower boundary of Byte2."
        textline "           "
        hexmask.long.byte 0x00 8.--15. 1. " HW_WR_DL_UP2 ,Automatic (HW) write calibration result of the upper boundary of Byte2."
        textline "           "
        hexmask.long.byte 0x00 16.--23. 1. " HW_WR_DL_LOW3 ,Automatic (HW) write calibration result of the lower boundary of Byte3."
        textline "           "
        hexmask.long.byte 0x00 24.--31. 1. " HW_WR_DL_UP3 ,Automatic (HW) write calibration result of the upper boundary of Byte3."
width 10.
group.long 0x878++0x3
    line.long 0x00 "MPWLHWERR,MMDC PHY Write Leveling HW Error Register"
        hexmask.long.byte 0x00 0.--8. 1. " HW_WL0_DQ ,HW write-leveling calibration result of Byte0."
        textline "         "
        hexmask.long.byte 0x00 8.--16. 1. " HW_WL1_DQ ,HW write-leveling calibration result of Byte1."
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " HW_WL2_DQ ,HW write-leveling calibration result of Byte2."
        textline "         "
        hexmask.long.byte 0x00 24.--32. 1. " HW_WL3_DQ ,HW write-leveling calibration result of Byte3."
width 10.
rgroup.long 0x87c++0x3
    line.long 0x00 "MPDGHWST0,MMDC PHY Read DQS Gating HW Status Register 0"
        hexmask.long.word 0x00 0.--11. 1. " HW_DG_LOW0 ,HW DQS gating calibration result of the lower boundary of Byte0."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " HW_DG_UP0 ,HW DQS gating calibration result of the upper boundary of Byte0."
width 10.
rgroup.long 0x880++0x3
    line.long 0x00 "MPDGHWST1,MMDC PHY Read DQS Gating HW Status Register 1"
        hexmask.long.word 0x00 0.--11. 1. " HW_DG_LOW1 ,HW DQS gating calibration result of the lower boundary of Byte1."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " HW_DG_UP1 ,HW DQS gating calibration result of the upper boundary of Byte1."
width 10.
rgroup.long 0x884++0x3
    line.long 0x00 "MPDGHWST2,MMDC PHY Read DQS Gating HW Status Register 2"
        hexmask.long.word 0x00 0.--11. 1. " HW_DG_LOW2 ,HW DQS gating calibration result of the lower boundary of Byte2."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " HW_DG_UP2 ,HW DQS gating calibration result of the upper boundary of Byte2."
width 10.
rgroup.long 0x888++0x3
    line.long 0x00 "MPDGHWST3,MMDC PHY Read DQS Gating HW Status Register 3"
        hexmask.long.word 0x00 0.--11. 1. " HW_DG_LOW3 ,HW DQS gating calibration result of the lower boundary of Byte3."
        textline "         "
        hexmask.long.word 0x00 16.--27. 1. " HW_DG_UP3 ,HW DQS gating calibration result of the upper boundary of Byte3."
width 10.
group.long 0x88c++0x3
    line.long 0x00 "MPPDCMPR1,MMDC PHY Pre-defined Compare Register 1"
        hexmask.long.word 0x00 0.--16. 1. " PDV1 ,MMDC Pre defined comapre value2."
        textline "         "
        hexmask.long.word 0x00 16.--32. 1. " PDV2 ,MMDC Pre defined comapre value2."
width 10.
group.long 0x890++0x3
    line.long 0x00 "MPPDCMPR2,MMDC PHY Pre-defined Compare and CA delay-line Configuration Register"
        bitfld.long 0x00 0. " MPR_CMP ,MPR(DDR3)/DQ calibration (LPDDR2) comapre enable." "0,1"
        textline "         "
        bitfld.long 0x00 1. " MPR_FULL_CMP ,MPR(DDR3)/DQ calibration (LPDDR2) full compare enable." "0,1"
        textline "         "
        bitfld.long 0x00 2. " READ_LEVEL_PATTERN ,MPR(DDR3)/DQ calibration(LPDDR2) read compare pattern." "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--23. 1. " CA_DL_ABS_OFFSET ,Absolute CA (Command/Address of LPDDRR2) offset."
        textline "         "
        hexmask.long.byte 0x00 24.--31. 1. " PHY_CA_DL_UNIT ,This field reflects the number of delay units that are actually used by CA (Command/Address of LPDDR2) delay-line"
width 9.
group.long 0x894++0x3
    line.long 0x00 "MPSWDAR0,MMDC PHY SW Dummy Access Register"
        bitfld.long 0x00 0. " SW_DUMMY_WR ,SW dummy write." "0,1"
        textline "        "
        bitfld.long 0x00 1. " SW_DUMMY_RD ,SW dummy read." "0,1"
        textline "        "
        bitfld.long 0x00 2. " SW_DUM_CMP0 ,SW dummy read byte0 compare results." "0,1"
        textline "        "
        bitfld.long 0x00 3. " SW_DUM_CMP1 ,SW dummy read byte1 compare results." "0,1"
        textline "        "
        bitfld.long 0x00 4. " SW_DUM_CMP2 ,SW dummy read byte2 compare results." "0,1"
        textline "        "
        bitfld.long 0x00 5. " SW_DUM_CMP3 ,SW dummy read byte3 compare results." "0,1"
width 10.
rgroup.long 0x898++0x3
    line.long 0x00 "MPSWDRDR0,MMDC PHY SW Dummy Read Data Register 0"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD0 ,Dummy read data0."
width 10.
rgroup.long 0x89c++0x3
    line.long 0x00 "MPSWDRDR1,MMDC PHY SW Dummy Read Data Register 1"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD1 ,Dummy read data1."
width 10.
rgroup.long 0x8a0++0x3
    line.long 0x00 "MPSWDRDR2,MMDC PHY SW Dummy Read Data Register 2"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD2 ,Dummy read data2."
width 10.
rgroup.long 0x8a4++0x3
    line.long 0x00 "MPSWDRDR3,MMDC PHY SW Dummy Read Data Register 3"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD3 ,Dummy read data3."
width 10.
rgroup.long 0x8a8++0x3
    line.long 0x00 "MPSWDRDR4,MMDC PHY SW Dummy Read Data Register 4"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD4 ,Dummy read data4."
width 10.
rgroup.long 0x8ac++0x3
    line.long 0x00 "MPSWDRDR5,MMDC PHY SW Dummy Read Data Register 5"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD5 ,Dummy read data5."
width 10.
rgroup.long 0x8b0++0x3
    line.long 0x00 "MPSWDRDR6,MMDC PHY SW Dummy Read Data Register 6"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD6 ,Dummy read data6."
width 10.
rgroup.long 0x8b4++0x3
    line.long 0x00 "MPSWDRDR7,MMDC PHY SW Dummy Read Data Register 7"
        hexmask.long.long 0x00 0.--32. 1. " DUM_RD7 ,Dummy read data7."
width 7.
group.long 0x8b8++0x3
    line.long 0x00 "MPMUR0,MMDC PHY Measure Unit Register"
        hexmask.long.word 0x00 0.--10. 1. " MU_BYP_VAL ,Number of delay units for measurement bypass."
        textline "      "
        bitfld.long 0x00 10. " MU_BYP_EN ,Measure unit bypass enable." "0,1"
        textline "      "
        bitfld.long 0x00 11. " FRC_MSR ,Force measuement on delay-lines." "0,1"
        textline "      "
        hexmask.long.word 0x00 16.--26. 1. " MU_UNIT_DEL_NUM ,Number of delay units measured per cycle."
width 9.
group.long 0x8bc++0x3
    line.long 0x00 "MPWRCADL,MMDC Write CA delay-line controller"
        hexmask.long.byte 0x00 0.--2. 1. " WR_CA0_DEL ,CA (Command/Address LPDDR2 bus) bit 0 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 2.--4. 1. " WR_CA1_DEL ,CA (Command/Address LPDDR2 bus) bit 1 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 4.--6. 1. " WR_CA2_DEL ,CA (Command/Address LPDDR2 bus) bit 2 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 6.--8. 1. " WR_CA3_DEL ,CA (Command/Address LPDDR2 bus) bit 3 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 8.--10. 1. " WR_CA4_DEL ,CA (Command/Address LPDDR2 bus) bit 4 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 10.--12. 1. " WR_CA5_DEL ,CA (Command/Address LPDDR2 bus) bit 5 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 12.--14. 1. " WR_CA6_DEL ,CA (Command/Address LPDDR2 bus) bit 6 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 14.--16. 1. " WR_CA7_DEL ,CA (Command/Address LPDDR2 bus) bit 7 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 16.--18. 1. " WR_CA8_DEL ,CA (Command/Address LPDDR2 bus) bit 8 delay fine tuning."
        textline "        "
        hexmask.long.byte 0x00 18.--20. 1. " WR_CA9_DEL ,CA (Command/Address LPDDR2 bus) bit 9 delay fine tuning."
width 7.
rgroup.long 0x8c0++0x3
    line.long 0x00 "MPDCCR,MMDC Duty Cycle Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " WR_DQS0_FT_DCC ,Write DQS duty cycle fine tuning control of Byte0."
        textline "      "
        hexmask.long.byte 0x00 3.--6. 1. " WR_DQS1_FT_DCC ,Write DQS duty cycle fine tuning control of Byte1."
        textline "      "
        hexmask.long.byte 0x00 6.--9. 1. " WR_DQS2_FT_DCC ,Write DQS duty cycle fine tuning control of Byte1."
        textline "      "
        hexmask.long.byte 0x00 9.--12. 1. " WR_DQS3_FT_DCC ,Write DQS duty cycle fine tuning control of Byte0."
        textline "      "
        hexmask.long.byte 0x00 12.--15. 1. " CK_FT0_DCC ,Primary duty cycle fine tuning control of DDR clock."
        textline "      "
        hexmask.long.byte 0x00 16.--19. 1. " CK_FT1_DCC ,Secondary duty cycle fine tuning control of DDR clock."
        textline "      "
        hexmask.long.byte 0x00 19.--22. 1. " RD_DQS0_FT_DCC ,Read DQS duty cycle fine tuning control of Byte0."
        textline "      "
        hexmask.long.byte 0x00 22.--25. 1. " RD_DQS1_FT_DCC ,Read DQS duty cycle fine tuning control of Byte1."
        textline "      "
        hexmask.long.byte 0x00 25.--28. 1. " RD_DQS2_FT_DCC ,Read DQS duty cycle fine tuning control of Byte2."
        textline "      "
        hexmask.long.byte 0x00 28.--31. 1. " RD_DQS3_FT_DCC ,Read DQS duty cycle fine tuning control of Byte3."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; OCOTP
;--------------------------------------------------------------------------------
tree "OCOTP"
    base ad:0x021bc000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CTRL,OTP Controller Control Register"
        hexmask.long.byte 0x00 0.--7. 1. " ADDR ,OTP write and read access address register."
        textline "    "
        bitfld.long 0x00 8. " BUSY ,OTP controller status bit." "0,1"
        textline "    "
        bitfld.long 0x00 9. " ERROR ,Set by the controller when an access to a locked region(OTP or shadow register) is requested." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RELOAD_SHADOWS ,Set to force re-loading the shadow registers (HW/SW capability and LOCK)." "0,1"
        textline "    "
        hexmask.long.word 0x00 16.--32. 1. " WR_UNLOCK ,Write 0x3E77 to enable OTP write accesses."
width 7.
group.long 0x10++0x3
    line.long 0x00 "TIMING,OTP Controller Timing Register"
        hexmask.long.word 0x00 0.--12. 1. " STROBE_PROG ,This count value specifies the strobe period in one time write OTP."
        textline "      "
        hexmask.long.byte 0x00 12.--16. 1. " RELAX ,This count value specifies the time to add to all default timing parameters other than the Tpgm and Trd."
        textline "      "
        hexmask.long.byte 0x00 16.--22. 1. " STROBE_READ ,This count value specifies the strobe period in one time read OTP."
        textline "      "
        hexmask.long.byte 0x00 22.--28. 1. " WAIT ,This count value specifies time interval between auto read and write access in one time program."
width 5.
group.long 0x20++0x3
    line.long 0x00 "DATA,OTP Controller Write Data Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Used to initiate a write to OTP."
width 10.
group.long 0x30++0x3
    line.long 0x00 "READ_CTRL,OTP Controller Write Data Register"
        bitfld.long 0x00 0. " READ_FUSE ,Used to initiate a read to OTP." "0,1"
width 15.
group.long 0x40++0x3
    line.long 0x00 "READ_FUSE_DATA,OTP Controller Read Data Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,The data read from OTP"
width 10.
group.long 0x50++0x3
    line.long 0x00 "SW_STICKY,Sticky bit Register"
        bitfld.long 0x00 1. " SRK_REVOKE_LOCK ,Shadow register write and OTP write lock for SRK_REVOKE, MC_ERA and AP_BI_VER regions." "0,1"
        textline "         "
        bitfld.long 0x00 2. " FIELD_RETURN_LOCK ,Shadow register write and OTP write lock for FIELD_RETURN region." "0,1"
width 4.
group.long 0x60++0x3
    line.long 0x00 "SCS,Software Controllable Signals Register"
        bitfld.long 0x00 0. " HAB_JDE ,HAB JTAG Debug Enable." "0,1"
        textline "   "
        hexmask.long.long 0x00 1.--31. 1. " SPARE ,Unallocated read/write bits for implementation specific software use."
        textline "   "
        bitfld.long 0x00 31. " LOCK ,When set, all of the bits in this register are locked and can not be changed through SW programming." "0,1"
width 8.
rgroup.long 0x90++0x3
    line.long 0x00 "VERSION,OTP Controller Version Register"
        hexmask.long.word 0x00 0.--16. 1. " STEP ,Fixed read-only value reflecting the stepping of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of the RTL version."
width 5.
rgroup.long 0x400++0x3
    line.long 0x00 "LOCK,Value of OTP Bank0 Word0 (Lock controls)"
        hexmask.long.byte 0x00 0.--2. 1. " TESTER ,Status of shadow register and OTP write lock for tester region."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " BOOT_CFG ,Status of shadow register and OTP write lock for boot_cfg region."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " MEM_TRIM ,Status of shadow register and OTP write lock for mem_trim region."
        textline "    "
        bitfld.long 0x00 6. " SJC_RESP ,Status of shadow register read and write, OTP read and write lock for sjc_resp region." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " MAC_ADDR ,Status of shadow register and OTP write lock for mac_addr region."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " GP1 ,Status of shadow register and OTP write lock for gp2 region."
        textline "    "
        hexmask.long.byte 0x00 12.--14. 1. " GP2 ,Status of shadow register and OTP write lock for gp2 region."
        textline "    "
        bitfld.long 0x00 14. " SRK ,Status of shadow register and OTP write lock for srk region." "0,1"
        textline "    "
        hexmask.long.byte 0x00 18.--20. 1. " ANALOG ,Status of shadow register and OTP write lock for analog region."
        textline "    "
        bitfld.long 0x00 22. " MISC_CONF ,Status of shadow register and OTP write lock for misc_conf region." "0,1"
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " UNALLOCATED ,Value of un-used portion of LOCK word"
width 5.
group.long 0x410++0x3
    line.long 0x00 "CFG0,Value of OTP Bank0 Word1 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,This register contains 32 bits of the Unique ID and SJC_CHALLENGE field."
width 5.
group.long 0x420++0x3
    line.long 0x00 "CFG1,Value of OTP Bank0 Word2 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,This register contains 32 bits of the Unique ID and SJC_CHALLENGE field."
width 5.
group.long 0x430++0x3
    line.long 0x00 "CFG2,Value of OTP Bank0 Word3 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 0, word 3 (ADDR = 0x03)."
width 5.
group.long 0x440++0x3
    line.long 0x00 "CFG3,Value of OTP Bank0 Word4 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 0, word 4 (ADDR = 0x04)."
width 5.
group.long 0x450++0x3
    line.long 0x00 "CFG4,Value of OTP Bank0 Word5 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 0, word 5 (ADDR = 0x05)."
width 5.
group.long 0x460++0x3
    line.long 0x00 "CFG5,Value of OTP Bank0 Word6 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 0, word 6 (ADDR = 0x06)."
width 5.
group.long 0x470++0x3
    line.long 0x00 "CFG6,Value of OTP Bank0 Word7 (Configuration and Manufacturing Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 0, word 7 (ADDR = 0x07)."
width 5.
group.long 0x480++0x3
    line.long 0x00 "MEM0,Value of OTP Bank1 Word0 (Memory Related Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 0 (ADDR = 0x08)."
width 5.
group.long 0x490++0x3
    line.long 0x00 "MEM1,Value of OTP Bank1 Word1 (Memory Related Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 1 (ADDR = 0x09)."
width 5.
group.long 0x4a0++0x3
    line.long 0x00 "MEM2,Value of OTP Bank1 Word2 (Memory Related Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 2 (ADDR = 0x0A)."
width 5.
group.long 0x4b0++0x3
    line.long 0x00 "MEM3,Value of OTP Bank1 Word3 (Memory Related Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 3 (ADDR = 0x0B)."
width 5.
group.long 0x4c0++0x3
    line.long 0x00 "MEM4,Value of OTP Bank1 Word4 (Memory Related Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 4 (ADDR = 0x0C)."
width 5.
group.long 0x4d0++0x3
    line.long 0x00 "ANA0,Value of OTP Bank1 Word5 (Memory Related Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 5 (ADDR = 0x0D)."
width 5.
group.long 0x4e0++0x3
    line.long 0x00 "ANA1,Value of OTP Bank1 Word6 (General Purpose Customer Defined Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 6 (ADDR = 0x0E)."
width 5.
group.long 0x4f0++0x3
    line.long 0x00 "ANA2,Value of OTP Bank1 Word7 (General Purpose Customer Defined Info.)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP bank 1, word 7 (ADDR = 0x0F)."
width 5.
group.long 0x580++0x3
    line.long 0x00 "SRK0,Shadow Register for OTP Bank3 Word0 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word0 (Copy of OTP Bank 3, word 0 (ADDR = 0x1C))."
width 5.
group.long 0x590++0x3
    line.long 0x00 "SRK1,Shadow Register for OTP Bank3 Word1 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word1 (Copy of OTP Bank 3, word 1 (ADDR = 0x1D))."
width 5.
group.long 0x5a0++0x3
    line.long 0x00 "SRK2,Shadow Register for OTP Bank3 Word2 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word2 (Copy of OTP Bank 3, word 2 (ADDR = 0x1E))."
width 5.
group.long 0x5b0++0x3
    line.long 0x00 "SRK3,Shadow Register for OTP Bank3 Word3 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word3 (Copy of OTP Bank 3, word 3 (ADDR = 0x1F))."
width 5.
group.long 0x5c0++0x3
    line.long 0x00 "SRK4,Shadow Register for OTP Bank3 Word4 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word4 (Copy of OTP Bank 3, word 4 (ADDR = 0x20))."
width 5.
group.long 0x5d0++0x3
    line.long 0x00 "SRK5,Shadow Register for OTP Bank3 Word5 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word5 (Copy of OTP Bank 3, word 5 (ADDR = 0x21))."
width 5.
group.long 0x5e0++0x3
    line.long 0x00 "SRK6,Shadow Register for OTP Bank3 Word6 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word6 (Copy of OTP Bank 3, word 6 (ADDR = 0x22))."
width 5.
group.long 0x5f0++0x3
    line.long 0x00 "SRK7,Shadow Register for OTP Bank3 Word7 (SRK Hash)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the hash of the Super Root Key word7 (Copy of OTP Bank 3, word 7 (ADDR = 0x23))."
width 6.
group.long 0x600++0x3
    line.long 0x00 "RESP0,Value of OTP Bank4 Word0 (Secure JTAG Response Field)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the SJC_RESP Key word0 (Copy of OTP Bank 4, word 0 (ADDR = 0x20))."
width 11.
group.long 0x610++0x3
    line.long 0x00 "HSJC_RESP1,Value of OTP Bank4 Word1 (Secure JTAG Response Field)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Shadow register for the SJC_RESP Key word1 (Copy of OTP Bank 4, word 1 (ADDR = 0x21))."
width 5.
group.long 0x620++0x3
    line.long 0x00 "MAC0,Value of OTP Bank4 Word2 (MAC Address)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 4, word 2 (ADDR = 0x22)."
width 5.
group.long 0x630++0x3
    line.long 0x00 "MAC1,Value of OTP Bank4 Word3 (MAC Address)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 4, word 3 (ADDR = 0x23)."
width 4.
group.long 0x660++0x3
    line.long 0x00 "GP1,Value of OTP Bank4 Word6 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 4, word 6 (ADDR = 0x26)."
width 4.
group.long 0x670++0x3
    line.long 0x00 "GP2,Value of OTP Bank4 Word7 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 4, word 7 (ADDR = 0x27)."
width 10.
group.long 0x6d0++0x3
    line.long 0x00 "MISC_CONF,Value of OTP Bank5 Word5 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 5, word 5 (ADDR = 0x2d)."
width 13.
group.long 0x6e0++0x3
    line.long 0x00 "FIELD_RETURN,Value of OTP Bank5 Word6 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 5, word 6 (ADDR = 0x2e)."
width 11.
group.long 0x6f0++0x3
    line.long 0x00 "SRK_REVOKE,Value of OTP Bank5 Word7 (HW Capabilities)"
        hexmask.long.long 0x00 0.--32. 1. " BITS ,Reflects value of OTP Bank 5, word 7 (ADDR = 0x2f)."


tree.end



;--------------------------------------------------------------------------------
; PCIE_EP
;--------------------------------------------------------------------------------
tree "PCIE_EP"
    base ad:0x01ffc000

width 9.
rgroup.long 0x0++0x3
    line.long 0x00 "DEVICEID,Device ID and Vendor ID Register"
width 8.
group.long 0x4++0x3
    line.long 0x00 "COMMAND,Command and Status Register"
        bitfld.long 0x00 0. " I_O_SPACE_ENABLE ,I/O Space Enable" "0,1"
        textline "       "
        bitfld.long 0x00 1. " MEMORY_SPACE_ENABLE ,Memory Space Enable" "0,1"
        textline "       "
        bitfld.long 0x00 2. " BUS_MASTER_ENABLE ,Bus Master Enable" "0,1"
        textline "       "
        bitfld.long 0x00 3. " SPECIAL_CYCLE_ENABLE ,Special Cycle Enable Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 4. " MEMORY_WRITE_AND_INVALIDATE ,Memory Write and Invalidate Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 5. " VGA_PALETTE_SNOOP ,VGA Palette Snoop Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 6. " PARITY_ERROR_RESPONSE ,Parity Error Response" "0,1"
        textline "       "
        bitfld.long 0x00 7. " IDSEL_STEPPING ,IDSEL Stepping/Wait Cycle Control Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 8. " SERR_ENABLE ,SERR# Enable" "0,1"
        textline "       "
        bitfld.long 0x00 9. " FAST_BACK_TO_BACK_ENABLE ,Fast Back-to-Back Enable Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 10. " INTX_ASSERTION_DISABLE ,INTx Assertion Disable" "0,1"
        textline "       "
        bitfld.long 0x00 19. " INTX_STATUS ,INTx Status" "0,1"
        textline "       "
        bitfld.long 0x00 20. " CAPABILITIES_LIST ,Capabilities List Indicates presence of an extended capability item." "0,1"
        textline "       "
        bitfld.long 0x00 21. " SIXTYSIX_MHZ_CAPABLE ,66 MHz Capable Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 23. " FAST_BACK_TO_BACK_CAPABLE ,Fast Back-to-Back Capable Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 24. " MASTER_DATA_PARITY_ERROR ,Master Data Parity Error" "0,1"
        textline "       "
        hexmask.long.byte 0x00 25.--27. 1. " DEVSEL_TIMING ,DEVSEL Timing Not applicable for PCI Express."
        textline "       "
        bitfld.long 0x00 27. " SIGNALED_TARGET_ABORT ,Signaled Target Abort" "0,1"
        textline "       "
        bitfld.long 0x00 28. " RECEIVED_TARGET_ABORT ,Received Target Abort" "0,1"
        textline "       "
        bitfld.long 0x00 29. " RECEIVED_MASTER_ABORT ,Received Master Abort" "0,1"
        textline "       "
        bitfld.long 0x00 30. " DETECTED_PARITY_ERROR ,Detected Parity Error" "0,1"
        textline "       "
        bitfld.long 0x00 31. " SIGNALED_SYSTEM_ERROR ,Signaled System Error" "0,1"
width 5.
group.long 0xc++0x3
    line.long 0x00 "BIST,BIST Register"
        hexmask.long.byte 0x00 0.--8. 1. " CACHE_LINE_SIZE ,Cache Line Size The Cache Line Size register is RW for legacy compatibility purposes and is not applicable to PCI Express device functionality."
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " MASTER_LATENCY_TIMER ,Master Latency Timer Not applicable for PCI Express, hardwired to 0."
        textline "    "
        hexmask.long.byte 0x00 16.--23. 1. " CONFIGURATION_HEADER_FORMAT ,Configuration Header Format Hardwired to 0 for type 0."
        textline "    "
        bitfld.long 0x00 23. " MULTI_FUNCTION_DEVICE ,Multi Function Device The default value is 0 for a single function device (`CX_NFUNC = 1) or 1 for a multi-function device (`CX_NFUNC != 1)." "0,1"
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " NOT_SUPPORTED_BY__CORE ,The BIST register functions are not supported by the core."
width 5.
rgroup.long 0x10++0x3
    line.long 0x00 "BAR0,Base Address 0"
        bitfld.long 0x00 0. " MEM_I_O ,Bits [3:0] are writable through the DBI." "0,1"
        textline "    "
        hexmask.long.byte 0x00 1.--3. 1. " TYPE ,If BAR 0 is an I/O BAR, bit 2 the least significant bit of the base address and bit 1 is 0."
        textline "    "
        bitfld.long 0x00 3. " PREF ,If BAR 0 is an I/O BAR, bit 3 is the second least significant bit of the base address." "0,1"
        textline "    "
        hexmask.long.long 0x00 4.--32. 1. " ADDRESS ,BAR 0 base address bits (for a 64-bit BAR, the remaining upper address bits are in BAR 1)."
width 6.
rgroup.long 0x10++0x3
    line.long 0x00 "MASK0,BAR 0 Mask Register"
        bitfld.long 0x00 0. " ENABLE ,Bit 0 is interpreted as BAR Enable when writing to the BAR Mask register rather than as a mask bit because bit 0 of a BAR is always masked from writing by host software." "0,1"
        textline "     "
        hexmask.long.long 0x00 1.--32. 1. " MASK ,Indicates which BAR 0 bits to mask (make non- writable) from host software, which, in turn, determines the size of the BAR."
width 6.
rgroup.long 0x14++0x3
    line.long 0x00 "MASK1,BAR 1 Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " MASK ,Bits [31:1]: BAR 1 Mask value, interpreted the same way as BAR 0 Mask."
width 6.
rgroup.long 0x18++0x3
    line.long 0x00 "MASK2,BAR 2 Mask Register"
        bitfld.long 0x00 0. " BAR2_ENABLED_N ,Bit 0 is interpreted as BAR Enable when writing to the BAR Mask register rather than as a mask bit because bit 0 of a BAR is always masked from writing by host software." "0,1"
        textline "     "
        hexmask.long.long 0x00 1.--32. 1. " BAR2_MASK_N ,Indicates which BAR 2 bits to mask (make non- writable) from host software, which, in turn, determines the size of the BAR."
width 6.
rgroup.long 0x1c++0x3
    line.long 0x00 "MASK3,BAR 3 Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " MASK ,Bits [31:1]: BAR 3 Mask value, interpreted the same way as BAR 2 Mask."
width 5.
rgroup.long 0x28++0x3
    line.long 0x00 "CISP,CardBus CIS Pointer Register"
        hexmask.long.long 0x00 0.--32. 1. " CARDBUS_CIS_PTR_N ,CardBus CIS Pointer Optional, writable through the DBI."
width 5.
rgroup.long 0x2c++0x3
    line.long 0x00 "SSID,Subsystem ID and Subsystem Vendor ID Register"
        hexmask.long.word 0x00 0.--16. 1. " SUBSYS_VENDOR_ID_N ,Subsystem Vendor ID Writable through the DBI."
        textline "    "
        hexmask.long.word 0x00 16.--32. 1. " SUBSYS_DEV_ID_N ,Subsystem ID Writable through the DBI."
width 8.
group.long 0x30++0x3
    line.long 0x00 "EROMBAR,Expansion ROM Base Address Register"
        bitfld.long 0x00 0. " ENABLE ,Expansion ROM Enable" "0,1"
        textline "       "
        hexmask.long.long 0x00 11.--32. 1. " ADDRESS ,Expansion ROM Address"
width 9.
group.long 0x30++0x3
    line.long 0x00 "EROMMASK,Expansion ROM BAR Mask Register"
        bitfld.long 0x00 0. " ROM_BAR_ENABLED_N ,Expansion ROM BAR Enable" "0,1"
        textline "        "
        hexmask.long.long 0x00 1.--32. 1. " ROM_MASK_N ,Indicates which Expansion ROM BAR bits to mask (make non-writable) from host software, which, in turn, determines the size of the BAR."
width 6.
rgroup.long 0x34++0x3
    line.long 0x00 "CAPPR,Capability Pointer Register"
        hexmask.long.byte 0x00 0.--8. 1. " CFG_NEXT_PTR ,First Capability Pointer."
width 4.
group.long 0x3c++0x3
    line.long 0x00 "ILR,Interrupt Line and Pin Register"
        hexmask.long.byte 0x00 0.--8. 1. " INTERRUPT_LINE ,Interrupt Line Value in this register is system architecture specific."
        textline "   "
        hexmask.long.byte 0x00 8.--16. 1. " INT_PIN_MAPPING_N ,Interrupt Pin Identifies the legacy interrupt Message that the device (or device function) uses."
width 4.
group.long 0x100++0x3
    line.long 0x00 "AER,AER Capability Header"
        hexmask.long.word 0x00 0.--16. 1. " PCI_EXPRESS_EXTENDED_CAPABILITY_ID ,PCI Express Extended Capability ID Value is 0x1 for Advanced Error Reporting."
        textline "   "
        hexmask.long.byte 0x00 16.--20. 1. " CAPABILITY_VERSION ,Capability Version"
        textline "   "
        hexmask.long.word 0x00 20.--32. 1. " NEXT_CAPABILITY_OFFSET ,Next Capability Offset"
width 5.
group.long 0x104++0x3
    line.long 0x00 "UESR,Uncorrectable Error Status Register"
        bitfld.long 0x00 4. " DATA_LINK_PROTOCOL_ERROR_STATUS ,Data Link Protocol Error Status" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SURPRISE_DOWN_ERROR_STATUS ,Surprise Down Error Status (not supported)" "0,1"
        textline "    "
        bitfld.long 0x00 12. " POISONED_TLP_STATUS ,Poisoned TLP Status" "0,1"
        textline "    "
        bitfld.long 0x00 13. " FLOW_CONTROL_PROTOCOL_ERROR_STATUS ,Flow Control Protocol Error Status" "0,1"
        textline "    "
        bitfld.long 0x00 14. " COMPLETION_TIMEOUT_STATUS ,Completion Timeout Status" "0,1"
        textline "    "
        bitfld.long 0x00 15. " COMPLETER_ABORT_STATUS ,Completer Abort Status" "0,1"
        textline "    "
        bitfld.long 0x00 16. " UNEXPECTED_COMPLETION_STATUS ,Unexpected Completion Status" "0,1"
        textline "    "
        bitfld.long 0x00 17. " RECEIVER_OVERFLOW_STATUS ,Receiver Overflow Status" "0,1"
        textline "    "
        bitfld.long 0x00 18. " MALFORMED_TLP_STATUS ,Malformed TLP Status" "0,1"
        textline "    "
        bitfld.long 0x00 19. " ECRC_ERROR_STATUS ,ECRC Error Status" "0,1"
        textline "    "
        bitfld.long 0x00 20. " UNSUPPORTED_REQUEST_ERROR_STATUS ,Unsupported Request Error Status" "0,1"
width 5.
group.long 0x108++0x3
    line.long 0x00 "UEMR,Uncorrectable Error Mask Register"
        bitfld.long 0x00 4. " DATA_LINK_PROTOCOL_ERROR_MASK ,Data Link Protocol Error Mask" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SURPRISE_DOWN_ERROR_MASK ,Surprise Down Error Mask (not supported)" "0,1"
        textline "    "
        bitfld.long 0x00 12. " POISONED_TLP_MASK ,Poisoned TLP Mask" "0,1"
        textline "    "
        bitfld.long 0x00 13. " FLOW_CONTROL_PROTOCOL_ERROR_MASK ,Flow Control Protocol Error Mask" "0,1"
        textline "    "
        bitfld.long 0x00 14. " COMPLETION_TIMEOUT_MASK ,Completion Timeout Mask" "0,1"
        textline "    "
        bitfld.long 0x00 15. " COMPLETER_ABORT_MASK ,Completer Abort Mask" "0,1"
        textline "    "
        bitfld.long 0x00 16. " UNEXPECTED_COMPLETION_MASK ,Unexpected Completion Mask" "0,1"
        textline "    "
        bitfld.long 0x00 17. " RECEIVER_OVERFLOW_MASK ,Receiver Overflow Mask" "0,1"
        textline "    "
        bitfld.long 0x00 18. " MALFORMED_TLP_MASK ,Malformed TLP Mask" "0,1"
        textline "    "
        bitfld.long 0x00 19. " ECRC_ERROR_MASK ,ECRC Error Mask" "0,1"
        textline "    "
        bitfld.long 0x00 20. " UNSUPPORTED_REQUEST_ERROR_MASK ,Unsupported Request Error Mask" "0,1"
width 7.
group.long 0x10c++0x3
    line.long 0x00 "UESEVR,Uncorrectable Error Severity Register"
        bitfld.long 0x00 4. " DATA_LINK_PROTOCOL_ERROR_SEVERITY ,Data Link Protocol Error Severity" "0,1"
        textline "      "
        bitfld.long 0x00 5. " SURPRISE_DOWN_ERROR_SEVERITY ,Surprise Down Error Severity (not supported)" "0,1"
        textline "      "
        bitfld.long 0x00 12. " POISONED_TLP_SEVERITY ,Poisoned TLP Severity" "0,1"
        textline "      "
        bitfld.long 0x00 13. " FLOW_CONTROL_PROTOCOL_ERROR_SEVERITY ,Flow Control Protocol Error Severity" "0,1"
        textline "      "
        bitfld.long 0x00 14. " COMPLETION_TIMEOUT_SEVERITY ,Completion Timeout Severity" "0,1"
        textline "      "
        bitfld.long 0x00 15. " COMPLETER_ABORT_SEVERITY ,Completer Abort Severity" "0,1"
        textline "      "
        bitfld.long 0x00 16. " UNEXPECTED_COMPLETION_SEVERITY ,Unexpected Completion Severity" "0,1"
        textline "      "
        bitfld.long 0x00 17. " RECEIVER_OVERFLOW_SEVERITY ,Receiver Overflow Severity" "0,1"
        textline "      "
        bitfld.long 0x00 18. " MALFORMED_TLP_SEVERITY ,Malformed TLP Severity" "0,1"
        textline "      "
        bitfld.long 0x00 19. " ECRC_ERROR_SEVERITY ,ECRC Error Severity" "0,1"
        textline "      "
        bitfld.long 0x00 20. " UNSUPPORTED_REQUEST_ERROR_SEVERITY ,Unsupported Request Error Severity" "0,1"
width 5.
group.long 0x110++0x3
    line.long 0x00 "CESR,Correctable Error Status Register"
        bitfld.long 0x00 0. " RECEIVER_ERROR_STATUS ,Receiver Error Status" "0,1"
        textline "    "
        bitfld.long 0x00 6. " BAD_TLP_STATUS ,Bad TLP Status" "0,1"
        textline "    "
        bitfld.long 0x00 7. " BAD_DLLP_STATUS ,Bad DLLP Status" "0,1"
        textline "    "
        bitfld.long 0x00 8. " REPLAY_NUM_ROLLOVER_STATUS ,REPLAY_NUM Rollover Status" "0,1"
        textline "    "
        bitfld.long 0x00 12. " REPLY_TIMER_TIMEOUT_STATUS ,Reply Timer Timeout Status" "0,1"
        textline "    "
        bitfld.long 0x00 13. " ADVISORY_NON_FATAL_ERROR_STATUS ,Advisory Non-Fatal Error Status" "0,1"
width 5.
group.long 0x114++0x3
    line.long 0x00 "CEMR,Correctable Error Mask Register"
        bitfld.long 0x00 0. " RECEIVER_ERROR_MASK ,Receiver Error Mask" "0,1"
        textline "    "
        bitfld.long 0x00 6. " BAD_TLP_MASK ,Bad TLP Mask" "0,1"
        textline "    "
        bitfld.long 0x00 7. " BAD_DLLP_MASK ,Bad DLLP Mask" "0,1"
        textline "    "
        bitfld.long 0x00 8. " REPLAY_NUM_ROLLOVER_MASK ,REPLAY_NUM Rollover Mask" "0,1"
        textline "    "
        bitfld.long 0x00 12. " REPLY_TIMER_TIMEOUT_MASK ,Reply Timer Timeout Mask" "0,1"
        textline "    "
        bitfld.long 0x00 13. " ADVISORY_NON_FATAL_ERROR_MASK ,Advisory Non-Fatal Error Mask" "0,1"
width 5.
group.long 0x118++0x3
    line.long 0x00 "ACCR,Advanced Capabilities and Control Register"
        hexmask.long.byte 0x00 0.--5. 1. " FIRST_ERROR_POINTER ,First Error Pointer"
        textline "    "
        bitfld.long 0x00 5. " ECRC_GENERATION_CAPABILITY ,ECRC Generation Capability" "0,1"
        textline "    "
        bitfld.long 0x00 6. " ECRC_GENERATION_ENABLE ,ECRC Generation Enable" "0,1"
        textline "    "
        bitfld.long 0x00 7. " ECRC_CHECK_CAPABLE ,ECRC Check Capable" "0,1"
        textline "    "
        bitfld.long 0x00 8. " ECRC_CHECK_ENABLE ,ECRC Check Enable" "0,1"
width 4.
rgroup.long 0x11c++0x3
    line.long 0x00 "HLR,Header Log Register"
width 7.
rgroup.long 0x140++0x3
    line.long 0x00 "VCECHR,VC Extended Capability Header"
        hexmask.long.word 0x00 0.--16. 1. " EXTENDED_CAPABILITY ,PCI Express Extended Capability The default value is 0x2 for VC Capability."
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " CAPABILITY_VERSION ,Capability Version"
        textline "      "
        hexmask.long.word 0x00 20.--32. 1. " NEXT_CAPABILITY_OFFSET ,Next Capability Offset"
width 7.
rgroup.long 0x144++0x3
    line.long 0x00 "PVCCR1,Port VC Capability Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " EXTENDED_VC_COUNT ,Extended VC Count The default value is the one less than the number of VCs that"
        textline "      "
        hexmask.long.byte 0x00 4.--7. 1. " LOW_PRIORITY_EXTENDED_VC_COUNT ,Low Priority Extended VC Count, writable through the DBI"
        textline "      "
        hexmask.long.byte 0x00 8.--10. 1. " REFERENCE_CLOCK ,Reference Clock"
        textline "      "
        hexmask.long.byte 0x00 10.--12. 1. " PORT_ARBITRATION_TABLE_ENTRY_SIZE ,Port Arbitration Table Entry Size"
width 7.
rgroup.long 0x148++0x3
    line.long 0x00 "PVCCR2,Port VC Capability Register 2"
        hexmask.long.byte 0x00 0.--8. 1. " VC_ARBITRATION_CAPABILITY ,VC Arbitration Capability Indicates which VC arbitration mode(s) the device supports, writable through the DBI: Bit 0: Device supports hardware fixed arbitration scheme."
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " VC_ARBITRATION_TABLE_OFFSET ,VC Arbitration Table Offset (not supported) The default value is 0x00 (no arbitration table present)."
width 7.
group.long 0x14c++0x3
    line.long 0x00 "PVCCSR,Port VC Control and Status Register"
        bitfld.long 0x00 0. " LOAD_VC_ARBITRATION_TABLE ,Load VC Arbitration Table" "0,1"
        textline "      "
        hexmask.long.byte 0x00 1.--4. 1. " VC_ARBITRATION_SELECT ,VC Arbitration Select"
        textline "      "
        bitfld.long 0x00 16. " ARBITRATION_TABLE_STATUS ,Arbitration Table Status" "0,1"
width 6.
rgroup.long 0x150++0x3
    line.long 0x00 "VCRCR,VC Resource Capability Register n"
        hexmask.long.byte 0x00 0.--8. 1. " PORT_ARBITRATION_CAPABILITY ,Port Arbitration Capability"
        textline "     "
        bitfld.long 0x00 15. " REJECT_SNOOP_TRANSACTIONS ,Reject Snoop Transactions" "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--23. 1. " MAXIMUM_TIME_SLOTS ,Maximum Time Slots"
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " PORT_ARBITRATION_TABLE_OFFSET ,Port Arbitration Table Offset"
width 8.
group.long 0x154++0x3
    line.long 0x00 "VCRCONR,VC Resource Control Register n"
        hexmask.long.byte 0x00 0.--8. 1. " TC_VC_MAP ,TC/VC Map Bit 0 is hardwired to 1; bits 7:1 are RW."
        textline "       "
        bitfld.long 0x00 16. " LOAD_PORT_ARBITRATION_TABLE ,Load Port Arbitration Table" "0,1"
        textline "       "
        hexmask.long.byte 0x00 17.--20. 1. " PORT_ARBITRATION_SELECT ,Port Arbitration Select"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " VC_ID ,VC ID Hardwired to 0 for VC0."
        textline "       "
        bitfld.long 0x00 31. " VC_ENABLE ,VC Enable Hardwired to 1 for the first VC." "0,1"
width 6.
rgroup.long 0x158++0x3
    line.long 0x00 "VCRSR,VC Resource Status Register n"
        bitfld.long 0x00 16. " PORT_ARBITRATION_TABLE_STATUS ,Port Arbitration Table Status" "0,1"
        textline "     "
        bitfld.long 0x00 17. " VC_NEGOTIATION_PENDING ,VC Negotiation Pending" "0,1"


tree.end



;--------------------------------------------------------------------------------
; PCIE_PL
;--------------------------------------------------------------------------------
tree "PCIE_PL"
    base ad:0x01ffc000

width 7.
group.long 0x700++0x3
    line.long 0x00 "ALTRTR,Ack Latency Timer and Replay Timer Register"
        hexmask.long.word 0x00 0.--16. 1. " ROUND_TRIP_LATENCY_TIME_LIMIT ,Round Trip Latency Time Limit The Ack/Nak latency timer expires when it reaches this limit."
        textline "      "
        hexmask.long.word 0x00 16.--32. 1. " REPLAY_TIME_LIMIT ,Replay Time Limit The replay timer expires when it reaches this limit."
width 5.
group.long 0x704++0x3
    line.long 0x00 "VSDR,Vendor Specific DLLP Register"
        hexmask.long.long 0x00 0.--32. 1. " VENDOR_SPECIFIC_DLLP ,Vendor Specific DLLP Register Used to send a specific PCI Express DLLP."
width 5.
group.long 0x708++0x3
    line.long 0x00 "PFLR,Port Force Link Register"
        hexmask.long.byte 0x00 0.--8. 1. " LINK_NUMBER ,Link Number Not used for Endpoint"
        textline "    "
        bitfld.long 0x00 15. " FORCE_LINK ,Force Link Forces the Link to the state specified by the Link State field." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--22. 1. " LINK_STATE ,Link State The Link state that the core will be forced to when bit 15 (Force Link) is set."
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " LOW_POWER_ENTRANCE_COUNT ,Low Power Entrance Count The Power Management state will wait for this many clock cycles for the associated completion of a CfgWr to D-state register to go low-power."
width 7.
group.long 0x70c++0x3
    line.long 0x00 "AFLACR,Ack Frequency and L0-L1 ASPM Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " ACK_FREQUENCY ,Ack Frequency The core accumulates the number of pending Ack's specified here (up to 255) before sending an Ack DLLP see for more details."
        textline "      "
        hexmask.long.byte 0x00 8.--16. 1. " N_FTS ,N_FTS The number of Fast Training Sequence ordered sets to be transmitted when transitioning from L0s to L0."
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " COMMON_CLOCK_N_FTS ,Common Clock N_FTS This is the N_FTS when common clock is used."
        textline "      "
        hexmask.long.byte 0x00 24.--27. 1. " L0S_ENTRANCE_LATENCY ,L0s Entrance Latency Values correspond to:"
        textline "      "
        hexmask.long.byte 0x00 27.--30. 1. " L1_ENTRANCE_LATENCY ,L1 Entrance Latency Values correspond to:"
        textline "      "
        bitfld.long 0x00 30. " ENTER_ASPM_L1 ,Enter ASPM L1 without receive in L0s." "0,1"
width 5.
group.long 0x710++0x3
    line.long 0x00 "PLCR,Port Link Control Register"
        bitfld.long 0x00 0. " VENDOR_SPECIFIC_DLLP_REQUEST ,Vendor Specific DLLP Request When software writes a '1' to this bit, the core transmits the DLLP contained in the ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SCRAMBLE_DISABLE ,Scramble Disable Turns off data scrambling." "0,1"
        textline "    "
        bitfld.long 0x00 2. " LOOPBACK_ENABLE ,Loopback Enable Turns on loopback." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RESET_ASSERT ,Reset Assert Triggers a recovery and forces the LTSSM to the Hot Reset state (downstream port only)." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DLL_LINK_ENABLE ,DLL Link Enable Enables Link initialization." "0,1"
        textline "    "
        bitfld.long 0x00 7. " FAST_LINK_MODE ,Fast Link Mode Sets all internal timers to Fast Mode for speeding up simulation." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--22. 1. " LINK_MODE_ENABLE ,Link Mode Enable The default value is the number of Lanes supported in the version of the core you are using."
        textline "    "
        bitfld.long 0x00 22. " CROSSLINK_ENABLE ,Crosslink Enable" "0,1"
        textline "    "
        bitfld.long 0x00 23. " CROSSLINK_ACTIVE ,Crosslink Active." "0,1"
width 4.
group.long 0x714++0x3
    line.long 0x00 "LSR,Lane Skew Register"
        hexmask.long.long 0x00 0.--24. 1. " INSERT_LANE_SKEW_FOR_TRANSMIT ,Insert Lane Skew for Transmit (not supported for x16) Optional feature that causes the core to insert skew between Lanes for test purposes."
        textline "   "
        bitfld.long 0x00 24. " FLOW_CONTROL_DISABLE ,Flow Control Disable Prevents the core from sending FC DLLPs." "0,1"
        textline "   "
        bitfld.long 0x00 25. " ACK_NAK_DISABLE ,Ack/Nak Disable Prevents the core from sending Ack and Nak DLLPs." "0,1"
        textline "   "
        bitfld.long 0x00 31. " DISABLE_LANE_TO_LANE_DESKEW ,Disable Lane-to-Lane Deskew Causes the core to disable the internal Lane-to-Lane deskew logic." "0,1"
width 4.
group.long 0x718++0x3
    line.long 0x00 "SNR,Symbol Number Register"
        hexmask.long.byte 0x00 0.--4. 1. " NUMBER_OF_TS_SYMBOLS ,Number of TS Symbols Sets the number of TS identifier symbols that are sent in TS1 and TS2 ordered sets."
        textline "   "
        hexmask.long.byte 0x00 8.--11. 1. " NUMBER_OF_SKP_SYMBOLS ,Number of SKP Symbols"
        textline "   "
        hexmask.long.byte 0x00 14.--19. 1. " TIMER_MODIFIER_FOR_REPLAY_TIMER ,Timer Modifier for Replay Timer Increases the timer value for the replay timer, in increments of 64 clock cycles."
        textline "   "
        hexmask.long.byte 0x00 19.--24. 1. " TIMER_MODIFIER_FOR_ACK_NAK_LATENCY_TIMER ,Timer Modifier for Ack/Nak Latency Timer Increases the timer value for the Ack/Nak latency timer, in increments of 64 clock cycles."
        textline "   "
        hexmask.long.byte 0x00 24.--29. 1. " TIMER_MODIFIER_FOR_FLOW_CONTROL_WATCHDOG_TIMER ,Timer Modifier for Flow Control Watchdog Timer Increases the timer value for the Flow Control watchdog timer, in increments of 16 clock cycles."
        textline "   "
        hexmask.long.byte 0x00 29.--32. 1. " CONFIGURATION_REQUESTS ,Configuration Requests targeted at function numbers above this value will be returned with UR (unsupported request)."
width 7.
group.long 0x71c++0x3
    line.long 0x00 "STRFM1,Symbol Timer Register and Filter Mask Register 1"
        hexmask.long.word 0x00 0.--11. 1. " SKP_INTERVAL_VALUE ,SKP Interval Value The number of symbol times to wait between transmitting SKP ordered sets."
        textline "      "
        bitfld.long 0x00 15. " DISABLE_FC_WATCHDOG_TIMER ,Disable FC Watchdog Timer" "0,1"
        textline "      "
        hexmask.long.word 0x00 16.--32. 1. " MASK_RADM_FILTERING_AND_ERROR_HANDLING_RULES ,Mask RADM Filtering and Error Handling Rules: Mask 1 There are several mask bits to turn off the filtering and error handling rules In each case, 0 applies the associated filtering rule and 1 masks the associated filtering rule."
width 7.
group.long 0x720++0x3
    line.long 0x00 "STRFM2,Filter Mask Register 2"
        hexmask.long.long 0x00 0.--32. 1. " MASK_RADM_FILTERING_AND_ERROR_HANDLING_RULES ,Mask RADM Filtering and Error Handling Rules: Mask 2 It defaults to 0x0 There are several mask bits used to turn off the filtering and error handling rules ."
width 9.
group.long 0x724++0x3
    line.long 0x00 "AMODNPSR,AMBA Multiple Outbound Decomposed NP Sub-Requests Control Register"
        bitfld.long 0x00 0. " ENABLE_AMBA_MULTIPLE_OUTBOUND_DECOMPOSED_NP_SUBREQUESTS ,Enable AMBA Multiple Outbound Decomposed NP Sub- Requests." "0,1"
width 7.
rgroup.long 0x728++0x3
    line.long 0x00 "DEBUG0,Debug Register 0"
        hexmask.long.long 0x00 0.--32. 1. " VALUE ,The value on cxpl_debug_info[31:0]."
width 7.
rgroup.long 0x72c++0x3
    line.long 0x00 "DEBUG1,Debug Register 1"
        hexmask.long.long 0x00 0.--32. 1. " VALUE ,The value on cxpl_debug_info[63:32]."
width 7.
rgroup.long 0x730++0x3
    line.long 0x00 "TPFCSR,Transmit Posted FC Credit Status Register"
        hexmask.long.word 0x00 0.--12. 1. " TRANSMIT_POSTED_DATA_FC_CREDITS ,Transmit Posted Data FC Credits The Posted Data credits advertised by the receiver at the other end of the Link, updated with each UpdateFC DLLP."
        textline "      "
        hexmask.long.byte 0x00 12.--20. 1. " TRANSMIT_POSTED_HEADER_FC_CREDITS ,Transmit Posted Header FC Credits The Posted Header credits advertised by the receiver at the other end of the Link, updated with each UpdateFC DLLP."
width 7.
rgroup.long 0x734++0x3
    line.long 0x00 "TNFCSR,Transmit Non-Posted FC Credit Status Register"
        hexmask.long.word 0x00 0.--12. 1. " TRANSMIT_NON_POSTED_DATA_FC_CREDITS ,Transmit Non-Posted Data FC Credits The Non-Posted Data credits advertised by the receiver at the other end of the Link, updated with each UpdateFC DLLP."
        textline "      "
        hexmask.long.byte 0x00 12.--20. 1. " TRANSMIT_NON_POSTED_HEADER_FC_CREDITS ,Transmit Non-Posted Header FC Credits The Non-Posted Header credits advertised by the receiver at the other end of the Link, updated with each UpdateFC DLLP."
width 7.
rgroup.long 0x738++0x3
    line.long 0x00 "TCFCSR,Transmit Completion FC Credit Status Register"
        hexmask.long.word 0x00 0.--12. 1. " TRANSMIT_COMPLETION_DATA_FC_CREDITS ,Transmit Completion Data FC Credits The Completion Data credits advertised by the receiver at the other end of the Link, updated with each UpdateFC DLLP."
        textline "      "
        hexmask.long.byte 0x00 12.--20. 1. " TRANSMIT_COMPLETION_HEADER_FC_CREDITS ,Transmit Completion Header FC Credits The Completion Header credits advertised by the receiver at the other end of the Link, updated with each UpdateFC DLLP."
width 4.
rgroup.long 0x73c++0x3
    line.long 0x00 "QSR,Queue Status Register"
        bitfld.long 0x00 0. " RECEIVED_TLP_FC_CREDITS_NOT_RETURNED ,Received TLP FC Credits Not Returned Indicates that the core has sent a TLP but has not yet received an UpdateFC DLLP indicating that the credits for that TLP have been restored by the receiver at the other end of the Link." "0,1"
        textline "   "
        bitfld.long 0x00 1. " TRANSMIT_RETRY_BUFFER_NOT_EMPTY ,Transmit Retry Buffer Not Empty Indicates that there is data in the transmit retry buffer." "0,1"
        textline "   "
        bitfld.long 0x00 2. " RECEIVED_QUEUE_NOT_EMPTY ,Received Queue Not Empty Indicates there is data in one or more of the receive buffers." "0,1"
width 7.
rgroup.long 0x740++0x3
    line.long 0x00 "VCTAR1,VC Transmit Arbitration Register 1"
        hexmask.long.byte 0x00 0.--8. 1. " WRR_WEIGHT_FOR_VC0 ,WRR Weight for VC0"
        textline "      "
        hexmask.long.byte 0x00 8.--16. 1. " WRR_WEIGHT_FOR_VC1 ,WRR Weight for VC1"
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " WRR_WEIGHT_FOR_VC2 ,WRR Weight for VC2"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " WRR_WEIGHT_FOR_VC3 ,WRR Weight for VC3"
width 7.
rgroup.long 0x744++0x3
    line.long 0x00 "VCTAR2,VC Transmit Arbitration Register 2"
        hexmask.long.byte 0x00 0.--8. 1. " WRR_WEIGHT_FOR_VC4 ,WRR Weight for VC4"
        textline "      "
        hexmask.long.byte 0x00 8.--16. 1. " WRR_WEIGHT_FOR_VC5 ,WRR Weight for VC5"
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " WRR_WEIGHT_FOR_VC6 ,WRR Weight for VC6"
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " WRR_WEIGHT_FOR_VC7 ,WRR Weight for VC7"
width 8.
group.long 0x748++0x3
    line.long 0x00 "VC0PRQC,VC0 Posted Receive Queue Control"
        hexmask.long.word 0x00 0.--12. 1. " VC0_POSTED_DATA_CREDITS ,VC0 Posted Data Credits The number of initial Posted data credits for VC0, used for all receive queue buffer configurations."
        textline "       "
        hexmask.long.byte 0x00 12.--20. 1. " VC0_POSTED_HEADER_CREDITS ,VC0 Posted Header Credits The number of initial Posted header credits for VC0, used for all receive queue buffer configurations."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " VC0_POSTED_TLP_QUEUE_MODE ,VC0 Posted TLP Queue Mode The operating mode of the Posted receive queue for VC0, used only in the segmented-buffer configuration, writable through the DBI."
        textline "       "
        bitfld.long 0x00 30. " TLP_TYPE_ORDERING_FOR_VC0 ,TLP Type Ordering for VC0 Determines the TLP type ordering rule for VC0 receive queues, used only in the segmented-buffer configuration, writable through the DBI:" "0,1"
        textline "       "
        bitfld.long 0x00 31. " VC_ORDERING_FOR_RECEIVE_QUEUES ,VC Ordering for Receive Queues Determines the VC ordering rule for the receive queues, used only in the segmented-buffer configuration, writable through the DBI:" "0,1"
width 8.
group.long 0x74c++0x3
    line.long 0x00 "VC0NRQC,VC0 Non-Posted Receive Queue Control"
        hexmask.long.word 0x00 0.--12. 1. " VC0_NON_POSTED_DATA_CREDITS ,VC0 Non-Posted Data Credits The number of initial Non-Posted data credits for VC0, used for all receive queue buffer configurations."
        textline "       "
        hexmask.long.byte 0x00 12.--20. 1. " VC0_NON_POSTED_HEADER_CREDITS ,VC0 Non-Posted Header Credits The number of initial Non-Posted header credits for VC0, used for all receive queue buffer configurations."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " VC0_NON_POSTED_TLP_QUEUE_MODE ,VC0 Non-Posted TLP Queue Mode The operating mode of the Non-Posted receive queue for VC0, used only in the segmented-buffer configuration, writable through the DBI."
width 8.
group.long 0x750++0x3
    line.long 0x00 "VC0CRQC,VC0 Completion Receive Queue Control"
        hexmask.long.word 0x00 0.--12. 1. " VC0_COMPLETION_DATA_CREDITS ,VC0 Completion Data Credits The number of initial Completion data credits for VC0, used for all receive queue buffer configurations."
        textline "       "
        hexmask.long.byte 0x00 12.--20. 1. " VC0_COMPLETION_HEADER_CREDITS ,VC0 Completion Header Credits The number of initial Completion header credits for VC0, used for all receive queue buffer configurations."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " VC0_COMPLETION_TLP_QUEUE_MODE ,VC0 Completion TLP Queue Mode The operating mode of the Completion receive queue for VC0, used only in the segmented-buffer configuration, writable through the DBI."
width 8.
group.long 0x754++0x3
    line.long 0x00 "VCNPRQC,VCn Posted Receive Queue Control"
        hexmask.long.word 0x00 0.--12. 1. " VC1_POSTED_DATA_CREDITS ,VC1 Posted Data Credits The number of initial Posted data credits for VC1, used for all receive queue buffer configurations."
        textline "       "
        hexmask.long.byte 0x00 12.--20. 1. " VC1_POSTED_HEADER_CREDITS ,VC1 Posted Header Credits The number of initial Posted header credits for VC1, used for all receive queue buffer configurations."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " VC1_POSTED_TLP_QUEUE_MODE ,VC1 Posted TLP Queue Mode The operating mode of the Posted receive queue for VC1, used only in the segmented-buffer configuration, writable through the DBI."
        textline "       "
        bitfld.long 0x00 30. " TLP_TYPE_ORDERING_FOR_VC1 ,TLP Type Ordering for VC1 Determines the TLP type ordering rule for VC1 receive queues, used only in the segmented-buffer configuration, writable through the DBI: 1: Ordering of received TLPs follows the rules in PCI Express Base 3.0 Specification 0: Strict ordering for received TLPs: Posted, then Completion, then Non-Posted" "0,1"
width 8.
group.long 0x758++0x3
    line.long 0x00 "VCNNRQC,VCn Non-Posted Receive Queue Control"
        hexmask.long.word 0x00 0.--12. 1. " VC1_NON_POSTED_DATA_CREDITS ,VC1 Non-Posted Data Credits The number of initial Non-Posted data credits for VC1, used for all receive queue buffer configurations."
        textline "       "
        hexmask.long.byte 0x00 12.--20. 1. " VC1_NON_POSTED_HEADER_CREDITS ,VC1 Non-Posted Header Credits The number of initial Non-Posted header credits for VC1, used for all receive queue buffer configurations."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " VC1_NON_POSTED_TLP_QUEUE_MODE ,VC1 Non-Posted TLP Queue Mode The operating mode of the Non-Posted receive queue for VC1, used only in the segmented-buffer configuration, writable through the DBI."
width 8.
group.long 0x75c++0x3
    line.long 0x00 "VCNCRQC,VCn Completion Receive Queue Control"
        hexmask.long.word 0x00 0.--12. 1. " VC1_COMPLETION_DATA_CREDITS ,VC1 Completion Data Credits The number of initial Completion data credits for VC1, used for all receive queue buffer configurations."
        textline "       "
        hexmask.long.byte 0x00 12.--20. 1. " VC1_COMPLETION_HEADER_CREDITS ,VC1 Completion Header Credits The number of initial Completion header credits for VC1, used for all receive queue buffer configurations."
        textline "       "
        hexmask.long.byte 0x00 21.--24. 1. " VC1_COMPLETION_TLP_QUEUE_MODE ,VC1 Completion TLP Queue Mode The operating mode of the Completion receive queue for VC1, used only in the segmented-buffer configuration, writable through the DBI."
width 7.
rgroup.long 0x7a8++0x3
    line.long 0x00 "VC0PBD,VC0 Posted Buffer Depth"
        hexmask.long.word 0x00 0.--14. 1. " VC0_POSTED_DATA_QUEUE_DEPTH ,VC0 Posted Data Queue Depth Sets the number of entries in the Posted data queue for VC0 when using the segmented-buffer configuration.Not writable through the DBI"
        textline "      "
        hexmask.long.word 0x00 16.--26. 1. " VC0_POSTED_HEADER_QUEUE_DEPTH ,VC0 Posted Header Queue Depth Sets the number of entries in the Posted header queue for VC0 when using the segmented-buffer configuration.Not writable through the DBI"
width 8.
rgroup.long 0x7ac++0x3
    line.long 0x00 "VC0NPBD,VC0 Non-Posted Buffer Depth"
        hexmask.long.word 0x00 0.--14. 1. " VC0_NON_POSTED_DATA_QUEUE_DEPTH ,VC0 Non-Posted Data Queue Depth Sets the number of entries in the Non-Posted data queue for VC0 when using the segmented-buffer configuration."
        textline "       "
        hexmask.long.word 0x00 16.--26. 1. " VC0_NON_POSTED_HEADER_QUEUE_DEPTH ,VC0 Non-Posted Header Queue Depth Sets the number of entries in the Non-Posted header queue for VC0 when using the segmented-buffer configuration.Not writable through the DBI"
width 7.
rgroup.long 0x7b0++0x3
    line.long 0x00 "VC0CBD,VC0 Completion Buffer Depth"
        hexmask.long.word 0x00 0.--14. 1. " VC0_COMPLETION_DATA_QUEUE_DEPTH ,VC0 Completion Data Queue Depth Sets the number of entries in the Completion data queue for VC0 when using the segmented-buffer configuration."
        textline "      "
        hexmask.long.word 0x00 16.--26. 1. " VC0_POSTED_HEADER_QUEUE_DEPTH ,VC0 Posted Header Queue Depth Sets the number of entries in the Completion header queue for VC0 when using the segmented-buffer configuration.Not writable through the DBI"
width 7.
rgroup.long 0x7b4++0x3
    line.long 0x00 "VC1PBD,VCn Posted Buffer Depth"
        hexmask.long.word 0x00 0.--14. 1. " VC1_POSTED_DATA_QUEUE_DEPTH ,VC1 Posted Data Queue Depth Sets the number of entries in the Posted data queue for VC1 when using the segmented-buffer configuration.Not writable through the DBI"
        textline "      "
        hexmask.long.word 0x00 16.--26. 1. " VC1_POSTED_HEADER_QUEUE_DEPTH ,VC1 Posted Header Queue Depth Sets the number of entries in the Posted header queue for VC1 when using the segmented-buffer configuration.Not writable through the DBI"
width 8.
rgroup.long 0x7b8++0x3
    line.long 0x00 "VC1NPBD,VCn Non-Posted Buffer Depth"
        hexmask.long.word 0x00 0.--14. 1. " VC1_NON_POSTED_DATA_QUEUE_DEPTH ,VC1 Non-Posted Data Queue Depth Sets the number of entries in the Non-Posted data queue for VC1 when using the segmented-buffer configuration."
        textline "       "
        hexmask.long.word 0x00 16.--26. 1. " VC1_NON_POSTED_HEADER_QUEUE_DEPTH ,VC1 Non-Posted Header Queue Depth Sets the number of entries in the Non-Posted header queue for VC1 when using the segmented-buffer configuration."
width 7.
rgroup.long 0x7bc++0x3
    line.long 0x00 "VC1CBD,VCnCompletion Buffer Depth"
        hexmask.long.word 0x00 0.--14. 1. " VC1_COMPLETION_DATA_QUEUE_DEPTH ,VC1 Completion Data Queue Depth Sets the number of entries in the Completion data queue for VC1 when using the segmented-buffer configuration."
        textline "      "
        hexmask.long.word 0x00 16.--26. 1. " VC1_POSTED_HEADER_QUEUE_DEPTH ,VC1 Posted Header Queue Depth Sets the number of entries in the Completion header queue for VC1 when using the segmented-buffer configuration."
width 5.
group.long 0x80c++0x3
    line.long 0x00 "G2CR,Gen2 Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " N_FTS ,Sets the Number of Fast Training Sequences (N_FTS) that the core advertises as its N_FTS during Gen2 Link training."
        textline "    "
        hexmask.long.word 0x00 8.--17. 1. " PREDETERMINED_NUMBER_OF_LANES ,Predetermined Number of Lanes Used to limit the effective link width to ignore ""broken"" lanes that detect a receiver."
        textline "    "
        bitfld.long 0x00 17. " DIRECTED_SPEED_CHANGE ,Directed Speed Change Indicates to the LTSSM whether or not to initiate a speed change to Gen2" "0,1"
        textline "    "
        bitfld.long 0x00 18. " CONFIG_PHY_TX_SWING ,Config PHY Tx Swing Indicates the voltage level the PHY should drive." "0,1"
        textline "    "
        bitfld.long 0x00 19. " CONFIG_TX_COMPLIANCE_RECEIVE_BIT ,Config Tx Compliance Receive Bit When set to 1, signals LTSSM to transmit TS ordered sets with the compliance receive bit assert (equal to 1)." "0,1"
        textline "    "
        bitfld.long 0x00 20. " DE_EMPHASIS_LEVEL ,Used to set the de-emphasis level for upstream ports." "0,1"
width 11.
rgroup.long 0x810++0x3
    line.long 0x00 "PHY_STATUS,PHY Status"
        hexmask.long.long 0x00 0.--32. 1. " PHY_STATUS ,PHY Status Data received directly from the phy_cfg_status bus."
width 9.
group.long 0x814++0x3
    line.long 0x00 "PHY_CTRL,PHY Control"
        hexmask.long.long 0x00 0.--32. 1. " PHY_CONTROL ,PHY Control Data sent directly to the cfg_phy_control bus."
width 7.
group.long 0x818++0x3
    line.long 0x00 "MRCCR0,Master Response Composer Control Register 0"
        hexmask.long.byte 0x00 0.--3. 1. " REMOTE_READ_REQUEST_SIZE ,Remote Read Request Size Specifies the largest amount of data (bytes) that will ever be requested (via an inbound MemRd TLP) by a remote device."
        textline "      "
        hexmask.long.byte 0x00 8.--16. 1. " REMOTE_MAX_BRIDGE_TAG ,Remote Max Bridge Tag Specifies the maximum number (-1) of Non-Posted AMBA requests outstanding at one time issued from the bridge master."
width 7.
group.long 0x81c++0x3
    line.long 0x00 "MRCCR1,Master Response Composer Control Register 1"
        bitfld.long 0x00 0. " SEGMENTED_BUFFER_CONTROLLER_INITIALIZE ,Segmented Buffer Controller Initialize." "0,1"
width 6.
group.long 0x820++0x3
    line.long 0x00 "MSICA,MSI Controller Address"
        hexmask.long.long 0x00 0.--32. 1. " MSI_CONTROLLER_ADDRESS ,MSI Controller Address System specified address for MSI memory write transaction termination."
width 7.
group.long 0x824++0x3
    line.long 0x00 "MSICUA,MSI Controller Upper Address"
        hexmask.long.long 0x00 0.--32. 1. " MSI_CONTROLLER_UPPER_ADDRESS ,MSI Controller Upper Address System specified upper address for MSI memory write transaction termination."
width 11.
group.long 0x828++0x3
    line.long 0x00 "MSICIN_ENB,MSI Controller Interrupt n Enable"
        hexmask.long.long 0x00 0.--32. 1. " MSI_INTERRUPT0_ENABLE ,MSI Interrupt#0 Enable Specifies which interrupts are enabled."
width 12.
group.long 0x82c++0x3
    line.long 0x00 "MSICIN_MASK,MSI Controller Interrupt n Mask"
        hexmask.long.long 0x00 0.--32. 1. " MSI_INTERRUPT0_MASK ,MSI Interrupt#0 Mask Allows enabled interrupts to be masked."
width 14.
group.long 0x830++0x3
    line.long 0x00 "MSICIN_STATUS,MSI Controller Interrupt nStatus"
        hexmask.long.long 0x00 0.--32. 1. " MSI_INTERRUPT0_STATUS ,MSI Interrupt#0 Status If an MSI is detected for EP#0, one bit in this register is set."
width 9.
group.long 0x888++0x3
    line.long 0x00 "MSICGPIO,MSI Controller General Purpose IO Register"
        hexmask.long.long 0x00 0.--32. 1. " MSI_GPIO_REGISTER ,MSI GPIO Register The contents of this register drives the top-level output msi_ctrl_io[31:0]"
width 7.
group.long 0x900++0x3
    line.long 0x00 "IATUVR,iATU Viewport Register"
        hexmask.long.byte 0x00 0.--4. 1. " REGION_INDEX ,Region Index Defines which region is being accessed when writing to the control, base, limit and target registers."
        textline "      "
        bitfld.long 0x00 31. " REGION_DIRECTION ,Region Direction Defines the region being accessed as either" "0,1"
width 8.
group.long 0x904++0x3
    line.long 0x00 "IATURC1,iATU Region Control 1 Register"
        hexmask.long.byte 0x00 0.--5. 1. " TYPE ,TYPE Outbound : When the address of an outbound TLP is matched to this region, then the TYPE field of the TLP is changed to the value in this register."
        textline "       "
        hexmask.long.byte 0x00 5.--8. 1. " TC ,TC Outbound : When the address of an outbound TLP is matched to this region, then the TC field of the TLP is changed to the value in this register."
        textline "       "
        bitfld.long 0x00 8. " TD ,TD Outbound : When the address of an outbound TLP is matched to this region, then the TD field of the TLP is changed to the value in this register." "0,1"
        textline "       "
        hexmask.long.byte 0x00 9.--11. 1. " ATTR ,ATTR Outbound : When the address of an outbound TLP is matched to this region, then the ATTR field of the TLP is changed to the value in this register."
        textline "       "
        hexmask.long.byte 0x00 16.--18. 1. " AT ,AT NA"
        textline "       "
        hexmask.long.byte 0x00 20.--23. 1. " FUNCTION_NUMBER ,Function Number Outbound : When the address of an outbound TLP is matched to this region, then the function number used in generating the 'Function' part of the Requester ID (RID) field of the TLP is taken from this 3-bit register."
width 8.
group.long 0x908++0x3
    line.long 0x00 "IATURC2,iATU Region Control 2 Register"
        hexmask.long.byte 0x00 0.--8. 1. " MESSAGE_CODE ,Message Code Outbound : When the address of an outbound TLP is matched to this region, and the translated TLP TYPE field is Msg or MsgD; then the Message field of the TLP is changed to the value in this register."
        textline "       "
        hexmask.long.byte 0x00 8.--11. 1. " BAR_NUMBER ,BAR Number Outbound : Not used."
        textline "       "
        bitfld.long 0x00 14. " TC_MATCH_ENABLE ,TC Match Enable Outbound : Not used." "0,1"
        textline "       "
        bitfld.long 0x00 15. " TD_MATCH_ENABLE ,TD Match Enable Outbound : Not used." "0,1"
        textline "       "
        bitfld.long 0x00 16. " ATTR_MATCH_ENABLE ,ATTR Match Enable Outbound : Not used." "0,1"
        textline "       "
        bitfld.long 0x00 18. " AT_MATCH_ENABLE ,AT Match Enable Outbound : Not used." "0,1"
        textline "       "
        bitfld.long 0x00 19. " FUNCTION_NUMBER_MATCH_ENABLE ,Function Number Match Enable Outbound : Not used." "0,1"
        textline "       "
        bitfld.long 0x00 20. " VIRTUAL_FUNCTION_NUMBER_MATCH_ENABLE ,Virtual Function Number Match Enable Outbound : Not used." "0,1"
        textline "       "
        bitfld.long 0x00 21. " MESSAGE_CODE_MATCH_ENABLE ,Message Code Match Enable Outbound : Not used." "0,1"
        textline "       "
        hexmask.long.byte 0x00 24.--26. 1. " RESPONSE_CODE ,Response Code Outbound : Not used."
        textline "       "
        bitfld.long 0x00 27. " FUZZY_TYPE_MATCH_MODE ,Fuzzy Type Match Mode Outbound : Not used." "0,1"
        textline "       "
        bitfld.long 0x00 28. " CFG_SHIFT_MODE ,CFG Shift Mode This is useful for CFG transactions where the PCIe configuration mechanism maps bits [27:12] of the address to the bus/device and function number." "0,1"
        textline "       "
        bitfld.long 0x00 29. " INVERT_MODE ,Invert Mode Outbound / Inbound : When set the address matching region is inverted." "0,1"
        textline "       "
        bitfld.long 0x00 30. " MATCH_MODE ,Match Mode Outbound : Not used." "0,1"
        textline "       "
        bitfld.long 0x00 31. " REGION_ENABLE ,Region Enable Outbound / Inbound : This bit must be set to '1' for address translation to take place." "0,1"
width 9.
group.long 0x90c++0x3
    line.long 0x00 "IATURLBA,iATU Region Lower Base Address Register"
        hexmask.long.word 0x00 0.--16. 1. " ADDRESS_LOWER ,Forms bits [15:0] of the start address of the address region to be translated."
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " ADDRESS_UPPER ,Forms bits [31:16] of the start address of the address region to be translated."
width 9.
group.long 0x910++0x3
    line.long 0x00 "IATURUBA,iATU Region Upper Base Address Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDRESS ,Outbound / Inbound : Forms bits [63:32] of the start (and end) address of the address region to be translated."
width 8.
group.long 0x914++0x3
    line.long 0x00 "IATURLA,iATU Region Limit Address Register"
        hexmask.long.word 0x00 0.--16. 1. " ADDRESS_LOWER ,Forms bits [15:0] of the end address of the address region to be translated."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " ADDRESS_UPPER ,Forms bits [31:16] of the end address of the address region to be translated."
width 9.
group.long 0x918++0x3
    line.long 0x00 "IATURLTA,iATU Region Lower Target Address Register"
        hexmask.long.word 0x00 0.--16. 1. " ADDRESS_LOWER ,Forms bits [15:0] of the start address of the new address of the translated region."
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " ADDRESS_UPPER ,Forms bits [31:16] of the of the new address of the translated region."
width 9.
group.long 0x91c++0x3
    line.long 0x00 "IATURUTA,iATU Region Upper Target Address Register"
        hexmask.long.long 0x00 0.--32. 1. " ADDRESS ,Outbound / Inbound : Forms bits [63:32] of the start address of the new address of the translated region."


tree.end



;--------------------------------------------------------------------------------
; PCIE_RC
;--------------------------------------------------------------------------------
tree "PCIE_RC"
    base ad:0x01ffc000

width 9.
rgroup.long 0x0++0x3
    line.long 0x00 "DEVICEID,Device ID and Vendor ID Register"
width 8.
group.long 0x4++0x3
    line.long 0x00 "COMMAND,Command and Status Register"
        bitfld.long 0x00 0. " I_O_SPACE_ENABLE ,I/O Space Enable" "0,1"
        textline "       "
        bitfld.long 0x00 1. " MEMORY_SPACE_ENABLE ,Memory Space Enable" "0,1"
        textline "       "
        bitfld.long 0x00 2. " BUS_MASTER_ENABLE ,Bus Master Enable" "0,1"
        textline "       "
        bitfld.long 0x00 3. " SPECIAL_CYCLE_ENABLE ,Special Cycle Enable Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 4. " MEMORY_WRITE_AND_INVALIDATE ,Memory Write and Invalidate Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 5. " VGA_PALETTE_SNOOP ,VGA Palette Snoop Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 6. " PARITY_ERROR_RESPONSE ,Parity Error Response" "0,1"
        textline "       "
        bitfld.long 0x00 7. " IDSEL_STEPPING ,IDSEL Stepping/Wait Cycle Control Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 8. " SERR_ENABLE ,SERR# Enable" "0,1"
        textline "       "
        bitfld.long 0x00 9. " FAST_BACK_TO_BACK_ENABLE ,Fast Back-to-Back Enable Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 10. " INTX_ASSERTION_DISABLE ,INTx Assertion Disable" "0,1"
        textline "       "
        bitfld.long 0x00 19. " INTX_STATUS ,INTx Status" "0,1"
        textline "       "
        bitfld.long 0x00 20. " CAPABILITIES_LIST ,Capabilities List Indicates presence of an extended capability item." "0,1"
        textline "       "
        bitfld.long 0x00 21. " SIXTYSIX_MHZ_CAPABLE ,66 MHz Capable Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 23. " FAST_BACK_TO_BACK_CAPABLE ,Fast Back-to-Back Capable Not applicable for PCI Express." "0,1"
        textline "       "
        bitfld.long 0x00 24. " MASTER_DATA_PARITY_ERROR ,Master Data Parity Error" "0,1"
        textline "       "
        hexmask.long.byte 0x00 25.--27. 1. " DEVSEL_TIMING ,DEVSEL Timing Not applicable for PCI Express."
        textline "       "
        bitfld.long 0x00 27. " SIGNALED_TARGET_ABORT ,Signaled Target Abort" "0,1"
        textline "       "
        bitfld.long 0x00 28. " RECEIVED_TARGET_ABORT ,Received Target Abort" "0,1"
        textline "       "
        bitfld.long 0x00 29. " RECEIVED_MASTER_ABORT ,Received Master Abort" "0,1"
        textline "       "
        bitfld.long 0x00 30. " DETECTED_PARITY_ERROR ,Detected Parity Error" "0,1"
        textline "       "
        bitfld.long 0x00 31. " SIGNALED_SYSTEM_ERROR ,Signaled System Error" "0,1"
width 6.
rgroup.long 0x8++0x3
    line.long 0x00 "REVID,Revision ID and Class Code Register"
        hexmask.long.byte 0x00 0.--8. 1. " CX_REVISION_ID_N ,Revision ID, writable through the DBI"
        textline "     "
        hexmask.long.byte 0x00 8.--16. 1. " IF_CODE_N ,Programming Interface, writable through the DBI"
        textline "     "
        hexmask.long.byte 0x00 16.--24. 1. " SUB_CLASS_CODE_N ,Subclass Code, writable through the DBI"
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " BASE_CLASS_CODE_N ,Base Class Code, writable through the DBI"
width 5.
group.long 0xc++0x3
    line.long 0x00 "BIST,BIST Register"
        hexmask.long.byte 0x00 0.--8. 1. " CACHE_LINE_SIZE ,Cache Line Size The Cache Line Size register is RW for legacy compatibility purposes and is not applicable to PCI Express device functionality."
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " MASTER_LATENCY_TIMER ,Master Latency Timer Not applicable for PCI Express, hardwired to 0."
        textline "    "
        hexmask.long.byte 0x00 16.--23. 1. " CONFIGURATION_HEADER_FORMAT ,Configuration Header Format Hardwired to 0 for type 0."
        textline "    "
        bitfld.long 0x00 23. " MULTI_FUNCTION_DEVICE ,Multi Function Device The default value is 0 for a single function device (`CX_NFUNC = 1) or 1 for a multi-function device (`CX_NFUNC != 1)." "0,1"
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " NOT_SUPPORTED_BY__CORE ,The BIST register functions are not supported by the core."
width 5.
rgroup.long 0x10++0x3
    line.long 0x00 "BAR0,Base Address 0"
        bitfld.long 0x00 0. " MEM_I_O ,Bits [3:0] are writable through the DBI." "0,1"
        textline "    "
        hexmask.long.byte 0x00 1.--3. 1. " TYPE ,If BAR 0 is an I/O BAR, bit 2 the least significant bit of the base address and bit 1 is 0."
        textline "    "
        bitfld.long 0x00 3. " PREF ,If BAR 0 is an I/O BAR, bit 3 is the second least significant bit of the base address." "0,1"
        textline "    "
        hexmask.long.long 0x00 4.--32. 1. " ADDRESS ,BAR 0 base address bits (for a 64-bit BAR, the remaining upper address bits are in BAR 1)."
width 5.
rgroup.long 0x14++0x3
    line.long 0x00 "BAR1,Base Address 1"
        hexmask.long.long 0x00 0.--32. 1. " ADDRESS ,BAR 1 contains the upper 32 bits of the BAR 0 base address (bits [63:32])."
width 4.
rgroup.long 0x18++0x3
    line.long 0x00 "BNR,Bus Number Registers"
        hexmask.long.byte 0x00 0.--8. 1. " PRIMARY_BUS_NUM ,Primary bus number."
        textline "   "
        hexmask.long.byte 0x00 8.--16. 1. " SECONDARY_BUS_NUM ,Secondary bus number."
        textline "   "
        hexmask.long.byte 0x00 16.--24. 1. " SUBORD_BUS_NUM ,Subordinate bus number."
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " SECONDARY_LAT_TMR ,Secondary latency timer."
width 8.
group.long 0x1c++0x3
    line.long 0x00 "IOBLSSR,I/O Base Limit Secondary Status Register"
        hexmask.long.byte 0x00 4.--8. 1. " IO_SB ,I/O Space Base."
        textline "       "
        hexmask.long.byte 0x00 12.--16. 1. " IO_SL ,I/O Space Limit."
        textline "       "
        bitfld.long 0x00 21. " _66M_CAP ,66 MHz Capable." "0,1"
        textline "       "
        bitfld.long 0x00 23. " FAST_B2B_CAP ,Reserved." "0,1"
        textline "       "
        bitfld.long 0x00 24. " MSTR_DAT_PARITY_ERR ,Master Data Parity Error." "0,1"
        textline "       "
        bitfld.long 0x00 27. " SIG_TARGET_ABORT ,Signaled Target Abort." "0,1"
        textline "       "
        bitfld.long 0x00 28. " RX_TARGET_ABORT ,Received Target Abort." "0,1"
        textline "       "
        bitfld.long 0x00 29. " RX_MASTER_ABORT ,Received Master Abort." "0,1"
        textline "       "
        bitfld.long 0x00 30. " RX_SYS_ERR ,Received System Error." "0,1"
        textline "       "
        bitfld.long 0x00 31. " DET_PARITY_ERR ,Detected Parity Error." "0,1"
width 8.
group.long 0x20++0x3
    line.long 0x00 "MEM_BLR,Memory Base and Memory Limit Register"
        hexmask.long.byte 0x00 8.--16. 1. " MEM_BASE_ADD ,Memory Base Address."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MEM_LIM_ADD ,Memory Limit Address."
width 13.
group.long 0x24++0x3
    line.long 0x00 "PREF_MEM_BLR,Prefetchable Memory Base and Limit Register"
        hexmask.long.word 0x00 4.--16. 1. " UPPER12_START_ADD ,Upper 12 bits of 32-bit Prefetchable Memory Start Address."
        textline "            "
        hexmask.long.word 0x00 20.--32. 1. " UPPER12_END_ADD ,Upper 12 bits of 32-bit Prefetchable Memory End Address."
width 14.
group.long 0x28++0x3
    line.long 0x00 "PREF_BASE_U32,Prefetchable Base Upper 32 Bits Register"
        hexmask.long.long 0x00 0.--32. 1. " UPPER32_BASE_PREF_MEM_ADD ,Upper 32 Bits of Base Address of Prefetchable Memory Space."
width 13.
group.long 0x2c++0x3
    line.long 0x00 "PREF_LIM_U32,Prefetchable Limit Upper 32 Bits Register"
        hexmask.long.long 0x00 0.--32. 1. " UPPER32_LIM_PREF_MEM_ADD ,Upper 32 Bits of Limit Address of Prefetchable Memory Space."
width 16.
group.long 0x30++0x3
    line.long 0x00 "IO_BASE_LIM_U16,I/O Base and Limit Upper 16 Bits Register"
        hexmask.long.word 0x00 0.--16. 1. " UPPER16_IO_BASE ,Upper 16 Bits of I/O Base (if 32-bit I/O decoding is supported for devices on the secondary side)."
        textline "               "
        hexmask.long.word 0x00 16.--32. 1. " UPPER16_IO_LIM ,Upper 16 Bits of I/O Limit (if 32-bit I/O decoding is supported for devices on the secondary side)."
width 6.
rgroup.long 0x34++0x3
    line.long 0x00 "CAPPR,Capability Pointer Register"
        hexmask.long.byte 0x00 0.--8. 1. " CFG_NEXT_PTR ,First Capability Pointer."
width 8.
group.long 0x38++0x3
    line.long 0x00 "EROMBAR,Expansion ROM Base Address Register"
        bitfld.long 0x00 0. " ENABLE ,Expansion ROM Enable" "0,1"
        textline "       "
        hexmask.long.long 0x00 11.--32. 1. " ADDRESS ,Expansion ROM Address"
width 9.
group.long 0x38++0x3
    line.long 0x00 "EROMMASK,Expansion ROM BAR Mask Register"
        bitfld.long 0x00 0. " ROM_BAR_ENABLED_N ,Expansion ROM BAR Enable" "0,1"
        textline "        "
        hexmask.long.long 0x00 1.--32. 1. " ROM_MASK_N ,Indicates which Expansion ROM BAR bits to mask (make non-writable) from host software, which, in turn, determines the size of the BAR."
width 5.
rgroup.long 0x40++0x3
    line.long 0x00 "PMCR,Power Management Capability Register"
        hexmask.long.byte 0x00 0.--8. 1. " POWER_MANAGEMENT_CAPABILITY_ID ,Power Management Capability ID"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " NEXT_CAPABILITY_POINTER ,Next Capability Pointer See and ."
        textline "    "
        hexmask.long.byte 0x00 16.--19. 1. " POWER_MANAGEMENT_SPECIFICATION_VERSION ,Power Management specification version, writable through the DBI"
        textline "    "
        bitfld.long 0x00 19. " PME_CLOCK ,PME Clock, hardwired to 0" "0,1"
        textline "    "
        bitfld.long 0x00 21. " DSI ,Device Specific Initialization (DSI), writable through the DBI" "0,1"
        textline "    "
        hexmask.long.byte 0x00 22.--25. 1. " AUX_CURRENT ,AUX Current, writable through the DBI"
        textline "    "
        bitfld.long 0x00 25. " D1_SUPPORT ,D1 Support, writable through the DBI" "0,1"
        textline "    "
        bitfld.long 0x00 26. " D2_SUPPORT ,D2 Support, writable through the DBI" "0,1"
        textline "    "
        hexmask.long.byte 0x00 27.--32. 1. " PME_SUPPORT ,PME_Support Identifies the power states from which the core can generate PME Messages."
width 6.
group.long 0x44++0x3
    line.long 0x00 "PMCSR,Power Management Control and Status Register"
        hexmask.long.byte 0x00 0.--2. 1. " POWER_STATE ,Power State The written value is ignored if the specific state is not supported."
        textline "     "
        bitfld.long 0x00 3. " NO_SOFT_RESET ,No Soft Reset, writable through the DBI" "0,1"
        textline "     "
        bitfld.long 0x00 8. " PME_ENABLE ,PME Enable (sticky bit) A value of 1 indicates that the device is enabled to generate PME." "0,1"
        textline "     "
        hexmask.long.byte 0x00 9.--13. 1. " DATA_SELECT ,Data Select (not supported)"
        textline "     "
        hexmask.long.byte 0x00 13.--15. 1. " DATA_SCALE ,Data Scale (not supported)"
        textline "     "
        bitfld.long 0x00 15. " PME_STATUS ,PME Status Indicates if a previously enabled PME event occurred or not." "0,1"
        textline "     "
        bitfld.long 0x00 22. " B2_B3_SUPPORT ,B2/B3 Support, hardwired to 0" "0,1"
        textline "     "
        bitfld.long 0x00 23. " BUS_POWER_CLOCK_CONTROL_ENABLE ,Bus Power/Clock Control Enable, hardwired to 0" "0,1"
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " DATA_REGISTER_FOR_ADDITIONAL_INFORMATION ,Data register for additional information (not supported)"
width 5.
rgroup.long 0x70++0x3
    line.long 0x00 "CIDR,PCI Express Capability ID Register"
        hexmask.long.byte 0x00 0.--8. 1. " PCI_EXPRESS_CAPABILITY_ID ,PCI Express Capability ID"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " NEXT_CAPABILITY_POINTER ,Next Capability Pointer See Tables 5-214 and 5-215 on page 638."
        textline "    "
        hexmask.long.byte 0x00 16.--20. 1. " PCI_EXPRESS_CAPABILITY_VERSION ,PCI Express Capability Version"
        textline "    "
        hexmask.long.byte 0x00 20.--24. 1. " DEVICE_PORT_TYPE ,Device/Port Type Indicates the specific type of this PCI Express Function."
        textline "    "
        bitfld.long 0x00 24. " SLOT_IMPLEMENTED ,Slot Implemented, writable through the DBI" "0,1"
        textline "    "
        hexmask.long.byte 0x00 25.--30. 1. " INTERRUPT_MESSAGE_NUMBER ,Interrupt Message Number Updated by hardware, writable through the DBI."
width 4.
group.long 0x74++0x3
    line.long 0x00 "DCR,Device Capabilities Register"
        hexmask.long.byte 0x00 0.--3. 1. " MAX_PAYLOAD_SIZE_SUPPORTED ,Max_Payload_Size Supported, writable through the DBI"
        textline "   "
        hexmask.long.byte 0x00 3.--5. 1. " PHANTOM_FUNCTION_SUPPORTED ,Phantom Function Supported This field is writable through the DBI."
        textline "   "
        bitfld.long 0x00 5. " EXTENDED_TAG_FIELD_SUPPORTED ,Extended Tag Field Supported This bit is writable through the DBI." "0,1"
        textline "   "
        hexmask.long.byte 0x00 6.--9. 1. " ENDPOINT_L0S_ACCEPTABLE_LATENCY ,Endpoint L0s Acceptable Latency Must be 0x0 for non-Endpoint devices."
        textline "   "
        hexmask.long.byte 0x00 9.--12. 1. " ENDPOINT_L1_ACCEPTABLE_LATENCY ,Endpoint L1 Acceptable Latency Must be 0x0 for non-Endpoint devices."
        textline "   "
        bitfld.long 0x00 15. " ROLE_BASED_ERROR_REPORTING ,Role-Based Error Reporting, writable through the DBI." "0,1"
        textline "   "
        hexmask.long.byte 0x00 18.--26. 1. " CAPTURED_SLOT_POWER_LIMIT_VALUE ,Captured Slot Power Limit Value Upstream port only."
        textline "   "
        hexmask.long.byte 0x00 26.--28. 1. " CAPTURED_SLOT_POWER_LIMIT_SCALE ,Captured Slot Power Limit Scale Upstream port only."
width 6.
group.long 0x78++0x3
    line.long 0x00 "DCONR,Device Control Register"
        bitfld.long 0x00 0. " CORRECTABLE_ERROR_REPORTING_ENABLE ,Correctable Error Reporting Enable" "0,1"
        textline "     "
        bitfld.long 0x00 1. " NON_FATAL_ERROR_REPORTING_ENABLE ,Non-Fatal Error Reporting Enable" "0,1"
        textline "     "
        bitfld.long 0x00 2. " FATAL_ERROR_REPORTING_ENABLE ,Fatal Error Reporting Enable" "0,1"
        textline "     "
        bitfld.long 0x00 3. " UNSUPPORTED_REQUEST_REPORTING_ENABLE ,Unsupported Request Reporting Enable" "0,1"
        textline "     "
        bitfld.long 0x00 4. " ENABLE_RELAXED_ORDERING ,Enable Relaxed Ordering" "0,1"
        textline "     "
        hexmask.long.byte 0x00 5.--8. 1. " MAX_PAYLOAD_SIZE ,Max_Payload_Size"
        textline "     "
        bitfld.long 0x00 8. " EXTENDED_TAG_FIELD_ENABLE ,Extended Tag Field Enable" "0,1"
        textline "     "
        bitfld.long 0x00 9. " PHANTOM_FUNCTION_ENABLE ,Phantom Function Enable" "0,1"
        textline "     "
        bitfld.long 0x00 10. " AUX_POWER_PM_ENABLE ,AUX Power PM Enable" "0,1"
        textline "     "
        bitfld.long 0x00 11. " ENABLE_NO_SNOOP ,Enable No Snoop" "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--15. 1. " MAX_READ_REQUEST_SIZE ,Max_Read_Request_Size"
        textline "     "
        bitfld.long 0x00 16. " CORRECTABLE_ERROR_DETECTED ,Correctable Error Detected Errors are logged in this register regardless of whether error reporting is enabled in the Device Control register." "0,1"
        textline "     "
        bitfld.long 0x00 17. " NON_FATAL_ERROR_DETECTED ,Non-Fatal Error detected Errors are logged in this register regardless of whether error reporting is enabled in the Device Control register." "0,1"
        textline "     "
        bitfld.long 0x00 18. " FATAL_ERROR_DETECTED ,Fatal Error Detected Errors are logged in this register regardless of whether error reporting is enabled in the Device Control register." "0,1"
        textline "     "
        bitfld.long 0x00 19. " UNSUPPORTED_REQUEST_DETECTED ,Unsupported Request Detected Errors are logged in this register regardless of whether error reporting is enabled in the Device Control register." "0,1"
        textline "     "
        bitfld.long 0x00 20. " AUX_POWER_DETECTED ,Aux Power Detected From sys_aux_pwr_det input port." "0,1"
        textline "     "
        bitfld.long 0x00 21. " TRANSACTION_PENDING ,Transaction Pending Hard-wired to 0." "0,1"
width 4.
rgroup.long 0x7c++0x3
    line.long 0x00 "LCR,Link Capabilities Register"
        hexmask.long.byte 0x00 0.--4. 1. " MAX_LINK_SPEEDS ,Max Link Speeds Indicates the supported maximum Link speeds of the associated Port."
        textline "   "
        hexmask.long.byte 0x00 4.--10. 1. " MAXIMUM_LINK_WIDTH ,Maximum Link Width Writable through the DBI."
        textline "   "
        hexmask.long.byte 0x00 10.--12. 1. " ACTIVE_STATE_LINK_PM_SUPPORT ,Active State Link PM Support The default value is the value you specify during core configuration, writable through the DBI."
        textline "   "
        hexmask.long.byte 0x00 12.--15. 1. " L0S_EXIT_LATENCY ,L0s Exit Latency Writable through the DBI."
        textline "   "
        hexmask.long.byte 0x00 15.--18. 1. " L1_EXIT_LATENCY ,L1 Exit Latency Writable through the DBI."
        textline "   "
        bitfld.long 0x00 18. " CLOCK_POWER_MANAGEMENT ,Clock Power Management Component can tolerate the removal of refclk via CLKREQ# (if supported)." "0,1"
        textline "   "
        bitfld.long 0x00 19. " SURPRISE_DOWN_ERROR_REPORTING_CAPABLE ,Surprise Down Error Reporting Capable Not supported, hardwired to 0x0." "0,1"
        textline "   "
        bitfld.long 0x00 20. " DATA_LINK_LAYER_ACTIVE_REPORTING_CAPABLE ,Data Link Layer Active Reporting Capable Hardwired to 1 for Downstream Ports and 0 for Upstream Ports." "0,1"
        textline "   "
        bitfld.long 0x00 21. " LINK_BANDWIDTH_NOTIFICATION_CAPABILITY ,Link Bandwidth Notification Capability Hardwired to 1 for Downstream Ports and 0 for Upstream Ports." "0,1"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " PORT_NUMBER ,Port Number"
width 5.
group.long 0x80++0x3
    line.long 0x00 "LCSR,Link Control and Status Register"
        hexmask.long.byte 0x00 0.--2. 1. " ACTIVE_STATE_LINK_PM_CONTROL ,Active State Link PM Control"
        textline "    "
        bitfld.long 0x00 3. " RCB ,Read Completion Boundary (RCB) RC: Writable through DBI" "0,1"
        textline "    "
        bitfld.long 0x00 4. " LINK_DISABLE ,Link Disable This bit is reserved for PCI Express-to-PCI/PCI-X bridges." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RETRAIN_LINK ,Retrain Link This bit is reserved for PCI Express-to-PCI/PCI-X bridges." "0,1"
        textline "    "
        bitfld.long 0x00 6. " COMMON_CLOCK_CONFIGURATION ,Common Clock Configuration" "0,1"
        textline "    "
        bitfld.long 0x00 7. " EXTENDED_SYNCH ,Extended Synch" "0,1"
        textline "    "
        bitfld.long 0x00 8. " ENABLE_CLOCK_POWER_MANAGEMENT ,Enable Clock Power Management Hardwired to 0 if Clock Power Management is disabled in the Link Capabilities register." "0,1"
        textline "    "
        bitfld.long 0x00 9. " HARDWARE_AUTONOMOUS_WIDTH_DISABLE ,Hardware Autonomous Width Disable Not supported, hardwired to 0." "0,1"
        textline "    "
        bitfld.long 0x00 10. " LINK_BANDWIDTH_MANAGEMENT_INTERRUPT_ENABLE ,Link Bandwidth Management Interrupt Enable When set, this bit enables the generation of an interrupt to indicate that the Link Bandwidth Management Status bit has been set." "0,1"
        textline "    "
        bitfld.long 0x00 11. " LINK_AUTONOMOUS_BANDWIDTH_INTERRUPT_ENABLE ,Link Autonomous Bandwidth Interrupt Enable When set, this bit enables the generation of an interrupt to indicate that the Link Autonomous Bandwidth Status bit has been set." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--20. 1. " LINK_SPEED ,Link Speed Indicates the negotiated Link speed."
        textline "    "
        hexmask.long.byte 0x00 20.--26. 1. " NEGOTIATED_LINK_WIDTH ,Negotiated Link Width Set automatically by hardware after Link initialization."
        textline "    "
        bitfld.long 0x00 27. " LINK_TRAINING ,Link Training This bit is not applicable and is reserved for Endpoints, PCI Express to PCI/PCI-X bridges." "0,1"
        textline "    "
        bitfld.long 0x00 28. " SLOT_CLOCK_CONFIGURATION ,Slot Clock Configuration Indicates that the component uses the same physical reference clock that the platform provides on the connector." "0,1"
        textline "    "
        bitfld.long 0x00 29. " DATA_LINK_LAYER_ACTIVE ,Data Link Layer Active This bit must be implemented if the corresponding Data Link Layer Link Active Reporting capability bit is implemented." "0,1"
        textline "    "
        bitfld.long 0x00 30. " LINK_BANDWIDTH_MANAGEMENT_STATUS ,Link Bandwidth Management Status This bit is set by hardware to indicate that either of the following has occurred without the Port transitioning through DL_Down status: A Link retraining has completed following a write of 1b to the Retrain Link bit." "0,1"
        textline "    "
        bitfld.long 0x00 31. " LINK_AUTONOMOUS_BANDWIDTH_STATUS ,Link Autonomous Bandwidth Status This bit is set by hardware to indicate that hardware has autonomously changed Link speed or width, without the Port transitioning through DL_Down status, for reasons other than to attempt to correct unreliable Link operation." "0,1"
width 4.
rgroup.long 0x84++0x3
    line.long 0x00 "SCR,Slot Capabilities Register"
        bitfld.long 0x00 0. " ATTENTION_INDICATOR_PRESENT ,Attention Indicator Present, writable through the DBI" "0,1"
        textline "   "
        bitfld.long 0x00 1. " POWER_CONTROLLER_PRESENT_0 ,Power Controller Present, writable through the DBI" "0,1"
        textline "   "
        bitfld.long 0x00 2. " MRL_SENSOR_PRESENT ,MRL Sensor Present, writable through the DBI" "0,1"
        textline "   "
        bitfld.long 0x00 3. " ATTENTION_INDICATOR_PRESENT_1 ,Attention Indicator Present, writable through the DBI" "0,1"
        textline "   "
        bitfld.long 0x00 4. " POWER_INDICATOR_PRESENT ,Power Indicator Present, writable through the DBI" "0,1"
        textline "   "
        bitfld.long 0x00 5. " HOT_PLUG_SURPRISE ,Hot-Plug Surprise, writable through the DBI" "0,1"
        textline "   "
        bitfld.long 0x00 6. " HOT_PLUG_CAPABLE ,Hot-Plug Capable, writable through the DBI" "0,1"
        textline "   "
        hexmask.long.byte 0x00 7.--15. 1. " SLOT_POWER_LIMIT_VALUE ,Slot Power Limit Value, writable through the DBI"
        textline "   "
        hexmask.long.byte 0x00 15.--17. 1. " SLOT_POWER_LIMIT_SCALE ,Slot Power Limit Scale, writable through the DBI"
        textline "   "
        bitfld.long 0x00 17. " ELECTROMECHANICAL_INTERLOCK_PRESENT ,Electromechanical Interlock Present, writable through the DBI" "0,1"
        textline "   "
        bitfld.long 0x00 18. " NO_COMMAND_COMPLETE_SUPPORT ,No Command Complete Support, writable through the DBI" "0,1"
        textline "   "
        hexmask.long.word 0x00 19.--32. 1. " PHYSICAL_SLOT_NUMBER ,Physical Slot Number, writable through the DBI"
width 5.
group.long 0x88++0x3
    line.long 0x00 "SCSR,Slot Control and Status Register"
        bitfld.long 0x00 0. " ATTENTION_BUTTON_PRESSED_ENABLE ,Attention Button Pressed Enable" "0,1"
        textline "    "
        bitfld.long 0x00 1. " POWER_FAULT_DETECTED_ENABLE ,Power Fault Detected Enable" "0,1"
        textline "    "
        bitfld.long 0x00 2. " MRL_SENSOR_CHANGED_ENABLE ,MRL Sensor Changed Enable" "0,1"
        textline "    "
        bitfld.long 0x00 3. " PRESENCE_DETECT_CHANGED_ENABLE ,Presence Detect Changed Enable" "0,1"
        textline "    "
        bitfld.long 0x00 4. " COMMAND_COMPLETED_INTERRUPT_ENABLE ,Command Completed Interrupt Enable" "0,1"
        textline "    "
        bitfld.long 0x00 5. " HOT_PLUG_INTERRUPT_ENABLE ,Hot-Plug Interrupt Enable" "0,1"
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ATTENTION_INDICATOR_CONTROL ,Attention Indicator Control"
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " POWER_INDICATOR_CONTROL ,Power Indicator Control"
        textline "    "
        bitfld.long 0x00 10. " POWER_CONTROLLER_CONTROL ,Power Controller Control" "0,1"
        textline "    "
        bitfld.long 0x00 11. " ELECTROMECHANICAL_INTERLOCK_CONTROL ,Electromechanical Interlock Control" "0,1"
        textline "    "
        bitfld.long 0x00 12. " DATA_LINK_LAYER_STATE_CHANGED_ENABLE ,Data Link Layer State Changed Enable" "0,1"
        textline "    "
        bitfld.long 0x00 16. " ATTENTION_BUTTON_PRESSED ,Attention Button Pressed" "0,1"
        textline "    "
        bitfld.long 0x00 17. " POWER_FAULT_DETECTED ,Power Fault Detected" "0,1"
        textline "    "
        bitfld.long 0x00 18. " MRL_SENSOR_CHANGED ,MRL Sensor Changed" "0,1"
        textline "    "
        bitfld.long 0x00 19. " PRESENCE_DETECT_CHANGED ,Presence Detect Changed" "0,1"
        textline "    "
        bitfld.long 0x00 20. " COMMAND_COMPLETED ,Command Completed" "0,1"
        textline "    "
        bitfld.long 0x00 21. " MRL_SENSOR_STATE ,MRL Sensor State" "0,1"
        textline "    "
        bitfld.long 0x00 22. " PRESENCE_DETECT_STATE ,Presence Detect State" "0,1"
        textline "    "
        bitfld.long 0x00 23. " ELECTROMECHANICAL_INTERLOCK_STATUS ,Electromechanical Interlock Status" "0,1"
        textline "    "
        bitfld.long 0x00 24. " DATA_LINK_LAYER_STATE_CHANGED ,Data Link Layer State Changed" "0,1"
width 5.
group.long 0x8c++0x3
    line.long 0x00 "RCCR,Root Control and Capabilities Register"
        bitfld.long 0x00 0. " SYSTEM_ERROR_ON_CORRECTABLE_ERROR_ENABLE ,System Error on Correctable Error Enable" "0,1"
        textline "    "
        bitfld.long 0x00 1. " SYSTEM_ERROR_ON_NON_FATAL_ERROR_ENABLE ,System Error on Non-fatal Error Enable" "0,1"
        textline "    "
        bitfld.long 0x00 2. " SYSTEM_ERROR_ON_FATAL_ERROR_ENABLE ,System Error on Fatal Error Enable" "0,1"
        textline "    "
        bitfld.long 0x00 3. " PME_INTERRUPT_ENABLE ,PME Interrupt Enable" "0,1"
        textline "    "
        bitfld.long 0x00 4. " CRS_SOFTWARE_VISIBILITY_ENABLE ,CRS Software Visibility Enable Not supported, hardwired to 0x0." "0,1"
        textline "    "
        bitfld.long 0x00 16. " CRS_SOFTWARE_VISIBILITY ,CRS Software Visibility Not supported, hardwired to 0x0." "0,1"
width 4.
group.long 0x90++0x3
    line.long 0x00 "RSR,Root Status Register"
        hexmask.long.word 0x00 0.--16. 1. " PME_REQUESTER_ID ,PME Requester ID"
        textline "   "
        bitfld.long 0x00 16. " PME_STATUS ,PME Status" "0,1"
        textline "   "
        bitfld.long 0x00 17. " PME_PENDING ,PME Pending" "0,1"
width 5.
rgroup.long 0x94++0x3
    line.long 0x00 "DCR2,Device Capabilities 2 Register"
        hexmask.long.byte 0x00 0.--4. 1. " COMPLETION_TIMEOUT_RANGES_SUPPORTED ,Completion Timeout Ranges Supported This field is applicable only to Root Ports, Endpoints that issue Requests on their own behalf, and PCI Express to PCI/PCI-X Bridges that take ownership of Requests issued on PCI Express."
        textline "    "
        bitfld.long 0x00 4. " COMPLETION_TIMEOUT_DISABLE_SUPPORTED ,Completion Timeout Disable Supported" "0,1"
width 6.
group.long 0x98++0x3
    line.long 0x00 "DCSR2,Device Control and Status 2 Register"
        hexmask.long.byte 0x00 0.--4. 1. " COMPLETION_TIMEOUT_VALUE ,Completion Timeout Value If the default range is chosen, the core will have a timeout in the range of 16ms to 55ms."
        textline "     "
        bitfld.long 0x00 4. " COMPLETION_TIMEOUT_DISABLE ,Completion Timeout Disable" "0,1"
width 5.
rgroup.long 0x9c++0x3
    line.long 0x00 "LCR2,Link Capabilities 2 Register"
        hexmask.long.byte 0x00 1.--8. 1. " SUPPORTED_LINK_SPEEDS_VECTOR ,Supported Link Speeds Vector Indicates the supported Link speeds of the associated Port."
        textline "    "
        bitfld.long 0x00 8. " CROSSLINK_SUPPORTED ,Crosslink Supported" "0,1"
width 6.
group.long 0xa0++0x3
    line.long 0x00 "LCSR2,Link Control and Status 2 Register"
        hexmask.long.byte 0x00 0.--4. 1. " TARGET_LINK_SPEED ,Target Link Speed For Downstream ports, this field sets an upper limit on link operational speed by restricting the values advertised by the upstream component in its training sequences: The encoding is the binary value of the bit in the Supported Link Speeds Vector (in the Link Capabilities 2 register) that corresponds to the desired target Link speed."
        textline "     "
        bitfld.long 0x00 4. " ENTER_COMPLIANCE ,Enter Compliance Software is permitted to force a link to enter Compliance mode at the speed indicated in the Target Link Speed field by setting this bit to 1b in both components on a link and then initiating a hot reset on the link." "0,1"
        textline "     "
        bitfld.long 0x00 5. " HARDWARE_AUTONOMOUS_SPEED_DISABLE ,Hardware Autonomous Speed Disable When cfg_hw_auto_sp_dis signal is asserted, the application must disable hardware from changing the Link speed for device-specific reasons other than attempting to correct unreliable Link operation by reducing Link speed." "0,1"
        textline "     "
        bitfld.long 0x00 6. " SELECTABLE_DEEMPHASIS ,Selectable De-emphasis When the Link is operating at 2.5 GT/s speed, the setting of this bit has no effect." "0,1"
        textline "     "
        hexmask.long.byte 0x00 7.--10. 1. " TRANSMIT_MARGIN ,Transmit Margin This field is reset to 000b on entry to the LTSSM Polling."
        textline "     "
        bitfld.long 0x00 10. " ENTER_MODIFIED_COMPLIANCE ,Enter Modified Compliance When this bit is set to 1b, the device transmits modified compliance pattern if the LTSSM enters Polling." "0,1"
        textline "     "
        bitfld.long 0x00 11. " COMPLIANCE_SOS ,Compliance SOS When set to 1b, the LTSSM is required to send SKP Ordered Sets periodically in between the (modified) compliance patterns." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " COMPLIANCE_PRE_SET_DEEMPHASIS ,Compliance Pre-set/ De-emphasis"
        textline "     "
        bitfld.long 0x00 16. " CURRENT_DEEMPHASIS_LEVEL ,Current De-emphasis Level" "0,1"
        textline "     "
        bitfld.long 0x00 17. " EQUALIZATION_COMPLETE ,Equalization Complete" "0,1"
        textline "     "
        bitfld.long 0x00 18. " EQUALIZATION_PHASE_1_SUCCESSFUL ,Equalization Phase 1 Successful" "0,1"
        textline "     "
        bitfld.long 0x00 19. " EQUALIZATION_PHASE_2_SUCCESSFUL ,Equalization Phase 2 Successful" "0,1"
        textline "     "
        bitfld.long 0x00 20. " EQUALIZATION_PHASE_3_SUCCESSFUL ,Equalization Phase 3 Successful" "0,1"
        textline "     "
        bitfld.long 0x00 21. " LINK_EQUALIZATION_REQUEST ,Link Equalization Request" "0,1"
width 4.
group.long 0x100++0x3
    line.long 0x00 "AER,AER Capability Header"
        hexmask.long.word 0x00 0.--16. 1. " PCI_EXPRESS_EXTENDED_CAPABILITY_ID ,PCI Express Extended Capability ID Value is 0x1 for Advanced Error Reporting."
        textline "   "
        hexmask.long.byte 0x00 16.--20. 1. " CAPABILITY_VERSION ,Capability Version"
        textline "   "
        hexmask.long.word 0x00 20.--32. 1. " NEXT_CAPABILITY_OFFSET ,Next Capability Offset See Table 5-222 on page 641."
width 5.
group.long 0x104++0x3
    line.long 0x00 "UESR,Uncorrectable Error Status Register"
        bitfld.long 0x00 4. " DATA_LINK_PROTOCOL_ERROR_STATUS ,Data Link Protocol Error Status" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SURPRISE_DOWN_ERROR_STATUS ,Surprise Down Error Status (not supported)" "0,1"
        textline "    "
        bitfld.long 0x00 12. " POISONED_TLP_STATUS ,Poisoned TLP Status" "0,1"
        textline "    "
        bitfld.long 0x00 13. " FLOW_CONTROL_PROTOCOL_ERROR_STATUS ,Flow Control Protocol Error Status" "0,1"
        textline "    "
        bitfld.long 0x00 14. " COMPLETION_TIMEOUT_STATUS ,Completion Timeout Status" "0,1"
        textline "    "
        bitfld.long 0x00 15. " COMPLETER_ABORT_STATUS ,Completer Abort Status" "0,1"
        textline "    "
        bitfld.long 0x00 16. " UNEXPECTED_COMPLETION_STATUS ,Unexpected Completion Status" "0,1"
        textline "    "
        bitfld.long 0x00 17. " RECEIVER_OVERFLOW_STATUS ,Receiver Overflow Status" "0,1"
        textline "    "
        bitfld.long 0x00 18. " MALFORMED_TLP_STATUS ,Malformed TLP Status" "0,1"
        textline "    "
        bitfld.long 0x00 19. " ECRC_ERROR_STATUS ,ECRC Error Status" "0,1"
        textline "    "
        bitfld.long 0x00 20. " UNSUPPORTED_REQUEST_ERROR_STATUS ,Unsupported Request Error Status" "0,1"
width 5.
group.long 0x108++0x3
    line.long 0x00 "UEMR,Uncorrectable Error Mask Register"
        bitfld.long 0x00 4. " DATA_LINK_PROTOCOL_ERROR_MASK ,Data Link Protocol Error Mask" "0,1"
        textline "    "
        bitfld.long 0x00 5. " SURPRISE_DOWN_ERROR_MASK ,Surprise Down Error Mask (not supported)" "0,1"
        textline "    "
        bitfld.long 0x00 12. " POISONED_TLP_MASK ,Poisoned TLP Mask" "0,1"
        textline "    "
        bitfld.long 0x00 13. " FLOW_CONTROL_PROTOCOL_ERROR_MASK ,Flow Control Protocol Error Mask" "0,1"
        textline "    "
        bitfld.long 0x00 14. " COMPLETION_TIMEOUT_MASK ,Completion Timeout Mask" "0,1"
        textline "    "
        bitfld.long 0x00 15. " COMPLETER_ABORT_MASK ,Completer Abort Mask" "0,1"
        textline "    "
        bitfld.long 0x00 16. " UNEXPECTED_COMPLETION_MASK ,Unexpected Completion Mask" "0,1"
        textline "    "
        bitfld.long 0x00 17. " RECEIVER_OVERFLOW_MASK ,Receiver Overflow Mask" "0,1"
        textline "    "
        bitfld.long 0x00 18. " MALFORMED_TLP_MASK ,Malformed TLP Mask" "0,1"
        textline "    "
        bitfld.long 0x00 19. " ECRC_ERROR_MASK ,ECRC Error Mask" "0,1"
        textline "    "
        bitfld.long 0x00 20. " UNSUPPORTED_REQUEST_ERROR_MASK ,Unsupported Request Error Mask" "0,1"
width 7.
group.long 0x10c++0x3
    line.long 0x00 "UESEVR,Uncorrectable Error Severity Register"
        bitfld.long 0x00 4. " DATA_LINK_PROTOCOL_ERROR_SEVERITY ,Data Link Protocol Error Severity" "0,1"
        textline "      "
        bitfld.long 0x00 5. " SURPRISE_DOWN_ERROR_SEVERITY ,Surprise Down Error Severity (not supported)" "0,1"
        textline "      "
        bitfld.long 0x00 12. " POISONED_TLP_SEVERITY ,Poisoned TLP Severity" "0,1"
        textline "      "
        bitfld.long 0x00 13. " FLOW_CONTROL_PROTOCOL_ERROR_SEVERITY ,Flow Control Protocol Error Severity" "0,1"
        textline "      "
        bitfld.long 0x00 14. " COMPLETION_TIMEOUT_SEVERITY ,Completion Timeout Severity" "0,1"
        textline "      "
        bitfld.long 0x00 15. " COMPLETER_ABORT_SEVERITY ,Completer Abort Severity" "0,1"
        textline "      "
        bitfld.long 0x00 16. " UNEXPECTED_COMPLETION_SEVERITY ,Unexpected Completion Severity" "0,1"
        textline "      "
        bitfld.long 0x00 17. " RECEIVER_OVERFLOW_SEVERITY ,Receiver Overflow Severity" "0,1"
        textline "      "
        bitfld.long 0x00 18. " MALFORMED_TLP_SEVERITY ,Malformed TLP Severity" "0,1"
        textline "      "
        bitfld.long 0x00 19. " ECRC_ERROR_SEVERITY ,ECRC Error Severity" "0,1"
        textline "      "
        bitfld.long 0x00 20. " UNSUPPORTED_REQUEST_ERROR_SEVERITY ,Unsupported Request Error Severity" "0,1"
width 5.
group.long 0x110++0x3
    line.long 0x00 "CESR,Correctable Error Status Register"
        bitfld.long 0x00 0. " RECEIVER_ERROR_STATUS ,Receiver Error Status" "0,1"
        textline "    "
        bitfld.long 0x00 6. " BAD_TLP_STATUS ,Bad TLP Status" "0,1"
        textline "    "
        bitfld.long 0x00 7. " BAD_DLLP_STATUS ,Bad DLLP Status" "0,1"
        textline "    "
        bitfld.long 0x00 8. " REPLAY_NUM_ROLLOVER_STATUS ,REPLAY_NUM Rollover Status" "0,1"
        textline "    "
        bitfld.long 0x00 12. " REPLY_TIMER_TIMEOUT_STATUS ,Reply Timer Timeout Status" "0,1"
        textline "    "
        bitfld.long 0x00 13. " ADVISORY_NON_FATAL_ERROR_STATUS ,Advisory Non-Fatal Error Status" "0,1"
width 5.
group.long 0x114++0x3
    line.long 0x00 "CEMR,Correctable Error Mask Register"
        bitfld.long 0x00 0. " RECEIVER_ERROR_MASK ,Receiver Error Mask" "0,1"
        textline "    "
        bitfld.long 0x00 6. " BAD_TLP_MASK ,Bad TLP Mask" "0,1"
        textline "    "
        bitfld.long 0x00 7. " BAD_DLLP_MASK ,Bad DLLP Mask" "0,1"
        textline "    "
        bitfld.long 0x00 8. " REPLAY_NUM_ROLLOVER_MASK ,REPLAY_NUM Rollover Mask" "0,1"
        textline "    "
        bitfld.long 0x00 12. " REPLY_TIMER_TIMEOUT_MASK ,Reply Timer Timeout Mask" "0,1"
        textline "    "
        bitfld.long 0x00 13. " ADVISORY_NON_FATAL_ERROR_MASK ,Advisory Non-Fatal Error Mask" "0,1"
width 5.
group.long 0x118++0x3
    line.long 0x00 "ACCR,Advanced Capabilities and Control Register"
        hexmask.long.byte 0x00 0.--5. 1. " FIRST_ERROR_POINTER ,First Error Pointer"
        textline "    "
        bitfld.long 0x00 5. " ECRC_GENERATION_CAPABILITY ,ECRC Generation Capability" "0,1"
        textline "    "
        bitfld.long 0x00 6. " ECRC_GENERATION_ENABLE ,ECRC Generation Enable" "0,1"
        textline "    "
        bitfld.long 0x00 7. " ECRC_CHECK_CAPABLE ,ECRC Check Capable" "0,1"
        textline "    "
        bitfld.long 0x00 8. " ECRC_CHECK_ENABLE ,ECRC Check Enable" "0,1"
width 4.
rgroup.long 0x11c++0x3
    line.long 0x00 "HLR,Header Log Register"
width 5.
group.long 0x12c++0x3
    line.long 0x00 "RECR,Root Error Command Register"
        bitfld.long 0x00 0. " CORRECTABLE_ERROR_REPORTING_ENABLE ,Correctable Error Reporting Enable" "0,1"
        textline "    "
        bitfld.long 0x00 1. " NON_FATAL_ERROR_REPORTING_ENABLE ,Non-Fatal Error Reporting Enable" "0,1"
        textline "    "
        bitfld.long 0x00 2. " FATAL_ERROR_REPORTING_ENABLE ,Fatal Error Reporting Enable" "0,1"
width 5.
group.long 0x130++0x3
    line.long 0x00 "RESR,Root Error Status Register"
        bitfld.long 0x00 0. " ERR_COR_RECEIVED ,ERR_COR Received" "0,1"
        textline "    "
        bitfld.long 0x00 1. " MULTIPLE_ERR_COR_RECEIVED ,Multiple ERR_COR Received" "0,1"
        textline "    "
        bitfld.long 0x00 2. " ERR_FATAL_NONFATAL_RECEIVED ,ERR_FATAL/NONFATAL Received" "0,1"
        textline "    "
        bitfld.long 0x00 3. " MULTIPLE_ERR_FATAL_NONFATAL_RECEIVED ,Multiple ERR_FATAL/NONFATAL Received" "0,1"
        textline "    "
        bitfld.long 0x00 4. " FIRST_UNCORRECTABLE_FATAL ,First Uncorrectable Fatal" "0,1"
        textline "    "
        bitfld.long 0x00 5. " NON_FATAL_ERROR_MESSAGES_RECEIVED ,Non-Fatal Error Messages Received" "0,1"
        textline "    "
        bitfld.long 0x00 6. " FATAL_ERROR_MESSAGES_RECEIVED ,Fatal Error Messages Received" "0,1"
        textline "    "
        hexmask.long.byte 0x00 27.--32. 1. " ADVANCED_ERROR_INTERRUPT_MESSAGE_NUMBER ,Advanced Error Interrupt Message Number, writable through the DBI"
width 5.
rgroup.long 0x134++0x3
    line.long 0x00 "ESIR,Error Source Identification Register"
        hexmask.long.word 0x00 0.--16. 1. " ERR_COR_SID ,ERR_COR Source Identification"
        textline "    "
        hexmask.long.word 0x00 16.--32. 1. " ERR_FATAL_NONFATAL_SID ,ERR_FATAL/NONFATAL Source Identification"
width 7.
rgroup.long 0x140++0x3
    line.long 0x00 "VCECHR,VC Extended Capability Header"
        hexmask.long.word 0x00 0.--16. 1. " EXTENDED_CAPABILITY ,PCI Express Extended Capability The default value is 0x2 for VC Capability."
        textline "      "
        hexmask.long.byte 0x00 16.--20. 1. " CAPABILITY_VERSION ,Capability Version"
        textline "      "
        hexmask.long.word 0x00 20.--32. 1. " NEXT_CAPABILITY_OFFSET ,Next Capability Offset See Table 5-222 on page 641."
width 7.
rgroup.long 0x144++0x3
    line.long 0x00 "PVCCR1,Port VC Capability Register 1"
        hexmask.long.byte 0x00 0.--3. 1. " EXTENDED_VC_COUNT ,Extended VC Count The default value is the one less than the number of VCs that"
        textline "      "
        hexmask.long.byte 0x00 4.--7. 1. " LOW_PRIORITY_EXTENDED_VC_COUNT ,Low Priority Extended VC Count, writable through the DBI"
        textline "      "
        hexmask.long.byte 0x00 8.--10. 1. " REFERENCE_CLOCK ,Reference Clock"
        textline "      "
        hexmask.long.byte 0x00 10.--12. 1. " PORT_ARBITRATION_TABLE_ENTRY_SIZE ,Port Arbitration Table Entry Size"
width 7.
rgroup.long 0x148++0x3
    line.long 0x00 "PVCCR2,Port VC Capability Register 2"
        hexmask.long.byte 0x00 0.--8. 1. " VC_ARBITRATION_CAPABILITY ,VC Arbitration Capability Indicates which VC arbitration mode(s) the device supports, writable through the DBI: Bit 0: Device supports hardware fixed arbitration scheme."
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " VC_ARBITRATION_TABLE_OFFSET ,VC Arbitration Table Offset (not supported) The default value is 0x00 (no arbitration table present)."
width 7.
group.long 0x14c++0x3
    line.long 0x00 "PVCCSR,Port VC Control and Status Register"
        bitfld.long 0x00 0. " LOAD_VC_ARBITRATION_TABLE ,Load VC Arbitration Table" "0,1"
        textline "      "
        hexmask.long.byte 0x00 1.--4. 1. " VC_ARBITRATION_SELECT ,VC Arbitration Select"
        textline "      "
        bitfld.long 0x00 16. " ARBITRATION_TABLE_STATUS ,Arbitration Table Status" "0,1"
width 6.
rgroup.long 0x150++0x3
    line.long 0x00 "VCRCR,VC Resource Capability Register n"
        hexmask.long.byte 0x00 0.--8. 1. " PORT_ARBITRATION_CAPABILITY ,Port Arbitration Capability"
        textline "     "
        bitfld.long 0x00 15. " REJECT_SNOOP_TRANSACTIONS ,Reject Snoop Transactions" "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--23. 1. " MAXIMUM_TIME_SLOTS ,Maximum Time Slots"
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " PORT_ARBITRATION_TABLE_OFFSET ,Port Arbitration Table Offset"
width 8.
group.long 0x154++0x3
    line.long 0x00 "VCRCONR,VC Resource Control Register n"
        hexmask.long.byte 0x00 0.--8. 1. " TC_VC_MAP ,TC/VC Map Bit 0 is hardwired to 1; bits 7:1 are RW."
        textline "       "
        bitfld.long 0x00 16. " LOAD_PORT_ARBITRATION_TABLE ,Load Port Arbitration Table" "0,1"
        textline "       "
        hexmask.long.byte 0x00 17.--20. 1. " PORT_ARBITRATION_SELECT ,Port Arbitration Select"
        textline "       "
        hexmask.long.byte 0x00 24.--27. 1. " VC_ID ,VC ID Hardwired to 0 for VC0."
        textline "       "
        bitfld.long 0x00 31. " VC_ENABLE ,VC Enable Hardwired to 1 for the first VC." "0,1"
width 6.
rgroup.long 0x158++0x3
    line.long 0x00 "VCRSR,VC Resource Status Register n"
        bitfld.long 0x00 16. " PORT_ARBITRATION_TABLE_STATUS ,Port Arbitration Table Status" "0,1"
        textline "     "
        bitfld.long 0x00 17. " VC_NEGOTIATION_PENDING ,VC Negotiation Pending" "0,1"


tree.end



;--------------------------------------------------------------------------------
; PGC
;--------------------------------------------------------------------------------
tree "PGC"
    base ad:0x020dc000

width 9.
group.long 0x260++0x3
    line.long 0x00 "GPU_CTRL,PGC Control Register"
        bitfld.long 0x00 0. " PCR ,Power Control PCR must not change from power-down request (pdn_req) assertion until the target subsystem is completely powered up." "0,1"
width 11.
group.long 0x264++0x3
    line.long 0x00 "GPU_PUPSCR,Power Up Sequence Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " SW ,After a power-up request (pup_req assertion), the PGC waits a number of clocks equal to the value of SW before asserting switch_b."
        textline "          "
        hexmask.long.byte 0x00 8.--14. 1. " SW2ISO ,After asserting switch_b, the PGC waits a number of clocks equal to the value of SW2ISO before negating isolation."
width 11.
group.long 0x268++0x3
    line.long 0x00 "GPU_PDNSCR,Pull Down Sequence Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " ISO ,After a power-down request (pdn_req assertion), the PGC waits a number of clocks equal to the value of ISO before asserting isolation."
        textline "          "
        hexmask.long.byte 0x00 8.--14. 1. " ISO2SW ,After asserting isolation, the PGC waits a number of clocks equal to the value of ISO2SW before negating switch_b."
width 7.
group.long 0x26c++0x3
    line.long 0x00 "GPU_SR,Power Gating Controller Status Register"
        bitfld.long 0x00 0. " PSR ,Power status." "0,1"
width 9.
group.long 0x2a0++0x3
    line.long 0x00 "CPU_CTRL,PGC Control Register"
        bitfld.long 0x00 0. " PCR ,Power Control PCR must not change from power-down request (pdn_req) assertion until the target subsystem is completely powered up." "0,1"
width 11.
group.long 0x2a4++0x3
    line.long 0x00 "CPU_PUPSCR,Power Up Sequence Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " SW ,After a power-up request (pup_req assertion), the PGC waits a number of clocks equal to the value of SW before asserting switch_b."
        textline "          "
        hexmask.long.byte 0x00 8.--14. 1. " SW2ISO ,After asserting switch_b, the PGC waits a number of clocks equal to the value of SW2ISO before negating isolation."
width 11.
group.long 0x2a8++0x3
    line.long 0x00 "CPU_PDNSCR,Pull Down Sequence Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " ISO ,After a power-down request (pdn_req assertion), the PGC waits a number of clocks equal to the value of ISO before asserting isolation."
        textline "          "
        hexmask.long.byte 0x00 8.--14. 1. " ISO2SW ,After asserting isolation, the PGC waits a number of clocks equal to the value of ISO2SW before negating switch_b."
width 7.
group.long 0x2ac++0x3
    line.long 0x00 "CPU_SR,Power Gating Controller Status Register"
        bitfld.long 0x00 0. " PSR ,Power status." "0,1"


tree.end



;--------------------------------------------------------------------------------
; PMU
;--------------------------------------------------------------------------------
tree "PMU"
    base ad:0x020c8000

width 8.
group.long 0x110++0x3
    line.long 0x00 "REG_1P1,Regulator 1P1 Register"
        bitfld.long 0x00 0. " ENABLE_LINREG ,Control bit to enable the regulator output." "0,1"
        textline "       "
        bitfld.long 0x00 1. " ENABLE_BO ,Control bit to enable the brown-out circuitry in the regulator." "0,1"
        textline "       "
        bitfld.long 0x00 2. " ENABLE_ILIMIT ,Control bit to enable the current-limit circuitry in the regulator." "0,1"
        textline "       "
        bitfld.long 0x00 3. " ENABLE_PULLDOWN ,Control bit to enable the pull-down circuitry in the regulator" "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " BO_OFFSET ,Control bits to adjust the regulator brown-out offset voltage in 25mV steps."
        textline "       "
        hexmask.long.byte 0x00 8.--13. 1. " OUTPUT_TRG ,Control bits to adjust the regulator output voltage."
        textline "       "
        bitfld.long 0x00 16. " BO_VDD1P1 ,Status bit that signals when a brown-out is detected on the regulator output." "0,1"
        textline "       "
        bitfld.long 0x00 17. " OK_VDD1P1 ,Status bit that signals when the regulator output is ok." "0,1"
width 8.
group.long 0x120++0x3
    line.long 0x00 "REG_3P0,Regulator 3P0 Register"
        bitfld.long 0x00 0. " ENABLE_LINREG ,Control bit to enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference." "0,1"
        textline "       "
        bitfld.long 0x00 1. " ENABLE_BO ,Control bit to enable the brown-out circuitry in the regulator." "0,1"
        textline "       "
        bitfld.long 0x00 2. " ENABLE_ILIMIT ,Control bit to enable the current-limit circuitry in the regulator." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " BO_OFFSET ,Control bits to adjust the regulator brown-out offset voltage in 25mV steps."
        textline "       "
        bitfld.long 0x00 7. " VBUS_SEL ,Select input voltage source for LDO_3P0 from either USB_H1_VBUS or USB_OTG_VBUS." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--13. 1. " OUTPUT_TRG ,Control bits to adjust the regulator output voltage."
        textline "       "
        bitfld.long 0x00 16. " BO_VDD3P0 ,Status bit that signals when a brown-out is detected on the regulator output." "0,1"
        textline "       "
        bitfld.long 0x00 17. " OK_VDD3P0 ,Status bit that signals when the regulator output is ok." "0,1"
width 8.
group.long 0x130++0x3
    line.long 0x00 "REG_2P5,Regulator 2P5 Register"
        bitfld.long 0x00 0. " ENABLE_LINREG ,Control bit to enable the regulator output." "0,1"
        textline "       "
        bitfld.long 0x00 1. " ENABLE_BO ,Control bit to enable the brown-out circuitry in the regulator." "0,1"
        textline "       "
        bitfld.long 0x00 2. " ENABLE_ILIMIT ,Control bit to enable the current-limit circuitry in the regulator." "0,1"
        textline "       "
        bitfld.long 0x00 3. " ENABLE_PULLDOWN ,Control bit to enable the pull-down circuitry in the regulator" "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--7. 1. " BO_OFFSET ,Control bits to adjust the regulator brown-out offset voltage in 25mV steps."
        textline "       "
        hexmask.long.byte 0x00 8.--13. 1. " OUTPUT_TRG ,Control bits to adjust the regulator output voltage."
        textline "       "
        bitfld.long 0x00 16. " BO_VDD2P5 ,Status bit that signals when a brown-out is detected on the regulator output." "0,1"
        textline "       "
        bitfld.long 0x00 17. " OK_VDD2P5 ,Status bit that signals when the regulator output is ok." "0,1"
        textline "       "
        bitfld.long 0x00 18. " ENABLE_WEAK_LINREG ,Enables the weak 2p5 regulator." "0,1"
width 9.
group.long 0x140++0x3
    line.long 0x00 "REG_CORE,Digital Regulator Core Register"
        hexmask.long.byte 0x00 0.--5. 1. " REG0_TARG ,This bitfield defines the target voltage for the arm core power domain."
        textline "        "
        hexmask.long.byte 0x00 5.--9. 1. " REG0_ADJ ,This bitfield defines the adjustment bits to calibrate the target value of REG1 (ARM_CORE)."
        textline "        "
        hexmask.long.byte 0x00 9.--14. 1. " REG1_TARG ,This bitfield defines the target voltage for the VPU/GPU power domain."
        textline "        "
        hexmask.long.byte 0x00 14.--18. 1. " REG1_ADJ ,This bitfield defines the adjustment bits to calibrate the target value of REG1 (REG_PU)."
        textline "        "
        hexmask.long.byte 0x00 18.--23. 1. " REG2_TARG ,This bitfield defines the target voltage for the SOC power domain."
        textline "        "
        hexmask.long.byte 0x00 23.--27. 1. " REG2_ADJ ,This bitfield defines the adjustment bits to calibrate the target value of REG2 (REG_SOC)."
        textline "        "
        bitfld.long 0x00 29. " FET_ODRIVE ,If set, increases the gate drive on power gating fets to reduce leakage in the off state." "0,1"
width 6.
group.long 0x150++0x3
    line.long 0x00 "MISC0,Miscellaneous Register 0"
        bitfld.long 0x00 0. " REFTOP_PWD ,Control bit to power-down the analog bandgap reference circuitry." "0,1"
        textline "     "
        bitfld.long 0x00 3. " REFTOP_SELFBIASOFF ,Control bit to disable the self-bias circuit in the analog bandgap." "0,1"
        textline "     "
        hexmask.long.byte 0x00 4.--7. 1. " REFTOP_VBGADJ ,"
        textline "     "
        bitfld.long 0x00 7. " REFTOP_VBGUP ,Status bit which signals that the analog bandgap voltage is up and stable." "0,1"
        textline "     "
        bitfld.long 0x00 12. " STOP_MODE_CONFIG ,Configure the analog behavior in stop mode." "0,1"
        textline "     "
        bitfld.long 0x00 13. " DISCON_HIGH_SNVS ,This bit forces the short between VDDHIGH_IN and VSNVS_IN to open when asserted." "0,1"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " OSC_I ,This bit field determines the bias current in the 24MHz oscillator."
        textline "     "
        bitfld.long 0x00 16. " OSC_XTALOK ,Status bit which signals that the output of the 24MHz crystal oscillator is stable." "0,1"
        textline "     "
        bitfld.long 0x00 17. " OSC_XTALOK_EN ,This bit enables the detector which signals when the 24MHz crystal oscillator is stable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " WBCP_VPW_THRESH ,This signal alters the voltage that the pwell is charged pumped to."
        textline "     "
        bitfld.long 0x00 25. " CLKGATE_CTRL ,This bit allows disabling the clock gate (always un-gated) for the xtal 24MHz clock that clocks the digital logic in the analog block." "0,1"
        textline "     "
        hexmask.long.byte 0x00 26.--29. 1. " CLKGATE_DELAY ,This field specifies the delay between powering up the XTAL 24MHz clock and release the clock to the digital logic inside the analog block."
width 6.
group.long 0x160++0x3
    line.long 0x00 "MISC1,Miscellaneous Register 1"
        hexmask.long.byte 0x00 0.--5. 1. " LVDS1_CLK_SEL ,This field selects the clk to be routed to anaclk2/2b."
        textline "     "
        hexmask.long.byte 0x00 5.--10. 1. " LVDS2_CLK_SEL ,This field selects the clk to be routed to anaclk2/2b."
        textline "     "
        bitfld.long 0x00 10. " LVDSCLK1_OBEN ,This enables the lvds output buffer for anaclk1/1b." "0,1"
        textline "     "
        bitfld.long 0x00 11. " LVDSCLK2_OBEN ,This enables the lvds output buffer for anaclk2/2b." "0,1"
        textline "     "
        bitfld.long 0x00 12. " LVDSCLK1_IBEN ,This enables the lvds input buffer for anaclk1/1b." "0,1"
        textline "     "
        bitfld.long 0x00 13. " LVDSCLK2_IBEN ,This enables the lvds input buffer for anaclk2/2b." "0,1"
        textline "     "
        bitfld.long 0x00 29. " IRQ_TEMPSENSE ,This status bit is set to one when when the temperature sensor interrupt asserts." "0,1"
        textline "     "
        bitfld.long 0x00 30. " IRQ_ANA_BO ,This status bit is set to one when when any of the analog regulator brownout interrupts assert." "0,1"
        textline "     "
        bitfld.long 0x00 31. " IRQ_DIG_BO ,This status bit is set to one when when any of the digital regulator brownout interrupts assert." "0,1"
width 6.
group.long 0x170++0x3
    line.long 0x00 "MISC2,Miscellaneous Register 2"
        hexmask.long.byte 0x00 0.--3. 1. " REG0_BO_OFFSET ,This bit field defines the brown out voltage offset for the CORE power domain."
        textline "     "
        bitfld.long 0x00 3. " REG0_BO_STATUS ,Reg0 brownout status bit." "0,1"
        textline "     "
        bitfld.long 0x00 5. " REG0_ENABLE_BO ,Enables the brownout detection." "0,1"
        textline "     "
        bitfld.long 0x00 7. " PLL3_DISABLE ,Default value of ""0""." "0,1"
        textline "     "
        hexmask.long.byte 0x00 8.--11. 1. " REG1_BO_OFFSET ,This bit field defines the brown out voltage offset for the xPU power domain."
        textline "     "
        bitfld.long 0x00 11. " REG1_BO_STATUS ,Reg1 brownout status bit." "0,1"
        textline "     "
        bitfld.long 0x00 13. " REG1_ENABLE_BO ,Enables the brownout detection." "0,1"
        textline "     "
        bitfld.long 0x00 15. " AUDIO_DIV_LSB ,LSB of Audio Pll post divider two bit control: 0x0=div-by-1(default), 0x1=div-by-2, 0x2-div-by-1, 0x3=div-by-4." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--19. 1. " REG2_BO_OFFSET ,This bit field defines the brown out voltage offset for the xPU power domain."
        textline "     "
        bitfld.long 0x00 19. " REG2_BO_STATUS ,Reg2 brownout status bit." "0,1"
        textline "     "
        bitfld.long 0x00 21. " REG2_ENABLE_BO ,Enables the brownout detection." "0,1"
        textline "     "
        bitfld.long 0x00 22. " REG2_OK ,Signals that the voltage is above the brownout level for the SOC supply." "0,1"
        textline "     "
        bitfld.long 0x00 23. " AUDIO_DIV_MSB ,MSB of 2 bit post-divider field for the Audio PLL: 0x0=div-by-1(default), 0x1=div-by-2, 0x2=div-by-1, 0x3=div-by-4." "0,1"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " REG0_STEP_TIME ,Number of clock periods (24MHz clock)."
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " REG1_STEP_TIME ,Number of clock periods (24MHz clock)."
        textline "     "
        hexmask.long.byte 0x00 28.--30. 1. " REG2_STEP_TIME ,Number of clock periods (24MHz clock)."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " VIDEO_DIV ,Post-divider for video PLL."


tree.end



;--------------------------------------------------------------------------------
; PWM
;--------------------------------------------------------------------------------
tree.open "PWM"
    tree "PWM1"
        base ad:0x02080000

width 6.
group.long 0x0++0x3
    line.long 0x00 "PWMCR,PWM Control Register"
        bitfld.long 0x00 0. " EN ,PWM Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 1.--3. 1. " REPEAT ,Sample Repeat."
        textline "     "
        bitfld.long 0x00 3. " SWR ,Software Reset." "0,1"
        textline "     "
        hexmask.long.word 0x00 4.--16. 1. " PRESCALER ,Counter Clock Prescaler Value."
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CLKSRC ,Select Clock Source."
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " POUTC ,PWM Output Configuration."
        textline "     "
        bitfld.long 0x00 20. " HCTR ,Half-word Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 21. " BCTR ,Byte Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 22. " DBGEN ,Debug Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 23. " WAITEN ,Wait Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 24. " DOZEN ,Doze Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 25. " STOPEN ,Stop Mode Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " FWM ,FIFO Water Mark."
width 6.
group.long 0x4++0x3
    line.long 0x00 "PWMSR,PWM Status Register"
        hexmask.long.byte 0x00 0.--3. 1. " FIFOAV ,FIFO Available."
        textline "     "
        bitfld.long 0x00 3. " FE ,FIFO Empty Status Bit." "0,1"
        textline "     "
        bitfld.long 0x00 4. " ROV ,Roll-over Status." "0,1"
        textline "     "
        bitfld.long 0x00 5. " CMP ,Compare Status." "0,1"
        textline "     "
        bitfld.long 0x00 6. " FWE ,FIFO Write Error Status." "0,1"
width 6.
group.long 0x8++0x3
    line.long 0x00 "PWMIR,PWM Interrupt Register"
        bitfld.long 0x00 0. " FIE ,FIFO Empty Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RIE ,Roll-over Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 2. " CIE ,Compare Interrupt Enable." "0,1"
width 7.
group.long 0xc++0x3
    line.long 0x00 "PWMSAR,PWM Sample Register"
        hexmask.long.word 0x00 0.--16. 1. " SAMPLE ,Sample Value."
width 6.
group.long 0x10++0x3
    line.long 0x00 "PWMPR,PWM Period Register"
        hexmask.long.word 0x00 0.--16. 1. " PERIOD ,Period Value."
width 7.
rgroup.long 0x14++0x3
    line.long 0x00 "PWMCNR,PWM Counter Register"
        hexmask.long.word 0x00 0.--16. 1. " COUNT ,Counter Value."


    tree.end
    tree "PWM2"
        base ad:0x02084000

width 6.
group.long 0x0++0x3
    line.long 0x00 "PWMCR,PWM Control Register"
        bitfld.long 0x00 0. " EN ,PWM Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 1.--3. 1. " REPEAT ,Sample Repeat."
        textline "     "
        bitfld.long 0x00 3. " SWR ,Software Reset." "0,1"
        textline "     "
        hexmask.long.word 0x00 4.--16. 1. " PRESCALER ,Counter Clock Prescaler Value."
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CLKSRC ,Select Clock Source."
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " POUTC ,PWM Output Configuration."
        textline "     "
        bitfld.long 0x00 20. " HCTR ,Half-word Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 21. " BCTR ,Byte Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 22. " DBGEN ,Debug Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 23. " WAITEN ,Wait Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 24. " DOZEN ,Doze Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 25. " STOPEN ,Stop Mode Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " FWM ,FIFO Water Mark."
width 6.
group.long 0x4++0x3
    line.long 0x00 "PWMSR,PWM Status Register"
        hexmask.long.byte 0x00 0.--3. 1. " FIFOAV ,FIFO Available."
        textline "     "
        bitfld.long 0x00 3. " FE ,FIFO Empty Status Bit." "0,1"
        textline "     "
        bitfld.long 0x00 4. " ROV ,Roll-over Status." "0,1"
        textline "     "
        bitfld.long 0x00 5. " CMP ,Compare Status." "0,1"
        textline "     "
        bitfld.long 0x00 6. " FWE ,FIFO Write Error Status." "0,1"
width 6.
group.long 0x8++0x3
    line.long 0x00 "PWMIR,PWM Interrupt Register"
        bitfld.long 0x00 0. " FIE ,FIFO Empty Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RIE ,Roll-over Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 2. " CIE ,Compare Interrupt Enable." "0,1"
width 7.
group.long 0xc++0x3
    line.long 0x00 "PWMSAR,PWM Sample Register"
        hexmask.long.word 0x00 0.--16. 1. " SAMPLE ,Sample Value."
width 6.
group.long 0x10++0x3
    line.long 0x00 "PWMPR,PWM Period Register"
        hexmask.long.word 0x00 0.--16. 1. " PERIOD ,Period Value."
width 7.
rgroup.long 0x14++0x3
    line.long 0x00 "PWMCNR,PWM Counter Register"
        hexmask.long.word 0x00 0.--16. 1. " COUNT ,Counter Value."


    tree.end
    tree "PWM3"
        base ad:0x02088000

width 6.
group.long 0x0++0x3
    line.long 0x00 "PWMCR,PWM Control Register"
        bitfld.long 0x00 0. " EN ,PWM Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 1.--3. 1. " REPEAT ,Sample Repeat."
        textline "     "
        bitfld.long 0x00 3. " SWR ,Software Reset." "0,1"
        textline "     "
        hexmask.long.word 0x00 4.--16. 1. " PRESCALER ,Counter Clock Prescaler Value."
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CLKSRC ,Select Clock Source."
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " POUTC ,PWM Output Configuration."
        textline "     "
        bitfld.long 0x00 20. " HCTR ,Half-word Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 21. " BCTR ,Byte Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 22. " DBGEN ,Debug Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 23. " WAITEN ,Wait Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 24. " DOZEN ,Doze Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 25. " STOPEN ,Stop Mode Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " FWM ,FIFO Water Mark."
width 6.
group.long 0x4++0x3
    line.long 0x00 "PWMSR,PWM Status Register"
        hexmask.long.byte 0x00 0.--3. 1. " FIFOAV ,FIFO Available."
        textline "     "
        bitfld.long 0x00 3. " FE ,FIFO Empty Status Bit." "0,1"
        textline "     "
        bitfld.long 0x00 4. " ROV ,Roll-over Status." "0,1"
        textline "     "
        bitfld.long 0x00 5. " CMP ,Compare Status." "0,1"
        textline "     "
        bitfld.long 0x00 6. " FWE ,FIFO Write Error Status." "0,1"
width 6.
group.long 0x8++0x3
    line.long 0x00 "PWMIR,PWM Interrupt Register"
        bitfld.long 0x00 0. " FIE ,FIFO Empty Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RIE ,Roll-over Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 2. " CIE ,Compare Interrupt Enable." "0,1"
width 7.
group.long 0xc++0x3
    line.long 0x00 "PWMSAR,PWM Sample Register"
        hexmask.long.word 0x00 0.--16. 1. " SAMPLE ,Sample Value."
width 6.
group.long 0x10++0x3
    line.long 0x00 "PWMPR,PWM Period Register"
        hexmask.long.word 0x00 0.--16. 1. " PERIOD ,Period Value."
width 7.
rgroup.long 0x14++0x3
    line.long 0x00 "PWMCNR,PWM Counter Register"
        hexmask.long.word 0x00 0.--16. 1. " COUNT ,Counter Value."


    tree.end
    tree "PWM4"
        base ad:0x0208c000

width 6.
group.long 0x0++0x3
    line.long 0x00 "PWMCR,PWM Control Register"
        bitfld.long 0x00 0. " EN ,PWM Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 1.--3. 1. " REPEAT ,Sample Repeat."
        textline "     "
        bitfld.long 0x00 3. " SWR ,Software Reset." "0,1"
        textline "     "
        hexmask.long.word 0x00 4.--16. 1. " PRESCALER ,Counter Clock Prescaler Value."
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " CLKSRC ,Select Clock Source."
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " POUTC ,PWM Output Configuration."
        textline "     "
        bitfld.long 0x00 20. " HCTR ,Half-word Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 21. " BCTR ,Byte Data Swap Control." "0,1"
        textline "     "
        bitfld.long 0x00 22. " DBGEN ,Debug Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 23. " WAITEN ,Wait Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 24. " DOZEN ,Doze Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 25. " STOPEN ,Stop Mode Enable." "0,1"
        textline "     "
        hexmask.long.byte 0x00 26.--28. 1. " FWM ,FIFO Water Mark."
width 6.
group.long 0x4++0x3
    line.long 0x00 "PWMSR,PWM Status Register"
        hexmask.long.byte 0x00 0.--3. 1. " FIFOAV ,FIFO Available."
        textline "     "
        bitfld.long 0x00 3. " FE ,FIFO Empty Status Bit." "0,1"
        textline "     "
        bitfld.long 0x00 4. " ROV ,Roll-over Status." "0,1"
        textline "     "
        bitfld.long 0x00 5. " CMP ,Compare Status." "0,1"
        textline "     "
        bitfld.long 0x00 6. " FWE ,FIFO Write Error Status." "0,1"
width 6.
group.long 0x8++0x3
    line.long 0x00 "PWMIR,PWM Interrupt Register"
        bitfld.long 0x00 0. " FIE ,FIFO Empty Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RIE ,Roll-over Interrupt Enable." "0,1"
        textline "     "
        bitfld.long 0x00 2. " CIE ,Compare Interrupt Enable." "0,1"
width 7.
group.long 0xc++0x3
    line.long 0x00 "PWMSAR,PWM Sample Register"
        hexmask.long.word 0x00 0.--16. 1. " SAMPLE ,Sample Value."
width 6.
group.long 0x10++0x3
    line.long 0x00 "PWMPR,PWM Period Register"
        hexmask.long.word 0x00 0.--16. 1. " PERIOD ,Period Value."
width 7.
rgroup.long 0x14++0x3
    line.long 0x00 "PWMCNR,PWM Counter Register"
        hexmask.long.word 0x00 0.--16. 1. " COUNT ,Counter Value."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; PXP
;--------------------------------------------------------------------------------
tree "PXP"
    base ad:0x020f0000

width 5.
group.long 0x0++0x3
    line.long 0x00 "CTRL,Control Register 0"
        bitfld.long 0x00 0. " ENABLE ,Enables PXP operation with specified parameters." "0,1"
        textline "    "
        bitfld.long 0x00 1. " IRQ_ENABLE ,Interrupt enable." "0,1"
        textline "    "
        bitfld.long 0x00 2. " NEXT_IRQ_ENABLE ,Next command interrupt enable." "0,1"
        textline "    "
        bitfld.long 0x00 3. " LUT_DMA_IRQ_ENABLE ,LUT DMA interrupt enable." "0,1"
        textline "    "
        bitfld.long 0x00 4. " ENABLE_LCD_HANDSHAKE ,Enable handshake with LCD controller." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " ROTATE ,Indicates the clockwise rotation to be applied at the output buffer."
        textline "    "
        bitfld.long 0x00 10. " HFLIP ,Indicates that the output buffer should be flipped horizontally (effect applied before rotation)." "0,1"
        textline "    "
        bitfld.long 0x00 11. " VFLIP ,Indicates that the output buffer should be flipped vertically (effect applied before rotation)." "0,1"
        textline "    "
        bitfld.long 0x00 22. " ROT_POS ,This bit controls where rotation will occur in the PXP datapath." "0,1"
        textline "    "
        bitfld.long 0x00 23. " BLOCK_SIZE ,Select the block size to process." "0,1"
        textline "    "
        bitfld.long 0x00 28. " EN_REPEAT ,Enable the PXP to run continuously." "0,1"
        textline "    "
        bitfld.long 0x00 30. " CLKGATE ,This bit must be set to zero for normal operation." "0,1"
        textline "    "
        bitfld.long 0x00 31. " SFTRST ,Set this bit to zero to enable normal PXP operation." "0,1"
width 5.
group.long 0x10++0x3
    line.long 0x00 "STAT,Status Register"
        bitfld.long 0x00 0. " IRQ ,Indicates current PXP interrupt status." "0,1"
        textline "    "
        bitfld.long 0x00 1. " AXI_WRITE_ERROR ,Indicates PXP encountered an AXI write error and processing has been terminated." "0,1"
        textline "    "
        bitfld.long 0x00 2. " AXI_READ_ERROR ,Indicates PXP encountered an AXI read error and processing has been terminated." "0,1"
        textline "    "
        bitfld.long 0x00 3. " NEXT_IRQ ,Indicates that a command issued with the ""Next Command"" functionality has been issued and that a new command may be initiated with a write to the PXP_NEXT register." "0,1"
        textline "    "
        hexmask.long.byte 0x00 4.--8. 1. " AXI_ERROR_ID ,Indicates the AXI ID of the failing bus operation."
        textline "    "
        bitfld.long 0x00 8. " LUT_DMA_LOAD_DONE_IRQ ,Indicates that the LUT DMA transfer has completed." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--24. 1. " BLOCKY ,Indicates the X coordinate of the block currently being rendered."
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " BLOCKX ,Indicates the X coordinate of the block currently being rendered."
width 9.
group.long 0x20++0x3
    line.long 0x00 "OUT_CTRL,Output Buffer Control Register"
        hexmask.long.byte 0x00 0.--5. 1. " FORMAT ,Output framebuffer format."
        textline "        "
        hexmask.long.byte 0x00 8.--10. 1. " INTERLACED_OUTPUT ,Determines how the PXP writes it's output data."
        textline "        "
        bitfld.long 0x00 23. " ALPHA_OUTPUT ,Indicates that alpha component in output buffer pixels should be overwritten by PXP_OUT_CTRL[ALPHA]." "0,1"
        textline "        "
        hexmask.long.byte 0x00 24.--32. 1. " ALPHA ,When generating an output buffer with an alpha component, the value in this field will be used when enabled to override the alpha passed through the pixel data pipeline."
width 8.
group.long 0x30++0x3
    line.long 0x00 "OUT_BUF,Output Frame Buffer Pointer"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Current address pointer for the output frame buffer."
width 9.
group.long 0x40++0x3
    line.long 0x00 "OUT_BUF2,Output Frame Buffer Pointer #2"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Current address pointer for the output frame buffer."
width 10.
group.long 0x50++0x3
    line.long 0x00 "OUT_PITCH,Output Buffer Pitch"
        hexmask.long.word 0x00 0.--16. 1. " PITCH ,Indicates the number of bytes in memory between two vertically adjacent pixels."
width 8.
group.long 0x60++0x3
    line.long 0x00 "OUT_LRC,Output Surface Lower Right Coordinate"
        hexmask.long.word 0x00 0.--14. 1. " Y ,Indicates the number of vertical PIXELS in the output surface (non-rotated)."
        textline "       "
        hexmask.long.word 0x00 16.--30. 1. " X ,Indicates number of horizontal PIXELS in the output surface (non-rotated)."
width 11.
group.long 0x70++0x3
    line.long 0x00 "OUT_PS_ULC,Processed Surface Upper Left Coordinate"
        hexmask.long.word 0x00 0.--14. 1. " Y ,This field indicates the upper left Y-coordinate (in pixels) of the processed surface in the output buffer."
        textline "          "
        hexmask.long.word 0x00 16.--30. 1. " X ,This field indicates the upper left X-coordinate (in pixels) of the processed surface (PS) in the output buffer."
width 11.
group.long 0x80++0x3
    line.long 0x00 "OUT_PS_LRC,Processed Surface Lower Right Coordinate"
        hexmask.long.word 0x00 0.--14. 1. " Y ,This field indicates the lower right Y-coordinate (in pixels) of the processed surface in the output frame buffer."
        textline "          "
        hexmask.long.word 0x00 16.--30. 1. " X ,This field indicates the lower right X-coordinate (in pixels) of the processed surface (PS) in the output frame buffer."
width 11.
group.long 0x90++0x3
    line.long 0x00 "OUT_AS_ULC,Alpha Surface Upper Left Coordinate"
        hexmask.long.word 0x00 0.--14. 1. " Y ,This field indicates the upper left Y-coordinate (in pixels) of the alpha surface in the output frame buffer."
        textline "          "
        hexmask.long.word 0x00 16.--30. 1. " X ,This field indicates the upper left X-coordinate (in pixels) of the alpha surface (AS) in the output frame buffer."
width 11.
group.long 0xa0++0x3
    line.long 0x00 "OUT_AS_LRC,Alpha Surface Lower Right Coordinate"
        hexmask.long.word 0x00 0.--14. 1. " Y ,This field indicates the lower right Y-coordinate (in pixels) of the alpha surface in the output frame buffer."
        textline "          "
        hexmask.long.word 0x00 16.--30. 1. " X ,This field indicates the lower right X-coordinate (in pixels) of the alpha surface (AS) in the output frame buffer."
width 8.
group.long 0xb0++0x3
    line.long 0x00 "PS_CTRL,Processed Surface (PS) Control Register"
        hexmask.long.byte 0x00 0.--5. 1. " FORMAT ,PS buffer format."
        textline "       "
        bitfld.long 0x00 5. " WB_SWAP ,Swap bytes in words." "0,1"
        textline "       "
        hexmask.long.byte 0x00 8.--10. 1. " DECY ,Verticle pre decimation filter control."
        textline "       "
        hexmask.long.byte 0x00 10.--12. 1. " DECX ,Horizontal pre decimation filter control."
width 7.
group.long 0xc0++0x3
    line.long 0x00 "PS_BUF,PS Input Buffer Address"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address pointer for the PS RGB or Y (luma) input buffer."
width 8.
group.long 0xd0++0x3
    line.long 0x00 "PS_UBUF,PS U/Cb or 2 Plane UV Input Buffer Address"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address pointer for the PS U/Cb or 2 plane UV Chroma input buffer."
width 8.
group.long 0xe0++0x3
    line.long 0x00 "PS_VBUF,PS V/Cr Input Buffer Address"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address pointer for the PS V/Cr Chroma input buffer."
width 9.
group.long 0xf0++0x3
    line.long 0x00 "PS_PITCH,Processed Surface Pitch"
        hexmask.long.word 0x00 0.--16. 1. " PITCH ,Indicates the number of bytes in memory between two vertically adjacent pixels."
width 14.
group.long 0x100++0x3
    line.long 0x00 "PS_BACKGROUND,PS Background Color"
        hexmask.long.long 0x00 0.--24. 1. " COLOR ,Background color (in 24bpp format) for any pixels not within the buffer range specified by the PS ULC/LRC."
width 9.
group.long 0x110++0x3
    line.long 0x00 "PS_SCALE,PS Scale Factor Register"
        hexmask.long.word 0x00 0.--15. 1. " XSCALE ,This is a two bit integer and 12 bit fractional representation (##.####_####_####) of the X scaling factor for the PS source buffer."
        textline "        "
        hexmask.long.word 0x00 16.--31. 1. " YSCALE ,This is a two bit integer and 12 bit fractional representation (##.####_####_####) of the Y scaling factor for the PS source buffer."
width 10.
group.long 0x120++0x3
    line.long 0x00 "PS_OFFSET,PS Scale Offset Register"
        hexmask.long.word 0x00 0.--12. 1. " XOFFSET ,This is a 12 bit fractional representation (0.####_####_####) of the X scaling offset."
        textline "         "
        hexmask.long.word 0x00 16.--28. 1. " YOFFSET ,This is a 12 bit fractional representation (0.####_####_####) of the Y scaling offset."
width 13.
group.long 0x130++0x3
    line.long 0x00 "PS_CLRKEYLOW,PS Color Key Low"
        hexmask.long.long 0x00 0.--24. 1. " PIXEL ,Low range of color key applied to PS buffer."
width 14.
group.long 0x140++0x3
    line.long 0x00 "PS_CLRKEYHIGH,PS Color Key High"
        hexmask.long.long 0x00 0.--24. 1. " PIXEL ,High range of color key applied to PS buffer."
width 8.
group.long 0x150++0x3
    line.long 0x00 "AS_CTRL,Alpha Surface Control"
        hexmask.long.byte 0x00 1.--3. 1. " ALPHA_CTRL ,Determines how the alpha value is constructed for this alpha surface."
        textline "       "
        bitfld.long 0x00 3. " ENABLE_COLORKEY ,Indicates that colorkey functionality is enabled for this alpha surface." "0,1"
        textline "       "
        hexmask.long.byte 0x00 4.--8. 1. " FORMAT ,Indicates the input buffer format for AS."
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " ALPHA ,Alpha modifier used when the ALPHA_MULTIPLY or ALPHA_OVERRIDE values are programmed in PXP_AS_CTRL[ALPHA_CTRL]."
        textline "       "
        hexmask.long.byte 0x00 16.--20. 1. " ROP ,Indicates a raster operation to perform when enabled."
        textline "       "
        bitfld.long 0x00 20. " ALPHA_INVERT ,Setting this bit to logic 0 will not alter the alpha value." "0,1"
width 7.
group.long 0x160++0x3
    line.long 0x00 "AS_BUF,Alpha Surface Buffer Pointer"
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,Address pointer for the alpha surface 0 buffer."
width 9.
group.long 0x170++0x3
    line.long 0x00 "AS_PITCH,Alpha Surface Pitch"
        hexmask.long.word 0x00 0.--16. 1. " PITCH ,Indicates the number of bytes in memory between two vertically adjacent pixels."
width 13.
group.long 0x180++0x3
    line.long 0x00 "AS_CLRKEYLOW,Overlay Color Key Low"
        hexmask.long.long 0x00 0.--24. 1. " PIXEL ,Low range of RGB color key applied to AS buffer."
width 14.
group.long 0x190++0x3
    line.long 0x00 "AS_CLRKEYHIGH,Overlay Color Key High"
        hexmask.long.long 0x00 0.--24. 1. " PIXEL ,High range of RGB color key applied to AS buffer."
width 11.
group.long 0x1a0++0x3
    line.long 0x00 "CSC1_COEF0,Color Space Conversion Coefficient Register 0"
        hexmask.long.word 0x00 0.--9. 1. " Y_OFFSET ,Two's compliment amplitude offset implicit in the Y data."
        textline "          "
        hexmask.long.word 0x00 9.--18. 1. " UV_OFFSET ,Two's compliment phase offset implicit for CbCr data."
        textline "          "
        hexmask.long.word 0x00 18.--29. 1. " C0 ,Two's compliment Y multiplier coefficient."
        textline "          "
        bitfld.long 0x00 30. " BYPASS ,Bypass the CSC unit in the scaling engine." "0,1"
        textline "          "
        bitfld.long 0x00 31. " YCBCR_MODE ,Set to 1 when performing YCbCr conversion to RGB." "0,1"
width 11.
group.long 0x1b0++0x3
    line.long 0x00 "CSC1_COEF1,Color Space Conversion Coefficient Register 1"
        hexmask.long.word 0x00 0.--11. 1. " C4 ,Two's compliment Blue U/Cb multiplier coefficient."
        textline "          "
        hexmask.long.word 0x00 16.--27. 1. " C1 ,Two's compliment Red V/Cr multiplier coefficient."
width 11.
group.long 0x1c0++0x3
    line.long 0x00 "CSC1_COEF2,Color Space Conversion Coefficient Register 2"
        hexmask.long.word 0x00 0.--11. 1. " C3 ,Two's complement Green U/Cb multiplier coefficient."
        textline "          "
        hexmask.long.word 0x00 16.--27. 1. " C2 ,Two's complement Green V/Cr multiplier coefficient."
width 10.
group.long 0x1d0++0x3
    line.long 0x00 "CSC2_CTRL,Color Space Conversion Control Register."
        bitfld.long 0x00 0. " BYPASS ,This bit controls whether the pixels entering the CSC2 unit get converted or not." "0,1"
        textline "         "
        hexmask.long.byte 0x00 1.--3. 1. " CSC_MODE ,This field controls how the CSC unit operates on pixels when the CSC is not bypassed."
width 11.
group.long 0x1e0++0x3
    line.long 0x00 "CSC2_COEF0,Color Space Conversion Coefficient Register 0"
        hexmask.long.word 0x00 0.--11. 1. " A1 ,Two's complement coefficient offset."
        textline "          "
        hexmask.long.word 0x00 16.--27. 1. " A2 ,Two's complement coefficient offset."
width 11.
group.long 0x1f0++0x3
    line.long 0x00 "CSC2_COEF1,Color Space Conversion Coefficient Register 1"
        hexmask.long.word 0x00 0.--11. 1. " A3 ,Two's complement coefficient offset."
        textline "          "
        hexmask.long.word 0x00 16.--27. 1. " B1 ,Two's complement coefficient offset."
width 11.
group.long 0x200++0x3
    line.long 0x00 "CSC2_COEF2,Color Space Conversion Coefficient Register 2"
        hexmask.long.word 0x00 0.--11. 1. " B2 ,Two's complement coefficient offset."
        textline "          "
        hexmask.long.word 0x00 16.--27. 1. " B3 ,Two's complement coefficient offset."
width 11.
group.long 0x210++0x3
    line.long 0x00 "CSC2_COEF3,Color Space Conversion Coefficient Register 3"
        hexmask.long.word 0x00 0.--11. 1. " C1 ,Two's complement coefficient offset."
        textline "          "
        hexmask.long.word 0x00 16.--27. 1. " C2 ,Two's complement coefficient offset."
width 11.
group.long 0x220++0x3
    line.long 0x00 "CSC2_COEF4,Color Space Conversion Coefficient Register 4"
        hexmask.long.word 0x00 0.--11. 1. " C3 ,Two's complement coefficient offset."
        textline "          "
        hexmask.long.word 0x00 16.--25. 1. " D1 ,Two's complement coefficient integer offset to be added."
width 11.
group.long 0x230++0x3
    line.long 0x00 "CSC2_COEF5,Color Space Conversion Coefficient Register 5"
        hexmask.long.word 0x00 0.--9. 1. " D2 ,Two's complement D1 coefficient integer offset to be added."
        textline "          "
        hexmask.long.word 0x00 16.--25. 1. " D3 ,Two's complement coefficient integer offset to be added."
width 9.
group.long 0x240++0x3
    line.long 0x00 "LUT_CTRL,Lookup Table Control Register."
        bitfld.long 0x00 0. " DMA_START ,Setting this bit will result in the DMA operation to load the PXP LUT memory based on PXP_LUT_ADDR_NUM_BYTES, PXP_LUT_ADDR_ADDR, and PXP_LUT_MEM_ADDR." "0,1"
        textline "        "
        bitfld.long 0x00 8. " INVALID ,Invalidate the cache LRU and valid bits." "0,1"
        textline "        "
        bitfld.long 0x00 9. " LRU_UPD ,Least Recently Used Policy Update Control: 1=> block LRU update for hit after miss." "0,1"
        textline "        "
        bitfld.long 0x00 10. " SEL_8KB ,Selects which 8KB bank of memory to use for direct 12bpp lookup modes." "0,1"
        textline "        "
        hexmask.long.byte 0x00 16.--18. 1. " OUT_MODE ,Select the output mode of operation for the LUT resource."
        textline "        "
        hexmask.long.byte 0x00 24.--26. 1. " LOOKUP_MODE ,Configure the input address for the 16KB LUT memory."
        textline "        "
        bitfld.long 0x00 31. " BYPASS ,Setting this bit will bypass the LUT memory resource completely." "0,1"
width 9.
group.long 0x250++0x3
    line.long 0x00 "LUT_ADDR,Lookup Table Control Register."
        hexmask.long.word 0x00 0.--14. 1. " ADDR ,LUT indexed address pointer."
        textline "        "
        hexmask.long.word 0x00 16.--31. 1. " NUM_BYTES ,Indicates the number of bytes to load via a DMA operation."
width 9.
group.long 0x260++0x3
    line.long 0x00 "LUT_DATA,Lookup Table Data Register."
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Writing this field will load 4 bytes, aligned to four byte boundaries, of data indexed by the ADDR field of the PXP_LUT_CTRL register."
width 11.
group.long 0x270++0x3
    line.long 0x00 "LUT_EXTMEM,Lookup Table External Memory Address Register."
        hexmask.long.long 0x00 0.--32. 1. " ADDR ,This register contains the external memory address used for LUT memory operation."
width 4.
group.long 0x280++0x3
    line.long 0x00 "CFA,Color Filter Array Register."
        hexmask.long.long 0x00 0.--32. 1. " DATA ,This register contains the Color Filter Array pattern for decimation of RGBW4444 16 bit pixels to individual R, G, B, W values."
width 10.
group.long 0x290++0x3
    line.long 0x00 "HIST_CTRL,Histogram Control Register."
        hexmask.long.byte 0x00 0.--4. 1. " STATUS ,Indicates which histogram matched the processed bitmap."
        textline "         "
        hexmask.long.byte 0x00 4.--6. 1. " PANEL_MODE ,Specifies the EPDC panel grayscale depth."
width 12.
group.long 0x2a0++0x3
    line.long 0x00 "HIST2_PARAM,2-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,Black value for 2-level histogram"
        textline "           "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,White value for 2-level histogram"
width 12.
group.long 0x2b0++0x3
    line.long 0x00 "HIST4_PARAM,4-level Histogram Parameter Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,GRAY0 (Black) value for 4-level histogram"
        textline "           "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,GRAY1 value for 4-level histogram"
        textline "           "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE2 ,GRAY2 value for 4-level histogram"
        textline "           "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE3 ,GRAY3 (White) value for 4-level histogram"
width 13.
group.long 0x2c0++0x3
    line.long 0x00 "HIST8_PARAM0,8-level Histogram Parameter 0 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,GRAY0 (Black) value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,GRAY1 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE2 ,GRAY2 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE3 ,GRAY3 value for 8-level histogram"
width 13.
group.long 0x2d0++0x3
    line.long 0x00 "HIST8_PARAM1,8-level Histogram Parameter 1 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE4 ,GRAY4 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE5 ,GRAY5 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE6 ,GRAY6 value for 8-level histogram"
        textline "            "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE7 ,GRAY7 (White) value for 8-level histogram"
width 14.
group.long 0x2e0++0x3
    line.long 0x00 "HIST16_PARAM0,16-level Histogram Parameter 0 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE0 ,GRAY0 (Black) value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE1 ,GRAY1 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE2 ,GRAY2 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE3 ,GRAY3 value for 16-level histogram"
width 14.
group.long 0x2f0++0x3
    line.long 0x00 "HIST16_PARAM1,16-level Histogram Parameter 1 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE4 ,GRAY4 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE5 ,GRAY5 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE6 ,GRAY6 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE7 ,GRAY7 value for 16-level histogram"
width 14.
group.long 0x300++0x3
    line.long 0x00 "HIST16_PARAM2,16-level Histogram Parameter 2 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE8 ,GRAY8 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE9 ,GRAY9 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE10 ,GRAY10 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE11 ,GRAY11 value for 16-level histogram"
width 14.
group.long 0x310++0x3
    line.long 0x00 "HIST16_PARAM3,16-level Histogram Parameter 3 Register."
        hexmask.long.byte 0x00 0.--5. 1. " VALUE12 ,GRAY12 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 8.--13. 1. " VALUE13 ,GRAY13 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 16.--21. 1. " VALUE14 ,GRAY14 value for 16-level histogram"
        textline "             "
        hexmask.long.byte 0x00 24.--29. 1. " VALUE15 ,GRAY15 (White) value for 16-level histogram"
width 6.
group.long 0x320++0x3
    line.long 0x00 "POWER,PXP Power Control Register."
        hexmask.long.byte 0x00 0.--3. 1. " LUT_LP_STATE_WAY0_BANK0 ,Select the low power state of the LUT's WAY0-BANK0 memory."
        textline "     "
        hexmask.long.byte 0x00 3.--6. 1. " LUT_LP_STATE_WAY0_BANKN ,Select the low power state of the LUT's WAY0-BANK1,2,3 memory."
        textline "     "
        hexmask.long.byte 0x00 6.--9. 1. " LUT_LP_STATE_WAY1_BANKN ,Select the low power state of the LUT's WAY0-BANK0,1,2,3 memory."
        textline "     "
        hexmask.long.byte 0x00 9.--12. 1. " ROT_MEM_LP_STATE ,Select the low power state of the ROT memory."
        textline "     "
        hexmask.long.long 0x00 12.--32. 1. " CTRL ,This register contains power control for the PXP."
width 5.
group.long 0x400++0x3
    line.long 0x00 "NEXT,Next Frame Pointer"
        bitfld.long 0x00 0. " ENABLED ,Indicates that the ""next frame"" functionality has been enabled." "0,1"
        textline "    "
        hexmask.long.long 0x00 2.--32. 1. " POINTER ,A pointer to a data structure containing register values to be used when processing the next frame."


tree.end



;--------------------------------------------------------------------------------
; ROMC
;--------------------------------------------------------------------------------
tree "ROMC"
    base ad:0x021ac000

width 11.
group.long 0xd4++0x3
    line.long 0x00 "ROMPATCH0D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xd8++0x3
    line.long 0x00 "ROMPATCH1D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xdc++0x3
    line.long 0x00 "ROMPATCH2D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xe0++0x3
    line.long 0x00 "ROMPATCH3D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xe4++0x3
    line.long 0x00 "ROMPATCH4D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xe8++0x3
    line.long 0x00 "ROMPATCH5D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xec++0x3
    line.long 0x00 "ROMPATCH6D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 11.
group.long 0xf0++0x3
    line.long 0x00 "ROMPATCH7D,ROMC Data Registers"
        hexmask.long.long 0x00 0.--32. 1. " DATAX ,Data Fix Registers - Stores the data used for 1-word data fix operations."
width 13.
group.long 0xf4++0x3
    line.long 0x00 "ROMPATCHCNTL,ROMC Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " DATAFIX ,Data Fix Enable - Controls the use of the first 8 address comparators for 1-word data fix or for code patch routine."
        textline "            "
        bitfld.long 0x00 29. " DIS ,ROMC Disable -- This bit, when set, disables all ROMC operations." "0,1"
width 12.
rgroup.long 0xf8++0x3
    line.long 0x00 "ROMPATCHENH,ROMC Enable Register High"
width 12.
group.long 0xfc++0x3
    line.long 0x00 "ROMPATCHENL,ROMC Enable Register Low"
        hexmask.long.word 0x00 0.--16. 1. " ENABLE ,Enable Address Comparator - This bit enables the corresponding address comparator to trigger an event."
width 11.
group.long 0x100++0x3
    line.long 0x00 "ROMPATCH0A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x104++0x3
    line.long 0x00 "ROMPATCH1A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x108++0x3
    line.long 0x00 "ROMPATCH2A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x10c++0x3
    line.long 0x00 "ROMPATCH3A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x110++0x3
    line.long 0x00 "ROMPATCH4A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x114++0x3
    line.long 0x00 "ROMPATCH5A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x118++0x3
    line.long 0x00 "ROMPATCH6A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x11c++0x3
    line.long 0x00 "ROMPATCH7A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x120++0x3
    line.long 0x00 "ROMPATCH8A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x124++0x3
    line.long 0x00 "ROMPATCH9A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "          "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 12.
group.long 0x128++0x3
    line.long 0x00 "ROMPATCH10A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "           "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 12.
group.long 0x12c++0x3
    line.long 0x00 "ROMPATCH11A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "           "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 12.
group.long 0x130++0x3
    line.long 0x00 "ROMPATCH12A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "           "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 12.
group.long 0x134++0x3
    line.long 0x00 "ROMPATCH13A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "           "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 12.
group.long 0x138++0x3
    line.long 0x00 "ROMPATCH14A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "           "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 12.
group.long 0x13c++0x3
    line.long 0x00 "ROMPATCH15A,ROMC Address Registers"
        bitfld.long 0x00 0. " THUMBX ,THUMB Comparator Select - Indicates that this address will trigger a THUMB opcode patch or an ARM opcode patch." "0,1"
        textline "           "
        hexmask.long.long 0x00 1.--23. 1. " ADDRX ,Address Comparator Registers - Indicates the memory address to be watched."
width 11.
group.long 0x208++0x3
    line.long 0x00 "ROMPATCHSR,ROMC Status Register"
        hexmask.long.byte 0x00 0.--6. 1. " SOURCE ,ROMC Source Number - Binary encoding of the number of the address comparator which has an address match in the most recent patch event on ROMC AHB."
        textline "          "
        bitfld.long 0x00 17. " SW ,ROMC AHB Multiple Address Comparator matches Indicator - Indicates that multiple address comparator matches occurred." "0,1"


tree.end



;--------------------------------------------------------------------------------
; SDMAARM
;--------------------------------------------------------------------------------
tree "SDMAARM"
    base ad:0x020ec000

width 7.
group.long 0x0++0x3
    line.long 0x00 "MC0PTR,ARM platform Channel 0 Pointer"
        hexmask.long.long 0x00 0.--32. 1. " MC0PTR ,Channel 0 Pointer contains the 32-bit address, in ARM platform memory, of channel 0 control block (the boot channel)."
width 5.
group.long 0x4++0x3
    line.long 0x00 "INTR,Channel Interrupts"
        hexmask.long.long 0x00 0.--32. 1. " HI ,The ARM platform Interrupts register contains the 32 HI[i] bits."
width 10.
group.long 0x8++0x3
    line.long 0x00 "STOP_STAT,Channel Stop/Channel Status"
        hexmask.long.long 0x00 0.--32. 1. " HE ,This 32-bit register gives access to the ARM platform Enable bits."
width 7.
group.long 0xc++0x3
    line.long 0x00 "HSTART,Channel Start"
        hexmask.long.long 0x00 0.--32. 1. " HSTART_HE ,The HSTART_HE registers are 32 bits wide with one bit for every channel."
width 7.
group.long 0x10++0x3
    line.long 0x00 "EVTOVR,Channel Event Override"
        hexmask.long.long 0x00 0.--32. 1. " EO ,The Channel Event Override register contains the 32 EO[i] bits."
width 7.
group.long 0x14++0x3
    line.long 0x00 "DSPOVR,Channel BP Override"
        hexmask.long.long 0x00 0.--32. 1. " DO ,This register is reserved."
width 8.
group.long 0x18++0x3
    line.long 0x00 "HOSTOVR,Channel ARM platform Override"
        hexmask.long.long 0x00 0.--32. 1. " HO ,The Channel ARM platform Override register contains the 32 HO[i] bits."
width 8.
group.long 0x1c++0x3
    line.long 0x00 "EVTPEND,Channel Event Pending"
        hexmask.long.long 0x00 0.--32. 1. " EP ,The Channel Event Pending register contains the 32 EP[i] bits."
width 6.
rgroup.long 0x24++0x3
    line.long 0x00 "RESET,Reset Register"
        bitfld.long 0x00 0. " RESET ,When set, this bit causes the SDMA to be held in a software reset." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RESCHED ,When set, this bit forces the SDMA to reschedule as if a script had executed a done instruction." "0,1"
width 7.
rgroup.long 0x28++0x3
    line.long 0x00 "EVTERR,DMA Request Error Register"
        hexmask.long.long 0x00 0.--32. 1. " CHNERR ,This register is used by the SDMA to warn the ARM platform when an incoming DMA request was detected and it triggers a channel that is already pending or being serviced."
width 9.
group.long 0x2c++0x3
    line.long 0x00 "INTRMASK,Channel ARM platform Interrupt Mask"
        hexmask.long.long 0x00 0.--32. 1. " HIMASK ,The Interrupt Mask Register contains 32 interrupt generation mask bits."
width 4.
rgroup.long 0x30++0x3
    line.long 0x00 "PSW,Schedule Status"
        hexmask.long.byte 0x00 0.--4. 1. " CCR ,The Current Channel Register indicates the number of the channel that is being executed by the SDMA."
        textline "   "
        hexmask.long.byte 0x00 4.--8. 1. " CCP ,The Current Channel Priority indicates the priority of the current active channel."
        textline "   "
        hexmask.long.byte 0x00 8.--13. 1. " NCR ,The Next Channel Register indicates the number of the next scheduled pending channel with the highest priority."
        textline "   "
        hexmask.long.byte 0x00 13.--16. 1. " NCP ,The Next Channel Priority gives the next pending channel priority."
width 10.
rgroup.long 0x34++0x3
    line.long 0x00 "EVTERRDBG,DMA Request Error Register"
        hexmask.long.long 0x00 0.--32. 1. " CHNERR ,This register is the same as EVTERR, except reading it does not clear its contents."
width 7.
group.long 0x38++0x3
    line.long 0x00 "CONFIG,Configuration Register"
        hexmask.long.byte 0x00 0.--2. 1. " CSM ,Selects the Context Switch Mode."
        textline "      "
        bitfld.long 0x00 4. " ACR ,ARM platform DMA / SDMA Core Clock Ratio." "0,1"
        textline "      "
        bitfld.long 0x00 11. " RTDOBS ,Indicates if Real-Time Debug pins are used: They do not toggle by default in order to reduce power consumption." "0,1"
        textline "      "
        bitfld.long 0x00 12. " DSPDMA ,This bit's function is reserved and should be configured as zero." "0,1"
width 10.
group.long 0x3c++0x3
    line.long 0x00 "SDMA_LOCK,SDMA LOCK"
        bitfld.long 0x00 0. " LOCK ,The LOCK bit is used to restrict access to update SDMA script memory through ROM channel zero scripts and through the OnCE interface under ARM platform control." "0,1"
        textline "         "
        bitfld.long 0x00 1. " SRESET_LOCK_CLR ,The SRESET_LOCK_CLR bit determine if the LOCK bit is cleared on a software reset triggered by writing to the RESET register." "0,1"
width 9.
group.long 0x40++0x3
    line.long 0x00 "ONCE_ENB,OnCE Enable"
        bitfld.long 0x00 0. " ENB ,The OnCE Enable register selects the OnCE control source: When cleared (0), the OnCE registers are accessed through the JTAG interface; when set (1), the OnCE registers may be accessed by the ARM platform through the addresses described, as follows." "0,1"
width 10.
group.long 0x44++0x3
    line.long 0x00 "ONCE_DATA,OnCE Data Register"
        hexmask.long.long 0x00 0.--32. 1. " DATA ,Data register of the OnCE JTAG controller."
width 11.
group.long 0x48++0x3
    line.long 0x00 "ONCE_INSTR,OnCE Instruction Register"
        hexmask.long.word 0x00 0.--16. 1. " INSTR ,Instruction register of the OnCE JTAG controller."
width 10.
rgroup.long 0x4c++0x3
    line.long 0x00 "ONCE_STAT,OnCE Status Register"
        hexmask.long.byte 0x00 0.--3. 1. " ECDR ,Event Cell Debug Request."
        textline "         "
        bitfld.long 0x00 7. " MST ,This flag is raised when the OnCE is controlled from the ARM platform peripheral interface." "0,1"
        textline "         "
        bitfld.long 0x00 8. " SWB ,This flag is raised when the SDMA has entered debug mode after a software breakpoint." "0,1"
        textline "         "
        bitfld.long 0x00 9. " ODR ,This flag is raised when the SDMA has entered debug mode after a OnCE debug request." "0,1"
        textline "         "
        bitfld.long 0x00 10. " EDR ,This flag is raised when the SDMA has entered debug mode after an external debug request." "0,1"
        textline "         "
        bitfld.long 0x00 11. " RCV ,After each write access to the real time buffer (RTB), the RCV bit is set." "0,1"
        textline "         "
        hexmask.long.byte 0x00 12.--16. 1. " PST ,The Processor Status bits reflect the state of the SDMA RISC engine."
width 9.
group.long 0x50++0x3
    line.long 0x00 "ONCE_CMD,OnCE Command Register"
        hexmask.long.byte 0x00 0.--4. 1. " CMD ,Writing to this register will cause the OnCE to execute the command that is written."
width 12.
group.long 0x58++0x3
    line.long 0x00 "ILLINSTADDR,Illegal Instruction Trap Address"
        hexmask.long.word 0x00 0.--14. 1. " ILLINSTADDR ,The Illegal Instruction Trap Address is the address where the SDMA jumps when an illegal instruction is executed."
width 9.
group.long 0x5c++0x3
    line.long 0x00 "CHN0ADDR,Channel 0 Boot Address"
        hexmask.long.word 0x00 0.--14. 1. " CHN0ADDR ,This 14-bit register is used by the boot code of the SDMA."
        textline "        "
        bitfld.long 0x00 14. " SMSZ ,The bit 14 (Scratch Memory Size) determines if scratch memory must be available after every channel context." "0,1"
width 11.
rgroup.long 0x60++0x3
    line.long 0x00 "EVT_MIRROR,DMA Requests"
        hexmask.long.long 0x00 0.--32. 1. " EVENTS ,This register reflects the DMA requests received by the SDMA for events 31-0."
width 12.
rgroup.long 0x64++0x3
    line.long 0x00 "EVT_MIRROR2,DMA Requests 2"
        hexmask.long.word 0x00 0.--16. 1. " EVENTS ,This register reflects the DMA requests received by the SDMA for events 47-32."
width 12.
group.long 0x70++0x3
    line.long 0x00 "XTRIG_CONF1,Cross-Trigger Events Configuration Register 1"
        hexmask.long.byte 0x00 0.--6. 1. " NUM0 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 6. " CNF0 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
        textline "           "
        hexmask.long.byte 0x00 8.--14. 1. " NUM1 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 14. " CNF1 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
        textline "           "
        hexmask.long.byte 0x00 16.--22. 1. " NUM2 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 22. " CNF2 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
        textline "           "
        hexmask.long.byte 0x00 24.--30. 1. " NUM3 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 30. " CNF3 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
width 12.
group.long 0x74++0x3
    line.long 0x00 "XTRIG_CONF2,Cross-Trigger Events Configuration Register 2"
        hexmask.long.byte 0x00 0.--6. 1. " NUM4 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 6. " CNF4 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
        textline "           "
        hexmask.long.byte 0x00 8.--14. 1. " NUM5 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 14. " CNF5 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
        textline "           "
        hexmask.long.byte 0x00 16.--22. 1. " NUM6 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 22. " CNF6 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
        textline "           "
        hexmask.long.byte 0x00 24.--30. 1. " NUM7 ,Contains the number of the DMA request or channel that triggers the pulse on the cross-trigger event line number i ."
        textline "           "
        bitfld.long 0x00 30. " CNF7 ,Configuration of the SDMA event line number i that is connected to the cross-trigger." "0,1"
width 13.
group.long 0x100++0x3
    line.long 0x00 "SDMA_CHNPRI0,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x104++0x3
    line.long 0x00 "SDMA_CHNPRI1,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x108++0x3
    line.long 0x00 "SDMA_CHNPRI2,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x10c++0x3
    line.long 0x00 "SDMA_CHNPRI3,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x110++0x3
    line.long 0x00 "SDMA_CHNPRI4,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x114++0x3
    line.long 0x00 "SDMA_CHNPRI5,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x118++0x3
    line.long 0x00 "SDMA_CHNPRI6,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x11c++0x3
    line.long 0x00 "SDMA_CHNPRI7,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x120++0x3
    line.long 0x00 "SDMA_CHNPRI8,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 13.
group.long 0x124++0x3
    line.long 0x00 "SDMA_CHNPRI9,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x128++0x3
    line.long 0x00 "SDMA_CHNPRI10,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x12c++0x3
    line.long 0x00 "SDMA_CHNPRI11,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x130++0x3
    line.long 0x00 "SDMA_CHNPRI12,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x134++0x3
    line.long 0x00 "SDMA_CHNPRI13,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x138++0x3
    line.long 0x00 "SDMA_CHNPRI14,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x13c++0x3
    line.long 0x00 "SDMA_CHNPRI15,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x140++0x3
    line.long 0x00 "SDMA_CHNPRI16,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x144++0x3
    line.long 0x00 "SDMA_CHNPRI17,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x148++0x3
    line.long 0x00 "SDMA_CHNPRI18,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x14c++0x3
    line.long 0x00 "SDMA_CHNPRI19,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x150++0x3
    line.long 0x00 "SDMA_CHNPRI20,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x154++0x3
    line.long 0x00 "SDMA_CHNPRI21,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x158++0x3
    line.long 0x00 "SDMA_CHNPRI22,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x15c++0x3
    line.long 0x00 "SDMA_CHNPRI23,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x160++0x3
    line.long 0x00 "SDMA_CHNPRI24,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x164++0x3
    line.long 0x00 "SDMA_CHNPRI25,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x168++0x3
    line.long 0x00 "SDMA_CHNPRI26,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x16c++0x3
    line.long 0x00 "SDMA_CHNPRI27,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x170++0x3
    line.long 0x00 "SDMA_CHNPRI28,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x174++0x3
    line.long 0x00 "SDMA_CHNPRI29,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x178++0x3
    line.long 0x00 "SDMA_CHNPRI30,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 14.
group.long 0x17c++0x3
    line.long 0x00 "SDMA_CHNPRI31,Channel Priority Registers"
        hexmask.long.byte 0x00 0.--3. 1. " CHNPRIN ,This contains the priority of channel number n ."
width 9.
group.long 0x200++0x3
    line.long 0x00 "CHNENBL0,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x204++0x3
    line.long 0x00 "CHNENBL1,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x208++0x3
    line.long 0x00 "CHNENBL2,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x20c++0x3
    line.long 0x00 "CHNENBL3,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x210++0x3
    line.long 0x00 "CHNENBL4,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x214++0x3
    line.long 0x00 "CHNENBL5,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x218++0x3
    line.long 0x00 "CHNENBL6,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x21c++0x3
    line.long 0x00 "CHNENBL7,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x220++0x3
    line.long 0x00 "CHNENBL8,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 9.
group.long 0x224++0x3
    line.long 0x00 "CHNENBL9,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x228++0x3
    line.long 0x00 "CHNENBL10,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x22c++0x3
    line.long 0x00 "CHNENBL11,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x230++0x3
    line.long 0x00 "CHNENBL12,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x234++0x3
    line.long 0x00 "CHNENBL13,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x238++0x3
    line.long 0x00 "CHNENBL14,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x23c++0x3
    line.long 0x00 "CHNENBL15,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x240++0x3
    line.long 0x00 "CHNENBL16,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x244++0x3
    line.long 0x00 "CHNENBL17,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x248++0x3
    line.long 0x00 "CHNENBL18,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x24c++0x3
    line.long 0x00 "CHNENBL19,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x250++0x3
    line.long 0x00 "CHNENBL20,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x254++0x3
    line.long 0x00 "CHNENBL21,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x258++0x3
    line.long 0x00 "CHNENBL22,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x25c++0x3
    line.long 0x00 "CHNENBL23,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x260++0x3
    line.long 0x00 "CHNENBL24,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x264++0x3
    line.long 0x00 "CHNENBL25,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x268++0x3
    line.long 0x00 "CHNENBL26,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x26c++0x3
    line.long 0x00 "CHNENBL27,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x270++0x3
    line.long 0x00 "CHNENBL28,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x274++0x3
    line.long 0x00 "CHNENBL29,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x278++0x3
    line.long 0x00 "CHNENBL30,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x27c++0x3
    line.long 0x00 "CHNENBL31,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x280++0x3
    line.long 0x00 "CHNENBL32,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x284++0x3
    line.long 0x00 "CHNENBL33,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x288++0x3
    line.long 0x00 "CHNENBL34,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x28c++0x3
    line.long 0x00 "CHNENBL35,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x290++0x3
    line.long 0x00 "CHNENBL36,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x294++0x3
    line.long 0x00 "CHNENBL37,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x298++0x3
    line.long 0x00 "CHNENBL38,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x29c++0x3
    line.long 0x00 "CHNENBL39,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2a0++0x3
    line.long 0x00 "CHNENBL40,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2a4++0x3
    line.long 0x00 "CHNENBL41,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2a8++0x3
    line.long 0x00 "CHNENBL42,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2ac++0x3
    line.long 0x00 "CHNENBL43,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2b0++0x3
    line.long 0x00 "CHNENBL44,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2b4++0x3
    line.long 0x00 "CHNENBL45,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2b8++0x3
    line.long 0x00 "CHNENBL46,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."
width 10.
group.long 0x2bc++0x3
    line.long 0x00 "CHNENBL47,Channel Enable RAM"
        hexmask.long.long 0x00 0.--32. 1. " ENBLN ,This 32-bit value selects the channels that are triggered by the DMA request number n ."


tree.end



;--------------------------------------------------------------------------------
; SDMABP
;--------------------------------------------------------------------------------
tree "SDMABP"
    base ad:0x020ec000

width 7.
group.long 0x0++0x3
    line.long 0x00 "DC0PTR,Channel 0 Pointer"
        hexmask.long.long 0x00 0.--32. 1. " DC0PTR ,Channel 0 Pointer contains the 32-bit address, in BP memory, of the array of channel control blocks starting with the one for channel 0 (the control channel)."
width 5.
group.long 0x4++0x3
    line.long 0x00 "INTR,Channel Interrupts"
        hexmask.long.long 0x00 0.--32. 1. " DI ,The BP Interrupts register contains the 32 DI[i] bits."
width 10.
group.long 0x8++0x3
    line.long 0x00 "STOP_STAT,Channel Stop/Channel Status"
        hexmask.long.long 0x00 0.--32. 1. " DE ,This 32-bit register gives access to the BP (DSP) Enable bits, DE."
width 7.
rgroup.long 0xc++0x3
    line.long 0x00 "DSTART,Channel Start"
        hexmask.long.long 0x00 0.--32. 1. " DSTART_DE ,The DSTART_DE registers are 32 bits wide with one bit for every channel."
width 7.
rgroup.long 0x28++0x3
    line.long 0x00 "EVTERR,DMA Request Error Register"
        hexmask.long.long 0x00 0.--32. 1. " CHNERR ,This register is used by the SDMA to warn the BP when an incoming DMA request was detected; it then triggers a channel that is already pending or being serviced, which may mean there is an overflow of data for that channel."
width 9.
group.long 0x2c++0x3
    line.long 0x00 "INTRMASK,Channel DSP Interrupt Mask"
        hexmask.long.long 0x00 0.--32. 1. " DIMASK ,The Interrupt Mask Register contains 32 interrupt generation mask bits."
width 10.
rgroup.long 0x34++0x3
    line.long 0x00 "EVTERRDBG,DMA Request Error Register"
        hexmask.long.long 0x00 0.--32. 1. " CHNERR ,This register is the same as EVTERR except reading it does not clear its contents."


tree.end



;--------------------------------------------------------------------------------
; SDMACORE
;--------------------------------------------------------------------------------
tree "SDMACORE"
    base ad:0x020ec000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "MC0PTR,ARM platform Channel 0 Pointer"
        hexmask.long.long 0x00 0.--32. 1. " MC0PTR ,Contains the address-in the ARM platform memory space-of the initial SDMA context and scripts that are loaded by the SDMA boot script running on channel 0."
width 6.
rgroup.long 0x2++0x3
    line.long 0x00 "CCPTR,Current Channel Pointer"
        hexmask.long.word 0x00 0.--16. 1. " CCPTR ,Contains the start address of the context data for the current channel: Its value is CONTEXT_BASE + 24* CCR or CONTEXT_BASE + 32* CCR where CONTEXT_BASE = 0x0800."
width 4.
rgroup.long 0x3++0x3
    line.long 0x00 "CCR,Current Channel Register"
        hexmask.long.byte 0x00 0.--5. 1. " CCR ,Contains the number of the current running channel whose context is installed."
width 4.
rgroup.long 0x4++0x3
    line.long 0x00 "NCR,Highest Pending Channel Register"
        hexmask.long.byte 0x00 0.--5. 1. " NCR ,Contains the number of the pending channel that the scheduler has selected to run next."
width 7.
rgroup.long 0x5++0x3
    line.long 0x00 "EVENTS,External DMA Requests Mirror"
        hexmask.long.long 0x00 0.--32. 1. " EVENTS ,Reflects the status of the SDMA's external DMA requests."
width 6.
rgroup.long 0x6++0x3
    line.long 0x00 "CCPRI,Current Channel Priority"
        hexmask.long.byte 0x00 0.--3. 1. " CCPRI ,Contains the 3-bit priority of the channel whose context is installed."
width 6.
rgroup.long 0x7++0x3
    line.long 0x00 "NCPRI,Next Channel Priority"
        hexmask.long.byte 0x00 0.--3. 1. " NCPRI ,Contains the 3-bit priority of the channel the scheduler has selected to run next."
width 7.
group.long 0x9++0x3
    line.long 0x00 "ECOUNT,OnCE Event Cell Counter"
        hexmask.long.word 0x00 0.--16. 1. " ECOUNT ,The event cell counter contains the number of times minus one that an event detection must occur before generating a debug request."
width 5.
group.long 0xa++0x3
    line.long 0x00 "ECTL,OnCE Event Cell Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " ATS ,The access type select bits define the memory access type required on the SDMA memory bus."
        textline "    "
        hexmask.long.byte 0x00 2.--4. 1. " AATC ,The Address A Trigger Condition (AATC) controls the operations performed by address comparator A."
        textline "    "
        hexmask.long.byte 0x00 4.--6. 1. " ABTC ,The Address B Trigger Condition (ABTC) controls the operations performed by address comparator B."
        textline "    "
        hexmask.long.byte 0x00 6.--8. 1. " ATC ,The address trigger condition bits select how the two address conditions (addressA and addressB) are combined to define the global address matching condition."
        textline "    "
        hexmask.long.byte 0x00 8.--10. 1. " DTC ,The data trigger condition bits define when data is considered matching after comparison with the data register of the event detection unit."
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ECTC ,The event cell trigger condition bits select the combination of address and data matching conditions that generate the final address/data condition."
        textline "    "
        bitfld.long 0x00 12. " CNT ,Event Counter Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " EN ,Event Cell Enable." "0,1"
width 4.
group.long 0xb++0x3
    line.long 0x00 "EAA,OnCE Event Address Register A"
        hexmask.long.word 0x00 0.--16. 1. " EAA ,Event Cell Address Register A computes an address A condition."
width 4.
group.long 0xc++0x3
    line.long 0x00 "EAB,OnCE Event Cell Address Register B"
        hexmask.long.word 0x00 0.--16. 1. " EAB ,Event Cell Address Register B computes an address B condition."
width 4.
group.long 0xd++0x3
    line.long 0x00 "EAM,OnCE Event Cell Address Mask"
        hexmask.long.word 0x00 0.--16. 1. " EAM ,The Event Cell Address Mask contains a user-defined address mask value."
width 3.
group.long 0xe++0x3
    line.long 0x00 "ED,OnCE Event Cell Data Register"
        hexmask.long.long 0x00 0.--32. 1. " ED ,The event cell data register contains a user defined data value."
width 4.
group.long 0xf++0x3
    line.long 0x00 "EDM,OnCE Event Cell Data Mask"
        hexmask.long.long 0x00 0.--32. 1. " EDM ,The event cell data mask register contains the user-defined data mask value."
width 4.
group.long 0x18++0x3
    line.long 0x00 "RTB,OnCE Real-Time Buffer"
        hexmask.long.long 0x00 0.--32. 1. " RTB ,The Real Time Buffer register stores and retrieves run time information without putting the SDMA in debug mode."
width 3.
rgroup.long 0x19++0x3
    line.long 0x00 "TB,OnCE Trace Buffer"
        hexmask.long.word 0x00 0.--14. 1. " CHFADDR ,The change of flow address is the address where the change of flow is taken when executing a change of flow instruction."
        textline "  "
        hexmask.long.word 0x00 14.--28. 1. " TADDR ,The target address is the address taken after the execution of the change of flow instruction."
        textline "  "
        bitfld.long 0x00 28. " TBF ,The Trace Buffer Flag is set when the buffer contains the addresses of a valid change of flow." "0,1"
width 6.
rgroup.long 0x1a++0x3
    line.long 0x00 "OSTAT,OnCE Status"
        hexmask.long.byte 0x00 0.--3. 1. " ECDR ,Event Cell Debug Request."
        textline "     "
        bitfld.long 0x00 7. " MST ,This flag is raised when the OnCE is controlled from the ARM platform peripheral interface." "0,1"
        textline "     "
        bitfld.long 0x00 8. " SWB ,This flag is raised when the SDMA has entered debug mode after a software breakpoint." "0,1"
        textline "     "
        bitfld.long 0x00 9. " ODR ,This flag is raised when the SDMA has entered debug mode after a OnCE debug request." "0,1"
        textline "     "
        bitfld.long 0x00 10. " EDR ,This flag is raised when the SDMA has entered debug mode after an external debug request." "0,1"
        textline "     "
        bitfld.long 0x00 11. " RCV ,After each write access to the real time buffer (RTB), the RCV bit is set." "0,1"
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " PST ,The Processor Status bits reflect the state of the SDMA RISC engine."
width 10.
rgroup.long 0x1c++0x3
    line.long 0x00 "MCHN0ADDR,Channel 0 Boot Address"
        hexmask.long.word 0x00 0.--14. 1. " CHN0ADDR ,Contains the address of the channel 0 routine programmed by the ARM platform; it is loaded into a general register at the very start of the boot and the SDMA jumps to the address it contains."
        textline "         "
        bitfld.long 0x00 14. " SMSZ ,The bit 14 (Scratch Memory Size) determines if scratch memory must be available after every channel context." "0,1"
width 11.
rgroup.long 0x1d++0x3
    line.long 0x00 "ENDIANNESS,ENDIAN Status Register"
        bitfld.long 0x00 0. " APEND ,APEND indicates the endian mode of the Peripheral and Burst DMA interfaces." "0,1"
width 10.
rgroup.long 0x1e++0x3
    line.long 0x00 "SDMA_LOCK,Lock Status Register"
        bitfld.long 0x00 0. " LOCK ,The LOCK bit reports the value of the LOCK bit in the SDMA_LOCK status register." "0,1"
width 8.
rgroup.long 0x1f++0x3
    line.long 0x00 "EVENTS2,External DMA Requests Mirror #2"
        hexmask.long.word 0x00 0.--16. 1. " EVENTS ,Reflects the status of the SDMA's external DMA requests."


tree.end



;--------------------------------------------------------------------------------
; SJC
;--------------------------------------------------------------------------------
tree "SJC"
    base ad:0x00000000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "GPUSR1,General Purpose Unsecured Status Register 1"
        bitfld.long 0x00 0. " A_DBG ,ARM core debug status bit Bit 0 is the ARM core DBGACK (debug acknowledge) DBGACK can be overwritten in the ARM core DCR to force a particular DBGACK value." "0,1"
        textline "      "
        bitfld.long 0x00 1. " A_WFI ,ARM core wait-for interrupt bit Bit 1 is the ARM core standbywfi (stand by wait-for interrupt)." "0,1"
        textline "      "
        hexmask.long.byte 0x00 2.--5. 1. " S_STAT ,3 LSBits of SDMA core statusH."
        textline "      "
        bitfld.long 0x00 8. " PLL_LOCK ,PLL_LOCK A Combined PLL-Lock flag indicator, for all the PLL's." "0,1"
width 7.
rgroup.long 0x1++0x3
    line.long 0x00 "GPUSR2,General Purpose Unsecured Status Register 2"
        hexmask.long.byte 0x00 0.--4. 1. " STBYWFI ,STBYWFI[3:0] These bits provide status of ""Standby Wait-For-Interrupt"" state of all ARM cores."
        textline "      "
        hexmask.long.byte 0x00 4.--8. 1. " S_STAT ,S_STAT[3:0] SDMA debug status bits: debug_core_state[3:0]"
        textline "      "
        hexmask.long.byte 0x00 8.--12. 1. " STBYWFE ,STBYWFE[3:0] Reflecting the ""Standby Wait For Event"" signals of all cores."
width 7.
rgroup.long 0x2++0x3
    line.long 0x00 "GPUSR3,General Purpose Unsecured Status Register 3"
        bitfld.long 0x00 0. " IPG_WAIT ,IPG_WAIT CCM's ""ipg_wait"" signal indication" "0,1"
        textline "      "
        bitfld.long 0x00 1. " IPG_STOP ,IPG_STOP CCM's ""ipg_stop"" signal indication" "0,1"
        textline "      "
        bitfld.long 0x00 2. " SYS_WAIT ,System In wait Indication on System in wait mode (from CCM)." "0,1"
width 6.
rgroup.long 0x3++0x3
    line.long 0x00 "GPSSR,General Purpose Secured Status Register"
        hexmask.long.long 0x00 0.--32. 1. " GPSSR ,General Purpose Secured Status Register Register is used for testing and debug."
width 4.
group.long 0x4++0x3
    line.long 0x00 "DCR,Debug Control Register"
        bitfld.long 0x00 0. " DE_TO_ARM ,ARM platform debug request input propagation This bit controls the propagation of debug request to ARM platform (""dbgreq""), when the JTAG state machine is put in ""ENTER_DEBUG"" IR instruction." "0,1"
        textline "   "
        bitfld.long 0x00 1. " DE_TO_SDMA ,SDMA debug request input propagation This bit controls the propagation of debug request to SDMA, when the JTAG state machine is put in ""ENTER_DEBUG"" IR instruction.." "0,1"
        textline "   "
        bitfld.long 0x00 3. " DEBUG_OBS ,Debug observability This bit controls the propagation of the ""system debug"" input to SJC For i.MX 6x, the SJC's ""system_debug"" input is tied to logic HIGH value, therefore, set of ""debug_obs"" bit, will result in unconditional assertion of DE_B pad." "0,1"
        textline "   "
        bitfld.long 0x00 5. " DIRECT_SDMA_REQ_EN ,Debug enable of the sdma debug request This bit controls the propagation of debug request DE_B to the sdma." "0,1"
        textline "   "
        bitfld.long 0x00 6. " DIRECT_ARM_REQ_EN ,Pass Debug Enable event from DE_B pin to ARM platform debug request signal(s)." "0,1"
width 4.
rgroup.long 0x5++0x3
    line.long 0x00 "SSR,Security Status Register"
        bitfld.long 0x00 0. " KTF ,Kill Trace Enable fuse value" "0,1"
        textline "   "
        bitfld.long 0x00 1. " KTA ,Kill Trace is active" "0,1"
        textline "   "
        bitfld.long 0x00 2. " SWF ,Software JTAG enable fuse Status of the no SW disable JTAG fuse" "0,1"
        textline "   "
        bitfld.long 0x00 3. " SWE ,SW enable SW JTAG enable status" "0,1"
        textline "   "
        bitfld.long 0x00 4. " EBF ,External Boot fuse Status of the external boot disable fuse" "0,1"
        textline "   "
        bitfld.long 0x00 5. " EBG ,External boot granted External boot enabled, requested and granted" "0,1"
        textline "   "
        bitfld.long 0x00 8. " FT ,Fuse type Fuse type bit - e-fuse or laser fuse" "0,1"
        textline "   "
        hexmask.long.byte 0x00 9.--11. 1. " SJM ,SJC Secure mode Secure JTAG mode, as set by external fuses."
        textline "   "
        hexmask.long.byte 0x00 11.--13. 1. " RSSTAT ,Response status Response status bits"
        textline "   "
        bitfld.long 0x00 14. " BOOTIND ,Boot Indication Inverted Internal Boot indication, i.e inverse of SRC: ""src_int_boot"" signal" "0,1"
width 6.
group.long 0x7++0x3
    line.long 0x00 "GPCCR,General Purpose Clocks Control Register"
        bitfld.long 0x00 0. " SCLKR ,SDMA Clock ON Register - This bit forces the clock on of the SDMA" "0,1"
        textline "     "
        bitfld.long 0x00 1. " ACLKOFFDIS ,Disable/prevent ARM platform clock/power shutdown" "0,1"


tree.end



;--------------------------------------------------------------------------------
; SNVS
;--------------------------------------------------------------------------------
tree "SNVS"
    base ad:0x020cc000

width 5.
group.long 0x0++0x3
    line.long 0x00 "HPLR,SNVS _HP Lock Register"
        bitfld.long 0x00 0. " ZMK_WSL ,Zeroizable Master Key Write Soft Lock When set, prevents any writes (software and hardware) to the ZMK registers and MASTER_KEY_SEL, ZMK_HWP, ZMK_VAL, and ZMK_ECC_EN fields of the LPMKCR." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ZMK_RSL ,Zeroizable Master Key Read Soft Lock When set, prevents any software reads to the ZMK Registers and ZMK_ECC_VALUE field of the LPMKCR." "0,1"
        textline "    "
        bitfld.long 0x00 2. " SRTC_SL ,Secure Real Time Counter Soft Lock When set, prevents any writes to the SRTC Registers, SRTC_ENV, and SRTC_INV_EN bits." "0,1"
        textline "    "
        bitfld.long 0x00 3. " LPCALB_SL ,LP Calibration Soft Lock When set, prevents any writes to the LP Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)." "0,1"
        textline "    "
        bitfld.long 0x00 4. " MC_SL ,Monotonic Counter Soft Lock When set, prevents any writes (increments) to the MC Registers and MC_ENV bit." "0,1"
        textline "    "
        bitfld.long 0x00 5. " GPR_SL ,General Purpose Register Soft Lock When set, prevents any writes to the GPR." "0,1"
        textline "    "
        bitfld.long 0x00 6. " LPSVCR_SL ,LP Security Violation Control Register Soft Lock When set, prevents any writes to the LPSVCR." "0,1"
        textline "    "
        bitfld.long 0x00 7. " LPTGFCR_SL ,LP Tamper Glitch Filter Configuration Register Soft Lock When set, prevents any writes to the LPTGFCR." "0,1"
        textline "    "
        bitfld.long 0x00 8. " LPTDCR_SL ,LP Tamper Detectors Configuration Register Soft Lock When set, prevents any writes to the LPTDCR." "0,1"
        textline "    "
        bitfld.long 0x00 9. " MKS_SL ,Master Key Select Soft Lock When set, prevents any writes to the MASTER_KEY_SEL field of the LPMKCR." "0,1"
        textline "    "
        bitfld.long 0x00 16. " HPSVCR_L ,HP Security Violation Control Register Lock When set, prevents any writes to the HPSVCR." "0,1"
        textline "    "
        bitfld.long 0x00 17. " HPSICR_L ,HP Security Interrupt Control Register Lock When set, prevents any writes to the HPSICR." "0,1"
        textline "    "
        bitfld.long 0x00 18. " HAC_L ,High Assurance Configuration Lock When set, prevents any writes to HPHACIVR, HPHACR, and HAC_EN bit of HPCOMR." "0,1"
width 7.
group.long 0x4++0x3
    line.long 0x00 "HPCOMR,SNVS _HP Command Register"
        bitfld.long 0x00 0. " SSM_ST ,SSM State Transition Transition state of the system security monitor." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SSM_ST_DIS ,SSM Secure to Trusted State Transition Disable When set, disables the SSM transition from secure to trusted state." "0,1"
        textline "      "
        bitfld.long 0x00 2. " SSM_SFNS_DIS ,SSM Soft Fail to Non-Secure State Transition Disable When set, it disables the SSM transition from soft fail to non-secure state." "0,1"
        textline "      "
        bitfld.long 0x00 4. " LP_SWR ,LP Software Reset When set, it resets the SNVS _LP section." "0,1"
        textline "      "
        bitfld.long 0x00 5. " LP_SWR_DIS ,LP Software Reset Disable When set, disables the LP software reset." "0,1"
        textline "      "
        bitfld.long 0x00 8. " SW_SV ,Software Security Violation When set, the system security monitor treats this bit as a non-fatal security violation." "0,1"
        textline "      "
        bitfld.long 0x00 9. " SW_FSV ,Software Fatal Security Violation When set, the system security monitor treats this bit as a fatal security violation." "0,1"
        textline "      "
        bitfld.long 0x00 10. " SW_LPSV ,LP Software Security Violation When set, SNVS _LP treats this bit as a security violation." "0,1"
        textline "      "
        bitfld.long 0x00 12. " PROG_ZMK ,Program Zeroizable Master Key This bit activates ZMK hardware programming mechanism." "0,1"
        textline "      "
        bitfld.long 0x00 13. " MKS_EN ,Master Key Select Enable When not set, the one time programmable (OTP) master key is selected by default." "0,1"
        textline "      "
        bitfld.long 0x00 16. " HAC_EN ,High Assurance Configuration Enable This bit controls the SSM transition from the soft fail to the hard fail state." "0,1"
        textline "      "
        bitfld.long 0x00 17. " HAC_LOAD ,High Assurance Counter Load When set, it loads the High Assurance Counter Register with the value of the High Assurance Counter Load Register." "0,1"
        textline "      "
        bitfld.long 0x00 18. " HAC_CLEAR ,High Assurance Counter Clear When set, it clears the High Assurance Counter Register." "0,1"
        textline "      "
        bitfld.long 0x00 19. " HAC_STOP ,High Assurance Counter Stop This bit can be set only when SSM is in soft fail state." "0,1"
        textline "      "
        bitfld.long 0x00 31. " NPSWA_EN ,Non-Privileged Software Access Enable When set, allows non-privileged software to access all SNVS registers, including those that are privileged software read/write access only." "0,1"
width 5.
group.long 0x8++0x3
    line.long 0x00 "HPCR,SNVS_HP Control Register"
        bitfld.long 0x00 0. " RTC_EN ,HP Real Time Counter Enable" "0,1"
        textline "    "
        bitfld.long 0x00 1. " HPTA_EN ,HP Time Alarm Enable When set, the time alarm interrupt is generated if the value in the HP Time Alarm Registers is equal to the value of the HP Real Time Counter." "0,1"
        textline "    "
        bitfld.long 0x00 3. " PI_EN ,HP Periodic Interrupt Enable The periodic interrupt can be generated only if the HP Real Time Counter is enabled." "0,1"
        textline "    "
        hexmask.long.byte 0x00 4.--8. 1. " PI_FREQ ,Periodic Interrupt Frequency Defines frequency of the periodic interrupt."
        textline "    "
        bitfld.long 0x00 8. " HPCALB_EN ,HP Real Time Counter Calibration Enabled Indicates that the time calibration mechanism is enabled." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--15. 1. " HPCALB_VAL ,HP Calibration Value Defines signed calibration value for the HP Real Time Counter."
        textline "    "
        bitfld.long 0x00 16. " HP_TS ,HP Time Synchronize When set, this updates the HP Time Counter with the LP Time Counter value." "0,1"
width 7.
group.long 0xc++0x3
    line.long 0x00 "HPSICR,SNVS _HP Security Interrupt Control Register"
        bitfld.long 0x00 0. " SVI_EN0 ,Security Violation Interrupt 0 Enable This bit enables generation of the security interrupt to the host processor upon security violation detection on input port 0." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SVI_EN1 ,Security Violation Interrupt 1 Enable This bit enables generation of the security interrupt to the host processor upon security violation detection on input port 1." "0,1"
        textline "      "
        bitfld.long 0x00 2. " SVI_EN2 ,Security Violation Interrupt 2 Enable This bit enables generation of the security interrupt to the host processor upon security violation detection on input port 2." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SVI_EN3 ,Security Violation Interrupt 3 Enable This bit enables generation of the security interrupt to the host processor upon security violation detection on input port 3." "0,1"
        textline "      "
        bitfld.long 0x00 4. " SVI_EN4 ,Security Violation Interrupt 4 Enable This bit enables generation of the security interrupt to the host processor upon security violation detection on input port 4." "0,1"
        textline "      "
        bitfld.long 0x00 5. " SVI_EN5 ,Security Violation Interrupt 5 Enable This bit enables generation of the security interrupt to the host processor upon security violation detection on input port 5." "0,1"
        textline "      "
        bitfld.long 0x00 31. " LPSVI_EN ,LP Security Violation Interrupt Enable This bit enables generating of the security interrupt to the host processor upon security violation signal from the LP section." "0,1"
width 7.
group.long 0x10++0x3
    line.long 0x00 "HPSVCR,SNVS _HP Security Violation Control Register"
        bitfld.long 0x00 0. " SV_CFG0 ,Security Violation Input 0 Configuration This field configures the security violation input 0." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SV_CFG1 ,Security Violation Input 1 Configuration This field configures the Security Violation Input 1." "0,1"
        textline "      "
        bitfld.long 0x00 2. " SV_CFG2 ,Security Violation Input 2 Configuration This field configures the security violation input 2." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SV_CFG3 ,Security Violation Input 3 Configuration This field configures the security violation input 3." "0,1"
        textline "      "
        bitfld.long 0x00 4. " SV_CFG4 ,Security Violation Input 4 Configuration This field configures the security violation Input 4." "0,1"
        textline "      "
        hexmask.long.byte 0x00 5.--7. 1. " SV_CFG5 ,Security Violation Input 5 Configuration This field configures the Security Violation Input 5."
        textline "      "
        hexmask.long.byte 0x00 30.--32. 1. " LPSV_CFG ,LP Security Violation Configuration This field configures the LP security violation source."
width 5.
group.long 0x14++0x3
    line.long 0x00 "HPSR,SNVS _HP Status Register"
        bitfld.long 0x00 0. " HPTA ,HP Time Alarm Indicates that the HP Time Alarm has occurred since this bit was last cleared." "0,1"
        textline "    "
        bitfld.long 0x00 1. " PI ,Periodic Interrupt Indicates that periodic interrupt has occurred since this bit was last cleared." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LPDIS ,Low Power Disable If 1, the SNVS low power section has been disabled by means of an input signal to the SNVS ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--12. 1. " SSM_ST ,System Security Monitor State This field contains the encoded state of the SSM's state machine."
        textline "    "
        hexmask.long.byte 0x00 12.--15. 1. " SYS_SECURITY_CFG ,This field reflects the value of the sys_security_cfg input signal, which is defined as follows:"
        textline "    "
        bitfld.long 0x00 15. " SYS_SECURE_BOOT ,This bit reflects the value of the sys_secure_boot input signal to SNVS ." "0,1"
        textline "    "
        hexmask.long.word 0x00 16.--25. 1. " OTPMK_SYNDROME ,One Time Programmable Master Key Syndrome Value The eight lower bits of this value indicate error location in case of a single-bit error."
        textline "    "
        bitfld.long 0x00 27. " OTPMK_ZERO ,One Time Programmable Master Key is Equal to Zero." "0,1"
        textline "    "
        bitfld.long 0x00 31. " ZMK_ZERO ,Zeroizable Master Key is Equal to Zero." "0,1"
width 7.
group.long 0x18++0x3
    line.long 0x00 "HPSVSR,SNVS _HP Security Violation Status Register"
        bitfld.long 0x00 0. " SEC_VIO0 ,Security violation on input 0 is detected." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SEC_VIO1 ,Security violation on input 1 is detected." "0,1"
        textline "      "
        bitfld.long 0x00 2. " SEC_VIO2 ,Security violation on input 2 is detected." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SEC_VIO3 ,Security violation on input 3 is detected." "0,1"
        textline "      "
        bitfld.long 0x00 4. " SEC_VIO4 ,Security violation on input 4 is detected." "0,1"
        textline "      "
        bitfld.long 0x00 5. " SEC_VIO5 ,Security volation on input 5 is detected." "0,1"
        textline "      "
        hexmask.long.word 0x00 16.--25. 1. " ZMK_SYNDROME ,Zeroizable Master Key Syndrome Value The ZMK syndrome indicates error location and parity similar to the OTPMK syndrome ."
        textline "      "
        bitfld.long 0x00 27. " ZMK_ECC_FAIL ,Zeroizable Master Key Error Correcting Code Check Failure When set, this bit triggers a bad key violation to the SSM and a security violation to the SNVS _LP section, which clears security sensitive data." "0,1"
width 9.
group.long 0x1c++0x3
    line.long 0x00 "HPHACIVR,SNVS _HP High Assurance Counter IV Register"
        hexmask.long.long 0x00 0.--32. 1. " HAC_COUNTER_IV ,High Assurance Counter Initial Value This register is used to set the starting count value to the high assurance counter."
width 7.
group.long 0x20++0x3
    line.long 0x00 "HPHACR,SNVS _HP High Assurance Counter Register"
        hexmask.long.long 0x00 0.--32. 1. " HAC_COUNTER ,High Assurance Counter When the HAC_EN bit is set and the SSM is in the soft fail state, this counter starts to count down with the system clock."
width 8.
group.long 0x24++0x3
    line.long 0x00 "HPRTCMR,SNVS_HP Real Time Counter MSB Register"
        hexmask.long.word 0x00 0.--15. 1. " RTC ,HP Real Time Counter Most significant 15 bits."
width 8.
group.long 0x28++0x3
    line.long 0x00 "HPRTCLR,SNVS_HP Real Time Counter LSB Register"
        hexmask.long.long 0x00 0.--32. 1. " RTC ,HP Real Time Counter Least significant 32 bits."
width 7.
group.long 0x2c++0x3
    line.long 0x00 "HPTAMR,SNVS_HP Time Alarm MSB Register"
        hexmask.long.word 0x00 0.--15. 1. " HPTA ,HP Time Alarm Most significant 15 bits."
width 7.
group.long 0x30++0x3
    line.long 0x00 "HPTALR,SNVS_HP Time Alarm LSB Register"
        hexmask.long.long 0x00 0.--32. 1. " HPTA ,HP Time Alarm Least significant bits."
width 5.
group.long 0x34++0x3
    line.long 0x00 "LPLR,SNVS _LP Lock Register"
        bitfld.long 0x00 0. " ZMK_WHL ,Zeroizable Master Key Write Hard Lock When set, prevents any writes (software and hardware) to the ZMK registers and ZMK_HWP, ZMK_VAL, and ZMK_ECC_EN fields of the LPMKCR." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ZMK_RHL ,Zeroizable Master Key Read Hard Lock When set, prevents any software reads to the ZMK registers and ZMK_ECC_VALUE field of the LPMKCR." "0,1"
        textline "    "
        bitfld.long 0x00 2. " SRTC_HL ,Secure Real Time Counter Hard Lock When set, prevents any writes to the SRTC registers, SRTC_ENV, and SRTC_INV_EN bits." "0,1"
        textline "    "
        bitfld.long 0x00 3. " LPCALB_HL ,LP Calibration Hard Lock When set, prevents any writes to the LP Calibration Value (LPCALB_VAL) and LP Calibration Enable (LPCALB_EN)." "0,1"
        textline "    "
        bitfld.long 0x00 4. " MC_HL ,Monotonic Counter Hard Lock When set, prevents any writes (increments) to the MC Registers and MC_ENV bit." "0,1"
        textline "    "
        bitfld.long 0x00 5. " GPR_HL ,General Purpose Register Hard Lock When set, prevents any writes to the GPR." "0,1"
        textline "    "
        bitfld.long 0x00 6. " LPSVCR_HL ,LP Security Violation Control Register Hard Lock When set, prevents any writes to the LPSVCR." "0,1"
        textline "    "
        bitfld.long 0x00 7. " LPTGFCR_HL ,LP Tamper Glitch Filter Configuration Register Hard Lock When set, prevents any writes to the LPTGFCR." "0,1"
        textline "    "
        bitfld.long 0x00 8. " LPTDCR_HL ,LP Tamper Detectors Configuration Register Hard Lock When set, prevents any writes to the LPTDCR." "0,1"
        textline "    "
        bitfld.long 0x00 9. " MKS_HL ,Master Key Select Hard Lock When set, prevents any writes to the MASTER_KEY_SEL field of the LP Master Key Control Register." "0,1"
width 5.
group.long 0x38++0x3
    line.long 0x00 "LPCR,SNVS_LP Control Register"
        bitfld.long 0x00 0. " SRTC_ENV ,Secure Real Time Counter Enable and Valid When set, the SRTC becomes operational." "0,1"
        textline "    "
        bitfld.long 0x00 1. " LPTA_EN ,LP Time Alarm Enable When set, the SNVS functional interrupt is asserted if the LP Time Alarm Register is equal to the 32 MSBs of the secure real time counter." "0,1"
        textline "    "
        bitfld.long 0x00 2. " MC_ENV ,Monotonic Counter Enable and Valid When set, the MC can be incremented (by write transaction to the LPSMCMR or LPSMCLR)." "0,1"
        textline "    "
        bitfld.long 0x00 3. " LPWUI_EN ,LP Wake-Up Interrupt Enable This interrupt line should be connected to the external pin and is intended to inform the external chip about an SNVS _LP event (tamper event, MC rollover, SRTC rollover, or time alarm )." "0,1"
        textline "    "
        bitfld.long 0x00 4. " SRTC_INV_EN ,Secure Real Time Counter Invalidation Enable When set, the SRTC is invalidated (SRTC_ENV bit is cleared) in the case of security violation." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DP_EN ,Dumb PMIC Enabled" "0,1"
        textline "    "
        bitfld.long 0x00 6. " TOP ,Turn of System Power Asserting this bit causes a signal to be sent to the Power Management IC to turn off the system power." "0,1"
        textline "    "
        bitfld.long 0x00 8. " LPCALB_EN ,LP Calibration Enable When set, enables the SRTC calibration mechanism." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--15. 1. " LPCALB_VAL ,LP Calibration Value Defines signed calibration value for SRTC."
width 7.
group.long 0x3c++0x3
    line.long 0x00 "LPMKCR,SNVS_LP Master Key Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " MASTER_KEY_SEL ,Master Key Select These bits select the SNVS Master Key output when Master Key Select bits are enabled by MKS_EN bit in the HPCOMR ."
        textline "      "
        bitfld.long 0x00 2. " ZMK_HWP ,Zeroizable Master Key hardware Programming mode When set, only the hardware key programming mechanism can set the ZMK and software cannot read it." "0,1"
        textline "      "
        bitfld.long 0x00 3. " ZMK_VAL ,Zeroizable Master Key Valid When set, the ZMK value can be selected by the master key control block for use by cryptographic modules." "0,1"
        textline "      "
        bitfld.long 0x00 4. " ZMK_ECC_EN ,Zeroizable Master Key Error Correcting Code Check Enable Writing one to this field automatically calculates and sets the ZMK ECC value in the ZMK_ECC_VALUE field of this register." "0,1"
        textline "      "
        hexmask.long.word 0x00 7.--16. 1. " ZMK_ECC_VALUE ,Zeroizable Master Key Error Correcting Code Value This field is automatically calculated and set when one is written into ZMK_ECC_EN bit of this register."
width 7.
group.long 0x40++0x3
    line.long 0x00 "LPSVCR,SNVS_LP Security Violation Control Register"
        bitfld.long 0x00 0. " SV_EN0 ,Security Violation 0 Enable This bit enables security violation input 0." "0,1"
        textline "      "
        bitfld.long 0x00 1. " SV_EN1 ,Security Violation 1 Enable This bit enables security violation input 1." "0,1"
        textline "      "
        bitfld.long 0x00 2. " SV_EN2 ,Security Violation 2 Enable This bit enables security violation input 2." "0,1"
        textline "      "
        bitfld.long 0x00 3. " SV_EN3 ,Security Violation 3 Enable This bit enables security violation input 3." "0,1"
        textline "      "
        bitfld.long 0x00 4. " SV_EN4 ,Security Violation 4 Enable This bit enables security violation input 4." "0,1"
        textline "      "
        bitfld.long 0x00 5. " SV_EN5 ,Security Violation 5 Enable This bit enables security violation input 5." "0,1"
width 8.
group.long 0x44++0x3
    line.long 0x00 "LPTGFCR,SNVS_LP Tamper Glitch Filters Configuration Register"
        hexmask.long.byte 0x00 16.--21. 1. " ETGF1 ,External Tamper Glitch Filter 1 Configures the length of the digital glitch filter for the external tamper 1 pin between 128 and 8064 SRTC clock cycles."
        textline "       "
        bitfld.long 0x00 23. " ETGF1_EN ,External Tamper Glitch Filter 1 Enable When set, enables the external tamper glitch filter 1." "0,1"
width 7.
group.long 0x48++0x3
    line.long 0x00 "LPTDCR,SNVS_LP Tamper Detectors Configuration Register"
        bitfld.long 0x00 1. " SRTCR_EN ,SRTC Rollover Enable When set, an SRTC rollover event generates an LP security violation." "0,1"
        textline "      "
        bitfld.long 0x00 2. " MCR_EN ,MC Rollover Enable When set, an MC Rollover event generates an LP security violation." "0,1"
        textline "      "
        bitfld.long 0x00 9. " ET1_EN ,External Tampering 1 Enable When set, external tampering 1 detection generates an LP security violation." "0,1"
        textline "      "
        bitfld.long 0x00 14. " PFD_OBSERV ,System Power Fail Detector (PFD) Observability Flop The asynchronous reset input of this flop is connected directly to the inverted output of the PFD analog circuitry (external to the SNVS block)." "0,1"
        textline "      "
        bitfld.long 0x00 15. " POR_OBSERV ,Power On Reset (POR) Observability Flop The asynchronous reset input of this flop is connected directly to the output of the POR analog circuitry (external to the SNVS block)." "0,1"
width 5.
group.long 0x4c++0x3
    line.long 0x00 "LPSR,SNVS _LP Status Register"
        bitfld.long 0x00 0. " LPTA ,LP Time Alarm." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SRTCR ,Secure Real Time Counter Rollover." "0,1"
        textline "    "
        bitfld.long 0x00 2. " MCR ,Monotonic Counter Rollover." "0,1"
        textline "    "
        bitfld.long 0x00 3. " PGD ,Power Supply Glitch Detected." "0,1"
        textline "    "
        bitfld.long 0x00 9. " ET1D ,External Tampering 1 Detected." "0,1"
        textline "    "
        bitfld.long 0x00 16. " ESVD ,External Security Violation Detected Indicates that a security violation is detected on one of the HP security violation ports." "0,1"
        textline "    "
        bitfld.long 0x00 17. " EO ,Emergency Off This bit is set when a power off is requested." "0,1"
        textline "    "
        bitfld.long 0x00 18. " SPO ,Set Power Off This bit is set when power off was requested by a button press, but the button was not pressed for 5 seconds." "0,1"
        textline "    "
        bitfld.long 0x00 20. " SED ,Scan Exit Detected" "0,1"
        textline "    "
        bitfld.long 0x00 30. " LPNS ,LP Section is Non-Secured Indicates that LP section was provisioned/programmed in the non-secure state." "0,1"
        textline "    "
        bitfld.long 0x00 31. " LPS ,LP Section is Secured Indicates that the LP section is provisioned/programmed in the secure or trusted state." "0,1"
width 9.
group.long 0x50++0x3
    line.long 0x00 "LPSRTCMR,SNVS_LP Secure Real Time Counter MSB Register"
        hexmask.long.word 0x00 0.--15. 1. " SRTC ,LP Secure Real Time Counter most significant 15 bits This register can be programmed only when SRTC is not active and not locked, meaning the SRTC_ENV, SRTC_SL, and SRTC_HL bits are not set."
width 9.
group.long 0x54++0x3
    line.long 0x00 "LPSRTCLR,SNVS_LP Secure Real Time Counter LSB Register"
        hexmask.long.long 0x00 0.--32. 1. " SRTC ,LP Secure Real Time Counter least significant 32 bits This register can be programmed only when SRTC is not active and not locked, meaning the SRTC_ENV, SRTC_SL, and SRTC_HL bits are not set."
width 6.
group.long 0x58++0x3
    line.long 0x00 "LPTAR,SNVS_LP Time Alarm Register"
        hexmask.long.long 0x00 0.--32. 1. " LPTA ,LP Time Alarm This register can be programmed only when the LP time alarm is disabled (LPTA_EN bit is not set)."
width 8.
group.long 0x5c++0x3
    line.long 0x00 "LPSMCMR,SNVS_LP Secure Monotonic Counter MSB Register"
        hexmask.long.word 0x00 0.--16. 1. " MON_COUNTER ,Monotonic Counter Most Significant 16 Bits The MC is incremented by one when: A write transaction to the LPSMCMR or LPSMCLR register is detected."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " MC_ERA_BITS ,Monotonic Counter Era Bits These bits are inputs to the module and typically connect to fuses."
width 8.
group.long 0x60++0x3
    line.long 0x00 "LPSMCLR,SNVS_LP Secure Monotonic Counter LSB Register"
        hexmask.long.long 0x00 0.--32. 1. " MON_COUNTER ,Monotonic Counter bits The MC is incremented by one when: A write transaction to the LPSMCMR or LPSMCLR Register is detected."
width 7.
group.long 0x64++0x3
    line.long 0x00 "LPPGDR,SNVS _LP Power Glitch Detector Register"
        hexmask.long.long 0x00 0.--32. 1. " PGD ,Power Glitch Detector Value"
width 6.
group.long 0x68++0x3
    line.long 0x00 "LPGPR,SNVS_LP General Purpose Register"
        hexmask.long.long 0x00 0.--32. 1. " GPR ,General Purpose Register When GPR_SL or GPR_HL bit is set, the register cannot be programmed."
width 8.
group.long 0x6c++0x3
    line.long 0x00 "LPZMKR0,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x70++0x3
    line.long 0x00 "LPZMKR1,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x74++0x3
    line.long 0x00 "LPZMKR2,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x78++0x3
    line.long 0x00 "LPZMKR3,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x7c++0x3
    line.long 0x00 "LPZMKR4,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x80++0x3
    line.long 0x00 "LPZMKR5,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x84++0x3
    line.long 0x00 "LPZMKR6,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
group.long 0x88++0x3
    line.long 0x00 "LPZMKR7,SNVS_LP Zeroizable Master Key Register n"
        hexmask.long.long 0x00 0.--32. 1. " ZMK ,Zeroizable Master Key Each of these registers contains part of the 256-bit ZMK value: LPZMKR0 - ZMK[ 31-0 ] LPZMKR1 - ZMK[ 63-32 ] LPZMKR2 - ZMK[ 95-64 ] LPZMKR3 - ZMK[ 127-96 ] LPZMKR4 - ZMK[ 159-128 ] LPZMKR5 - ZMK[ 191-160 ] LPZMKR6 - ZMK[ 223-192 ] LPZMKR7 - ZMK[ 255-224 ]"
width 8.
rgroup.long 0xbf8++0x3
    line.long 0x00 "HPVIDR1,SNVS _HP Version ID Register 1"
        hexmask.long.byte 0x00 0.--8. 1. " MINOR_REV ,SNVS block minor version number"
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " MAJOR_REV ,SNVS block major version number"
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " IP_ID ,SNVS block ID"
width 8.
rgroup.long 0xbfc++0x3
    line.long 0x00 "HPVIDR2,SNVS _HP Version ID Register 2"
        hexmask.long.byte 0x00 0.--8. 1. " CONFIG_OPT ,SNVS Configuration Option"
        textline "       "
        hexmask.long.byte 0x00 8.--16. 1. " ECO_REV ,SNVS ECO Revision"
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " INTG_OPT ,SNVS Integration Option"


tree.end



;--------------------------------------------------------------------------------
; SPBA
;--------------------------------------------------------------------------------
tree "SPBA"
    base ad:0x0203c000

width 5.
group.long 0x0++0x3
    line.long 0x00 "PRR0,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x4++0x3
    line.long 0x00 "PRR1,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x8++0x3
    line.long 0x00 "PRR2,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0xc++0x3
    line.long 0x00 "PRR3,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x10++0x3
    line.long 0x00 "PRR4,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x14++0x3
    line.long 0x00 "PRR5,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x18++0x3
    line.long 0x00 "PRR6,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x1c++0x3
    line.long 0x00 "PRR7,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x20++0x3
    line.long 0x00 "PRR8,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 5.
group.long 0x24++0x3
    line.long 0x00 "PRR9,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "    "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "    "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x28++0x3
    line.long 0x00 "PRR10,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x2c++0x3
    line.long 0x00 "PRR11,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x30++0x3
    line.long 0x00 "PRR12,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x34++0x3
    line.long 0x00 "PRR13,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x38++0x3
    line.long 0x00 "PRR14,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x3c++0x3
    line.long 0x00 "PRR15,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x40++0x3
    line.long 0x00 "PRR16,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x44++0x3
    line.long 0x00 "PRR17,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x48++0x3
    line.long 0x00 "PRR18,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x4c++0x3
    line.long 0x00 "PRR19,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x50++0x3
    line.long 0x00 "PRR20,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x54++0x3
    line.long 0x00 "PRR21,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x58++0x3
    line.long 0x00 "PRR22,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x5c++0x3
    line.long 0x00 "PRR23,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x60++0x3
    line.long 0x00 "PRR24,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x64++0x3
    line.long 0x00 "PRR25,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x68++0x3
    line.long 0x00 "PRR26,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x6c++0x3
    line.long 0x00 "PRR27,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x70++0x3
    line.long 0x00 "PRR28,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x74++0x3
    line.long 0x00 "PRR29,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x78++0x3
    line.long 0x00 "PRR30,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."
width 6.
group.long 0x7c++0x3
    line.long 0x00 "PRR31,Peripheral Rights Register"
        bitfld.long 0x00 0. " RARA ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 1. " RARB ,Resource Access Right." "0,1"
        textline "     "
        bitfld.long 0x00 2. " RARC ,Resource Access Right." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--18. 1. " ROI ,Resource Owner ID."
        textline "     "
        hexmask.long.byte 0x00 30.--32. 1. " RMO ,Requesting Master Owner."


tree.end



;--------------------------------------------------------------------------------
; SPDIF
;--------------------------------------------------------------------------------
tree "SPDIF"
    base ad:0x02004000

width 4.
group.long 0x0++0x3
    line.long 0x00 "SCR,SPDIF Configuration Register"
        hexmask.long.byte 0x00 0.--2. 1. " USRC_SEL ,"
        textline "   "
        hexmask.long.byte 0x00 2.--5. 1. " TXSEL ,"
        textline "   "
        bitfld.long 0x00 5. " VALCTRL ," "0,1"
        textline "   "
        bitfld.long 0x00 8. " DMA_TX_EN ,DMA Transmit Request Enable (Tx FIFO empty)" "0,1"
        textline "   "
        bitfld.long 0x00 9. " DMA_RX_EN ,DMA Receive Request Enable (RX FIFO full)" "0,1"
        textline "   "
        hexmask.long.byte 0x00 10.--12. 1. " TXFIFO_CTRL ,"
        textline "   "
        bitfld.long 0x00 12. " SOFT_RESET ,When write 1 to this bit, it will cause SPDIF software reset." "0,1"
        textline "   "
        bitfld.long 0x00 13. " LOW_POWER ,When write 1 to this bit, it will cause SPDIF enter low-power mode." "0,1"
        textline "   "
        hexmask.long.byte 0x00 15.--17. 1. " TXFIFOEMPTY_SEL ,"
        textline "   "
        bitfld.long 0x00 17. " TXAUTOSYNC ," "0,1"
        textline "   "
        bitfld.long 0x00 18. " RXAUTOSYNC ," "0,1"
        textline "   "
        hexmask.long.byte 0x00 19.--21. 1. " RXFIFOFULL_SEL ,"
        textline "   "
        bitfld.long 0x00 21. " RXFIFO_RST ," "0,1"
        textline "   "
        bitfld.long 0x00 22. " RXFIFO_OFF_ON ," "0,1"
        textline "   "
        bitfld.long 0x00 23. " RXFIFO_CTRL ," "0,1"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 5.
group.long 0x4++0x3
    line.long 0x00 "SRCD,CDText Control Register"
        bitfld.long 0x00 1. " USYNCMODE ," "0,1"
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 5.
group.long 0x8++0x3
    line.long 0x00 "SRPC,PhaseConfig Register"
        hexmask.long.byte 0x00 3.--6. 1. " GAINSEL ,Gain selection:"
        textline "    "
        bitfld.long 0x00 6. " LOCK ,LOCK bit to show that the internal DPLL is locked, read only" "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--11. 1. " CLKSRC_SEL ,Clock source selection, all other settings not shown are reserved:"
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
group.long 0xc++0x3
    line.long 0x00 "SIE,InterruptEn Register"
        bitfld.long 0x00 0. " RXFIFOFUL ,SPDIF Rx FIFO full, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 1. " TXEM ,SPDIF Tx FIFO empty, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 2. " LOCKLOSS ,SPDIF receiver loss of lock" "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFIFORESYN ,Rx FIFO resync" "0,1"
        textline "   "
        bitfld.long 0x00 4. " RXFIFOUNOV ,Rx FIFO underrun/overrun" "0,1"
        textline "   "
        bitfld.long 0x00 5. " UQERR ,U/Q Channel framing error" "0,1"
        textline "   "
        bitfld.long 0x00 6. " UQSYNC ,U/Q Channel sync found" "0,1"
        textline "   "
        bitfld.long 0x00 7. " QRXOV ,Q Channel receive register overrun" "0,1"
        textline "   "
        bitfld.long 0x00 8. " QRXFUL ,Q Channel receive register full, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 9. " URXOV ,U Channel receive register overrun" "0,1"
        textline "   "
        bitfld.long 0x00 10. " URXFUL ,U Channel receive register full, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 14. " BITERR ,SPDIF receiver found parity bit error" "0,1"
        textline "   "
        bitfld.long 0x00 15. " SYMERR ,SPDIF receiver found illegal symbol" "0,1"
        textline "   "
        bitfld.long 0x00 16. " VALNOGOOD ,SPDIF validity flag no good" "0,1"
        textline "   "
        bitfld.long 0x00 17. " CNEW ,SPDIF receive change in value of control channel" "0,1"
        textline "   "
        bitfld.long 0x00 18. " TXRESYN ,SPDIF Tx FIFO resync" "0,1"
        textline "   "
        bitfld.long 0x00 19. " TXUNOV ,SPDIF Tx FIFO under/overrun" "0,1"
        textline "   "
        bitfld.long 0x00 20. " LOCK ,SPDIF receiver's DPLL is locked" "0,1"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
rgroup.long 0x10++0x3
    line.long 0x00 "SIS,InterruptStat Register"
        bitfld.long 0x00 0. " RXFIFOFUL ,SPDIF Rx FIFO full, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 1. " TXEM ,SPDIF Tx FIFO empty, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 2. " LOCKLOSS ,SPDIF receiver loss of lock" "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFIFORESYN ,Rx FIFO resync" "0,1"
        textline "   "
        bitfld.long 0x00 4. " RXFIFOUNOV ,Rx FIFO underrun/overrun" "0,1"
        textline "   "
        bitfld.long 0x00 5. " UQERR ,U/Q Channel framing error" "0,1"
        textline "   "
        bitfld.long 0x00 6. " UQSYNC ,U/Q Channel sync found" "0,1"
        textline "   "
        bitfld.long 0x00 7. " QRXOV ,Q Channel receive register overrun" "0,1"
        textline "   "
        bitfld.long 0x00 8. " QRXFUL ,Q Channel receive register full, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 9. " URXOV ,U Channel receive register overrun" "0,1"
        textline "   "
        bitfld.long 0x00 10. " URXFUL ,U Channel receive register full, can't be cleared with reg." "0,1"
        textline "   "
        bitfld.long 0x00 14. " BITERR ,SPDIF receiver found parity bit error" "0,1"
        textline "   "
        bitfld.long 0x00 15. " SYMERR ,SPDIF receiver found illegal symbol" "0,1"
        textline "   "
        bitfld.long 0x00 16. " VALNOGOOD ,SPDIF validity flag no good" "0,1"
        textline "   "
        bitfld.long 0x00 17. " CNEW ,SPDIF receive change in value of control channel" "0,1"
        textline "   "
        bitfld.long 0x00 18. " TXRESYN ,SPDIF Tx FIFO resync" "0,1"
        textline "   "
        bitfld.long 0x00 19. " TXUNOV ,SPDIF Tx FIFO under/overrun" "0,1"
        textline "   "
        bitfld.long 0x00 20. " LOCK ,SPDIF receiver's DPLL is locked" "0,1"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
wgroup.long 0x10++0x3
    line.long 0x00 "SIC,InterruptClear Register"
        bitfld.long 0x00 2. " LOCKLOSS ,SPDIF receiver loss of lock" "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFIFORESYN ,Rx FIFO resync" "0,1"
        textline "   "
        bitfld.long 0x00 4. " RXFIFOUNOV ,Rx FIFO underrun/overrun" "0,1"
        textline "   "
        bitfld.long 0x00 5. " UQERR ,U/Q Channel framing error" "0,1"
        textline "   "
        bitfld.long 0x00 6. " UQSYNC ,U/Q Channel sync found" "0,1"
        textline "   "
        bitfld.long 0x00 7. " QRXOV ,Q Channel receive register overrun" "0,1"
        textline "   "
        bitfld.long 0x00 9. " URXOV ,U Channel receive register overrun" "0,1"
        textline "   "
        bitfld.long 0x00 14. " BITERR ,SPDIF receiver found parity bit error" "0,1"
        textline "   "
        bitfld.long 0x00 15. " SYMERR ,SPDIF receiver found illegal symbol" "0,1"
        textline "   "
        bitfld.long 0x00 16. " VALNOGOOD ,SPDIF validity flag no good" "0,1"
        textline "   "
        bitfld.long 0x00 17. " CNEW ,SPDIF receive change in value of control channel" "0,1"
        textline "   "
        bitfld.long 0x00 18. " TXRESYN ,SPDIF Tx FIFO resync" "0,1"
        textline "   "
        bitfld.long 0x00 19. " TXUNOV ,SPDIF Tx FIFO under/overrun" "0,1"
        textline "   "
        bitfld.long 0x00 20. " LOCK ,SPDIF receiver's DPLL is locked" "0,1"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
rgroup.long 0x14++0x3
    line.long 0x00 "SRL,SPDIFRxLeft Register"
        hexmask.long.long 0x00 0.--24. 1. " RXDATALEFT ,Processor receive SPDIF data left"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
rgroup.long 0x18++0x3
    line.long 0x00 "SRR,SPDIFRxRight Register"
        hexmask.long.long 0x00 0.--24. 1. " RXDATARIGHT ,Processor receive SPDIF data right"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 6.
rgroup.long 0x1c++0x3
    line.long 0x00 "SRCSH,SPDIFRxCChannel_h Register"
        hexmask.long.long 0x00 0.--24. 1. " RXCCHANNEL_H ,SPDIF receive C channel register, contains first 24 bits of C channel without interpretation"
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 6.
rgroup.long 0x20++0x3
    line.long 0x00 "SRCSL,SPDIFRxCChannel_l Register"
        hexmask.long.long 0x00 0.--24. 1. " RXCCHANNEL_L ,SPDIF receive C channel register, contains next 24 bits of C channel without interpretation"
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
rgroup.long 0x24++0x3
    line.long 0x00 "SRU,UchannelRx Register"
        hexmask.long.long 0x00 0.--24. 1. " RXUCHANNEL ,SPDIF receive U channel register, contains next 3 U channel bytes"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,This is a 24-bit register the upper byte is unimplemented."
width 4.
rgroup.long 0x28++0x3
    line.long 0x00 "SRQ,QchannelRx Register"
        hexmask.long.long 0x00 0.--24. 1. " RXQCHANNEL ,SPDIF receive Q channel register, contains next 3 Q channel bytes"
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
wgroup.long 0x2c++0x3
    line.long 0x00 "STL,SPDIFTxLeft Register"
        hexmask.long.long 0x00 0.--24. 1. " TXDATALEFT ,SPDIF transmit left channel data."
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,This is a 24-bit register the upper byte is unimplemented."
width 4.
wgroup.long 0x30++0x3
    line.long 0x00 "STR,SPDIFTxRight Register"
        hexmask.long.long 0x00 0.--24. 1. " TXDATARIGHT ,SPDIF transmit right channel data."
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,This is a 24-bit register the upper byte is unimplemented."
width 7.
group.long 0x34++0x3
    line.long 0x00 "STCSCH,SPDIFTxCChannelCons_h Register"
        hexmask.long.long 0x00 0.--24. 1. " TXCCHANNELCONS_H ,SPDIF transmit Cons."
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 7.
group.long 0x38++0x3
    line.long 0x00 "STCSCL,SPDIFTxCChannelCons_l Register"
        hexmask.long.long 0x00 0.--24. 1. " TXCCHANNELCONS_L ,SPDIF transmit Cons."
        textline "      "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 5.
rgroup.long 0x44++0x3
    line.long 0x00 "SRFM,FreqMeas Register"
        hexmask.long.long 0x00 0.--24. 1. " FREQMEAS ,Frequency measurement data"
        textline "    "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"
width 4.
group.long 0x50++0x3
    line.long 0x00 "STC,SPDIFTxClk Register"
        hexmask.long.byte 0x00 0.--7. 1. " TXCLK_DF ,Divider factor (1-128)"
        textline "   "
        bitfld.long 0x00 7. " TX_ALL_CLK_EN ,Spdif transfer clock enable.When data is going to be transfered, this bit should be set to1." "0,1"
        textline "   "
        hexmask.long.byte 0x00 8.--11. 1. " TXCLK_SOURCE ,"
        textline "   "
        hexmask.long.word 0x00 11.--20. 1. " SYSCLK_DF ,system clock divider factor, 2~512."
        textline "   "
        hexmask.long.byte 0x00 24.--32. 1. " UNIMPLEMENTED ,"


tree.end



;--------------------------------------------------------------------------------
; SRC
;--------------------------------------------------------------------------------
tree "SRC"
    base ad:0x020d8000

width 4.
group.long 0x0++0x3
    line.long 0x00 "SCR,SRC Control Register"
        bitfld.long 0x00 0. " WARM_RESET_ENABLE ,WARM reset enable bit." "0,1"
        textline "   "
        bitfld.long 0x00 1. " SW_GPU_RST ,Software reset for gpu this is a self clearing bit." "0,1"
        textline "   "
        bitfld.long 0x00 2. " SW_VPU_RST ,Software reset for vpu this is a self clearing bit." "0,1"
        textline "   "
        bitfld.long 0x00 3. " SW_IPU1_RST ,Software reset for ipu1 Note: this is a self clearing bit." "0,1"
        textline "   "
        bitfld.long 0x00 4. " SW_OPEN_VG_RST ,Software reset for open_vg This is a self clearing bit." "0,1"
        textline "   "
        hexmask.long.byte 0x00 5.--7. 1. " WARM_RST_BYPASS_COUNT ,Defines the ckil cycles to count before bypassing the MMDC acknowledge for WARM reset."
        textline "   "
        hexmask.long.byte 0x00 7.--11. 1. " MASK_WDOG_RST ,Mask wdog_rst_b source."
        textline "   "
        bitfld.long 0x00 11. " EIM_RST ,EIM reset is needed in order to reconfigure the eim chip select." "0,1"
        textline "   "
        bitfld.long 0x00 13. " CORE0_RST ,Software reset for core0 only." "0,1"
        textline "   "
        bitfld.long 0x00 14. " CORE1_RST ,Software reset for core1 only." "0,1"
        textline "   "
        bitfld.long 0x00 17. " CORE0_DBG_RST ,Software reset for core0 debug only." "0,1"
        textline "   "
        bitfld.long 0x00 18. " CORE1_DBG_RST ,Software reset for core1 debug only." "0,1"
        textline "   "
        bitfld.long 0x00 21. " CORES_DBG_RST ,Software reset for debug of arm platform only." "0,1"
        textline "   "
        bitfld.long 0x00 22. " CORE1_ENABLE ,CPU core1 enable." "0,1"
        textline "   "
        bitfld.long 0x00 25. " DBG_RST_MSK_PG ,Do not assert debug resets after power gating event of cpu" "0,1"
width 6.
rgroup.long 0x4++0x3
    line.long 0x00 "SBMR1,SRC Boot Mode Register 1"
        hexmask.long.byte 0x00 0.--8. 1. " BOOT_CFG1 ,Please refer to fuse map."
        textline "     "
        hexmask.long.byte 0x00 8.--16. 1. " BOOT_CFG2 ,Please refer to fuse map."
        textline "     "
        hexmask.long.byte 0x00 16.--24. 1. " BOOT_CFG3 ,Please refer to fuse map."
        textline "     "
        hexmask.long.byte 0x00 24.--32. 1. " BOOT_CFG4 ,Please refer to fuse map."
width 5.
group.long 0x8++0x3
    line.long 0x00 "SRSR,SRC Reset Status Register"
        bitfld.long 0x00 0. " IPP_RESET_B ,Indicates whether reset was the result of ipp_reset_b pin (Power-up sequence)" "0,1"
        textline "    "
        bitfld.long 0x00 2. " CSU_RESET_B ,Indicates whether the reset was the result of the csu_reset_b input." "0,1"
        textline "    "
        bitfld.long 0x00 3. " IPP_USER_RESET_B ,Indicates whether the reset was the result of the ipp_user_reset_b qualified reset." "0,1"
        textline "    "
        bitfld.long 0x00 4. " WDOG_RST_B ,IC Watchdog Time-out reset." "0,1"
        textline "    "
        bitfld.long 0x00 5. " JTAG_RST_B ,HIGH - Z JTAG reset." "0,1"
        textline "    "
        bitfld.long 0x00 6. " JTAG_SW_RST ,JTAG SW reset." "0,1"
        textline "    "
        bitfld.long 0x00 16. " WARM_BOOT ,WARM boot indication shows that WARM boot was initiated by software." "0,1"
width 5.
rgroup.long 0x14++0x3
    line.long 0x00 "SISR,SRC Interrupt Status Register"
        bitfld.long 0x00 0. " GPU_PASSED_RESET ,Interrupt generated to indicate that gpu passed software reset and is ready to be used" "0,1"
        textline "    "
        bitfld.long 0x00 1. " VPU_PASSED_RESET ,Interrupt generated to indicate that vpu passed software reset and is ready to be used" "0,1"
        textline "    "
        bitfld.long 0x00 2. " IPU1_PASSED_RESET ,Interrupt generated to indicate that ipu passed software reset and is ready to be used" "0,1"
        textline "    "
        bitfld.long 0x00 3. " OPEN_VG_PASSED_RESET ,Interrupt generated to indicate that open_vg passed software reset and is ready to be used" "0,1"
        textline "    "
        bitfld.long 0x00 5. " CORE0_WDOG_RST_REQ ,WDOG reset request from CPU core0." "0,1"
        textline "    "
        bitfld.long 0x00 6. " CORE1_WDOG_RST_REQ ,WDOG reset request from CPU core1." "0,1"
width 5.
group.long 0x18++0x3
    line.long 0x00 "SIMR,SRC Interrupt Mask Register"
        bitfld.long 0x00 0. " MASK_GPU_PASSED_RESET ,mask interrupt generation due to gpu passed reset" "0,1"
        textline "    "
        bitfld.long 0x00 1. " MASK_VPU_PASSED_RESET ,mask interrupt generation due to vpu passed reset" "0,1"
        textline "    "
        bitfld.long 0x00 2. " MASK_IPU_PASSED_RESET ,mask interrupt generation due to ipu passed reset" "0,1"
        textline "    "
        bitfld.long 0x00 3. " MASK_OPEN_VG_PASSED_RESET ,mask interrupt generation due to open_vg passed reset" "0,1"
width 6.
rgroup.long 0x1c++0x3
    line.long 0x00 "SBMR2,SRC Boot Mode Register 2"
        hexmask.long.byte 0x00 0.--2. 1. " SEC_CONFIG ,Please refer to fuse map."
        textline "     "
        bitfld.long 0x00 3. " DIR_BT_DIS ,Please refer to fuse map." "0,1"
        textline "     "
        bitfld.long 0x00 4. " BT_FUSE_SEL ,BT_FUSE_SEL (connected to gpio bt_fuse_sel)" "0,1"
        textline "     "
        hexmask.long.byte 0x00 24.--26. 1. " BMOD ,Please refer to fuse map."
        textline "     "
        hexmask.long.byte 0x00 27.--30. 1. " TEST_MODE ,Please refer to fuse map."
width 5.
group.long 0x20++0x3
    line.long 0x00 "GPR1,SRC General Purpose Register 1"
width 5.
group.long 0x24++0x3
    line.long 0x00 "GPR2,SRC General Purpose Register 2"
width 5.
group.long 0x28++0x3
    line.long 0x00 "GPR3,SRC General Purpose Register 3"
width 5.
group.long 0x2c++0x3
    line.long 0x00 "GPR4,SRC General Purpose Register 4"
width 5.
group.long 0x30++0x3
    line.long 0x00 "GPR5,SRC General Purpose Register 5"
width 5.
group.long 0x34++0x3
    line.long 0x00 "GPR6,SRC General Purpose Register 6"
width 5.
group.long 0x38++0x3
    line.long 0x00 "GPR7,SRC General Purpose Register 7"
width 5.
group.long 0x3c++0x3
    line.long 0x00 "GPR8,SRC General Purpose Register 8"
width 5.
group.long 0x40++0x3
    line.long 0x00 "GPR9,SRC General Purpose Register 9"
width 6.
group.long 0x44++0x3
    line.long 0x00 "GPR10,SRC General Purpose Register 10"


tree.end



;--------------------------------------------------------------------------------
; SSI
;--------------------------------------------------------------------------------
tree.open "SSI"
    tree "SSI1"
        base ad:0x02028000

width 5.
group.long 0x0++0x3
    line.long 0x00 "STX0,SSI Transmit Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " STXN ,SSI Transmit Data."
width 5.
group.long 0x4++0x3
    line.long 0x00 "STX1,SSI Transmit Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " STXN ,SSI Transmit Data."
width 5.
rgroup.long 0x8++0x3
    line.long 0x00 "SRX0,SSI Receive Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " SRXN ,SSI Receive Data."
width 5.
rgroup.long 0xc++0x3
    line.long 0x00 "SRX1,SSI Receive Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " SRXN ,SSI Receive Data."
width 4.
group.long 0x10++0x3
    line.long 0x00 "SCR,SSI Control Register"
        bitfld.long 0x00 0. " SSIEN ,SSIEN - SSI Enable This bit is used to enable/disable the SSI." "0,1"
        textline "   "
        bitfld.long 0x00 1. " TE ,Transmit Enable." "0,1"
        textline "   "
        bitfld.long 0x00 2. " RE ,Receive Enable." "0,1"
        textline "   "
        bitfld.long 0x00 3. " NET ,Network Mode." "0,1"
        textline "   "
        bitfld.long 0x00 4. " SYN ,Synchronous Mode." "0,1"
        textline "   "
        hexmask.long.byte 0x00 5.--7. 1. " I2S_MODE ,I2S Mode Select."
        textline "   "
        bitfld.long 0x00 7. " SYS_CLK_EN ,Network Clock (Oversampling Clock) Enable." "0,1"
        textline "   "
        bitfld.long 0x00 8. " TCH_EN ,Two-Channel Operation Enable." "0,1"
        textline "   "
        bitfld.long 0x00 9. " CLK_IST ,Clock Idle State." "0,1"
        textline "   "
        bitfld.long 0x00 10. " TFR_CLK_DIS ,Transmit Frame Clock Disable." "0,1"
        textline "   "
        bitfld.long 0x00 11. " RFR_CLK_DIS ,Receive Frame Clock Disable." "0,1"
        textline "   "
        bitfld.long 0x00 12. " SYNC_TX_FS ,SYNC_FS_TX bit provides a safe window for TE to be visible to the internal circuit which is just after FS occurrence." "0,1"
width 5.
group.long 0x14++0x3
    line.long 0x00 "SISR,SSI Interrupt Status Register"
        bitfld.long 0x00 0. " TFE0 ,Transmit FIFO Empty 0." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFE1 ,Transmit FIFO Empty 1." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFF0 ,Receive FIFO Full 0." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RFF1 ,Receive FIFO Full 1." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RLS ,Receive Last Time Slot." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TLS ,Transmit Last Time Slot." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFS ,Receive Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFS ,Transmit Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TUE0 ,Transmitter Underrun Error 0." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TUE1 ,Transmitter Underrun Error 1." "0,1"
        textline "    "
        bitfld.long 0x00 10. " ROE0 ,Receiver Overrun Error 0." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ROE1 ,Receiver Overrun Error 1." "0,1"
        textline "    "
        bitfld.long 0x00 12. " TDE0 ,Transmit Data Register Empty 0." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TDE1 ,Transmit Data Register Empty 1." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RDR0 ,Receive Data Ready 0." "0,1"
        textline "    "
        bitfld.long 0x00 15. " RDR1 ,Receive Data Ready 1." "0,1"
        textline "    "
        bitfld.long 0x00 16. " RXT ,Receive Tag Updated." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CMDDU ,Command Data Register Updated." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CMDAU ,Command Address Register Updated." "0,1"
        textline "    "
        bitfld.long 0x00 23. " TFRC ,Transmit Frame Complete." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RFRC ,Receive Frame Complete." "0,1"
width 5.
group.long 0x18++0x3
    line.long 0x00 "SIER,SSI Interrupt Enable Register"
        bitfld.long 0x00 0. " TFE0IE ,Transmit FIFO Empty 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFE1IE ,Transmit FIFO Empty 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFF0IE ,Receive FIFO Full 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RFF1IE ,Receive FIFO Full 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RLSIE ,Receive Last Time Slot Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TLSIE ,Transmit Last Time Slot Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFSIE ,Receive Frame Sync Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFSIE ,Transmit Frame Sync Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TUE0IE ,Transmitter Underrun Error 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TUE1IE ,Transmitter Underrun Error 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 10. " ROE0IE ,Receiver Overrun Error 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ROE1IE ,Receiver Overrun Error 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " TDE0IE ,Transmit Data Register Empty 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TDE1IE ,Transmit Data Register Empty 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RDR0IE ,Receive Data Ready 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 15. " RDR1IE ,Receive Data Ready 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 16. " RXTIE ,Receive Tag Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CMDDUIE ,Command Data Register Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CMDAUIE ,Command Address Register Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 19. " TIE ,Transmit Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 20. " TDMAE ,Transmit DMA Enable." "0,1"
        textline "    "
        bitfld.long 0x00 21. " RIE ,Receive Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 22. " RDMAE ,Receive DMA Enable." "0,1"
        textline "    "
        bitfld.long 0x00 23. " TFRCIE ,Transmit Frame Complete Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RFRCIE ,Receive Frame Complete Interrupt Enable." "0,1"
width 5.
group.long 0x1c++0x3
    line.long 0x00 "STCR,SSI Transmit Configuration Register"
        bitfld.long 0x00 0. " TEFS ,Transmit Early Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFSL ,Transmit Frame Sync Length." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TFSI ,Transmit Frame Sync Invert." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TSCKP ,Transmit Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 4. " TSHFD ,Transmit Shift Direction." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TXDIR ,Transmit Clock Direction." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TFDIR ,Transmit Frame Direction." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFEN0 ,Transmit FIFO Enable 0." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TFEN1 ,Transmit FIFO Enable 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TXBIT0 ,Transmit Bit 0." "0,1"
width 5.
group.long 0x20++0x3
    line.long 0x00 "SRCR,SSI Receive Configuration Register"
        bitfld.long 0x00 0. " REFS ,Receive Early Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RFSL ,Receive Frame Sync Length." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFSI ,Receive Frame Sync Invert." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RSCKP ,Receive Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RSHFD ,Receive Shift Direction." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RXDIR ,Receive Clock Direction." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFDIR ,Receive Frame Direction." "0,1"
        textline "    "
        bitfld.long 0x00 7. " RFEN0 ,Receive FIFO Enable 0." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RFEN1 ,Receive FIFO Enable 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RXBIT0 ,Receive Bit 0." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RXEXT ,Receive Data Extension." "0,1"
width 6.
group.long 0x24++0x3
    line.long 0x00 "STCCR,SSI Transmit Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PM7_PM0 ,Prescaler Modulus Select."
        textline "     "
        hexmask.long.byte 0x00 8.--13. 1. " DC4_DC0 ,Frame Rate Divider Control."
        textline "     "
        hexmask.long.byte 0x00 13.--17. 1. " WL3_WL0 ,Word Length Control."
        textline "     "
        bitfld.long 0x00 17. " PSR ,Prescaler Range." "0,1"
        textline "     "
        bitfld.long 0x00 18. " DIV2 ,Divide By 2." "0,1"
width 6.
group.long 0x28++0x3
    line.long 0x00 "SRCCR,SSI Receive Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PM7_PM0 ,Prescaler Modulus Select."
        textline "     "
        hexmask.long.byte 0x00 8.--13. 1. " DC4_DC0 ,Frame Rate Divider Control."
        textline "     "
        hexmask.long.byte 0x00 13.--17. 1. " WL3_WL0 ,Word Length Control."
        textline "     "
        bitfld.long 0x00 17. " PSR ,Prescaler Range." "0,1"
        textline "     "
        bitfld.long 0x00 18. " DIV2 ,Divide By 2." "0,1"
width 6.
group.long 0x2c++0x3
    line.long 0x00 "SFCSR,SSI FIFO Control/Status Register"
        hexmask.long.byte 0x00 0.--4. 1. " TFWM0 ,Transmit FIFO Empty WaterMark 0."
        textline "     "
        hexmask.long.byte 0x00 4.--8. 1. " RFWM0 ,Receive FIFO Full WaterMark 0."
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " TFCNT0 ,Transmit FIFO Counter 0."
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RFCNT0 ,Receive FIFO Counter 0."
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " TFWM1 ,Transmit FIFO Empty WaterMark 1."
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " RFWM1 ,Receive FIFO Full WaterMark 1."
        textline "     "
        hexmask.long.byte 0x00 24.--28. 1. " TFCNT1 ,Transmit FIFO Counter1."
        textline "     "
        hexmask.long.byte 0x00 28.--32. 1. " RFCNT1 ,Receive FIFO Counter1."
width 6.
group.long 0x38++0x3
    line.long 0x00 "SACNT,SSI AC97 Control Register"
        bitfld.long 0x00 0. " AC97EN ,AC97 Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " FV ,Fixed/Variable Operation." "0,1"
        textline "     "
        bitfld.long 0x00 2. " TIF ,Tag in FIFO." "0,1"
        textline "     "
        bitfld.long 0x00 3. " RD ,Read Command." "0,1"
        textline "     "
        bitfld.long 0x00 4. " WR ,Write Command." "0,1"
        textline "     "
        hexmask.long.byte 0x00 5.--11. 1. " FRDIV ,Frame Rate Divider."
width 7.
group.long 0x3c++0x3
    line.long 0x00 "SACADD,SSI AC97 Command Address Register"
        hexmask.long.long 0x00 0.--19. 1. " SACADD ,AC97 Command Address."
width 7.
group.long 0x40++0x3
    line.long 0x00 "SACDAT,SSI AC97 Command Data Register"
        hexmask.long.long 0x00 0.--20. 1. " SACDAT ,AC97 Command Data."
width 6.
group.long 0x44++0x3
    line.long 0x00 "SATAG,SSI AC97 Tag Register"
        hexmask.long.word 0x00 0.--16. 1. " SATAG ,AC97 Tag Value."
width 6.
group.long 0x48++0x3
    line.long 0x00 "STMSK,SSI Transmit Time Slot Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " STMSK ,Transmit Mask."
width 6.
group.long 0x4c++0x3
    line.long 0x00 "SRMSK,SSI Receive Time Slot Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " SRMSK ,Receive Mask."
width 7.
rgroup.long 0x50++0x3
    line.long 0x00 "SACCST,SSI AC97 Channel Status Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCST ,AC97 Channel Status."
width 7.
wgroup.long 0x54++0x3
    line.long 0x00 "SACCEN,SSI AC97 Channel Enable Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCEN ,AC97 Channel Enable."
width 8.
wgroup.long 0x58++0x3
    line.long 0x00 "SACCDIS,SSI AC97 Channel Disable Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCDIS ,AC97 Channel Disable."


    tree.end
    tree "SSI2"
        base ad:0x0202c000

width 5.
group.long 0x0++0x3
    line.long 0x00 "STX0,SSI Transmit Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " STXN ,SSI Transmit Data."
width 5.
group.long 0x4++0x3
    line.long 0x00 "STX1,SSI Transmit Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " STXN ,SSI Transmit Data."
width 5.
rgroup.long 0x8++0x3
    line.long 0x00 "SRX0,SSI Receive Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " SRXN ,SSI Receive Data."
width 5.
rgroup.long 0xc++0x3
    line.long 0x00 "SRX1,SSI Receive Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " SRXN ,SSI Receive Data."
width 4.
group.long 0x10++0x3
    line.long 0x00 "SCR,SSI Control Register"
        bitfld.long 0x00 0. " SSIEN ,SSIEN - SSI Enable This bit is used to enable/disable the SSI." "0,1"
        textline "   "
        bitfld.long 0x00 1. " TE ,Transmit Enable." "0,1"
        textline "   "
        bitfld.long 0x00 2. " RE ,Receive Enable." "0,1"
        textline "   "
        bitfld.long 0x00 3. " NET ,Network Mode." "0,1"
        textline "   "
        bitfld.long 0x00 4. " SYN ,Synchronous Mode." "0,1"
        textline "   "
        hexmask.long.byte 0x00 5.--7. 1. " I2S_MODE ,I2S Mode Select."
        textline "   "
        bitfld.long 0x00 7. " SYS_CLK_EN ,Network Clock (Oversampling Clock) Enable." "0,1"
        textline "   "
        bitfld.long 0x00 8. " TCH_EN ,Two-Channel Operation Enable." "0,1"
        textline "   "
        bitfld.long 0x00 9. " CLK_IST ,Clock Idle State." "0,1"
        textline "   "
        bitfld.long 0x00 10. " TFR_CLK_DIS ,Transmit Frame Clock Disable." "0,1"
        textline "   "
        bitfld.long 0x00 11. " RFR_CLK_DIS ,Receive Frame Clock Disable." "0,1"
        textline "   "
        bitfld.long 0x00 12. " SYNC_TX_FS ,SYNC_FS_TX bit provides a safe window for TE to be visible to the internal circuit which is just after FS occurrence." "0,1"
width 5.
group.long 0x14++0x3
    line.long 0x00 "SISR,SSI Interrupt Status Register"
        bitfld.long 0x00 0. " TFE0 ,Transmit FIFO Empty 0." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFE1 ,Transmit FIFO Empty 1." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFF0 ,Receive FIFO Full 0." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RFF1 ,Receive FIFO Full 1." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RLS ,Receive Last Time Slot." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TLS ,Transmit Last Time Slot." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFS ,Receive Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFS ,Transmit Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TUE0 ,Transmitter Underrun Error 0." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TUE1 ,Transmitter Underrun Error 1." "0,1"
        textline "    "
        bitfld.long 0x00 10. " ROE0 ,Receiver Overrun Error 0." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ROE1 ,Receiver Overrun Error 1." "0,1"
        textline "    "
        bitfld.long 0x00 12. " TDE0 ,Transmit Data Register Empty 0." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TDE1 ,Transmit Data Register Empty 1." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RDR0 ,Receive Data Ready 0." "0,1"
        textline "    "
        bitfld.long 0x00 15. " RDR1 ,Receive Data Ready 1." "0,1"
        textline "    "
        bitfld.long 0x00 16. " RXT ,Receive Tag Updated." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CMDDU ,Command Data Register Updated." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CMDAU ,Command Address Register Updated." "0,1"
        textline "    "
        bitfld.long 0x00 23. " TFRC ,Transmit Frame Complete." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RFRC ,Receive Frame Complete." "0,1"
width 5.
group.long 0x18++0x3
    line.long 0x00 "SIER,SSI Interrupt Enable Register"
        bitfld.long 0x00 0. " TFE0IE ,Transmit FIFO Empty 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFE1IE ,Transmit FIFO Empty 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFF0IE ,Receive FIFO Full 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RFF1IE ,Receive FIFO Full 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RLSIE ,Receive Last Time Slot Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TLSIE ,Transmit Last Time Slot Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFSIE ,Receive Frame Sync Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFSIE ,Transmit Frame Sync Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TUE0IE ,Transmitter Underrun Error 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TUE1IE ,Transmitter Underrun Error 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 10. " ROE0IE ,Receiver Overrun Error 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ROE1IE ,Receiver Overrun Error 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " TDE0IE ,Transmit Data Register Empty 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TDE1IE ,Transmit Data Register Empty 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RDR0IE ,Receive Data Ready 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 15. " RDR1IE ,Receive Data Ready 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 16. " RXTIE ,Receive Tag Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CMDDUIE ,Command Data Register Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CMDAUIE ,Command Address Register Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 19. " TIE ,Transmit Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 20. " TDMAE ,Transmit DMA Enable." "0,1"
        textline "    "
        bitfld.long 0x00 21. " RIE ,Receive Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 22. " RDMAE ,Receive DMA Enable." "0,1"
        textline "    "
        bitfld.long 0x00 23. " TFRCIE ,Transmit Frame Complete Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RFRCIE ,Receive Frame Complete Interrupt Enable." "0,1"
width 5.
group.long 0x1c++0x3
    line.long 0x00 "STCR,SSI Transmit Configuration Register"
        bitfld.long 0x00 0. " TEFS ,Transmit Early Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFSL ,Transmit Frame Sync Length." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TFSI ,Transmit Frame Sync Invert." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TSCKP ,Transmit Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 4. " TSHFD ,Transmit Shift Direction." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TXDIR ,Transmit Clock Direction." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TFDIR ,Transmit Frame Direction." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFEN0 ,Transmit FIFO Enable 0." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TFEN1 ,Transmit FIFO Enable 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TXBIT0 ,Transmit Bit 0." "0,1"
width 5.
group.long 0x20++0x3
    line.long 0x00 "SRCR,SSI Receive Configuration Register"
        bitfld.long 0x00 0. " REFS ,Receive Early Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RFSL ,Receive Frame Sync Length." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFSI ,Receive Frame Sync Invert." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RSCKP ,Receive Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RSHFD ,Receive Shift Direction." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RXDIR ,Receive Clock Direction." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFDIR ,Receive Frame Direction." "0,1"
        textline "    "
        bitfld.long 0x00 7. " RFEN0 ,Receive FIFO Enable 0." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RFEN1 ,Receive FIFO Enable 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RXBIT0 ,Receive Bit 0." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RXEXT ,Receive Data Extension." "0,1"
width 6.
group.long 0x24++0x3
    line.long 0x00 "STCCR,SSI Transmit Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PM7_PM0 ,Prescaler Modulus Select."
        textline "     "
        hexmask.long.byte 0x00 8.--13. 1. " DC4_DC0 ,Frame Rate Divider Control."
        textline "     "
        hexmask.long.byte 0x00 13.--17. 1. " WL3_WL0 ,Word Length Control."
        textline "     "
        bitfld.long 0x00 17. " PSR ,Prescaler Range." "0,1"
        textline "     "
        bitfld.long 0x00 18. " DIV2 ,Divide By 2." "0,1"
width 6.
group.long 0x28++0x3
    line.long 0x00 "SRCCR,SSI Receive Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PM7_PM0 ,Prescaler Modulus Select."
        textline "     "
        hexmask.long.byte 0x00 8.--13. 1. " DC4_DC0 ,Frame Rate Divider Control."
        textline "     "
        hexmask.long.byte 0x00 13.--17. 1. " WL3_WL0 ,Word Length Control."
        textline "     "
        bitfld.long 0x00 17. " PSR ,Prescaler Range." "0,1"
        textline "     "
        bitfld.long 0x00 18. " DIV2 ,Divide By 2." "0,1"
width 6.
group.long 0x2c++0x3
    line.long 0x00 "SFCSR,SSI FIFO Control/Status Register"
        hexmask.long.byte 0x00 0.--4. 1. " TFWM0 ,Transmit FIFO Empty WaterMark 0."
        textline "     "
        hexmask.long.byte 0x00 4.--8. 1. " RFWM0 ,Receive FIFO Full WaterMark 0."
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " TFCNT0 ,Transmit FIFO Counter 0."
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RFCNT0 ,Receive FIFO Counter 0."
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " TFWM1 ,Transmit FIFO Empty WaterMark 1."
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " RFWM1 ,Receive FIFO Full WaterMark 1."
        textline "     "
        hexmask.long.byte 0x00 24.--28. 1. " TFCNT1 ,Transmit FIFO Counter1."
        textline "     "
        hexmask.long.byte 0x00 28.--32. 1. " RFCNT1 ,Receive FIFO Counter1."
width 6.
group.long 0x38++0x3
    line.long 0x00 "SACNT,SSI AC97 Control Register"
        bitfld.long 0x00 0. " AC97EN ,AC97 Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " FV ,Fixed/Variable Operation." "0,1"
        textline "     "
        bitfld.long 0x00 2. " TIF ,Tag in FIFO." "0,1"
        textline "     "
        bitfld.long 0x00 3. " RD ,Read Command." "0,1"
        textline "     "
        bitfld.long 0x00 4. " WR ,Write Command." "0,1"
        textline "     "
        hexmask.long.byte 0x00 5.--11. 1. " FRDIV ,Frame Rate Divider."
width 7.
group.long 0x3c++0x3
    line.long 0x00 "SACADD,SSI AC97 Command Address Register"
        hexmask.long.long 0x00 0.--19. 1. " SACADD ,AC97 Command Address."
width 7.
group.long 0x40++0x3
    line.long 0x00 "SACDAT,SSI AC97 Command Data Register"
        hexmask.long.long 0x00 0.--20. 1. " SACDAT ,AC97 Command Data."
width 6.
group.long 0x44++0x3
    line.long 0x00 "SATAG,SSI AC97 Tag Register"
        hexmask.long.word 0x00 0.--16. 1. " SATAG ,AC97 Tag Value."
width 6.
group.long 0x48++0x3
    line.long 0x00 "STMSK,SSI Transmit Time Slot Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " STMSK ,Transmit Mask."
width 6.
group.long 0x4c++0x3
    line.long 0x00 "SRMSK,SSI Receive Time Slot Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " SRMSK ,Receive Mask."
width 7.
rgroup.long 0x50++0x3
    line.long 0x00 "SACCST,SSI AC97 Channel Status Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCST ,AC97 Channel Status."
width 7.
wgroup.long 0x54++0x3
    line.long 0x00 "SACCEN,SSI AC97 Channel Enable Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCEN ,AC97 Channel Enable."
width 8.
wgroup.long 0x58++0x3
    line.long 0x00 "SACCDIS,SSI AC97 Channel Disable Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCDIS ,AC97 Channel Disable."


    tree.end
    tree "SSI3"
        base ad:0x02030000

width 5.
group.long 0x0++0x3
    line.long 0x00 "STX0,SSI Transmit Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " STXN ,SSI Transmit Data."
width 5.
group.long 0x4++0x3
    line.long 0x00 "STX1,SSI Transmit Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " STXN ,SSI Transmit Data."
width 5.
rgroup.long 0x8++0x3
    line.long 0x00 "SRX0,SSI Receive Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " SRXN ,SSI Receive Data."
width 5.
rgroup.long 0xc++0x3
    line.long 0x00 "SRX1,SSI Receive Data Register n"
        hexmask.long.long 0x00 0.--32. 1. " SRXN ,SSI Receive Data."
width 4.
group.long 0x10++0x3
    line.long 0x00 "SCR,SSI Control Register"
        bitfld.long 0x00 0. " SSIEN ,SSIEN - SSI Enable This bit is used to enable/disable the SSI." "0,1"
        textline "   "
        bitfld.long 0x00 1. " TE ,Transmit Enable." "0,1"
        textline "   "
        bitfld.long 0x00 2. " RE ,Receive Enable." "0,1"
        textline "   "
        bitfld.long 0x00 3. " NET ,Network Mode." "0,1"
        textline "   "
        bitfld.long 0x00 4. " SYN ,Synchronous Mode." "0,1"
        textline "   "
        hexmask.long.byte 0x00 5.--7. 1. " I2S_MODE ,I2S Mode Select."
        textline "   "
        bitfld.long 0x00 7. " SYS_CLK_EN ,Network Clock (Oversampling Clock) Enable." "0,1"
        textline "   "
        bitfld.long 0x00 8. " TCH_EN ,Two-Channel Operation Enable." "0,1"
        textline "   "
        bitfld.long 0x00 9. " CLK_IST ,Clock Idle State." "0,1"
        textline "   "
        bitfld.long 0x00 10. " TFR_CLK_DIS ,Transmit Frame Clock Disable." "0,1"
        textline "   "
        bitfld.long 0x00 11. " RFR_CLK_DIS ,Receive Frame Clock Disable." "0,1"
        textline "   "
        bitfld.long 0x00 12. " SYNC_TX_FS ,SYNC_FS_TX bit provides a safe window for TE to be visible to the internal circuit which is just after FS occurrence." "0,1"
width 5.
group.long 0x14++0x3
    line.long 0x00 "SISR,SSI Interrupt Status Register"
        bitfld.long 0x00 0. " TFE0 ,Transmit FIFO Empty 0." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFE1 ,Transmit FIFO Empty 1." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFF0 ,Receive FIFO Full 0." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RFF1 ,Receive FIFO Full 1." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RLS ,Receive Last Time Slot." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TLS ,Transmit Last Time Slot." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFS ,Receive Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFS ,Transmit Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TUE0 ,Transmitter Underrun Error 0." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TUE1 ,Transmitter Underrun Error 1." "0,1"
        textline "    "
        bitfld.long 0x00 10. " ROE0 ,Receiver Overrun Error 0." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ROE1 ,Receiver Overrun Error 1." "0,1"
        textline "    "
        bitfld.long 0x00 12. " TDE0 ,Transmit Data Register Empty 0." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TDE1 ,Transmit Data Register Empty 1." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RDR0 ,Receive Data Ready 0." "0,1"
        textline "    "
        bitfld.long 0x00 15. " RDR1 ,Receive Data Ready 1." "0,1"
        textline "    "
        bitfld.long 0x00 16. " RXT ,Receive Tag Updated." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CMDDU ,Command Data Register Updated." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CMDAU ,Command Address Register Updated." "0,1"
        textline "    "
        bitfld.long 0x00 23. " TFRC ,Transmit Frame Complete." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RFRC ,Receive Frame Complete." "0,1"
width 5.
group.long 0x18++0x3
    line.long 0x00 "SIER,SSI Interrupt Enable Register"
        bitfld.long 0x00 0. " TFE0IE ,Transmit FIFO Empty 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFE1IE ,Transmit FIFO Empty 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFF0IE ,Receive FIFO Full 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RFF1IE ,Receive FIFO Full 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RLSIE ,Receive Last Time Slot Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TLSIE ,Transmit Last Time Slot Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFSIE ,Receive Frame Sync Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFSIE ,Transmit Frame Sync Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TUE0IE ,Transmitter Underrun Error 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TUE1IE ,Transmitter Underrun Error 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 10. " ROE0IE ,Receiver Overrun Error 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ROE1IE ,Receiver Overrun Error 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " TDE0IE ,Transmit Data Register Empty 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TDE1IE ,Transmit Data Register Empty 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RDR0IE ,Receive Data Ready 0 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 15. " RDR1IE ,Receive Data Ready 1 Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 16. " RXTIE ,Receive Tag Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 17. " CMDDUIE ,Command Data Register Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 18. " CMDAUIE ,Command Address Register Updated Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 19. " TIE ,Transmit Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 20. " TDMAE ,Transmit DMA Enable." "0,1"
        textline "    "
        bitfld.long 0x00 21. " RIE ,Receive Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 22. " RDMAE ,Receive DMA Enable." "0,1"
        textline "    "
        bitfld.long 0x00 23. " TFRCIE ,Transmit Frame Complete Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 24. " RFRCIE ,Receive Frame Complete Interrupt Enable." "0,1"
width 5.
group.long 0x1c++0x3
    line.long 0x00 "STCR,SSI Transmit Configuration Register"
        bitfld.long 0x00 0. " TEFS ,Transmit Early Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 1. " TFSL ,Transmit Frame Sync Length." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TFSI ,Transmit Frame Sync Invert." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TSCKP ,Transmit Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 4. " TSHFD ,Transmit Shift Direction." "0,1"
        textline "    "
        bitfld.long 0x00 5. " TXDIR ,Transmit Clock Direction." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TFDIR ,Transmit Frame Direction." "0,1"
        textline "    "
        bitfld.long 0x00 7. " TFEN0 ,Transmit FIFO Enable 0." "0,1"
        textline "    "
        bitfld.long 0x00 8. " TFEN1 ,Transmit FIFO Enable 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " TXBIT0 ,Transmit Bit 0." "0,1"
width 5.
group.long 0x20++0x3
    line.long 0x00 "SRCR,SSI Receive Configuration Register"
        bitfld.long 0x00 0. " REFS ,Receive Early Frame Sync." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RFSL ,Receive Frame Sync Length." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RFSI ,Receive Frame Sync Invert." "0,1"
        textline "    "
        bitfld.long 0x00 3. " RSCKP ,Receive Clock Polarity." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RSHFD ,Receive Shift Direction." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RXDIR ,Receive Clock Direction." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RFDIR ,Receive Frame Direction." "0,1"
        textline "    "
        bitfld.long 0x00 7. " RFEN0 ,Receive FIFO Enable 0." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RFEN1 ,Receive FIFO Enable 1." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RXBIT0 ,Receive Bit 0." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RXEXT ,Receive Data Extension." "0,1"
width 6.
group.long 0x24++0x3
    line.long 0x00 "STCCR,SSI Transmit Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PM7_PM0 ,Prescaler Modulus Select."
        textline "     "
        hexmask.long.byte 0x00 8.--13. 1. " DC4_DC0 ,Frame Rate Divider Control."
        textline "     "
        hexmask.long.byte 0x00 13.--17. 1. " WL3_WL0 ,Word Length Control."
        textline "     "
        bitfld.long 0x00 17. " PSR ,Prescaler Range." "0,1"
        textline "     "
        bitfld.long 0x00 18. " DIV2 ,Divide By 2." "0,1"
width 6.
group.long 0x28++0x3
    line.long 0x00 "SRCCR,SSI Receive Clock Control Register"
        hexmask.long.byte 0x00 0.--8. 1. " PM7_PM0 ,Prescaler Modulus Select."
        textline "     "
        hexmask.long.byte 0x00 8.--13. 1. " DC4_DC0 ,Frame Rate Divider Control."
        textline "     "
        hexmask.long.byte 0x00 13.--17. 1. " WL3_WL0 ,Word Length Control."
        textline "     "
        bitfld.long 0x00 17. " PSR ,Prescaler Range." "0,1"
        textline "     "
        bitfld.long 0x00 18. " DIV2 ,Divide By 2." "0,1"
width 6.
group.long 0x2c++0x3
    line.long 0x00 "SFCSR,SSI FIFO Control/Status Register"
        hexmask.long.byte 0x00 0.--4. 1. " TFWM0 ,Transmit FIFO Empty WaterMark 0."
        textline "     "
        hexmask.long.byte 0x00 4.--8. 1. " RFWM0 ,Receive FIFO Full WaterMark 0."
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " TFCNT0 ,Transmit FIFO Counter 0."
        textline "     "
        hexmask.long.byte 0x00 12.--16. 1. " RFCNT0 ,Receive FIFO Counter 0."
        textline "     "
        hexmask.long.byte 0x00 16.--20. 1. " TFWM1 ,Transmit FIFO Empty WaterMark 1."
        textline "     "
        hexmask.long.byte 0x00 20.--24. 1. " RFWM1 ,Receive FIFO Full WaterMark 1."
        textline "     "
        hexmask.long.byte 0x00 24.--28. 1. " TFCNT1 ,Transmit FIFO Counter1."
        textline "     "
        hexmask.long.byte 0x00 28.--32. 1. " RFCNT1 ,Receive FIFO Counter1."
width 6.
group.long 0x38++0x3
    line.long 0x00 "SACNT,SSI AC97 Control Register"
        bitfld.long 0x00 0. " AC97EN ,AC97 Mode Enable." "0,1"
        textline "     "
        bitfld.long 0x00 1. " FV ,Fixed/Variable Operation." "0,1"
        textline "     "
        bitfld.long 0x00 2. " TIF ,Tag in FIFO." "0,1"
        textline "     "
        bitfld.long 0x00 3. " RD ,Read Command." "0,1"
        textline "     "
        bitfld.long 0x00 4. " WR ,Write Command." "0,1"
        textline "     "
        hexmask.long.byte 0x00 5.--11. 1. " FRDIV ,Frame Rate Divider."
width 7.
group.long 0x3c++0x3
    line.long 0x00 "SACADD,SSI AC97 Command Address Register"
        hexmask.long.long 0x00 0.--19. 1. " SACADD ,AC97 Command Address."
width 7.
group.long 0x40++0x3
    line.long 0x00 "SACDAT,SSI AC97 Command Data Register"
        hexmask.long.long 0x00 0.--20. 1. " SACDAT ,AC97 Command Data."
width 6.
group.long 0x44++0x3
    line.long 0x00 "SATAG,SSI AC97 Tag Register"
        hexmask.long.word 0x00 0.--16. 1. " SATAG ,AC97 Tag Value."
width 6.
group.long 0x48++0x3
    line.long 0x00 "STMSK,SSI Transmit Time Slot Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " STMSK ,Transmit Mask."
width 6.
group.long 0x4c++0x3
    line.long 0x00 "SRMSK,SSI Receive Time Slot Mask Register"
        hexmask.long.long 0x00 0.--32. 1. " SRMSK ,Receive Mask."
width 7.
rgroup.long 0x50++0x3
    line.long 0x00 "SACCST,SSI AC97 Channel Status Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCST ,AC97 Channel Status."
width 7.
wgroup.long 0x54++0x3
    line.long 0x00 "SACCEN,SSI AC97 Channel Enable Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCEN ,AC97 Channel Enable."
width 8.
wgroup.long 0x58++0x3
    line.long 0x00 "SACCDIS,SSI AC97 Channel Disable Register"
        hexmask.long.word 0x00 0.--10. 1. " SACCDIS ,AC97 Channel Disable."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; TEMPMON
;--------------------------------------------------------------------------------
tree "TEMPMON"
    base ad:0x020c8000

width 11.
group.long 0x180++0x3
    line.long 0x00 "TEMPSENSE0,Tempsensor Control Register 0"
        bitfld.long 0x00 0. " POWER_DOWN ,This bit powers down the temperature sensor." "0,1"
        textline "          "
        bitfld.long 0x00 1. " MEASURE_TEMP ,Starts the measurement process." "0,1"
        textline "          "
        bitfld.long 0x00 2. " FINISHED ,Indicates that the latest temp is valid." "0,1"
        textline "          "
        hexmask.long.word 0x00 8.--20. 1. " TEMP_CNT ,This bit field contains the last measured temperature count."
        textline "          "
        hexmask.long.word 0x00 20.--32. 1. " ALARM_VALUE ,This bit field contains the temperature count (raw sensor output) that will generate an alarm interrupt."
width 11.
group.long 0x190++0x3
    line.long 0x00 "TEMPSENSE1,Tempsensor Control Register 1"
        hexmask.long.word 0x00 0.--16. 1. " MEASURE_FREQ ,This bits determines how many RTC clocks to wait before automatically repeating a temperature measurement."


tree.end



;--------------------------------------------------------------------------------
; UART
;--------------------------------------------------------------------------------
tree.open "UART"
    tree "UART1"
        base ad:0x02020000

width 5.
rgroup.long 0x0++0x3
    line.long 0x00 "URXD,UART Receiver Register"
        hexmask.long.byte 0x00 0.--8. 1. " RX_DATA ,Received Data ."
        textline "    "
        bitfld.long 0x00 10. " PRERR ,In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bit RS-485 data In RS232/IrDA mode, it is the Parity Error flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " BRK ,BREAK Detect." "0,1"
        textline "    "
        bitfld.long 0x00 12. " FRMERR ,Frame Error." "0,1"
        textline "    "
        bitfld.long 0x00 13. " OVRRUN ,Receiver Overrun." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR ,Error Detect." "0,1"
        textline "    "
        bitfld.long 0x00 15. " CHARRDY ,Character Ready." "0,1"
width 5.
wgroup.long 0x40++0x3
    line.long 0x00 "UTXD,UART Transmitter Register"
        hexmask.long.byte 0x00 0.--8. 1. " TX_DATA ,Transmit Data ."
width 5.
group.long 0x80++0x3
    line.long 0x00 "UCR1,UART Control Register 1"
        bitfld.long 0x00 0. " UARTEN ,UART Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " DOZE ,DOZE ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ATDMAEN ,Aging DMA Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDMAEN ,Transmitter Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " SNDBRK ,Send BREAK ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RTSDEN ,RTS Delta Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TXMPTYEN ,Transmitter Empty Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " IREN ,Infrared Interface Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RXDMAEN ,Receive Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDYEN ,Receiver Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICD ,Idle Condition Detect ."
        textline "    "
        bitfld.long 0x00 12. " IDEN ,Idle Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDYEN ,Transmitter Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ADBR ,Automatic Detection of Baud Rate ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADEN ,Automatic Baud Rate Detection Interrupt Enable ." "0,1"
width 5.
group.long 0x84++0x3
    line.long 0x00 "UCR2,UART Control Register 2"
        bitfld.long 0x00 0. " SRST ,Software Reset ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RXEN ,Receiver Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXEN ,Transmitter Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " ATEN ,Aging Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSEN ,Request to Send Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " WS ,Word Size ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " STPB ,Stop ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " PROE ,Parity Odd/Even ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " PREN ,Parity Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 9.--11. 1. " RTEC ,Request to Send Edge Control ."
        textline "    "
        bitfld.long 0x00 11. " ESCEN ,Escape Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " CTS ,Clear to Send ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " CTSC ,CTS Pin Control ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " IRTS ,Ignore RTS Pin ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ESCI ,Escape Sequence Interrupt Enable ." "0,1"
width 5.
group.long 0x88++0x3
    line.long 0x00 "UCR3,UART Control Register 3"
        bitfld.long 0x00 0. " ACIEN ,Autobaud Counter Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " INVT ,Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA mode." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RXDMUXSEL ,RXD Muxed Input Selected." "0,1"
        textline "    "
        bitfld.long 0x00 3. " DTRDEN ,Data Terminal Ready Delta Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKEN ,Asynchronous WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINTEN ,Asynchronous IR WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDSEN ,Receive Status Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ADNIMP ,Autobaud Detection Not Improved-." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RI ,Ring Indicator ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " DCD ,Data Carrier Detect ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " DSR ,Data Set Ready ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " FRAERREN ,Frame Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " PARERREN ,Parity Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTREN ,Data Terminal Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " DPEC ,DTR/DSR Interrupt Edge Control ."
width 5.
group.long 0x8c++0x3
    line.long 0x00 "UCR4,UART Control Register 4"
        bitfld.long 0x00 0. " DREN ,Receive Data Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " OREN ,Receiver Overrun Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BKEN ,BREAK Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TCEN ,Transmit Complete Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LPBYP ,Low Power Bypass ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " IRSC ,IR Special Case ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " IDDMAEN ,DMA IDLE Condition Detected Interrupt Enable Enables/Disables the receive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE flag in USR2[12])." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WKEN ,WAKE Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " ENIRI ,Serial Infrared Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " INVR ,Invert RXD input in RS-232/RS-485 Mode, d etermine RXD input logic level being sampled in In IrDA mode." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " CTSTL ,CTS Trigger Level ."
width 5.
group.long 0x90++0x3
    line.long 0x00 "UFCR,UART FIFO Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " RXTL ,Receiver Trigger Level ."
        textline "    "
        bitfld.long 0x00 6. " DCEDTE ,DCE/DTE mode select ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--10. 1. " RFDIV ,Reference Frequency Divider."
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " TXTL ,Transmitter Trigger Level ."
width 5.
group.long 0x94++0x3
    line.long 0x00 "USR1,UART Status Register 1"
        bitfld.long 0x00 3. " SAD ,RS-485 Slave Address Detected Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKE ,Asynchronous WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINT ,Asynchronous IR WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDS ,Receiver IDLE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 7. " DTRD ,DTR Delta." "0,1"
        textline "    "
        bitfld.long 0x00 8. " AGTIM ,Ageing Timer Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDY ,Receiver Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " FRAMERR ,Frame Error Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ESCF ,Escape Sequence Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " RTSD ,RTS Delta." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDY ,Transmitter Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RTSS ,RTS Pin Status ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " PARITYERR ,Parity Error Interrupt Flag ." "0,1"
width 5.
group.long 0x98++0x3
    line.long 0x00 "USR2,UART Status Register 2"
        bitfld.long 0x00 0. " RDR ,Receive Data Ready -Indicates that at least 1 character is received and written to the RxFIFO." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ORE ,Overrun Error ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BRCD ,BREAK Condition Detected ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDC ,Transmitter Complete ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSF ,RTS Edge Triggered Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DCDIN ,Data Carrier Detect Input ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " DCDDELT ,Data Carrier Detect Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WAKE ,Wake ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " IRINT ,Serial Infrared Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RIIN ,Ring Indicator Input ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RIDELT ,Ring Indicator Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ACST ,Autobaud Counter Stopped ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " IDLE ,Idle Condition ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTRF ,DTR edge triggered interrupt flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " TXFE ,Transmit Buffer FIFO Empty ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADET ,Automatic Baud Rate Detect Complete ." "0,1"
width 5.
group.long 0x9c++0x3
    line.long 0x00 "UESC,UART Escape Character Register"
        hexmask.long.byte 0x00 0.--8. 1. " ESC_CHAR ,UART Escape Character ."
width 5.
group.long 0xa0++0x3
    line.long 0x00 "UTIM,UART Escape Timer Register"
        hexmask.long.word 0x00 0.--12. 1. " TIM ,UART Escape Timer."
width 5.
group.long 0xa4++0x3
    line.long 0x00 "UBIR,UART BRM Incremental Register"
        hexmask.long.word 0x00 0.--16. 1. " INC ,Incremental Numerator."
width 5.
group.long 0xa8++0x3
    line.long 0x00 "UBMR,UART BRM Modulator Register"
        hexmask.long.word 0x00 0.--16. 1. " MOD ,Modulator Denominator."
width 5.
rgroup.long 0xac++0x3
    line.long 0x00 "UBRC,UART Baud Rate Count Register"
        hexmask.long.word 0x00 0.--16. 1. " BCNT ,Baud Rate Count Register."
width 6.
group.long 0xb0++0x3
    line.long 0x00 "ONEMS,UART One Millisecond Register"
        hexmask.long.long 0x00 0.--24. 1. " ONEMS ,One Millisecond Register."
width 4.
group.long 0xb4++0x3
    line.long 0x00 "UTS,UART Test Register"
        bitfld.long 0x00 0. " SOFTRST ,Software Reset." "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFULL ,RxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 4. " TXFULL ,TxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 5. " RXEMPTY ,RxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 6. " TXEMPTY ,TxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 9. " RXDBG ,RX_fifo_debug_mode." "0,1"
        textline "   "
        bitfld.long 0x00 10. " LOOPIR ,Loop TX and RX for IR Test (LOOPIR) ." "0,1"
        textline "   "
        bitfld.long 0x00 11. " DBGEN ,debug_enable ." "0,1"
        textline "   "
        bitfld.long 0x00 12. " LOOP ,Loop TX and RX for Test." "0,1"
        textline "   "
        bitfld.long 0x00 13. " FRCPERR ,Force Parity Error." "0,1"
width 5.
group.long 0xb8++0x3
    line.long 0x00 "UMCR,UART RS-485 Mode Control Register"
        bitfld.long 0x00 0. " MDEN ,9-bit data or Multidrop Mode (RS-485) Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SLAM ,RS-485 Slave Address Detect Mode Selection." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXB8 ,Transmit RS-485 bit 8 (the ninth bit or 9 th bit)." "0,1"
        textline "    "
        bitfld.long 0x00 3. " SADEN ,RS-485 Slave Address Detected Interrupt Enable." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " SLADDR ,RS-485 Slave Address Character."


    tree.end
    tree "UART2"
        base ad:0x021e8000

width 5.
rgroup.long 0x0++0x3
    line.long 0x00 "URXD,UART Receiver Register"
        hexmask.long.byte 0x00 0.--8. 1. " RX_DATA ,Received Data ."
        textline "    "
        bitfld.long 0x00 10. " PRERR ,In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bit RS-485 data In RS232/IrDA mode, it is the Parity Error flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " BRK ,BREAK Detect." "0,1"
        textline "    "
        bitfld.long 0x00 12. " FRMERR ,Frame Error." "0,1"
        textline "    "
        bitfld.long 0x00 13. " OVRRUN ,Receiver Overrun." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR ,Error Detect." "0,1"
        textline "    "
        bitfld.long 0x00 15. " CHARRDY ,Character Ready." "0,1"
width 5.
wgroup.long 0x40++0x3
    line.long 0x00 "UTXD,UART Transmitter Register"
        hexmask.long.byte 0x00 0.--8. 1. " TX_DATA ,Transmit Data ."
width 5.
group.long 0x80++0x3
    line.long 0x00 "UCR1,UART Control Register 1"
        bitfld.long 0x00 0. " UARTEN ,UART Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " DOZE ,DOZE ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ATDMAEN ,Aging DMA Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDMAEN ,Transmitter Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " SNDBRK ,Send BREAK ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RTSDEN ,RTS Delta Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TXMPTYEN ,Transmitter Empty Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " IREN ,Infrared Interface Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RXDMAEN ,Receive Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDYEN ,Receiver Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICD ,Idle Condition Detect ."
        textline "    "
        bitfld.long 0x00 12. " IDEN ,Idle Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDYEN ,Transmitter Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ADBR ,Automatic Detection of Baud Rate ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADEN ,Automatic Baud Rate Detection Interrupt Enable ." "0,1"
width 5.
group.long 0x84++0x3
    line.long 0x00 "UCR2,UART Control Register 2"
        bitfld.long 0x00 0. " SRST ,Software Reset ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RXEN ,Receiver Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXEN ,Transmitter Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " ATEN ,Aging Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSEN ,Request to Send Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " WS ,Word Size ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " STPB ,Stop ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " PROE ,Parity Odd/Even ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " PREN ,Parity Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 9.--11. 1. " RTEC ,Request to Send Edge Control ."
        textline "    "
        bitfld.long 0x00 11. " ESCEN ,Escape Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " CTS ,Clear to Send ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " CTSC ,CTS Pin Control ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " IRTS ,Ignore RTS Pin ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ESCI ,Escape Sequence Interrupt Enable ." "0,1"
width 5.
group.long 0x88++0x3
    line.long 0x00 "UCR3,UART Control Register 3"
        bitfld.long 0x00 0. " ACIEN ,Autobaud Counter Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " INVT ,Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA mode." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RXDMUXSEL ,RXD Muxed Input Selected." "0,1"
        textline "    "
        bitfld.long 0x00 3. " DTRDEN ,Data Terminal Ready Delta Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKEN ,Asynchronous WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINTEN ,Asynchronous IR WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDSEN ,Receive Status Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ADNIMP ,Autobaud Detection Not Improved-." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RI ,Ring Indicator ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " DCD ,Data Carrier Detect ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " DSR ,Data Set Ready ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " FRAERREN ,Frame Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " PARERREN ,Parity Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTREN ,Data Terminal Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " DPEC ,DTR/DSR Interrupt Edge Control ."
width 5.
group.long 0x8c++0x3
    line.long 0x00 "UCR4,UART Control Register 4"
        bitfld.long 0x00 0. " DREN ,Receive Data Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " OREN ,Receiver Overrun Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BKEN ,BREAK Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TCEN ,Transmit Complete Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LPBYP ,Low Power Bypass ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " IRSC ,IR Special Case ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " IDDMAEN ,DMA IDLE Condition Detected Interrupt Enable Enables/Disables the receive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE flag in USR2[12])." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WKEN ,WAKE Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " ENIRI ,Serial Infrared Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " INVR ,Invert RXD input in RS-232/RS-485 Mode, d etermine RXD input logic level being sampled in In IrDA mode." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " CTSTL ,CTS Trigger Level ."
width 5.
group.long 0x90++0x3
    line.long 0x00 "UFCR,UART FIFO Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " RXTL ,Receiver Trigger Level ."
        textline "    "
        bitfld.long 0x00 6. " DCEDTE ,DCE/DTE mode select ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--10. 1. " RFDIV ,Reference Frequency Divider."
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " TXTL ,Transmitter Trigger Level ."
width 5.
group.long 0x94++0x3
    line.long 0x00 "USR1,UART Status Register 1"
        bitfld.long 0x00 3. " SAD ,RS-485 Slave Address Detected Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKE ,Asynchronous WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINT ,Asynchronous IR WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDS ,Receiver IDLE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 7. " DTRD ,DTR Delta." "0,1"
        textline "    "
        bitfld.long 0x00 8. " AGTIM ,Ageing Timer Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDY ,Receiver Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " FRAMERR ,Frame Error Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ESCF ,Escape Sequence Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " RTSD ,RTS Delta." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDY ,Transmitter Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RTSS ,RTS Pin Status ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " PARITYERR ,Parity Error Interrupt Flag ." "0,1"
width 5.
group.long 0x98++0x3
    line.long 0x00 "USR2,UART Status Register 2"
        bitfld.long 0x00 0. " RDR ,Receive Data Ready -Indicates that at least 1 character is received and written to the RxFIFO." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ORE ,Overrun Error ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BRCD ,BREAK Condition Detected ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDC ,Transmitter Complete ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSF ,RTS Edge Triggered Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DCDIN ,Data Carrier Detect Input ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " DCDDELT ,Data Carrier Detect Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WAKE ,Wake ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " IRINT ,Serial Infrared Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RIIN ,Ring Indicator Input ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RIDELT ,Ring Indicator Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ACST ,Autobaud Counter Stopped ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " IDLE ,Idle Condition ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTRF ,DTR edge triggered interrupt flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " TXFE ,Transmit Buffer FIFO Empty ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADET ,Automatic Baud Rate Detect Complete ." "0,1"
width 5.
group.long 0x9c++0x3
    line.long 0x00 "UESC,UART Escape Character Register"
        hexmask.long.byte 0x00 0.--8. 1. " ESC_CHAR ,UART Escape Character ."
width 5.
group.long 0xa0++0x3
    line.long 0x00 "UTIM,UART Escape Timer Register"
        hexmask.long.word 0x00 0.--12. 1. " TIM ,UART Escape Timer."
width 5.
group.long 0xa4++0x3
    line.long 0x00 "UBIR,UART BRM Incremental Register"
        hexmask.long.word 0x00 0.--16. 1. " INC ,Incremental Numerator."
width 5.
group.long 0xa8++0x3
    line.long 0x00 "UBMR,UART BRM Modulator Register"
        hexmask.long.word 0x00 0.--16. 1. " MOD ,Modulator Denominator."
width 5.
rgroup.long 0xac++0x3
    line.long 0x00 "UBRC,UART Baud Rate Count Register"
        hexmask.long.word 0x00 0.--16. 1. " BCNT ,Baud Rate Count Register."
width 6.
group.long 0xb0++0x3
    line.long 0x00 "ONEMS,UART One Millisecond Register"
        hexmask.long.long 0x00 0.--24. 1. " ONEMS ,One Millisecond Register."
width 4.
group.long 0xb4++0x3
    line.long 0x00 "UTS,UART Test Register"
        bitfld.long 0x00 0. " SOFTRST ,Software Reset." "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFULL ,RxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 4. " TXFULL ,TxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 5. " RXEMPTY ,RxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 6. " TXEMPTY ,TxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 9. " RXDBG ,RX_fifo_debug_mode." "0,1"
        textline "   "
        bitfld.long 0x00 10. " LOOPIR ,Loop TX and RX for IR Test (LOOPIR) ." "0,1"
        textline "   "
        bitfld.long 0x00 11. " DBGEN ,debug_enable ." "0,1"
        textline "   "
        bitfld.long 0x00 12. " LOOP ,Loop TX and RX for Test." "0,1"
        textline "   "
        bitfld.long 0x00 13. " FRCPERR ,Force Parity Error." "0,1"
width 5.
group.long 0xb8++0x3
    line.long 0x00 "UMCR,UART RS-485 Mode Control Register"
        bitfld.long 0x00 0. " MDEN ,9-bit data or Multidrop Mode (RS-485) Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SLAM ,RS-485 Slave Address Detect Mode Selection." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXB8 ,Transmit RS-485 bit 8 (the ninth bit or 9 th bit)." "0,1"
        textline "    "
        bitfld.long 0x00 3. " SADEN ,RS-485 Slave Address Detected Interrupt Enable." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " SLADDR ,RS-485 Slave Address Character."


    tree.end
    tree "UART3"
        base ad:0x021ec000

width 5.
rgroup.long 0x0++0x3
    line.long 0x00 "URXD,UART Receiver Register"
        hexmask.long.byte 0x00 0.--8. 1. " RX_DATA ,Received Data ."
        textline "    "
        bitfld.long 0x00 10. " PRERR ,In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bit RS-485 data In RS232/IrDA mode, it is the Parity Error flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " BRK ,BREAK Detect." "0,1"
        textline "    "
        bitfld.long 0x00 12. " FRMERR ,Frame Error." "0,1"
        textline "    "
        bitfld.long 0x00 13. " OVRRUN ,Receiver Overrun." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR ,Error Detect." "0,1"
        textline "    "
        bitfld.long 0x00 15. " CHARRDY ,Character Ready." "0,1"
width 5.
wgroup.long 0x40++0x3
    line.long 0x00 "UTXD,UART Transmitter Register"
        hexmask.long.byte 0x00 0.--8. 1. " TX_DATA ,Transmit Data ."
width 5.
group.long 0x80++0x3
    line.long 0x00 "UCR1,UART Control Register 1"
        bitfld.long 0x00 0. " UARTEN ,UART Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " DOZE ,DOZE ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ATDMAEN ,Aging DMA Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDMAEN ,Transmitter Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " SNDBRK ,Send BREAK ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RTSDEN ,RTS Delta Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TXMPTYEN ,Transmitter Empty Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " IREN ,Infrared Interface Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RXDMAEN ,Receive Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDYEN ,Receiver Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICD ,Idle Condition Detect ."
        textline "    "
        bitfld.long 0x00 12. " IDEN ,Idle Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDYEN ,Transmitter Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ADBR ,Automatic Detection of Baud Rate ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADEN ,Automatic Baud Rate Detection Interrupt Enable ." "0,1"
width 5.
group.long 0x84++0x3
    line.long 0x00 "UCR2,UART Control Register 2"
        bitfld.long 0x00 0. " SRST ,Software Reset ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RXEN ,Receiver Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXEN ,Transmitter Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " ATEN ,Aging Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSEN ,Request to Send Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " WS ,Word Size ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " STPB ,Stop ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " PROE ,Parity Odd/Even ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " PREN ,Parity Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 9.--11. 1. " RTEC ,Request to Send Edge Control ."
        textline "    "
        bitfld.long 0x00 11. " ESCEN ,Escape Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " CTS ,Clear to Send ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " CTSC ,CTS Pin Control ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " IRTS ,Ignore RTS Pin ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ESCI ,Escape Sequence Interrupt Enable ." "0,1"
width 5.
group.long 0x88++0x3
    line.long 0x00 "UCR3,UART Control Register 3"
        bitfld.long 0x00 0. " ACIEN ,Autobaud Counter Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " INVT ,Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA mode." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RXDMUXSEL ,RXD Muxed Input Selected." "0,1"
        textline "    "
        bitfld.long 0x00 3. " DTRDEN ,Data Terminal Ready Delta Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKEN ,Asynchronous WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINTEN ,Asynchronous IR WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDSEN ,Receive Status Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ADNIMP ,Autobaud Detection Not Improved-." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RI ,Ring Indicator ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " DCD ,Data Carrier Detect ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " DSR ,Data Set Ready ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " FRAERREN ,Frame Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " PARERREN ,Parity Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTREN ,Data Terminal Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " DPEC ,DTR/DSR Interrupt Edge Control ."
width 5.
group.long 0x8c++0x3
    line.long 0x00 "UCR4,UART Control Register 4"
        bitfld.long 0x00 0. " DREN ,Receive Data Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " OREN ,Receiver Overrun Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BKEN ,BREAK Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TCEN ,Transmit Complete Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LPBYP ,Low Power Bypass ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " IRSC ,IR Special Case ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " IDDMAEN ,DMA IDLE Condition Detected Interrupt Enable Enables/Disables the receive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE flag in USR2[12])." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WKEN ,WAKE Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " ENIRI ,Serial Infrared Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " INVR ,Invert RXD input in RS-232/RS-485 Mode, d etermine RXD input logic level being sampled in In IrDA mode." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " CTSTL ,CTS Trigger Level ."
width 5.
group.long 0x90++0x3
    line.long 0x00 "UFCR,UART FIFO Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " RXTL ,Receiver Trigger Level ."
        textline "    "
        bitfld.long 0x00 6. " DCEDTE ,DCE/DTE mode select ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--10. 1. " RFDIV ,Reference Frequency Divider."
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " TXTL ,Transmitter Trigger Level ."
width 5.
group.long 0x94++0x3
    line.long 0x00 "USR1,UART Status Register 1"
        bitfld.long 0x00 3. " SAD ,RS-485 Slave Address Detected Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKE ,Asynchronous WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINT ,Asynchronous IR WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDS ,Receiver IDLE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 7. " DTRD ,DTR Delta." "0,1"
        textline "    "
        bitfld.long 0x00 8. " AGTIM ,Ageing Timer Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDY ,Receiver Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " FRAMERR ,Frame Error Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ESCF ,Escape Sequence Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " RTSD ,RTS Delta." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDY ,Transmitter Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RTSS ,RTS Pin Status ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " PARITYERR ,Parity Error Interrupt Flag ." "0,1"
width 5.
group.long 0x98++0x3
    line.long 0x00 "USR2,UART Status Register 2"
        bitfld.long 0x00 0. " RDR ,Receive Data Ready -Indicates that at least 1 character is received and written to the RxFIFO." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ORE ,Overrun Error ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BRCD ,BREAK Condition Detected ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDC ,Transmitter Complete ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSF ,RTS Edge Triggered Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DCDIN ,Data Carrier Detect Input ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " DCDDELT ,Data Carrier Detect Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WAKE ,Wake ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " IRINT ,Serial Infrared Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RIIN ,Ring Indicator Input ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RIDELT ,Ring Indicator Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ACST ,Autobaud Counter Stopped ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " IDLE ,Idle Condition ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTRF ,DTR edge triggered interrupt flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " TXFE ,Transmit Buffer FIFO Empty ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADET ,Automatic Baud Rate Detect Complete ." "0,1"
width 5.
group.long 0x9c++0x3
    line.long 0x00 "UESC,UART Escape Character Register"
        hexmask.long.byte 0x00 0.--8. 1. " ESC_CHAR ,UART Escape Character ."
width 5.
group.long 0xa0++0x3
    line.long 0x00 "UTIM,UART Escape Timer Register"
        hexmask.long.word 0x00 0.--12. 1. " TIM ,UART Escape Timer."
width 5.
group.long 0xa4++0x3
    line.long 0x00 "UBIR,UART BRM Incremental Register"
        hexmask.long.word 0x00 0.--16. 1. " INC ,Incremental Numerator."
width 5.
group.long 0xa8++0x3
    line.long 0x00 "UBMR,UART BRM Modulator Register"
        hexmask.long.word 0x00 0.--16. 1. " MOD ,Modulator Denominator."
width 5.
rgroup.long 0xac++0x3
    line.long 0x00 "UBRC,UART Baud Rate Count Register"
        hexmask.long.word 0x00 0.--16. 1. " BCNT ,Baud Rate Count Register."
width 6.
group.long 0xb0++0x3
    line.long 0x00 "ONEMS,UART One Millisecond Register"
        hexmask.long.long 0x00 0.--24. 1. " ONEMS ,One Millisecond Register."
width 4.
group.long 0xb4++0x3
    line.long 0x00 "UTS,UART Test Register"
        bitfld.long 0x00 0. " SOFTRST ,Software Reset." "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFULL ,RxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 4. " TXFULL ,TxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 5. " RXEMPTY ,RxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 6. " TXEMPTY ,TxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 9. " RXDBG ,RX_fifo_debug_mode." "0,1"
        textline "   "
        bitfld.long 0x00 10. " LOOPIR ,Loop TX and RX for IR Test (LOOPIR) ." "0,1"
        textline "   "
        bitfld.long 0x00 11. " DBGEN ,debug_enable ." "0,1"
        textline "   "
        bitfld.long 0x00 12. " LOOP ,Loop TX and RX for Test." "0,1"
        textline "   "
        bitfld.long 0x00 13. " FRCPERR ,Force Parity Error." "0,1"
width 5.
group.long 0xb8++0x3
    line.long 0x00 "UMCR,UART RS-485 Mode Control Register"
        bitfld.long 0x00 0. " MDEN ,9-bit data or Multidrop Mode (RS-485) Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SLAM ,RS-485 Slave Address Detect Mode Selection." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXB8 ,Transmit RS-485 bit 8 (the ninth bit or 9 th bit)." "0,1"
        textline "    "
        bitfld.long 0x00 3. " SADEN ,RS-485 Slave Address Detected Interrupt Enable." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " SLADDR ,RS-485 Slave Address Character."


    tree.end
    tree "UART4"
        base ad:0x021f0000

width 5.
rgroup.long 0x0++0x3
    line.long 0x00 "URXD,UART Receiver Register"
        hexmask.long.byte 0x00 0.--8. 1. " RX_DATA ,Received Data ."
        textline "    "
        bitfld.long 0x00 10. " PRERR ,In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bit RS-485 data In RS232/IrDA mode, it is the Parity Error flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " BRK ,BREAK Detect." "0,1"
        textline "    "
        bitfld.long 0x00 12. " FRMERR ,Frame Error." "0,1"
        textline "    "
        bitfld.long 0x00 13. " OVRRUN ,Receiver Overrun." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR ,Error Detect." "0,1"
        textline "    "
        bitfld.long 0x00 15. " CHARRDY ,Character Ready." "0,1"
width 5.
wgroup.long 0x40++0x3
    line.long 0x00 "UTXD,UART Transmitter Register"
        hexmask.long.byte 0x00 0.--8. 1. " TX_DATA ,Transmit Data ."
width 5.
group.long 0x80++0x3
    line.long 0x00 "UCR1,UART Control Register 1"
        bitfld.long 0x00 0. " UARTEN ,UART Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " DOZE ,DOZE ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ATDMAEN ,Aging DMA Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDMAEN ,Transmitter Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " SNDBRK ,Send BREAK ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RTSDEN ,RTS Delta Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TXMPTYEN ,Transmitter Empty Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " IREN ,Infrared Interface Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RXDMAEN ,Receive Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDYEN ,Receiver Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICD ,Idle Condition Detect ."
        textline "    "
        bitfld.long 0x00 12. " IDEN ,Idle Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDYEN ,Transmitter Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ADBR ,Automatic Detection of Baud Rate ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADEN ,Automatic Baud Rate Detection Interrupt Enable ." "0,1"
width 5.
group.long 0x84++0x3
    line.long 0x00 "UCR2,UART Control Register 2"
        bitfld.long 0x00 0. " SRST ,Software Reset ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RXEN ,Receiver Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXEN ,Transmitter Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " ATEN ,Aging Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSEN ,Request to Send Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " WS ,Word Size ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " STPB ,Stop ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " PROE ,Parity Odd/Even ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " PREN ,Parity Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 9.--11. 1. " RTEC ,Request to Send Edge Control ."
        textline "    "
        bitfld.long 0x00 11. " ESCEN ,Escape Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " CTS ,Clear to Send ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " CTSC ,CTS Pin Control ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " IRTS ,Ignore RTS Pin ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ESCI ,Escape Sequence Interrupt Enable ." "0,1"
width 5.
group.long 0x88++0x3
    line.long 0x00 "UCR3,UART Control Register 3"
        bitfld.long 0x00 0. " ACIEN ,Autobaud Counter Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " INVT ,Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA mode." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RXDMUXSEL ,RXD Muxed Input Selected." "0,1"
        textline "    "
        bitfld.long 0x00 3. " DTRDEN ,Data Terminal Ready Delta Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKEN ,Asynchronous WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINTEN ,Asynchronous IR WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDSEN ,Receive Status Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ADNIMP ,Autobaud Detection Not Improved-." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RI ,Ring Indicator ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " DCD ,Data Carrier Detect ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " DSR ,Data Set Ready ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " FRAERREN ,Frame Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " PARERREN ,Parity Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTREN ,Data Terminal Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " DPEC ,DTR/DSR Interrupt Edge Control ."
width 5.
group.long 0x8c++0x3
    line.long 0x00 "UCR4,UART Control Register 4"
        bitfld.long 0x00 0. " DREN ,Receive Data Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " OREN ,Receiver Overrun Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BKEN ,BREAK Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TCEN ,Transmit Complete Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LPBYP ,Low Power Bypass ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " IRSC ,IR Special Case ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " IDDMAEN ,DMA IDLE Condition Detected Interrupt Enable Enables/Disables the receive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE flag in USR2[12])." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WKEN ,WAKE Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " ENIRI ,Serial Infrared Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " INVR ,Invert RXD input in RS-232/RS-485 Mode, d etermine RXD input logic level being sampled in In IrDA mode." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " CTSTL ,CTS Trigger Level ."
width 5.
group.long 0x90++0x3
    line.long 0x00 "UFCR,UART FIFO Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " RXTL ,Receiver Trigger Level ."
        textline "    "
        bitfld.long 0x00 6. " DCEDTE ,DCE/DTE mode select ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--10. 1. " RFDIV ,Reference Frequency Divider."
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " TXTL ,Transmitter Trigger Level ."
width 5.
group.long 0x94++0x3
    line.long 0x00 "USR1,UART Status Register 1"
        bitfld.long 0x00 3. " SAD ,RS-485 Slave Address Detected Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKE ,Asynchronous WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINT ,Asynchronous IR WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDS ,Receiver IDLE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 7. " DTRD ,DTR Delta." "0,1"
        textline "    "
        bitfld.long 0x00 8. " AGTIM ,Ageing Timer Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDY ,Receiver Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " FRAMERR ,Frame Error Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ESCF ,Escape Sequence Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " RTSD ,RTS Delta." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDY ,Transmitter Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RTSS ,RTS Pin Status ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " PARITYERR ,Parity Error Interrupt Flag ." "0,1"
width 5.
group.long 0x98++0x3
    line.long 0x00 "USR2,UART Status Register 2"
        bitfld.long 0x00 0. " RDR ,Receive Data Ready -Indicates that at least 1 character is received and written to the RxFIFO." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ORE ,Overrun Error ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BRCD ,BREAK Condition Detected ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDC ,Transmitter Complete ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSF ,RTS Edge Triggered Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DCDIN ,Data Carrier Detect Input ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " DCDDELT ,Data Carrier Detect Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WAKE ,Wake ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " IRINT ,Serial Infrared Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RIIN ,Ring Indicator Input ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RIDELT ,Ring Indicator Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ACST ,Autobaud Counter Stopped ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " IDLE ,Idle Condition ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTRF ,DTR edge triggered interrupt flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " TXFE ,Transmit Buffer FIFO Empty ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADET ,Automatic Baud Rate Detect Complete ." "0,1"
width 5.
group.long 0x9c++0x3
    line.long 0x00 "UESC,UART Escape Character Register"
        hexmask.long.byte 0x00 0.--8. 1. " ESC_CHAR ,UART Escape Character ."
width 5.
group.long 0xa0++0x3
    line.long 0x00 "UTIM,UART Escape Timer Register"
        hexmask.long.word 0x00 0.--12. 1. " TIM ,UART Escape Timer."
width 5.
group.long 0xa4++0x3
    line.long 0x00 "UBIR,UART BRM Incremental Register"
        hexmask.long.word 0x00 0.--16. 1. " INC ,Incremental Numerator."
width 5.
group.long 0xa8++0x3
    line.long 0x00 "UBMR,UART BRM Modulator Register"
        hexmask.long.word 0x00 0.--16. 1. " MOD ,Modulator Denominator."
width 5.
rgroup.long 0xac++0x3
    line.long 0x00 "UBRC,UART Baud Rate Count Register"
        hexmask.long.word 0x00 0.--16. 1. " BCNT ,Baud Rate Count Register."
width 6.
group.long 0xb0++0x3
    line.long 0x00 "ONEMS,UART One Millisecond Register"
        hexmask.long.long 0x00 0.--24. 1. " ONEMS ,One Millisecond Register."
width 4.
group.long 0xb4++0x3
    line.long 0x00 "UTS,UART Test Register"
        bitfld.long 0x00 0. " SOFTRST ,Software Reset." "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFULL ,RxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 4. " TXFULL ,TxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 5. " RXEMPTY ,RxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 6. " TXEMPTY ,TxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 9. " RXDBG ,RX_fifo_debug_mode." "0,1"
        textline "   "
        bitfld.long 0x00 10. " LOOPIR ,Loop TX and RX for IR Test (LOOPIR) ." "0,1"
        textline "   "
        bitfld.long 0x00 11. " DBGEN ,debug_enable ." "0,1"
        textline "   "
        bitfld.long 0x00 12. " LOOP ,Loop TX and RX for Test." "0,1"
        textline "   "
        bitfld.long 0x00 13. " FRCPERR ,Force Parity Error." "0,1"
width 5.
group.long 0xb8++0x3
    line.long 0x00 "UMCR,UART RS-485 Mode Control Register"
        bitfld.long 0x00 0. " MDEN ,9-bit data or Multidrop Mode (RS-485) Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SLAM ,RS-485 Slave Address Detect Mode Selection." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXB8 ,Transmit RS-485 bit 8 (the ninth bit or 9 th bit)." "0,1"
        textline "    "
        bitfld.long 0x00 3. " SADEN ,RS-485 Slave Address Detected Interrupt Enable." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " SLADDR ,RS-485 Slave Address Character."


    tree.end
    tree "UART5"
        base ad:0x021f4000

width 5.
rgroup.long 0x0++0x3
    line.long 0x00 "URXD,UART Receiver Register"
        hexmask.long.byte 0x00 0.--8. 1. " RX_DATA ,Received Data ."
        textline "    "
        bitfld.long 0x00 10. " PRERR ,In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bit RS-485 data In RS232/IrDA mode, it is the Parity Error flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " BRK ,BREAK Detect." "0,1"
        textline "    "
        bitfld.long 0x00 12. " FRMERR ,Frame Error." "0,1"
        textline "    "
        bitfld.long 0x00 13. " OVRRUN ,Receiver Overrun." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ERR ,Error Detect." "0,1"
        textline "    "
        bitfld.long 0x00 15. " CHARRDY ,Character Ready." "0,1"
width 5.
wgroup.long 0x40++0x3
    line.long 0x00 "UTXD,UART Transmitter Register"
        hexmask.long.byte 0x00 0.--8. 1. " TX_DATA ,Transmit Data ."
width 5.
group.long 0x80++0x3
    line.long 0x00 "UCR1,UART Control Register 1"
        bitfld.long 0x00 0. " UARTEN ,UART Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " DOZE ,DOZE ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ATDMAEN ,Aging DMA Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDMAEN ,Transmitter Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " SNDBRK ,Send BREAK ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " RTSDEN ,RTS Delta Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " TXMPTYEN ,Transmitter Empty Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " IREN ,Infrared Interface Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RXDMAEN ,Receive Ready DMA Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDYEN ,Receiver Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--12. 1. " ICD ,Idle Condition Detect ."
        textline "    "
        bitfld.long 0x00 12. " IDEN ,Idle Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDYEN ,Transmitter Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ADBR ,Automatic Detection of Baud Rate ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADEN ,Automatic Baud Rate Detection Interrupt Enable ." "0,1"
width 5.
group.long 0x84++0x3
    line.long 0x00 "UCR2,UART Control Register 2"
        bitfld.long 0x00 0. " SRST ,Software Reset ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " RXEN ,Receiver Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXEN ,Transmitter Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " ATEN ,Aging Timer Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSEN ,Request to Send Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " WS ,Word Size ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " STPB ,Stop ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " PROE ,Parity Odd/Even ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " PREN ,Parity Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 9.--11. 1. " RTEC ,Request to Send Edge Control ."
        textline "    "
        bitfld.long 0x00 11. " ESCEN ,Escape Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " CTS ,Clear to Send ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " CTSC ,CTS Pin Control ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " IRTS ,Ignore RTS Pin ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ESCI ,Escape Sequence Interrupt Enable ." "0,1"
width 5.
group.long 0x88++0x3
    line.long 0x00 "UCR3,UART Control Register 3"
        bitfld.long 0x00 0. " ACIEN ,Autobaud Counter Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " INVT ,Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA mode." "0,1"
        textline "    "
        bitfld.long 0x00 2. " RXDMUXSEL ,RXD Muxed Input Selected." "0,1"
        textline "    "
        bitfld.long 0x00 3. " DTRDEN ,Data Terminal Ready Delta Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKEN ,Asynchronous WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINTEN ,Asynchronous IR WAKE Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDSEN ,Receive Status Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ADNIMP ,Autobaud Detection Not Improved-." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RI ,Ring Indicator ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " DCD ,Data Carrier Detect ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " DSR ,Data Set Ready ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " FRAERREN ,Frame Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 12. " PARERREN ,Parity Error Interrupt Enable." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTREN ,Data Terminal Ready Interrupt Enable ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 14.--16. 1. " DPEC ,DTR/DSR Interrupt Edge Control ."
width 5.
group.long 0x8c++0x3
    line.long 0x00 "UCR4,UART Control Register 4"
        bitfld.long 0x00 0. " DREN ,Receive Data Ready Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " OREN ,Receiver Overrun Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BKEN ,BREAK Condition Detected Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TCEN ,Transmit Complete Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " LPBYP ,Low Power Bypass ." "0,1"
        textline "    "
        bitfld.long 0x00 5. " IRSC ,IR Special Case ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " IDDMAEN ,DMA IDLE Condition Detected Interrupt Enable Enables/Disables the receive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE flag in USR2[12])." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WKEN ,WAKE Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " ENIRI ,Serial Infrared Interrupt Enable ." "0,1"
        textline "    "
        bitfld.long 0x00 9. " INVR ,Invert RXD input in RS-232/RS-485 Mode, d etermine RXD input logic level being sampled in In IrDA mode." "0,1"
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " CTSTL ,CTS Trigger Level ."
width 5.
group.long 0x90++0x3
    line.long 0x00 "UFCR,UART FIFO Control Register"
        hexmask.long.byte 0x00 0.--6. 1. " RXTL ,Receiver Trigger Level ."
        textline "    "
        bitfld.long 0x00 6. " DCEDTE ,DCE/DTE mode select ." "0,1"
        textline "    "
        hexmask.long.byte 0x00 7.--10. 1. " RFDIV ,Reference Frequency Divider."
        textline "    "
        hexmask.long.byte 0x00 10.--16. 1. " TXTL ,Transmitter Trigger Level ."
width 5.
group.long 0x94++0x3
    line.long 0x00 "USR1,UART Status Register 1"
        bitfld.long 0x00 3. " SAD ,RS-485 Slave Address Detected Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 4. " AWAKE ,Asynchronous WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " AIRINT ,Asynchronous IR WAKE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 6. " RXDS ,Receiver IDLE Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 7. " DTRD ,DTR Delta." "0,1"
        textline "    "
        bitfld.long 0x00 8. " AGTIM ,Ageing Timer Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RRDY ,Receiver Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " FRAMERR ,Frame Error Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ESCF ,Escape Sequence Interrupt Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " RTSD ,RTS Delta." "0,1"
        textline "    "
        bitfld.long 0x00 13. " TRDY ,Transmitter Ready Interrupt / DMA Flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " RTSS ,RTS Pin Status ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " PARITYERR ,Parity Error Interrupt Flag ." "0,1"
width 5.
group.long 0x98++0x3
    line.long 0x00 "USR2,UART Status Register 2"
        bitfld.long 0x00 0. " RDR ,Receive Data Ready -Indicates that at least 1 character is received and written to the RxFIFO." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ORE ,Overrun Error ." "0,1"
        textline "    "
        bitfld.long 0x00 2. " BRCD ,BREAK Condition Detected ." "0,1"
        textline "    "
        bitfld.long 0x00 3. " TXDC ,Transmitter Complete ." "0,1"
        textline "    "
        bitfld.long 0x00 4. " RTSF ,RTS Edge Triggered Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DCDIN ,Data Carrier Detect Input ." "0,1"
        textline "    "
        bitfld.long 0x00 6. " DCDDELT ,Data Carrier Detect Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 7. " WAKE ,Wake ." "0,1"
        textline "    "
        bitfld.long 0x00 8. " IRINT ,Serial Infrared Interrupt Flag." "0,1"
        textline "    "
        bitfld.long 0x00 9. " RIIN ,Ring Indicator Input ." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RIDELT ,Ring Indicator Delta ." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ACST ,Autobaud Counter Stopped ." "0,1"
        textline "    "
        bitfld.long 0x00 12. " IDLE ,Idle Condition ." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DTRF ,DTR edge triggered interrupt flag ." "0,1"
        textline "    "
        bitfld.long 0x00 14. " TXFE ,Transmit Buffer FIFO Empty ." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ADET ,Automatic Baud Rate Detect Complete ." "0,1"
width 5.
group.long 0x9c++0x3
    line.long 0x00 "UESC,UART Escape Character Register"
        hexmask.long.byte 0x00 0.--8. 1. " ESC_CHAR ,UART Escape Character ."
width 5.
group.long 0xa0++0x3
    line.long 0x00 "UTIM,UART Escape Timer Register"
        hexmask.long.word 0x00 0.--12. 1. " TIM ,UART Escape Timer."
width 5.
group.long 0xa4++0x3
    line.long 0x00 "UBIR,UART BRM Incremental Register"
        hexmask.long.word 0x00 0.--16. 1. " INC ,Incremental Numerator."
width 5.
group.long 0xa8++0x3
    line.long 0x00 "UBMR,UART BRM Modulator Register"
        hexmask.long.word 0x00 0.--16. 1. " MOD ,Modulator Denominator."
width 5.
rgroup.long 0xac++0x3
    line.long 0x00 "UBRC,UART Baud Rate Count Register"
        hexmask.long.word 0x00 0.--16. 1. " BCNT ,Baud Rate Count Register."
width 6.
group.long 0xb0++0x3
    line.long 0x00 "ONEMS,UART One Millisecond Register"
        hexmask.long.long 0x00 0.--24. 1. " ONEMS ,One Millisecond Register."
width 4.
group.long 0xb4++0x3
    line.long 0x00 "UTS,UART Test Register"
        bitfld.long 0x00 0. " SOFTRST ,Software Reset." "0,1"
        textline "   "
        bitfld.long 0x00 3. " RXFULL ,RxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 4. " TXFULL ,TxFIFO FULL." "0,1"
        textline "   "
        bitfld.long 0x00 5. " RXEMPTY ,RxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 6. " TXEMPTY ,TxFIFO Empty." "0,1"
        textline "   "
        bitfld.long 0x00 9. " RXDBG ,RX_fifo_debug_mode." "0,1"
        textline "   "
        bitfld.long 0x00 10. " LOOPIR ,Loop TX and RX for IR Test (LOOPIR) ." "0,1"
        textline "   "
        bitfld.long 0x00 11. " DBGEN ,debug_enable ." "0,1"
        textline "   "
        bitfld.long 0x00 12. " LOOP ,Loop TX and RX for Test." "0,1"
        textline "   "
        bitfld.long 0x00 13. " FRCPERR ,Force Parity Error." "0,1"
width 5.
group.long 0xb8++0x3
    line.long 0x00 "UMCR,UART RS-485 Mode Control Register"
        bitfld.long 0x00 0. " MDEN ,9-bit data or Multidrop Mode (RS-485) Enable." "0,1"
        textline "    "
        bitfld.long 0x00 1. " SLAM ,RS-485 Slave Address Detect Mode Selection." "0,1"
        textline "    "
        bitfld.long 0x00 2. " TXB8 ,Transmit RS-485 bit 8 (the ninth bit or 9 th bit)." "0,1"
        textline "    "
        bitfld.long 0x00 3. " SADEN ,RS-485 Slave Address Detected Interrupt Enable." "0,1"
        textline "    "
        hexmask.long.byte 0x00 8.--16. 1. " SLADDR ,RS-485 Slave Address Character."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; USB_ANALOG
;--------------------------------------------------------------------------------
tree "USB_ANALOG"
    base ad:0x020c8000

width 17.
group.long 0x1a0++0x3
    line.long 0x00 "USB1_VBUS_DETECT,USB VBUS Detect Register"
        hexmask.long.byte 0x00 0.--3. 1. " VBUSVALID_THRESH ,Set the threshold for the VBUSVALID comparator."
        textline "                "
        bitfld.long 0x00 20. " VBUSVALID_PWRUP_CMPS ,Powers up comparators for vbus_valid detector." "0,1"
        textline "                "
        bitfld.long 0x00 26. " DISCHARGE_VBUS ,USB OTG discharge VBUS." "0,1"
        textline "                "
        bitfld.long 0x00 27. " CHARGE_VBUS ,USB OTG charge VBUS." "0,1"
width 17.
group.long 0x1b0++0x3
    line.long 0x00 "USB1_CHRG_DETECT,USB Charger Detect Register"
        bitfld.long 0x00 18. " CHK_CONTACT ," "0,1"
        textline "                "
        bitfld.long 0x00 19. " CHK_CHRG_B ," "0,1"
        textline "                "
        bitfld.long 0x00 20. " EN_B ,Control the charger detector." "0,1"
width 22.
rgroup.long 0x1c0++0x3
    line.long 0x00 "USB1_VBUS_DETECT_STAT,USB VBUS Detect Status Register"
        bitfld.long 0x00 0. " SESSEND ,Session End for USB OTG." "0,1"
        textline "                     "
        bitfld.long 0x00 1. " BVALID ,Indicates VBus is valid for a B-peripheral." "0,1"
        textline "                     "
        bitfld.long 0x00 2. " AVALID ,Indicates VBus is valid for a A-peripheral." "0,1"
        textline "                     "
        bitfld.long 0x00 3. " VBUS_VALID ,VBus valid for USB OTG." "0,1"
width 22.
rgroup.long 0x1d0++0x3
    line.long 0x00 "USB1_CHRG_DETECT_STAT,USB Charger Detect Status Register"
        bitfld.long 0x00 0. " PLUG_CONTACT ,State of the USB plug contact detector." "0,1"
        textline "                     "
        bitfld.long 0x00 1. " CHRG_DETECTED ,State of charger detection." "0,1"
        textline "                     "
        bitfld.long 0x00 2. " DM_STATE ,DM line state output of the charger detector." "0,1"
        textline "                     "
        bitfld.long 0x00 3. " DP_STATE ,DP line state output of the charger detector." "0,1"
width 10.
group.long 0x1f0++0x3
    line.long 0x00 "USB1_MISC,USB Misc Register"
        bitfld.long 0x00 0. " HS_USE_EXTERNAL_R ,Use external resistor to generate the current bias for the high speed transmitter." "0,1"
        textline "         "
        bitfld.long 0x00 1. " EN_DEGLITCH ,Enable the deglitching circuit of the USB PLL output." "0,1"
        textline "         "
        bitfld.long 0x00 30. " EN_CLK_UTMI ,Enables the clk to the UTMI block." "0,1"
width 17.
group.long 0x200++0x3
    line.long 0x00 "USB2_VBUS_DETECT,USB VBUS Detect Register"
        hexmask.long.byte 0x00 0.--3. 1. " VBUSVALID_THRESH ,Set the threshold for the VBUSVALID comparator."
        textline "                "
        bitfld.long 0x00 20. " VBUSVALID_PWRUP_CMPS ,Powers up comparators for vbus_valid detector." "0,1"
        textline "                "
        bitfld.long 0x00 26. " DISCHARGE_VBUS ,USB OTG discharge VBUS." "0,1"
        textline "                "
        bitfld.long 0x00 27. " CHARGE_VBUS ,USB OTG charge VBUS." "0,1"
width 17.
group.long 0x210++0x3
    line.long 0x00 "USB2_CHRG_DETECT,USB Charger Detect Register"
        bitfld.long 0x00 18. " CHK_CONTACT ," "0,1"
        textline "                "
        bitfld.long 0x00 19. " CHK_CHRG_B ," "0,1"
        textline "                "
        bitfld.long 0x00 20. " EN_B ,Control the charger detector." "0,1"
width 22.
rgroup.long 0x220++0x3
    line.long 0x00 "USB2_VBUS_DETECT_STAT,USB VBUS Detect Status Register"
        bitfld.long 0x00 0. " SESSEND ,Session End for USB OTG." "0,1"
        textline "                     "
        bitfld.long 0x00 1. " BVALID ,Indicates VBus is valid for a B-peripheral." "0,1"
        textline "                     "
        bitfld.long 0x00 2. " AVALID ,Indicates VBus is valid for a A-peripheral." "0,1"
        textline "                     "
        bitfld.long 0x00 3. " VBUS_VALID ,VBus valid for USB OTG." "0,1"
width 22.
rgroup.long 0x230++0x3
    line.long 0x00 "USB2_CHRG_DETECT_STAT,USB Charger Detect Status Register"
        bitfld.long 0x00 0. " PLUG_CONTACT ,State of the USB plug contact detector." "0,1"
        textline "                     "
        bitfld.long 0x00 1. " CHRG_DETECTED ,State of charger detection." "0,1"
        textline "                     "
        bitfld.long 0x00 2. " DM_STATE ,DM line state output of the charger detector." "0,1"
        textline "                     "
        bitfld.long 0x00 3. " DP_STATE ,DP line state output of the charger detector." "0,1"
width 10.
group.long 0x250++0x3
    line.long 0x00 "USB2_MISC,USB Misc Register"
        bitfld.long 0x00 0. " HS_USE_EXTERNAL_R ,Use external resistor to generate the current bias for the high speed transmitter." "0,1"
        textline "         "
        bitfld.long 0x00 1. " EN_DEGLITCH ,Enable the deglitching circuit of the USB PLL output." "0,1"
        textline "         "
        bitfld.long 0x00 30. " EN_CLK_UTMI ,Enables the clk to the UTMI block." "0,1"
width 8.
rgroup.long 0x260++0x3
    line.long 0x00 "DIGPROG,Chip Silicon Version"
        hexmask.long.byte 0x00 0.--8. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of the RTL version."
        textline "       "
        hexmask.long.word 0x00 8.--24. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of the RTL version."


tree.end



;--------------------------------------------------------------------------------
; USBC
;--------------------------------------------------------------------------------
tree "USBC"
    base ad:0x02184000

width 7.
rgroup.long 0x0++0x3
    line.long 0x00 "UOG_ID,Identification register"
        hexmask.long.byte 0x00 0.--6. 1. " ID ,Configuration number."
        textline "      "
        hexmask.long.byte 0x00 8.--14. 1. " NID ,Complement version of ID"
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " REVISION ,Revision number of the controller core."
width 14.
rgroup.long 0x4++0x3
    line.long 0x00 "UOG_HWGENERAL,Hardware General"
        hexmask.long.byte 0x00 4.--6. 1. " PHYW ,Data width of the transciever connected to the controller core."
        textline "             "
        hexmask.long.byte 0x00 6.--9. 1. " PHYM ,Transciever type PHYM bit reset value: '0000b' for OTG controller core, '0100b' for Host-only controller core."
        textline "             "
        hexmask.long.byte 0x00 9.--11. 1. " SM ,Serial interface mode capability SM bit reset value is '00b'"
width 11.
rgroup.long 0x8++0x3
    line.long 0x00 "UOG_HWHOST,Host Hardware Parameters"
        bitfld.long 0x00 0. " HC ,Host Capable." "0,1"
        textline "          "
        hexmask.long.byte 0x00 1.--4. 1. " NPORT ,The Nmber of downstream ports supported by the host controller is (NPORT+1)."
width 13.
rgroup.long 0xc++0x3
    line.long 0x00 "UOG_HWDEVICE,Device Hardware Parameters"
        bitfld.long 0x00 0. " DC ,Device Capable." "0,1"
        textline "            "
        hexmask.long.byte 0x00 1.--6. 1. " DEVEP ,Device Endpoint Number"
width 12.
rgroup.long 0x10++0x3
    line.long 0x00 "UOG_HWTXBUF,TX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " TXBURST ,Default burst size for memory to TX buffer transfer."
        textline "           "
        hexmask.long.byte 0x00 16.--24. 1. " TXCHANADD ,TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes."
width 12.
rgroup.long 0x14++0x3
    line.long 0x00 "UOG_HWRXBUF,RX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " RXBURST ,Default burst size for memory to RX buffer transfer."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " RXADD ,Buffer total size for all receive endpoints is (2^RXADD)."
width 15.
group.long 0x80++0x3
    line.long 0x00 "UOG_GPTIMER0LD,General Purpose Timer #0 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 17.
group.long 0x84++0x3
    line.long 0x00 "UOG_GPTIMER0CTRL,General Purpose Timer #0 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software; In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter value from GPTLD bits to start again." "0,1"
        textline "                "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 15.
group.long 0x88++0x3
    line.long 0x00 "UOG_GPTIMER1LD,General Purpose Timer #1 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 17.
group.long 0x8c++0x3
    line.long 0x00 "UOG_GPTIMER1CTRL,General Purpose Timer #1 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software." "0,1"
        textline "                "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 12.
group.long 0x90++0x3
    line.long 0x00 "UOG_SBUSCFG,System Bus Config"
        hexmask.long.byte 0x00 0.--3. 1. " AHBBRST ,AHB master interface Burst configuration These bits control AHB master transfer type sequence (or priority)."
width 14.
rgroup.byte 0x100++0x0
    line.byte 0x00 "UOG_CAPLENGTH,Capability Registers Length"
        hexmask.byte.byte 0x00 0.--8. 1. " CAPLENGTH ,These bits are used as an offset to add to register base to find the beginning of the Operational Register."
width 15.
rgroup.word 0x102++0x1
    line.word 0x00 "UOG_HCIVERSION,Host Controller Interface Version"
        hexmask.word.word 0x00 0.--16. 1. " HCIVERSION ,Host Controller Interface Version Number Default value is '10h', which means EHCI rev1.0."
width 14.
rgroup.long 0x104++0x3
    line.long 0x00 "UOG_HCSPARAMS,Host Controller Structural Parameters"
        hexmask.long.byte 0x00 0.--4. 1. " N_PORTS ,Number of downstream ports."
        textline "             "
        bitfld.long 0x00 4. " PPC ,Port Power Control This field indicates whether the host controller implementation includes port power control." "0,1"
        textline "             "
        hexmask.long.byte 0x00 8.--12. 1. " N_PCC ,Number of Ports per Companion Controller This field indicates the number of ports supported per internal Companion Controller."
        textline "             "
        hexmask.long.byte 0x00 12.--16. 1. " N_CC ,Number of Companion Controller (N_CC)."
        textline "             "
        bitfld.long 0x00 16. " PI ,Port Indicators (P INDICATOR) This bit indicates whether the ports support port indicator control." "0,1"
        textline "             "
        hexmask.long.byte 0x00 20.--24. 1. " N_PTT ,Number of Ports per Transaction Translator (N_PTT)."
        textline "             "
        hexmask.long.byte 0x00 24.--28. 1. " N_TT ,Number of Transaction Translators (N_TT)."
width 14.
rgroup.long 0x108++0x3
    line.long 0x00 "UOG_HCCPARAMS,Host Controller Capability Parameters"
        bitfld.long 0x00 0. " ADC ,64-bit Addressing Capability This bit is set '0b' in all controller core, no 64-bit addressing capability is supported." "0,1"
        textline "             "
        bitfld.long 0x00 1. " PFL ,Programmable Frame List Flag If this bit is set to zero, then the system software must use a frame list length of 1024 elements with this host controller." "0,1"
        textline "             "
        bitfld.long 0x00 2. " ASP ,Asynchronous Schedule Park Capability If this bit is set to a one, then the host controller supports the park feature for high-speed queue heads in the Asynchronous Schedule." "0,1"
        textline "             "
        hexmask.long.byte 0x00 4.--8. 1. " IST ,Isochronous Scheduling Threshold."
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " EECP ,EHCI Extended Capabilities Pointer."
width 15.
rgroup.word 0x120++0x1
    line.word 0x00 "UOG_DCIVERSION,Device Controller Interface Version"
        hexmask.word.word 0x00 0.--16. 1. " DCIVERSION ,Device Controller Interface Version Number Default value is '01h', which means rev0.1."
width 14.
rgroup.long 0x124++0x3
    line.long 0x00 "UOG_DCCPARAMS,Device Controller Capability Parameters"
        hexmask.long.byte 0x00 0.--5. 1. " DEN ,Device Endpoint Number This field indicates the number of endpoints built into the device controller."
        textline "             "
        bitfld.long 0x00 7. " DC ,Device Capable When this bit is 1, this controller is capable of operating as a USB 2.0 device." "0,1"
        textline "             "
        bitfld.long 0x00 8. " HC ,Host Capable When this bit is 1, this controller is capable of operating as an EHCI compatible USB 2.0 host controller." "0,1"
width 11.
group.long 0x140++0x3
    line.long 0x00 "UOG_USBCMD,USB Command Register"
        bitfld.long 0x00 0. " RS ,Run/Stop (RS) - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 1. " RST ,Controller Reset (RESET) - Read/Write." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " FS_1 ,See description at bit 15"
        textline "          "
        bitfld.long 0x00 4. " PSE ,Periodic Schedule Enable- Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 5. " ASE ,Asynchronous Schedule Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 6. " IAA ,Interrupt on Async Advance Doorbell - Read/Write." "0,1"
        textline "          "
        hexmask.long.byte 0x00 8.--10. 1. " ASP ,Asynchronous Schedule Park Mode Count - Read/Write."
        textline "          "
        bitfld.long 0x00 11. " ASPE ,Asynchronous Schedule Park Mode Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 13. " SUTW ,Setup TripWire - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 14. " ATDTW ,Add dTD TripWire - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 15. " FS_2 ,See also bits 3-2 Frame List Size - (Read/Write or Read Only)." "0,1"
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " ITC ,Interrupt Threshold Control -Read/Write."
width 11.
group.long 0x144++0x3
    line.long 0x00 "UOG_USBSTS,USB Status Register"
        bitfld.long 0x00 0. " UI ,USB Interrupt (USBINT) - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 1. " UEI ,USB Error Interrupt (USBERRINT) - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 2. " PCI ,Port Change Detect - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 3. " FRI ,Frame List Rollover - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 4. " SEI ,System Error- R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 5. " AAI ,Interrupt on Async Advance - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 6. " URI ,USB Reset Received - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SRI ,SOF Received - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 8. " SLI ,DCSuspend - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 10. " ULPII ,ULPI Interrupt - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 12. " HCH ,HCHaIted - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 13. " RCL ,Reclamation - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 14. " PS ,Periodic Schedule Status - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 15. " AS ,Asynchronous Schedule Status - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 16. " NAKI ,NAK Interrupt Bit--RO." "0,1"
        textline "          "
        bitfld.long 0x00 24. " TI0 ,General Purpose Timer Interrupt 0(GPTINT0)--R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 25. " TI1 ,General Purpose Timer Interrupt 1(GPTINT1)--R/WC." "0,1"
width 12.
group.long 0x148++0x3
    line.long 0x00 "UOG_USBINTR,Interrupt Enable Register"
        bitfld.long 0x00 0. " UE ,USB Interrupt Enalbe When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 1. " UEE ,USB Error Interrupt Enable When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 2. " PCE ,Port Change Detect Interrupt Enable When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 3. " FRE ,Frame List Rollover Interrupt Enable When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 4. " SEE ,System Error Interrupt Enable When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 5. " AAE ,Async Advance Interrupt Enable When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 6. " URE ,USB Reset Interrupt Enable When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 7. " SRE ,SOF Received Interrupt Enable When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 8. " SLE ,Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 10. " ULPIE ,ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 16. " NAKE ,NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 18. " UAIE ,USB Host Asynchronous Interrupt Enable When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "           "
        bitfld.long 0x00 19. " UPIE ,USB Host Periodic Interrupt Enable When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "           "
        bitfld.long 0x00 24. " TIE0 ,General Purpose Timer #0 Interrupt Enable When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 25. " TIE1 ,General Purpose Timer #1 Interrupt Enable When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
width 12.
group.long 0x14c++0x3
    line.long 0x00 "UOG_FRINDEX,USB Frame Index"
        hexmask.long.word 0x00 0.--14. 1. " FRINDEX ,Frame Index."
width 21.
group.long 0x154++0x3
    line.long 0x00 "UOG_PERIODICLISTBASE,Frame List Base Address"
        hexmask.long.long 0x00 12.--32. 1. " BASEADR ,Base Address (Low)."
width 15.
group.long 0x154++0x3
    line.long 0x00 "UOG_DEVICEADDR,Device Address"
        bitfld.long 0x00 24. " USBADRA ,Device Address Advance." "0,1"
        textline "              "
        hexmask.long.byte 0x00 25.--32. 1. " USBADR ,Device Address."
width 18.
group.long 0x158++0x3
    line.long 0x00 "UOG_ASYNCLISTADDR,Next Asynch. Address"
        hexmask.long.long 0x00 5.--32. 1. " ASYBASE ,Link Pointer Low (LPL)."
width 18.
group.long 0x158++0x3
    line.long 0x00 "UOG_ENDPTLISTADDR,Endpoint List Address"
        hexmask.long.long 0x00 11.--32. 1. " EPBASE ,Endpoint List Pointer(Low)."
width 14.
group.long 0x160++0x3
    line.long 0x00 "UOG_BURSTSIZE,Programmable Burst Size"
        hexmask.long.byte 0x00 0.--8. 1. " RXPBURST ,Programmable RX Burst Size."
        textline "             "
        hexmask.long.word 0x00 8.--17. 1. " TXPBURST ,Programmable TX Burst Size."
width 17.
group.long 0x164++0x3
    line.long 0x00 "UOG_TXFILLTUNING,TX FIFO Fill Tuning"
        hexmask.long.byte 0x00 0.--8. 1. " TXSCHOH ,Scheduler Overhead."
        textline "                "
        hexmask.long.byte 0x00 8.--13. 1. " TXSCHHEALTH ,Scheduler Health Counter."
        textline "                "
        hexmask.long.byte 0x00 16.--22. 1. " TXFIFOTHRES ,FIFO Burst Threshold."
width 13.
group.long 0x178++0x3
    line.long 0x00 "UOG_ENDPTNAK,Endpoint NAK"
        hexmask.long.byte 0x00 0.--8. 1. " EPRN ,RX Endpoint NAK - R/WC."
        textline "            "
        hexmask.long.byte 0x00 16.--24. 1. " EPTN ,TX Endpoint NAK - R/WC."
width 15.
group.long 0x17c++0x3
    line.long 0x00 "UOG_ENDPTNAKEN,Endpoint NAK Enable"
        hexmask.long.byte 0x00 0.--8. 1. " EPRNE ,RX Endpoint NAK Enable - R/W."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " EPTNE ,TX Endpoint NAK Enable - R/W."
width 15.
group.long 0x180++0x3
    line.long 0x00 "UOG_CONFIGFLAG,Configure Flag Register"
        bitfld.long 0x00 0. " CF ,Configure Flag Host software sets this bit as the last action in its process of configuring the Host Controller." "0,1"
width 12.
group.long 0x184++0x3
    line.long 0x00 "UOG_PORTSC1,Port Status & Control"
        bitfld.long 0x00 0. " CCS ,Current Connect Status-Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 1. " CSC ,Connect Status Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 2. " PE ,Port Enabled/Disabled-Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 3. " PEC ,Port Enable/Disable Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 4. " OCA ,Over-current Active-Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 5. " OCC ,Over-current Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 6. " FPR ,Force Port Resume -Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 7. " SUSP ,Suspend - Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 8. " PR ,Port Reset - Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 9. " HSP ,High-Speed Port - Read Only." "0,1"
        textline "           "
        hexmask.long.byte 0x00 10.--12. 1. " LS ,Line Status-Read Only."
        textline "           "
        bitfld.long 0x00 12. " PP ,Port Power (PP)-Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 13. " PO ,Port Owner-Read/Write." "0,1"
        textline "           "
        hexmask.long.byte 0x00 14.--16. 1. " PIC ,Port Indicator Control - Read/Write."
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " PTC ,Port Test Control - Read/Write."
        textline "           "
        bitfld.long 0x00 20. " WKCN ,Wake on Connect Enable (WKCNNT_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 21. " WKDC ,Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 22. " WKOC ,Wake on Over-current Enable (WKOC_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 23. " PHCD ,PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 24. " PFSC ,Port Force Full Speed Connect - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 25. " PTS_2 ,See description at bits 31-30" "0,1"
        textline "           "
        hexmask.long.byte 0x00 26.--28. 1. " PSPD ,Port Speed - Read Only."
        textline "           "
        bitfld.long 0x00 28. " PTW ,Parallel Transceiver Width This bit has no effect if serial interface engine is used." "0,1"
        textline "           "
        bitfld.long 0x00 29. " STS ,Serial Transceiver Select - Read Only Serial Transceiver Select 1 Serial Interface Engine is selected 0 Parallel Interface signals is selected Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals." "0,1"
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " PTS_1 ,Bit field {bit25, bit31, bit30}: ""000b"" UTMI/UTMI+ ""001b"" Reserved ""010b"" ULPI ""011b"" Serial/USB 1.1 PHY/IC-USB (FS Only) ""100b"" HSIC Parallel Transceiver Select (bit25, bit31, bi30)."
width 10.
group.long 0x1a4++0x3
    line.long 0x00 "UOG_OTGSC,On-The-Go Status & control"
        bitfld.long 0x00 0. " VD ,VBUS_Discharge - Read/Write." "0,1"
        textline "         "
        bitfld.long 0x00 1. " VC ,VBUS Charge - Read/Write." "0,1"
        textline "         "
        bitfld.long 0x00 3. " OT ,OTG Termination - Read/Write." "0,1"
        textline "         "
        bitfld.long 0x00 4. " DP ,Data Pulsing - Read/Write." "0,1"
        textline "         "
        bitfld.long 0x00 5. " IDPU ,ID Pullup - Read/Write This bit provide control over the ID pull-up resister; 0 = off, 1 = on [default]." "0,1"
        textline "         "
        bitfld.long 0x00 8. " ID ,USB ID - Read Only." "0,1"
        textline "         "
        bitfld.long 0x00 9. " AVV ,A VBus Valid - Read Only." "0,1"
        textline "         "
        bitfld.long 0x00 10. " ASV ,A Session Valid - Read Only." "0,1"
        textline "         "
        bitfld.long 0x00 11. " BSV ,B Session Valid - Read Only." "0,1"
        textline "         "
        bitfld.long 0x00 12. " BSE ,B Session End - Read Only." "0,1"
        textline "         "
        bitfld.long 0x00 13. " _1MST ,1 millisecond timer toggle - Read Only." "0,1"
        textline "         "
        bitfld.long 0x00 14. " DPS ,Data Bus Pulsing Status - Read Only." "0,1"
        textline "         "
        bitfld.long 0x00 16. " IDIS ,USB ID Interrupt Status - Read/Write." "0,1"
        textline "         "
        bitfld.long 0x00 17. " AVVIS ,A VBus Valid Interrupt Status - Read/Write to Clear." "0,1"
        textline "         "
        bitfld.long 0x00 18. " ASVIS ,A Session Valid Interrupt Status - Read/Write to Clear." "0,1"
        textline "         "
        bitfld.long 0x00 19. " BSVIS ,B Session Valid Interrupt Status - Read/Write to Clear." "0,1"
        textline "         "
        bitfld.long 0x00 20. " BSEIS ,B Session End Interrupt Status - Read/Write to Clear." "0,1"
        textline "         "
        bitfld.long 0x00 21. " _1MSS ,1 millisecond timer Interrupt Status - Read/Write to Clear." "0,1"
        textline "         "
        bitfld.long 0x00 22. " DPIS ,Data Pulse Interrupt Status - Read/Write to Clear." "0,1"
        textline "         "
        bitfld.long 0x00 24. " IDIE ,USB ID Interrupt Enable - Read/Write." "0,1"
        textline "         "
        bitfld.long 0x00 25. " AVVIE ,A VBus Valid Interrupt Enable - Read/Write." "0,1"
        textline "         "
        bitfld.long 0x00 26. " ASVIE ,A Session Valid Interrupt Enable - Read/Write." "0,1"
        textline "         "
        bitfld.long 0x00 27. " BSVIE ,B Session Valid Interrupt Enable - Read/Write." "0,1"
        textline "         "
        bitfld.long 0x00 28. " BSEIE ,B Session End Interrupt Enable - Read/Write." "0,1"
        textline "         "
        bitfld.long 0x00 29. " _1MSE ,1 millisecond timer Interrupt Enable - Read/Write" "0,1"
        textline "         "
        bitfld.long 0x00 30. " DPIE ,Data Pulse Interrupt Enable" "0,1"
width 12.
group.long 0x1a8++0x3
    line.long 0x00 "UOG_USBMODE,USB Device Mode"
        hexmask.long.byte 0x00 0.--2. 1. " CM ,Controller Mode - R/WO."
        textline "           "
        bitfld.long 0x00 2. " ES ,Endian Select - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 3. " SLOM ,Setup Lockout Mode." "0,1"
        textline "           "
        bitfld.long 0x00 4. " SDIS ,Stream Disable Mode." "0,1"
width 19.
group.long 0x1ac++0x3
    line.long 0x00 "UOG_ENDPTSETUPSTAT,Endpoint Setup Status"
        hexmask.long.word 0x00 0.--16. 1. " ENDPTSETUPSTAT ,Setup Endpoint Status."
width 15.
group.long 0x1b0++0x3
    line.long 0x00 "UOG_ENDPTPRIME,Endpoint Prime"
        hexmask.long.byte 0x00 0.--8. 1. " PERB ,Prime Endpoint Receive Buffer - R/WS."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " PETB ,Prime Endpoint Transmit Buffer - R/WS."
width 15.
group.long 0x1b4++0x3
    line.long 0x00 "UOG_ENDPTFLUSH,Endpoint Flush"
        hexmask.long.byte 0x00 0.--8. 1. " FERB ,Flush Endpoint Receive Buffer - R/WS."
        textline "              "
        hexmask.long.byte 0x00 16.--24. 1. " FETB ,Flush Endpoint Transmit Buffer - R/WS."
width 14.
rgroup.long 0x1b8++0x3
    line.long 0x00 "UOG_ENDPTSTAT,Endpoint Status"
        hexmask.long.byte 0x00 0.--8. 1. " ERBR ,Endpoint Receive Buffer Ready -- Read Only."
        textline "             "
        hexmask.long.byte 0x00 16.--24. 1. " ETBR ,Endpoint Transmit Buffer Ready -- Read Only."
width 18.
group.long 0x1bc++0x3
    line.long 0x00 "UOG_ENDPTCOMPLETE,Endpoint Complete"
        hexmask.long.byte 0x00 0.--8. 1. " ERCE ,Endpoint Receive Complete Event - RW/C."
        textline "                 "
        hexmask.long.byte 0x00 16.--24. 1. " ETCE ,Endpoint Transmit Complete Event - R/WC."
width 15.
group.long 0x1c0++0x3
    line.long 0x00 "UOG_ENDPTCTRL0,Endpoint Control0"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "              "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control Endpoint0 is fixed as a Control End Point."
        textline "              "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 1 Enabled Endpoint0 is always enabled." "0,1"
        textline "              "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK [Default] 1 End Point Stalled Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host." "0,1"
        textline "              "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 - Control Endpoint0 is fixed as a Control End Point."
        textline "              "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 1 Enabled Endpoint0 is always enabled." "0,1"
width 15.
group.long 0x1c4++0x3
    line.long 0x00 "UOG_ENDPTCTRL1,Endpoint Control 1"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "              "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "              "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "              "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "              "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "              "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "              "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "              "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "              "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "              "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "              "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "              "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 15.
group.long 0x1c8++0x3
    line.long 0x00 "UOG_ENDPTCTRL2,Endpoint Control 2"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "              "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "              "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "              "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "              "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "              "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "              "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "              "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "              "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "              "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "              "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "              "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 15.
group.long 0x1cc++0x3
    line.long 0x00 "UOG_ENDPTCTRL3,Endpoint Control 3"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "              "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "              "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "              "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "              "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "              "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "              "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "              "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "              "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "              "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "              "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "              "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 15.
group.long 0x1d0++0x3
    line.long 0x00 "UOG_ENDPTCTRL4,Endpoint Control 4"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "              "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "              "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "              "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "              "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "              "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "              "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "              "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "              "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "              "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "              "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "              "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 15.
group.long 0x1d4++0x3
    line.long 0x00 "UOG_ENDPTCTRL5,Endpoint Control 5"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "              "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "              "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "              "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "              "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "              "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "              "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "              "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "              "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "              "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "              "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "              "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 15.
group.long 0x1d8++0x3
    line.long 0x00 "UOG_ENDPTCTRL6,Endpoint Control 6"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "              "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "              "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "              "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "              "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "              "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "              "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "              "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "              "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "              "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "              "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "              "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 15.
group.long 0x1dc++0x3
    line.long 0x00 "UOG_ENDPTCTRL7,Endpoint Control 7"
        bitfld.long 0x00 0. " RXS ,RX Endpoint Stall - Read/Write 0 End Point OK." "0,1"
        textline "              "
        bitfld.long 0x00 1. " RXD ,RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA Engine [Default] Should always be written as zero." "0,1"
        textline "              "
        hexmask.long.byte 0x00 2.--4. 1. " RXT ,RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Reserved"
        textline "              "
        bitfld.long 0x00 5. " RXI ,RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only used for test and should always be written as zero." "0,1"
        textline "              "
        bitfld.long 0x00 6. " RXR ,RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the host and device." "0,1"
        textline "              "
        bitfld.long 0x00 7. " RXE ,RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
        textline "              "
        bitfld.long 0x00 16. " TXS ,TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This bit is set automatically upon receipt of a SETUP request if this Endpoint is not configured as a Control Endpoint." "0,1"
        textline "              "
        bitfld.long 0x00 17. " TXD ,TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Engine [DEFAULT] Should always be written as 0." "0,1"
        textline "              "
        hexmask.long.byte 0x00 18.--20. 1. " TXT ,TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Interrupt"
        textline "              "
        bitfld.long 0x00 21. " TXI ,TX Data Toggle Inhibit 0 PID Sequencing Enabled." "0,1"
        textline "              "
        bitfld.long 0x00 22. " TXR ,TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order to synchronize the data PID's between the Host and device." "0,1"
        textline "              "
        bitfld.long 0x00 23. " TXE ,TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should be enabled only after it has been configured." "0,1"
width 7.
rgroup.long 0x200++0x3
    line.long 0x00 "UH1_ID,Identification register"
        hexmask.long.byte 0x00 0.--6. 1. " ID ,Configuration number."
        textline "      "
        hexmask.long.byte 0x00 8.--14. 1. " NID ,Complement version of ID"
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " REVISION ,Revision number of the controller core."
width 14.
rgroup.long 0x204++0x3
    line.long 0x00 "UH1_HWGENERAL,Hardware General"
        hexmask.long.byte 0x00 4.--6. 1. " PHYW ,Data width of the transciever connected to the controller core."
        textline "             "
        hexmask.long.byte 0x00 6.--9. 1. " PHYM ,Transciever type PHYM bit reset value: '0000b' for OTG controller core, '0100b' for Host-only controller core."
        textline "             "
        hexmask.long.byte 0x00 9.--11. 1. " SM ,Serial interface mode capability SM bit reset value is '00b'"
width 11.
rgroup.long 0x208++0x3
    line.long 0x00 "UH1_HWHOST,Host Hardware Parameters"
        bitfld.long 0x00 0. " HC ,Host Capable." "0,1"
        textline "          "
        hexmask.long.byte 0x00 1.--4. 1. " NPORT ,The Nmber of downstream ports supported by the host controller is (NPORT+1)."
width 12.
rgroup.long 0x210++0x3
    line.long 0x00 "UH1_HWTXBUF,TX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " TXBURST ,Default burst size for memory to TX buffer transfer."
        textline "           "
        hexmask.long.byte 0x00 16.--24. 1. " TXCHANADD ,TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes."
width 12.
rgroup.long 0x214++0x3
    line.long 0x00 "UH1_HWRXBUF,RX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " RXBURST ,Default burst size for memory to RX buffer transfer."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " RXADD ,Buffer total size for all receive endpoints is (2^RXADD)."
width 15.
group.long 0x280++0x3
    line.long 0x00 "UH1_GPTIMER0LD,General Purpose Timer #0 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 17.
group.long 0x284++0x3
    line.long 0x00 "UH1_GPTIMER0CTRL,General Purpose Timer #0 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software; In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter value from GPTLD bits to start again." "0,1"
        textline "                "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 15.
group.long 0x288++0x3
    line.long 0x00 "UH1_GPTIMER1LD,General Purpose Timer #1 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 17.
group.long 0x28c++0x3
    line.long 0x00 "UH1_GPTIMER1CTRL,General Purpose Timer #1 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software." "0,1"
        textline "                "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 12.
group.long 0x290++0x3
    line.long 0x00 "UH1_SBUSCFG,System Bus Config"
        hexmask.long.byte 0x00 0.--3. 1. " AHBBRST ,AHB master interface Burst configuration These bits control AHB master transfer type sequence (or priority)."
width 14.
rgroup.byte 0x300++0x0
    line.byte 0x00 "UH1_CAPLENGTH,Capability Registers Length"
        hexmask.byte.byte 0x00 0.--8. 1. " CAPLENGTH ,These bits are used as an offset to add to register base to find the beginning of the Operational Register."
width 15.
rgroup.word 0x302++0x1
    line.word 0x00 "UH1_HCIVERSION,Host Controller Interface Version"
        hexmask.word.word 0x00 0.--16. 1. " HCIVERSION ,Host Controller Interface Version Number Default value is '10h', which means EHCI rev1.0."
width 14.
rgroup.long 0x304++0x3
    line.long 0x00 "UH1_HCSPARAMS,Host Controller Structural Parameters"
        hexmask.long.byte 0x00 0.--4. 1. " N_PORTS ,Number of downstream ports."
        textline "             "
        bitfld.long 0x00 4. " PPC ,Port Power Control This field indicates whether the host controller implementation includes port power control." "0,1"
        textline "             "
        hexmask.long.byte 0x00 8.--12. 1. " N_PCC ,Number of Ports per Companion Controller This field indicates the number of ports supported per internal Companion Controller."
        textline "             "
        hexmask.long.byte 0x00 12.--16. 1. " N_CC ,Number of Companion Controller (N_CC)."
        textline "             "
        bitfld.long 0x00 16. " PI ,Port Indicators (P INDICATOR) This bit indicates whether the ports support port indicator control." "0,1"
        textline "             "
        hexmask.long.byte 0x00 20.--24. 1. " N_PTT ,Number of Ports per Transaction Translator (N_PTT)."
        textline "             "
        hexmask.long.byte 0x00 24.--28. 1. " N_TT ,Number of Transaction Translators (N_TT)."
width 14.
rgroup.long 0x308++0x3
    line.long 0x00 "UH1_HCCPARAMS,Host Controller Capability Parameters"
        bitfld.long 0x00 0. " ADC ,64-bit Addressing Capability This bit is set '0b' in all controller core, no 64-bit addressing capability is supported." "0,1"
        textline "             "
        bitfld.long 0x00 1. " PFL ,Programmable Frame List Flag If this bit is set to zero, then the system software must use a frame list length of 1024 elements with this host controller." "0,1"
        textline "             "
        bitfld.long 0x00 2. " ASP ,Asynchronous Schedule Park Capability If this bit is set to a one, then the host controller supports the park feature for high-speed queue heads in the Asynchronous Schedule." "0,1"
        textline "             "
        hexmask.long.byte 0x00 4.--8. 1. " IST ,Isochronous Scheduling Threshold."
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " EECP ,EHCI Extended Capabilities Pointer."
width 11.
group.long 0x340++0x3
    line.long 0x00 "UH1_USBCMD,USB Command Register"
        bitfld.long 0x00 0. " RS ,Run/Stop (RS) - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 1. " RST ,Controller Reset (RESET) - Read/Write." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " FS_1 ,See description at bit 15"
        textline "          "
        bitfld.long 0x00 4. " PSE ,Periodic Schedule Enable- Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 5. " ASE ,Asynchronous Schedule Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 6. " IAA ,Interrupt on Async Advance Doorbell - Read/Write." "0,1"
        textline "          "
        hexmask.long.byte 0x00 8.--10. 1. " ASP ,Asynchronous Schedule Park Mode Count - Read/Write."
        textline "          "
        bitfld.long 0x00 11. " ASPE ,Asynchronous Schedule Park Mode Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 13. " SUTW ,Setup TripWire - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 14. " ATDTW ,Add dTD TripWire - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 15. " FS_2 ,See also bits 3-2 Frame List Size - (Read/Write or Read Only)." "0,1"
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " ITC ,Interrupt Threshold Control -Read/Write."
width 11.
group.long 0x344++0x3
    line.long 0x00 "UH1_USBSTS,USB Status Register"
        bitfld.long 0x00 0. " UI ,USB Interrupt (USBINT) - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 1. " UEI ,USB Error Interrupt (USBERRINT) - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 2. " PCI ,Port Change Detect - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 3. " FRI ,Frame List Rollover - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 4. " SEI ,System Error- R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 5. " AAI ,Interrupt on Async Advance - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 6. " URI ,USB Reset Received - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SRI ,SOF Received - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 8. " SLI ,DCSuspend - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 10. " ULPII ,ULPI Interrupt - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 12. " HCH ,HCHaIted - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 13. " RCL ,Reclamation - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 14. " PS ,Periodic Schedule Status - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 15. " AS ,Asynchronous Schedule Status - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 16. " NAKI ,NAK Interrupt Bit--RO." "0,1"
        textline "          "
        bitfld.long 0x00 24. " TI0 ,General Purpose Timer Interrupt 0(GPTINT0)--R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 25. " TI1 ,General Purpose Timer Interrupt 1(GPTINT1)--R/WC." "0,1"
width 12.
group.long 0x348++0x3
    line.long 0x00 "UH1_USBINTR,Interrupt Enable Register"
        bitfld.long 0x00 0. " UE ,USB Interrupt Enalbe When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 1. " UEE ,USB Error Interrupt Enable When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 2. " PCE ,Port Change Detect Interrupt Enable When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 3. " FRE ,Frame List Rollover Interrupt Enable When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 4. " SEE ,System Error Interrupt Enable When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 5. " AAE ,Async Advance Interrupt Enable When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 6. " URE ,USB Reset Interrupt Enable When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 7. " SRE ,SOF Received Interrupt Enable When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 8. " SLE ,Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 10. " ULPIE ,ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 16. " NAKE ,NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 18. " UAIE ,USB Host Asynchronous Interrupt Enable When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "           "
        bitfld.long 0x00 19. " UPIE ,USB Host Periodic Interrupt Enable When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "           "
        bitfld.long 0x00 24. " TIE0 ,General Purpose Timer #0 Interrupt Enable When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 25. " TIE1 ,General Purpose Timer #1 Interrupt Enable When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
width 12.
group.long 0x34c++0x3
    line.long 0x00 "UH1_FRINDEX,USB Frame Index"
        hexmask.long.word 0x00 0.--14. 1. " FRINDEX ,Frame Index."
width 21.
group.long 0x354++0x3
    line.long 0x00 "UH1_PERIODICLISTBASE,Frame List Base Address"
        hexmask.long.long 0x00 12.--32. 1. " BASEADR ,Base Address (Low)."
width 18.
group.long 0x358++0x3
    line.long 0x00 "UH1_ASYNCLISTADDR,Next Asynch. Address"
        hexmask.long.long 0x00 5.--32. 1. " ASYBASE ,Link Pointer Low (LPL)."
width 14.
group.long 0x360++0x3
    line.long 0x00 "UH1_BURSTSIZE,Programmable Burst Size"
        hexmask.long.byte 0x00 0.--8. 1. " RXPBURST ,Programmable RX Burst Size."
        textline "             "
        hexmask.long.word 0x00 8.--17. 1. " TXPBURST ,Programmable TX Burst Size."
width 17.
group.long 0x364++0x3
    line.long 0x00 "UH1_TXFILLTUNING,TX FIFO Fill Tuning"
        hexmask.long.byte 0x00 0.--8. 1. " TXSCHOH ,Scheduler Overhead."
        textline "                "
        hexmask.long.byte 0x00 8.--13. 1. " TXSCHHEALTH ,Scheduler Health Counter."
        textline "                "
        hexmask.long.byte 0x00 16.--22. 1. " TXFIFOTHRES ,FIFO Burst Threshold."
width 15.
group.long 0x380++0x3
    line.long 0x00 "UH1_CONFIGFLAG,Configure Flag Register"
        bitfld.long 0x00 0. " CF ,Configure Flag Host software sets this bit as the last action in its process of configuring the Host Controller." "0,1"
width 12.
group.long 0x384++0x3
    line.long 0x00 "UH1_PORTSC1,Port Status & Control"
        bitfld.long 0x00 0. " CCS ,Current Connect Status-Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 1. " CSC ,Connect Status Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 2. " PE ,Port Enabled/Disabled-Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 3. " PEC ,Port Enable/Disable Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 4. " OCA ,Over-current Active-Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 5. " OCC ,Over-current Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 6. " FPR ,Force Port Resume -Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 7. " SUSP ,Suspend - Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 8. " PR ,Port Reset - Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 9. " HSP ,High-Speed Port - Read Only." "0,1"
        textline "           "
        hexmask.long.byte 0x00 10.--12. 1. " LS ,Line Status-Read Only."
        textline "           "
        bitfld.long 0x00 12. " PP ,Port Power (PP)-Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 13. " PO ,Port Owner-Read/Write." "0,1"
        textline "           "
        hexmask.long.byte 0x00 14.--16. 1. " PIC ,Port Indicator Control - Read/Write."
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " PTC ,Port Test Control - Read/Write."
        textline "           "
        bitfld.long 0x00 20. " WKCN ,Wake on Connect Enable (WKCNNT_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 21. " WKDC ,Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 22. " WKOC ,Wake on Over-current Enable (WKOC_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 23. " PHCD ,PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 24. " PFSC ,Port Force Full Speed Connect - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 25. " PTS_2 ,See description at bits 31-30" "0,1"
        textline "           "
        hexmask.long.byte 0x00 26.--28. 1. " PSPD ,Port Speed - Read Only."
        textline "           "
        bitfld.long 0x00 28. " PTW ,Parallel Transceiver Width This bit has no effect if serial interface engine is used." "0,1"
        textline "           "
        bitfld.long 0x00 29. " STS ,Serial Transceiver Select - Read Only Serial Transceiver Select 1 Serial Interface Engine is selected 0 Parallel Interface signals is selected Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals." "0,1"
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " PTS_1 ,Bit field {bit25, bit31, bit30}: ""000b"" UTMI/UTMI+ ""001b"" Reserved ""010b"" ULPI ""011b"" Serial/USB 1.1 PHY/IC-USB (FS Only) ""100b"" HSIC Parallel Transceiver Select (bit25, bit31, bi30)."
width 12.
group.long 0x3a8++0x3
    line.long 0x00 "UH1_USBMODE,USB Device Mode"
        hexmask.long.byte 0x00 0.--2. 1. " CM ,Controller Mode - R/WO."
        textline "           "
        bitfld.long 0x00 2. " ES ,Endian Select - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 3. " SLOM ,Setup Lockout Mode." "0,1"
        textline "           "
        bitfld.long 0x00 4. " SDIS ,Stream Disable Mode." "0,1"
width 7.
rgroup.long 0x400++0x3
    line.long 0x00 "UH2_ID,Identification register"
        hexmask.long.byte 0x00 0.--6. 1. " ID ,Configuration number."
        textline "      "
        hexmask.long.byte 0x00 8.--14. 1. " NID ,Complement version of ID"
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " REVISION ,Revision number of the controller core."
width 14.
rgroup.long 0x404++0x3
    line.long 0x00 "UH2_HWGENERAL,Hardware General"
        hexmask.long.byte 0x00 4.--6. 1. " PHYW ,Data width of the transciever connected to the controller core."
        textline "             "
        hexmask.long.byte 0x00 6.--9. 1. " PHYM ,Transciever type PHYM bit reset value: '0000b' for OTG controller core, '0100b' for Host-only controller core."
        textline "             "
        hexmask.long.byte 0x00 9.--11. 1. " SM ,Serial interface mode capability SM bit reset value is '00b'"
width 11.
rgroup.long 0x408++0x3
    line.long 0x00 "UH2_HWHOST,Host Hardware Parameters"
        bitfld.long 0x00 0. " HC ,Host Capable." "0,1"
        textline "          "
        hexmask.long.byte 0x00 1.--4. 1. " NPORT ,The Nmber of downstream ports supported by the host controller is (NPORT+1)."
width 12.
rgroup.long 0x410++0x3
    line.long 0x00 "UH2_HWTXBUF,TX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " TXBURST ,Default burst size for memory to TX buffer transfer."
        textline "           "
        hexmask.long.byte 0x00 16.--24. 1. " TXCHANADD ,TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes."
width 12.
rgroup.long 0x414++0x3
    line.long 0x00 "UH2_HWRXBUF,RX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " RXBURST ,Default burst size for memory to RX buffer transfer."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " RXADD ,Buffer total size for all receive endpoints is (2^RXADD)."
width 15.
group.long 0x480++0x3
    line.long 0x00 "UH2_GPTIMER0LD,General Purpose Timer #0 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 17.
group.long 0x484++0x3
    line.long 0x00 "UH2_GPTIMER0CTRL,General Purpose Timer #0 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software; In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter value from GPTLD bits to start again." "0,1"
        textline "                "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 15.
group.long 0x488++0x3
    line.long 0x00 "UH2_GPTIMER1LD,General Purpose Timer #1 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 17.
group.long 0x48c++0x3
    line.long 0x00 "UH2_GPTIMER1CTRL,General Purpose Timer #1 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software." "0,1"
        textline "                "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 12.
group.long 0x490++0x3
    line.long 0x00 "UH2_SBUSCFG,System Bus Config"
        hexmask.long.byte 0x00 0.--3. 1. " AHBBRST ,AHB master interface Burst configuration These bits control AHB master transfer type sequence (or priority)."
width 14.
rgroup.byte 0x500++0x0
    line.byte 0x00 "UH2_CAPLENGTH,Capability Registers Length"
        hexmask.byte.byte 0x00 0.--8. 1. " CAPLENGTH ,These bits are used as an offset to add to register base to find the beginning of the Operational Register."
width 15.
rgroup.word 0x502++0x1
    line.word 0x00 "UH2_HCIVERSION,Host Controller Interface Version"
        hexmask.word.word 0x00 0.--16. 1. " HCIVERSION ,Host Controller Interface Version Number Default value is '10h', which means EHCI rev1.0."
width 14.
rgroup.long 0x504++0x3
    line.long 0x00 "UH2_HCSPARAMS,Host Controller Structural Parameters"
        hexmask.long.byte 0x00 0.--4. 1. " N_PORTS ,Number of downstream ports."
        textline "             "
        bitfld.long 0x00 4. " PPC ,Port Power Control This field indicates whether the host controller implementation includes port power control." "0,1"
        textline "             "
        hexmask.long.byte 0x00 8.--12. 1. " N_PCC ,Number of Ports per Companion Controller This field indicates the number of ports supported per internal Companion Controller."
        textline "             "
        hexmask.long.byte 0x00 12.--16. 1. " N_CC ,Number of Companion Controller (N_CC)."
        textline "             "
        bitfld.long 0x00 16. " PI ,Port Indicators (P INDICATOR) This bit indicates whether the ports support port indicator control." "0,1"
        textline "             "
        hexmask.long.byte 0x00 20.--24. 1. " N_PTT ,Number of Ports per Transaction Translator (N_PTT)."
        textline "             "
        hexmask.long.byte 0x00 24.--28. 1. " N_TT ,Number of Transaction Translators (N_TT)."
width 14.
rgroup.long 0x508++0x3
    line.long 0x00 "UH2_HCCPARAMS,Host Controller Capability Parameters"
        bitfld.long 0x00 0. " ADC ,64-bit Addressing Capability This bit is set '0b' in all controller core, no 64-bit addressing capability is supported." "0,1"
        textline "             "
        bitfld.long 0x00 1. " PFL ,Programmable Frame List Flag If this bit is set to zero, then the system software must use a frame list length of 1024 elements with this host controller." "0,1"
        textline "             "
        bitfld.long 0x00 2. " ASP ,Asynchronous Schedule Park Capability If this bit is set to a one, then the host controller supports the park feature for high-speed queue heads in the Asynchronous Schedule." "0,1"
        textline "             "
        hexmask.long.byte 0x00 4.--8. 1. " IST ,Isochronous Scheduling Threshold."
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " EECP ,EHCI Extended Capabilities Pointer."
width 11.
group.long 0x540++0x3
    line.long 0x00 "UH2_USBCMD,USB Command Register"
        bitfld.long 0x00 0. " RS ,Run/Stop (RS) - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 1. " RST ,Controller Reset (RESET) - Read/Write." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " FS_1 ,See description at bit 15"
        textline "          "
        bitfld.long 0x00 4. " PSE ,Periodic Schedule Enable- Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 5. " ASE ,Asynchronous Schedule Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 6. " IAA ,Interrupt on Async Advance Doorbell - Read/Write." "0,1"
        textline "          "
        hexmask.long.byte 0x00 8.--10. 1. " ASP ,Asynchronous Schedule Park Mode Count - Read/Write."
        textline "          "
        bitfld.long 0x00 11. " ASPE ,Asynchronous Schedule Park Mode Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 13. " SUTW ,Setup TripWire - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 14. " ATDTW ,Add dTD TripWire - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 15. " FS_2 ,See also bits 3-2 Frame List Size - (Read/Write or Read Only)." "0,1"
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " ITC ,Interrupt Threshold Control -Read/Write."
width 11.
group.long 0x544++0x3
    line.long 0x00 "UH2_USBSTS,USB Status Register"
        bitfld.long 0x00 0. " UI ,USB Interrupt (USBINT) - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 1. " UEI ,USB Error Interrupt (USBERRINT) - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 2. " PCI ,Port Change Detect - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 3. " FRI ,Frame List Rollover - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 4. " SEI ,System Error- R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 5. " AAI ,Interrupt on Async Advance - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 6. " URI ,USB Reset Received - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SRI ,SOF Received - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 8. " SLI ,DCSuspend - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 10. " ULPII ,ULPI Interrupt - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 12. " HCH ,HCHaIted - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 13. " RCL ,Reclamation - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 14. " PS ,Periodic Schedule Status - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 15. " AS ,Asynchronous Schedule Status - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 16. " NAKI ,NAK Interrupt Bit--RO." "0,1"
        textline "          "
        bitfld.long 0x00 24. " TI0 ,General Purpose Timer Interrupt 0(GPTINT0)--R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 25. " TI1 ,General Purpose Timer Interrupt 1(GPTINT1)--R/WC." "0,1"
width 12.
group.long 0x548++0x3
    line.long 0x00 "UH2_USBINTR,Interrupt Enable Register"
        bitfld.long 0x00 0. " UE ,USB Interrupt Enalbe When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 1. " UEE ,USB Error Interrupt Enable When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 2. " PCE ,Port Change Detect Interrupt Enable When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 3. " FRE ,Frame List Rollover Interrupt Enable When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 4. " SEE ,System Error Interrupt Enable When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 5. " AAE ,Async Advance Interrupt Enable When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 6. " URE ,USB Reset Interrupt Enable When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 7. " SRE ,SOF Received Interrupt Enable When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 8. " SLE ,Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 10. " ULPIE ,ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 16. " NAKE ,NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 18. " UAIE ,USB Host Asynchronous Interrupt Enable When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "           "
        bitfld.long 0x00 19. " UPIE ,USB Host Periodic Interrupt Enable When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "           "
        bitfld.long 0x00 24. " TIE0 ,General Purpose Timer #0 Interrupt Enable When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 25. " TIE1 ,General Purpose Timer #1 Interrupt Enable When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
width 12.
group.long 0x54c++0x3
    line.long 0x00 "UH2_FRINDEX,USB Frame Index"
        hexmask.long.word 0x00 0.--14. 1. " FRINDEX ,Frame Index."
width 21.
group.long 0x554++0x3
    line.long 0x00 "UH2_PERIODICLISTBASE,Frame List Base Address"
        hexmask.long.long 0x00 12.--32. 1. " BASEADR ,Base Address (Low)."
width 18.
group.long 0x558++0x3
    line.long 0x00 "UH2_ASYNCLISTADDR,Next Asynch. Address"
        hexmask.long.long 0x00 5.--32. 1. " ASYBASE ,Link Pointer Low (LPL)."
width 14.
group.long 0x560++0x3
    line.long 0x00 "UH2_BURSTSIZE,Programmable Burst Size"
        hexmask.long.byte 0x00 0.--8. 1. " RXPBURST ,Programmable RX Burst Size."
        textline "             "
        hexmask.long.word 0x00 8.--17. 1. " TXPBURST ,Programmable TX Burst Size."
width 17.
group.long 0x564++0x3
    line.long 0x00 "UH2_TXFILLTUNING,TX FIFO Fill Tuning"
        hexmask.long.byte 0x00 0.--8. 1. " TXSCHOH ,Scheduler Overhead."
        textline "                "
        hexmask.long.byte 0x00 8.--13. 1. " TXSCHHEALTH ,Scheduler Health Counter."
        textline "                "
        hexmask.long.byte 0x00 16.--22. 1. " TXFIFOTHRES ,FIFO Burst Threshold."
width 15.
group.long 0x580++0x3
    line.long 0x00 "UH2_CONFIGFLAG,Configure Flag Register"
        bitfld.long 0x00 0. " CF ,Configure Flag Host software sets this bit as the last action in its process of configuring the Host Controller." "0,1"
width 12.
group.long 0x584++0x3
    line.long 0x00 "UH2_PORTSC1,Port Status & Control"
        bitfld.long 0x00 0. " CCS ,Current Connect Status-Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 1. " CSC ,Connect Status Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 2. " PE ,Port Enabled/Disabled-Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 3. " PEC ,Port Enable/Disable Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 4. " OCA ,Over-current Active-Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 5. " OCC ,Over-current Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 6. " FPR ,Force Port Resume -Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 7. " SUSP ,Suspend - Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 8. " PR ,Port Reset - Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 9. " HSP ,High-Speed Port - Read Only." "0,1"
        textline "           "
        hexmask.long.byte 0x00 10.--12. 1. " LS ,Line Status-Read Only."
        textline "           "
        bitfld.long 0x00 12. " PP ,Port Power (PP)-Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 13. " PO ,Port Owner-Read/Write." "0,1"
        textline "           "
        hexmask.long.byte 0x00 14.--16. 1. " PIC ,Port Indicator Control - Read/Write."
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " PTC ,Port Test Control - Read/Write."
        textline "           "
        bitfld.long 0x00 20. " WKCN ,Wake on Connect Enable (WKCNNT_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 21. " WKDC ,Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 22. " WKOC ,Wake on Over-current Enable (WKOC_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 23. " PHCD ,PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 24. " PFSC ,Port Force Full Speed Connect - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 25. " PTS_2 ,See description at bits 31-30" "0,1"
        textline "           "
        hexmask.long.byte 0x00 26.--28. 1. " PSPD ,Port Speed - Read Only."
        textline "           "
        bitfld.long 0x00 28. " PTW ,Parallel Transceiver Width This bit has no effect if serial interface engine is used." "0,1"
        textline "           "
        bitfld.long 0x00 29. " STS ,Serial Transceiver Select - Read Only Serial Transceiver Select 1 Serial Interface Engine is selected 0 Parallel Interface signals is selected Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals." "0,1"
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " PTS_1 ,Bit field {bit25, bit31, bit30}: ""000b"" UTMI/UTMI+ ""001b"" Reserved ""010b"" ULPI ""011b"" Serial/USB 1.1 PHY/IC-USB (FS Only) ""100b"" HSIC Parallel Transceiver Select (bit25, bit31, bi30)."
width 12.
group.long 0x5a8++0x3
    line.long 0x00 "UH2_USBMODE,USB Device Mode"
        hexmask.long.byte 0x00 0.--2. 1. " CM ,Controller Mode - R/WO."
        textline "           "
        bitfld.long 0x00 2. " ES ,Endian Select - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 3. " SLOM ,Setup Lockout Mode." "0,1"
        textline "           "
        bitfld.long 0x00 4. " SDIS ,Stream Disable Mode." "0,1"
width 7.
rgroup.long 0x600++0x3
    line.long 0x00 "UH3_ID,Identification register"
        hexmask.long.byte 0x00 0.--6. 1. " ID ,Configuration number."
        textline "      "
        hexmask.long.byte 0x00 8.--14. 1. " NID ,Complement version of ID"
        textline "      "
        hexmask.long.byte 0x00 16.--24. 1. " REVISION ,Revision number of the controller core."
width 14.
rgroup.long 0x604++0x3
    line.long 0x00 "UH3_HWGENERAL,Hardware General"
        hexmask.long.byte 0x00 4.--6. 1. " PHYW ,Data width of the transciever connected to the controller core."
        textline "             "
        hexmask.long.byte 0x00 6.--9. 1. " PHYM ,Transciever type PHYM bit reset value: '0000b' for OTG controller core, '0100b' for Host-only controller core."
        textline "             "
        hexmask.long.byte 0x00 9.--11. 1. " SM ,Serial interface mode capability SM bit reset value is '00b'"
width 11.
rgroup.long 0x608++0x3
    line.long 0x00 "UH3_HWHOST,Host Hardware Parameters"
        bitfld.long 0x00 0. " HC ,Host Capable." "0,1"
        textline "          "
        hexmask.long.byte 0x00 1.--4. 1. " NPORT ,The Nmber of downstream ports supported by the host controller is (NPORT+1)."
width 12.
rgroup.long 0x610++0x3
    line.long 0x00 "UH3_HWTXBUF,TX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " TXBURST ,Default burst size for memory to TX buffer transfer."
        textline "           "
        hexmask.long.byte 0x00 16.--24. 1. " TXCHANADD ,TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes."
width 12.
rgroup.long 0x614++0x3
    line.long 0x00 "UH3_HWRXBUF,RX Buffer Hardware Parameters"
        hexmask.long.byte 0x00 0.--8. 1. " RXBURST ,Default burst size for memory to RX buffer transfer."
        textline "           "
        hexmask.long.byte 0x00 8.--16. 1. " RXADD ,Buffer total size for all receive endpoints is (2^RXADD)."
width 15.
group.long 0x680++0x3
    line.long 0x00 "UH3_GPTIMER0LD,General Purpose Timer #0 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 17.
group.long 0x684++0x3
    line.long 0x00 "UH3_GPTIMER0CTRL,General Purpose Timer #0 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software; In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter value from GPTLD bits to start again." "0,1"
        textline "                "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 15.
group.long 0x688++0x3
    line.long 0x00 "UH3_GPTIMER1LD,General Purpose Timer #1 Load"
        hexmask.long.long 0x00 0.--24. 1. " GPTLD ,General Purpose Timer Load Value These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'."
width 17.
group.long 0x68c++0x3
    line.long 0x00 "UH3_GPTIMER1CTRL,General Purpose Timer #1 Controller"
        hexmask.long.long 0x00 0.--24. 1. " GPTCNT ,General Purpose Timer Counter."
        textline "                "
        bitfld.long 0x00 24. " GPTMODE ,General Purpose Timer Mode In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is reset by software." "0,1"
        textline "                "
        bitfld.long 0x00 30. " GPTRST ,General Purpose Timer Reset" "0,1"
        textline "                "
        bitfld.long 0x00 31. " GPTRUN ,General Purpose Timer Run GPTCNT bits are not effected when setting or clearing this bit." "0,1"
width 12.
group.long 0x690++0x3
    line.long 0x00 "UH3_SBUSCFG,System Bus Config"
        hexmask.long.byte 0x00 0.--3. 1. " AHBBRST ,AHB master interface Burst configuration These bits control AHB master transfer type sequence (or priority)."
width 14.
rgroup.byte 0x700++0x0
    line.byte 0x00 "UH3_CAPLENGTH,Capability Registers Length"
        hexmask.byte.byte 0x00 0.--8. 1. " CAPLENGTH ,These bits are used as an offset to add to register base to find the beginning of the Operational Register."
width 15.
rgroup.word 0x702++0x1
    line.word 0x00 "UH3_HCIVERSION,Host Controller Interface Version"
        hexmask.word.word 0x00 0.--16. 1. " HCIVERSION ,Host Controller Interface Version Number Default value is '10h', which means EHCI rev1.0."
width 14.
rgroup.long 0x704++0x3
    line.long 0x00 "UH3_HCSPARAMS,Host Controller Structural Parameters"
        hexmask.long.byte 0x00 0.--4. 1. " N_PORTS ,Number of downstream ports."
        textline "             "
        bitfld.long 0x00 4. " PPC ,Port Power Control This field indicates whether the host controller implementation includes port power control." "0,1"
        textline "             "
        hexmask.long.byte 0x00 8.--12. 1. " N_PCC ,Number of Ports per Companion Controller This field indicates the number of ports supported per internal Companion Controller."
        textline "             "
        hexmask.long.byte 0x00 12.--16. 1. " N_CC ,Number of Companion Controller (N_CC)."
        textline "             "
        bitfld.long 0x00 16. " PI ,Port Indicators (P INDICATOR) This bit indicates whether the ports support port indicator control." "0,1"
        textline "             "
        hexmask.long.byte 0x00 20.--24. 1. " N_PTT ,Number of Ports per Transaction Translator (N_PTT)."
        textline "             "
        hexmask.long.byte 0x00 24.--28. 1. " N_TT ,Number of Transaction Translators (N_TT)."
width 14.
rgroup.long 0x708++0x3
    line.long 0x00 "UH3_HCCPARAMS,Host Controller Capability Parameters"
        bitfld.long 0x00 0. " ADC ,64-bit Addressing Capability This bit is set '0b' in all controller core, no 64-bit addressing capability is supported." "0,1"
        textline "             "
        bitfld.long 0x00 1. " PFL ,Programmable Frame List Flag If this bit is set to zero, then the system software must use a frame list length of 1024 elements with this host controller." "0,1"
        textline "             "
        bitfld.long 0x00 2. " ASP ,Asynchronous Schedule Park Capability If this bit is set to a one, then the host controller supports the park feature for high-speed queue heads in the Asynchronous Schedule." "0,1"
        textline "             "
        hexmask.long.byte 0x00 4.--8. 1. " IST ,Isochronous Scheduling Threshold."
        textline "             "
        hexmask.long.byte 0x00 8.--16. 1. " EECP ,EHCI Extended Capabilities Pointer."
width 11.
group.long 0x740++0x3
    line.long 0x00 "UH3_USBCMD,USB Command Register"
        bitfld.long 0x00 0. " RS ,Run/Stop (RS) - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 1. " RST ,Controller Reset (RESET) - Read/Write." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--4. 1. " FS_1 ,See description at bit 15"
        textline "          "
        bitfld.long 0x00 4. " PSE ,Periodic Schedule Enable- Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 5. " ASE ,Asynchronous Schedule Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 6. " IAA ,Interrupt on Async Advance Doorbell - Read/Write." "0,1"
        textline "          "
        hexmask.long.byte 0x00 8.--10. 1. " ASP ,Asynchronous Schedule Park Mode Count - Read/Write."
        textline "          "
        bitfld.long 0x00 11. " ASPE ,Asynchronous Schedule Park Mode Enable - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 13. " SUTW ,Setup TripWire - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 14. " ATDTW ,Add dTD TripWire - Read/Write." "0,1"
        textline "          "
        bitfld.long 0x00 15. " FS_2 ,See also bits 3-2 Frame List Size - (Read/Write or Read Only)." "0,1"
        textline "          "
        hexmask.long.byte 0x00 16.--24. 1. " ITC ,Interrupt Threshold Control -Read/Write."
width 11.
group.long 0x744++0x3
    line.long 0x00 "UH3_USBSTS,USB Status Register"
        bitfld.long 0x00 0. " UI ,USB Interrupt (USBINT) - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 1. " UEI ,USB Error Interrupt (USBERRINT) - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 2. " PCI ,Port Change Detect - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 3. " FRI ,Frame List Rollover - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 4. " SEI ,System Error- R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 5. " AAI ,Interrupt on Async Advance - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 6. " URI ,USB Reset Received - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SRI ,SOF Received - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 8. " SLI ,DCSuspend - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 10. " ULPII ,ULPI Interrupt - R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 12. " HCH ,HCHaIted - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 13. " RCL ,Reclamation - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 14. " PS ,Periodic Schedule Status - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 15. " AS ,Asynchronous Schedule Status - Read Only." "0,1"
        textline "          "
        bitfld.long 0x00 16. " NAKI ,NAK Interrupt Bit--RO." "0,1"
        textline "          "
        bitfld.long 0x00 24. " TI0 ,General Purpose Timer Interrupt 0(GPTINT0)--R/WC." "0,1"
        textline "          "
        bitfld.long 0x00 25. " TI1 ,General Purpose Timer Interrupt 1(GPTINT1)--R/WC." "0,1"
width 12.
group.long 0x748++0x3
    line.long 0x00 "UH3_USBINTR,Interrupt Enable Register"
        bitfld.long 0x00 0. " UE ,USB Interrupt Enalbe When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 1. " UEE ,USB Error Interrupt Enable When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 2. " PCE ,Port Change Detect Interrupt Enable When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 3. " FRE ,Frame List Rollover Interrupt Enable When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 4. " SEE ,System Error Interrupt Enable When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 5. " AAE ,Async Advance Interrupt Enable When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 6. " URE ,USB Reset Interrupt Enable When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 7. " SRE ,SOF Received Interrupt Enable When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 8. " SLE ,Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 10. " ULPIE ,ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 16. " NAKE ,NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 18. " UAIE ,USB Host Asynchronous Interrupt Enable When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "           "
        bitfld.long 0x00 19. " UPIE ,USB Host Periodic Interrupt Enable When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an interrupt at the next interrupt threshold." "0,1"
        textline "           "
        bitfld.long 0x00 24. " TIE0 ,General Purpose Timer #0 Interrupt Enable When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
        textline "           "
        bitfld.long 0x00 25. " TIE1 ,General Purpose Timer #1 Interrupt Enable When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt." "0,1"
width 12.
group.long 0x74c++0x3
    line.long 0x00 "UH3_FRINDEX,USB Frame Index"
        hexmask.long.word 0x00 0.--14. 1. " FRINDEX ,Frame Index."
width 21.
group.long 0x754++0x3
    line.long 0x00 "UH3_PERIODICLISTBASE,Frame List Base Address"
        hexmask.long.long 0x00 12.--32. 1. " BASEADR ,Base Address (Low)."
width 18.
group.long 0x758++0x3
    line.long 0x00 "UH3_ASYNCLISTADDR,Next Asynch. Address"
        hexmask.long.long 0x00 5.--32. 1. " ASYBASE ,Link Pointer Low (LPL)."
width 14.
group.long 0x760++0x3
    line.long 0x00 "UH3_BURSTSIZE,Programmable Burst Size"
        hexmask.long.byte 0x00 0.--8. 1. " RXPBURST ,Programmable RX Burst Size."
        textline "             "
        hexmask.long.word 0x00 8.--17. 1. " TXPBURST ,Programmable TX Burst Size."
width 17.
group.long 0x764++0x3
    line.long 0x00 "UH3_TXFILLTUNING,TX FIFO Fill Tuning"
        hexmask.long.byte 0x00 0.--8. 1. " TXSCHOH ,Scheduler Overhead."
        textline "                "
        hexmask.long.byte 0x00 8.--13. 1. " TXSCHHEALTH ,Scheduler Health Counter."
        textline "                "
        hexmask.long.byte 0x00 16.--22. 1. " TXFIFOTHRES ,FIFO Burst Threshold."
width 15.
group.long 0x780++0x3
    line.long 0x00 "UH3_CONFIGFLAG,Configure Flag Register"
        bitfld.long 0x00 0. " CF ,Configure Flag Host software sets this bit as the last action in its process of configuring the Host Controller." "0,1"
width 12.
group.long 0x784++0x3
    line.long 0x00 "UH3_PORTSC1,Port Status & Control"
        bitfld.long 0x00 0. " CCS ,Current Connect Status-Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 1. " CSC ,Connect Status Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 2. " PE ,Port Enabled/Disabled-Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 3. " PEC ,Port Enable/Disable Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 4. " OCA ,Over-current Active-Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 5. " OCC ,Over-current Change-R/WC." "0,1"
        textline "           "
        bitfld.long 0x00 6. " FPR ,Force Port Resume -Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 7. " SUSP ,Suspend - Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 8. " PR ,Port Reset - Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 9. " HSP ,High-Speed Port - Read Only." "0,1"
        textline "           "
        hexmask.long.byte 0x00 10.--12. 1. " LS ,Line Status-Read Only."
        textline "           "
        bitfld.long 0x00 12. " PP ,Port Power (PP)-Read/Write or Read Only." "0,1"
        textline "           "
        bitfld.long 0x00 13. " PO ,Port Owner-Read/Write." "0,1"
        textline "           "
        hexmask.long.byte 0x00 14.--16. 1. " PIC ,Port Indicator Control - Read/Write."
        textline "           "
        hexmask.long.byte 0x00 16.--20. 1. " PTC ,Port Test Control - Read/Write."
        textline "           "
        bitfld.long 0x00 20. " WKCN ,Wake on Connect Enable (WKCNNT_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 21. " WKDC ,Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 22. " WKOC ,Wake on Over-current Enable (WKOC_E) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 23. " PHCD ,PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 24. " PFSC ,Port Force Full Speed Connect - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 25. " PTS_2 ,See description at bits 31-30" "0,1"
        textline "           "
        hexmask.long.byte 0x00 26.--28. 1. " PSPD ,Port Speed - Read Only."
        textline "           "
        bitfld.long 0x00 28. " PTW ,Parallel Transceiver Width This bit has no effect if serial interface engine is used." "0,1"
        textline "           "
        bitfld.long 0x00 29. " STS ,Serial Transceiver Select - Read Only Serial Transceiver Select 1 Serial Interface Engine is selected 0 Parallel Interface signals is selected Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals." "0,1"
        textline "           "
        hexmask.long.byte 0x00 30.--32. 1. " PTS_1 ,Bit field {bit25, bit31, bit30}: ""000b"" UTMI/UTMI+ ""001b"" Reserved ""010b"" ULPI ""011b"" Serial/USB 1.1 PHY/IC-USB (FS Only) ""100b"" HSIC Parallel Transceiver Select (bit25, bit31, bi30)."
width 12.
group.long 0x7a8++0x3
    line.long 0x00 "UH3_USBMODE,USB Device Mode"
        hexmask.long.byte 0x00 0.--2. 1. " CM ,Controller Mode - R/WO."
        textline "           "
        bitfld.long 0x00 2. " ES ,Endian Select - Read/Write." "0,1"
        textline "           "
        bitfld.long 0x00 3. " SLOM ,Setup Lockout Mode." "0,1"
        textline "           "
        bitfld.long 0x00 4. " SDIS ,Stream Disable Mode." "0,1"


tree.end



;--------------------------------------------------------------------------------
; USBNC
;--------------------------------------------------------------------------------
tree "USBNC"
    base ad:0x02184000

width 13.
group.long 0x800++0x3
    line.long 0x00 "USB_OTG_CTRL,USB OTG Control Register"
        bitfld.long 0x00 7. " OVER_CUR_DIS ,Disable OTG Overcurrent Detection" "0,1"
        textline "            "
        bitfld.long 0x00 8. " OVER_CUR_POL ,OTG Polarity of Overcurrent The polarity of OTG port overcurrent event" "0,1"
        textline "            "
        bitfld.long 0x00 9. " PWR_POL ,OTG Power Polarity This bit should be set according to power switch's enable polarity." "0,1"
        textline "            "
        bitfld.long 0x00 10. " WIE ,OTG Wake-up Interrupt Enable This bit enables or disables the OTG wake-up interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 11. " RESET ,Force OTG UTMI PHY Reset This bit is used to force a reset to the UTMI PHY." "0,1"
        textline "            "
        bitfld.long 0x00 12. " SUSPENDM ,Force OTG UTMI PHY Suspend." "0,1"
        textline "            "
        bitfld.long 0x00 13. " UTMI_ON_CLOCK ,Force OTG UTMI PHY clock output on even if suspend mode." "0,1"
        textline "            "
        bitfld.long 0x00 14. " WKUP_SW_EN ,OTG Software Wake-up Enable" "0,1"
        textline "            "
        bitfld.long 0x00 15. " WKUP_SW ,OTG Software Wake-up" "0,1"
        textline "            "
        bitfld.long 0x00 16. " WKUP_ID_EN ,OTG Wake-up on ID change enable" "0,1"
        textline "            "
        bitfld.long 0x00 17. " WKUP_VBUS_EN ,OTG wake-up on VBUS change enable" "0,1"
        textline "            "
        bitfld.long 0x00 31. " WIR ,OTG Wake-up Interrupt Request This bit indicates that a wake-up interrupt request is received on the OTG port." "0,1"
width 13.
group.long 0x804++0x3
    line.long 0x00 "USB_UH1_CTRL,USB Host1 Control Register"
        bitfld.long 0x00 7. " OVER_CUR_DIS ,Disable Host 1 Overcurrent Detection" "0,1"
        textline "            "
        bitfld.long 0x00 8. " OVER_CUR_POL ,Host 1 Polarity of Overcurrent The polarity of Host 1 port overcurrent event" "0,1"
        textline "            "
        bitfld.long 0x00 9. " PWR_POL ,Host1 Power Polarity This bit should be set according to the power switch's enable polarity." "0,1"
        textline "            "
        bitfld.long 0x00 10. " WIE ,Host 1 Wake-up Interrupt Enable This bit enables or disables the Host 1 wake-up interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 11. " RESET ,Force Host 1 UTMI PHY Reset." "0,1"
        textline "            "
        bitfld.long 0x00 12. " SUSPENDM ,Force Host 1 UTMI PHY Suspend." "0,1"
        textline "            "
        bitfld.long 0x00 13. " UTMI_ON_CLOCK ,Force Host 1 UTMI PHY clock output on even if in low-power suspend mode." "0,1"
        textline "            "
        bitfld.long 0x00 14. " WKUP_SW_EN ,Host 1 Software Wake-up Enable" "0,1"
        textline "            "
        bitfld.long 0x00 15. " WKUP_SW ,Host 1 Software Wake-up" "0,1"
        textline "            "
        bitfld.long 0x00 16. " WKUP_ID_EN ,Host 1 Wake-up on ID change enable" "0,1"
        textline "            "
        bitfld.long 0x00 17. " WKUP_VBUS_EN ,Host 1 wake-up on VBUS change enable" "0,1"
        textline "            "
        bitfld.long 0x00 31. " WIR ,Host 1 Wake-up Interrupt Request This bit indicates that a wake-up interrupt request is received on the OTG port." "0,1"
width 13.
group.long 0x808++0x3
    line.long 0x00 "USB_UH2_CTRL,USB Host2 Control Register"
        bitfld.long 0x00 10. " WIE ,Host 2 Wake-up Interrupt Enable This bit enables or disables the Host 2 wake-up interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 11. " RESET ,Force Host 2 UTMI PHY Reset This bit is used to force a reset to the UTMI PHY." "0,1"
        textline "            "
        bitfld.long 0x00 12. " SUSPENDM ,Force Host 2 UTMI PHY Suspend This bit is used to put PHY into suspend mode." "0,1"
        textline "            "
        bitfld.long 0x00 13. " _480M_CLK_ON ,Force OTG UTMI PHY 480M clock output on when Host 2 is not in suspend mode." "0,1"
        textline "            "
        bitfld.long 0x00 14. " WKUP_SW_EN ,Host 2 Software Wake-up Enable" "0,1"
        textline "            "
        bitfld.long 0x00 15. " WKUP_SW ,Host 2 Software Wake-up" "0,1"
        textline "            "
        bitfld.long 0x00 31. " WIR ,Host 2 Wake-up Interrupt Request This bit indicates that a wake-up interrupt request is received on the Host 2 port." "0,1"
width 13.
group.long 0x80c++0x3
    line.long 0x00 "USB_UH3_CTRL,USB Host3 Control Register"
        bitfld.long 0x00 10. " WIE ,Host 3 Wake-up Interrupt Enable This bit enables or disables the Host 3 wake-up interrupt." "0,1"
        textline "            "
        bitfld.long 0x00 11. " RESET ,Force Host 3 UTMI PHY Reset This bit is used to force a reset to the UTMI PHY." "0,1"
        textline "            "
        bitfld.long 0x00 12. " SUSPENDM ,Force Host 3 UTMI PHY Suspend This bit is used to put PHY into suspend mode." "0,1"
        textline "            "
        bitfld.long 0x00 13. " _480M_CLK_ON ,Force OTG UTMI PHY 480M clock output on when Host 3 is not in suspend mode." "0,1"
        textline "            "
        bitfld.long 0x00 14. " WKUP_SW_EN ,Host 3 Software Wake-up Enable" "0,1"
        textline "            "
        bitfld.long 0x00 15. " WKUP_SW ,Host 3 Software Wake-up" "0,1"
        textline "            "
        bitfld.long 0x00 31. " WIR ,Host 3 Wake-up Interrupt Request This bit indicates that a wake-up interrupt request is received on the OTG port." "0,1"
width 18.
group.long 0x810++0x3
    line.long 0x00 "USB_UH2_HSIC_CTRL,USB Host2 HSIC Control Register"
        bitfld.long 0x00 11. " HSIC_CLK_ON ,Force Host2 HSIC module 480M clock on, even when in Host 2 is in suspend mode." "0,1"
        textline "                 "
        bitfld.long 0x00 12. " HSIC_EN ,Host2 HSIC enable" "0,1"
        textline "                 "
        bitfld.long 0x00 31. " CLK_VLD ,Indicating whether Host2 HSIC clock is valid." "0,1"
width 18.
group.long 0x814++0x3
    line.long 0x00 "USB_UH3_HSIC_CTRL,USB Host3 HSIC Control Register"
        bitfld.long 0x00 11. " HSIC_CLK_ON ,Force Host3 HSIC module 480M clock on, even when in Host 2 is in suspend mode." "0,1"
        textline "                 "
        bitfld.long 0x00 12. " HSIC_EN ,Host3 HSIC enable" "0,1"
        textline "                 "
        bitfld.long 0x00 31. " CLK_VLD ,Indicating whether Host3 HSIC clock is valid." "0,1"
width 19.
group.long 0x818++0x3
    line.long 0x00 "USB_OTG_PHY_CTRL_0,OTG UTMI PHY Control 0 Register"
        bitfld.long 0x00 31. " UTMI_CLK_VLD ,Indicating whether OTG UTMI PHY clock is valid" "0,1"
width 19.
group.long 0x81c++0x3
    line.long 0x00 "USB_UH1_PHY_CTRL_0,Host1 UTMI PHY Control 0 Register"
        bitfld.long 0x00 31. " UTMI_CLK_VLD ,Indicating whether Host 1 UTMI PHY clock is valid" "0,1"


tree.end



;--------------------------------------------------------------------------------
; USBPHY
;--------------------------------------------------------------------------------
tree.open "USBPHY"
    tree "USBPHY1"
        base ad:0x020c9000

width 4.
group.long 0x0++0x3
    line.long 0x00 "PWD,USB PHY Power-Down Register"
        bitfld.long 0x00 10. " TXPWDFS ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 11. " TXPWDIBIAS ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 12. " TXPWDV2I ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 17. " RXPWDENV ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 18. " RXPWD1PT1 ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 19. " RXPWDDIFF ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 20. " RXPWDRX ,0 = Normal operation." "0,1"
width 3.
group.long 0x10++0x3
    line.long 0x00 "TX,USB PHY Transmitter Control Register"
        hexmask.long.byte 0x00 0.--4. 1. " D_CAL ,Resistor Trimming Code: 0000 = 0.16% 0111 = Nominal 1111 = +25%"
        textline "  "
        hexmask.long.byte 0x00 8.--12. 1. " TXCAL45DN ,Decode to select a 45-Ohm resistance to the USB_DN output pin."
        textline "  "
        hexmask.long.byte 0x00 16.--20. 1. " TXCAL45DP ,Decode to select a 45-Ohm resistance to the USB_DP output pin."
        textline "  "
        hexmask.long.byte 0x00 26.--29. 1. " USBPHY_TX_EDGECTRL ,Controls the edge-rate of the current sensing transistors used in HS transmit."
width 3.
group.long 0x20++0x3
    line.long 0x00 "RX,USB PHY Receiver Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " ENVADJ ,The ENVADJ field adjusts the trip point for the envelope detector."
        textline "  "
        hexmask.long.byte 0x00 4.--7. 1. " DISCONADJ ,The DISCONADJ field adjusts the trip point for the disconnect detector: 000 = Trip-Level Voltage is 0.57500 V 001 = Trip-Level Voltage is 0.56875 V 010 = Trip-Level Voltage is 0.58125 V 011 = Trip-Level Voltage is 0.58750 V 1XX = Reserved"
        textline "  "
        bitfld.long 0x00 22. " RXDBYPASS ,0 = Normal operation." "0,1"
width 5.
group.long 0x30++0x3
    line.long 0x00 "CTRL,USB PHY General Control Register"
        bitfld.long 0x00 0. " ENOTG_ID_CHG_IRQ ,Enable OTG_ID_CHG_IRQ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ENHOSTDISCONDETECT ,For host mode, enables high-speed disconnect detector." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ENIRQHOSTDISCON ,Enables interrupt for detection of disconnection to Device when in high-speed host mode." "0,1"
        textline "    "
        bitfld.long 0x00 3. " HOSTDISCONDETECT_IRQ ,Indicates that the device has disconnected in high-speed mode." "0,1"
        textline "    "
        bitfld.long 0x00 4. " ENDEVPLUGINDETECT ,For device mode, enables 200-KOhm pullups for detecting connectivity to the host." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DEVPLUGIN_POLARITY ,For device mode, if this bit is cleared to 0, then it trips the interrupt if the device is plugged in." "0,1"
        textline "    "
        bitfld.long 0x00 6. " OTG_ID_CHG_IRQ ,OTG ID change interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ENOTGIDDETECT ,Enables circuit to detect resistance of MiniAB ID pin." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RESUMEIRQSTICKY ,Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it." "0,1"
        textline "    "
        bitfld.long 0x00 9. " ENIRQRESUMEDETECT ,Enables interrupt for detection of a non-J state on the USB line." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RESUME_IRQ ,Indicates that the host is sending a wake-up after suspend." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ENIRQDEVPLUGIN ,Enables interrupt for the detection of connectivity to the USB line." "0,1"
        textline "    "
        bitfld.long 0x00 12. " DEVPLUGIN_IRQ ,Indicates that the device is connected." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DATA_ON_LRADC ,Enables the LRADC to monitor USB_DP and USB_DM." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ENUTMILEVEL2 ,Enables UTMI+ Level2." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ENUTMILEVEL3 ,Enables UTMI+ Level3." "0,1"
        textline "    "
        bitfld.long 0x00 16. " ENIRQWAKEUP ,Enables interrupt for the wakeup events." "0,1"
        textline "    "
        bitfld.long 0x00 17. " WAKEUP_IRQ ,Indicates that there is a wakeup event." "0,1"
        textline "    "
        bitfld.long 0x00 19. " ENAUTOCLR_CLKGATE ,Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 20. " ENAUTOCLR_PHY_PWD ,Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD if there is wakeup event while USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 21. " ENDPDMCHG_WKUP ,Enables the feature to wakeup USB if DP/DM is toggled when USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 22. " ENIDCHG_WKUP ,Enables the feature to wakeup USB if ID is toggled when USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 23. " ENVBUSCHG_WKUP ,Enables the feature to wakeup USB if VBUS is toggled when USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 24. " FSDLL_RST_EN ,Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet." "0,1"
        textline "    "
        bitfld.long 0x00 27. " OTG_ID_VALUE ,Almost same as OTGID_STATUS in USBPHYx_STATUS Register." "0,1"
        textline "    "
        bitfld.long 0x00 28. " HOST_FORCE_LS_SE0 ,Forces the next FS packet that is transmitted to have a EOP with LS timing." "0,1"
        textline "    "
        bitfld.long 0x00 29. " UTMI_SUSPENDM ,Used by the PHY to indicate a powered-down state." "0,1"
        textline "    "
        bitfld.long 0x00 30. " CLKGATE ,Gate UTMI Clocks." "0,1"
        textline "    "
        bitfld.long 0x00 31. " SFTRST ,Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, USBPHYx_RX, and USBPHYx_CTRL registers." "0,1"
width 7.
group.long 0x40++0x3
    line.long 0x00 "STATUS,USB PHY Status Register"
        bitfld.long 0x00 3. " HOSTDISCONDETECT_STATUS ,Indicates that the device has disconnected while in high-speed host mode." "0,1"
        textline "      "
        bitfld.long 0x00 6. " DEVPLUGIN_STATUS ,Indicates that the device has been connected on the USB_DP and USB_DM lines." "0,1"
        textline "      "
        bitfld.long 0x00 8. " OTGID_STATUS ,Indicates the results of ID pin on MiniAB plug." "0,1"
        textline "      "
        bitfld.long 0x00 10. " RESUME_STATUS ,Indicates that the host is sending a wake-up after suspend and has triggered an interrupt." "0,1"
width 6.
group.long 0x50++0x3
    line.long 0x00 "DEBUG,USB PHY Debug Register"
        bitfld.long 0x00 0. " OTGIDPIOLOCK ,Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the value." "0,1"
        textline "     "
        bitfld.long 0x00 1. " DEBUG_INTERFACE_HOLD ,Use holding registers to assist in timing for external UTMI interface." "0,1"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " HSTPULLDOWN ,Set bit 3 to 1 to pull down 15-KOhm on USB_DP line."
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " ENHSTPULLDOWN ,Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown."
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " TX2RXCOUNT ,Delay in between the end of transmit to the beginning of receive."
        textline "     "
        bitfld.long 0x00 12. " ENTX2RXCOUNT ,Set this bit to allow a countdown to transition in between TX and RX." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--21. 1. " SQUELCHRESETCOUNT ,Delay in between the detection of squelch to the reset of high-speed RX."
        textline "     "
        bitfld.long 0x00 24. " ENSQUELCHRESET ,Set bit to allow squelch to reset high-speed receive." "0,1"
        textline "     "
        hexmask.long.byte 0x00 25.--29. 1. " SQUELCHRESETLENGTH ,Duration of RESET in terms of the number of 480-MHz cycles."
        textline "     "
        bitfld.long 0x00 29. " HOST_RESUME_DEBUG ,Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1." "0,1"
        textline "     "
        bitfld.long 0x00 30. " CLKGATE ,Gate Test Clocks." "0,1"
width 14.
rgroup.long 0x60++0x3
    line.long 0x00 "DEBUG0_STATUS,UTMI Debug Status Register 0"
        hexmask.long.word 0x00 0.--16. 1. " LOOP_BACK_FAIL_COUNT ,Running count of the failed pseudo-random generator loopback."
        textline "             "
        hexmask.long.word 0x00 16.--26. 1. " UTMI_RXERROR_FAIL_COUNT ,Running count of the UTMI_RXERROR."
        textline "             "
        hexmask.long.byte 0x00 26.--32. 1. " SQUELCH_COUNT ,Running count of the squelch reset instead of normal end for HS RX."
width 7.
group.long 0x70++0x3
    line.long 0x00 "DEBUG1,UTMI Debug Status Register 1"
        hexmask.long.byte 0x00 13.--15. 1. " ENTAILADJVD ,Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Delay is +20% 10 = Delay is -20% 11 = Delay is -40%"
width 8.
rgroup.long 0x80++0x3
    line.long 0x00 "VERSION,UTMI RTL Version"
        hexmask.long.word 0x00 0.--16. 1. " STEP ,Fixed read-only value reflecting the stepping of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of the RTL version."


    tree.end
    tree "USBPHY2"
        base ad:0x020ca000

width 4.
group.long 0x0++0x3
    line.long 0x00 "PWD,USB PHY Power-Down Register"
        bitfld.long 0x00 10. " TXPWDFS ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 11. " TXPWDIBIAS ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 12. " TXPWDV2I ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 17. " RXPWDENV ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 18. " RXPWD1PT1 ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 19. " RXPWDDIFF ,0 = Normal operation." "0,1"
        textline "   "
        bitfld.long 0x00 20. " RXPWDRX ,0 = Normal operation." "0,1"
width 3.
group.long 0x10++0x3
    line.long 0x00 "TX,USB PHY Transmitter Control Register"
        hexmask.long.byte 0x00 0.--4. 1. " D_CAL ,Resistor Trimming Code: 0000 = 0.16% 0111 = Nominal 1111 = +25%"
        textline "  "
        hexmask.long.byte 0x00 8.--12. 1. " TXCAL45DN ,Decode to select a 45-Ohm resistance to the USB_DN output pin."
        textline "  "
        hexmask.long.byte 0x00 16.--20. 1. " TXCAL45DP ,Decode to select a 45-Ohm resistance to the USB_DP output pin."
        textline "  "
        hexmask.long.byte 0x00 26.--29. 1. " USBPHY_TX_EDGECTRL ,Controls the edge-rate of the current sensing transistors used in HS transmit."
width 3.
group.long 0x20++0x3
    line.long 0x00 "RX,USB PHY Receiver Control Register"
        hexmask.long.byte 0x00 0.--3. 1. " ENVADJ ,The ENVADJ field adjusts the trip point for the envelope detector."
        textline "  "
        hexmask.long.byte 0x00 4.--7. 1. " DISCONADJ ,The DISCONADJ field adjusts the trip point for the disconnect detector: 000 = Trip-Level Voltage is 0.57500 V 001 = Trip-Level Voltage is 0.56875 V 010 = Trip-Level Voltage is 0.58125 V 011 = Trip-Level Voltage is 0.58750 V 1XX = Reserved"
        textline "  "
        bitfld.long 0x00 22. " RXDBYPASS ,0 = Normal operation." "0,1"
width 5.
group.long 0x30++0x3
    line.long 0x00 "CTRL,USB PHY General Control Register"
        bitfld.long 0x00 0. " ENOTG_ID_CHG_IRQ ,Enable OTG_ID_CHG_IRQ." "0,1"
        textline "    "
        bitfld.long 0x00 1. " ENHOSTDISCONDETECT ,For host mode, enables high-speed disconnect detector." "0,1"
        textline "    "
        bitfld.long 0x00 2. " ENIRQHOSTDISCON ,Enables interrupt for detection of disconnection to Device when in high-speed host mode." "0,1"
        textline "    "
        bitfld.long 0x00 3. " HOSTDISCONDETECT_IRQ ,Indicates that the device has disconnected in high-speed mode." "0,1"
        textline "    "
        bitfld.long 0x00 4. " ENDEVPLUGINDETECT ,For device mode, enables 200-KOhm pullups for detecting connectivity to the host." "0,1"
        textline "    "
        bitfld.long 0x00 5. " DEVPLUGIN_POLARITY ,For device mode, if this bit is cleared to 0, then it trips the interrupt if the device is plugged in." "0,1"
        textline "    "
        bitfld.long 0x00 6. " OTG_ID_CHG_IRQ ,OTG ID change interrupt." "0,1"
        textline "    "
        bitfld.long 0x00 7. " ENOTGIDDETECT ,Enables circuit to detect resistance of MiniAB ID pin." "0,1"
        textline "    "
        bitfld.long 0x00 8. " RESUMEIRQSTICKY ,Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it." "0,1"
        textline "    "
        bitfld.long 0x00 9. " ENIRQRESUMEDETECT ,Enables interrupt for detection of a non-J state on the USB line." "0,1"
        textline "    "
        bitfld.long 0x00 10. " RESUME_IRQ ,Indicates that the host is sending a wake-up after suspend." "0,1"
        textline "    "
        bitfld.long 0x00 11. " ENIRQDEVPLUGIN ,Enables interrupt for the detection of connectivity to the USB line." "0,1"
        textline "    "
        bitfld.long 0x00 12. " DEVPLUGIN_IRQ ,Indicates that the device is connected." "0,1"
        textline "    "
        bitfld.long 0x00 13. " DATA_ON_LRADC ,Enables the LRADC to monitor USB_DP and USB_DM." "0,1"
        textline "    "
        bitfld.long 0x00 14. " ENUTMILEVEL2 ,Enables UTMI+ Level2." "0,1"
        textline "    "
        bitfld.long 0x00 15. " ENUTMILEVEL3 ,Enables UTMI+ Level3." "0,1"
        textline "    "
        bitfld.long 0x00 16. " ENIRQWAKEUP ,Enables interrupt for the wakeup events." "0,1"
        textline "    "
        bitfld.long 0x00 17. " WAKEUP_IRQ ,Indicates that there is a wakeup event." "0,1"
        textline "    "
        bitfld.long 0x00 19. " ENAUTOCLR_CLKGATE ,Enables the feature to auto-clear the CLKGATE bit if there is wakeup event while USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 20. " ENAUTOCLR_PHY_PWD ,Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD if there is wakeup event while USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 21. " ENDPDMCHG_WKUP ,Enables the feature to wakeup USB if DP/DM is toggled when USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 22. " ENIDCHG_WKUP ,Enables the feature to wakeup USB if ID is toggled when USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 23. " ENVBUSCHG_WKUP ,Enables the feature to wakeup USB if VBUS is toggled when USB is suspended." "0,1"
        textline "    "
        bitfld.long 0x00 24. " FSDLL_RST_EN ,Enables the feature to reset the FSDLL lock detection logic at the end of each TX packet." "0,1"
        textline "    "
        bitfld.long 0x00 27. " OTG_ID_VALUE ,Almost same as OTGID_STATUS in USBPHYx_STATUS Register." "0,1"
        textline "    "
        bitfld.long 0x00 28. " HOST_FORCE_LS_SE0 ,Forces the next FS packet that is transmitted to have a EOP with LS timing." "0,1"
        textline "    "
        bitfld.long 0x00 29. " UTMI_SUSPENDM ,Used by the PHY to indicate a powered-down state." "0,1"
        textline "    "
        bitfld.long 0x00 30. " CLKGATE ,Gate UTMI Clocks." "0,1"
        textline "    "
        bitfld.long 0x00 31. " SFTRST ,Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, USBPHYx_RX, and USBPHYx_CTRL registers." "0,1"
width 7.
group.long 0x40++0x3
    line.long 0x00 "STATUS,USB PHY Status Register"
        bitfld.long 0x00 3. " HOSTDISCONDETECT_STATUS ,Indicates that the device has disconnected while in high-speed host mode." "0,1"
        textline "      "
        bitfld.long 0x00 6. " DEVPLUGIN_STATUS ,Indicates that the device has been connected on the USB_DP and USB_DM lines." "0,1"
        textline "      "
        bitfld.long 0x00 8. " OTGID_STATUS ,Indicates the results of ID pin on MiniAB plug." "0,1"
        textline "      "
        bitfld.long 0x00 10. " RESUME_STATUS ,Indicates that the host is sending a wake-up after suspend and has triggered an interrupt." "0,1"
width 6.
group.long 0x50++0x3
    line.long 0x00 "DEBUG,USB PHY Debug Register"
        bitfld.long 0x00 0. " OTGIDPIOLOCK ,Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the value." "0,1"
        textline "     "
        bitfld.long 0x00 1. " DEBUG_INTERFACE_HOLD ,Use holding registers to assist in timing for external UTMI interface." "0,1"
        textline "     "
        hexmask.long.byte 0x00 2.--4. 1. " HSTPULLDOWN ,Set bit 3 to 1 to pull down 15-KOhm on USB_DP line."
        textline "     "
        hexmask.long.byte 0x00 4.--6. 1. " ENHSTPULLDOWN ,Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown."
        textline "     "
        hexmask.long.byte 0x00 8.--12. 1. " TX2RXCOUNT ,Delay in between the end of transmit to the beginning of receive."
        textline "     "
        bitfld.long 0x00 12. " ENTX2RXCOUNT ,Set this bit to allow a countdown to transition in between TX and RX." "0,1"
        textline "     "
        hexmask.long.byte 0x00 16.--21. 1. " SQUELCHRESETCOUNT ,Delay in between the detection of squelch to the reset of high-speed RX."
        textline "     "
        bitfld.long 0x00 24. " ENSQUELCHRESET ,Set bit to allow squelch to reset high-speed receive." "0,1"
        textline "     "
        hexmask.long.byte 0x00 25.--29. 1. " SQUELCHRESETLENGTH ,Duration of RESET in terms of the number of 480-MHz cycles."
        textline "     "
        bitfld.long 0x00 29. " HOST_RESUME_DEBUG ,Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UTMI_SUSPEND = 1." "0,1"
        textline "     "
        bitfld.long 0x00 30. " CLKGATE ,Gate Test Clocks." "0,1"
width 14.
rgroup.long 0x60++0x3
    line.long 0x00 "DEBUG0_STATUS,UTMI Debug Status Register 0"
        hexmask.long.word 0x00 0.--16. 1. " LOOP_BACK_FAIL_COUNT ,Running count of the failed pseudo-random generator loopback."
        textline "             "
        hexmask.long.word 0x00 16.--26. 1. " UTMI_RXERROR_FAIL_COUNT ,Running count of the UTMI_RXERROR."
        textline "             "
        hexmask.long.byte 0x00 26.--32. 1. " SQUELCH_COUNT ,Running count of the squelch reset instead of normal end for HS RX."
width 7.
group.long 0x70++0x3
    line.long 0x00 "DEBUG1,UTMI Debug Status Register 1"
        hexmask.long.byte 0x00 13.--15. 1. " ENTAILADJVD ,Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Delay is +20% 10 = Delay is -20% 11 = Delay is -40%"
width 8.
rgroup.long 0x80++0x3
    line.long 0x00 "VERSION,UTMI RTL Version"
        hexmask.long.word 0x00 0.--16. 1. " STEP ,Fixed read-only value reflecting the stepping of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 16.--24. 1. " MINOR ,Fixed read-only value reflecting the MINOR field of the RTL version."
        textline "       "
        hexmask.long.byte 0x00 24.--32. 1. " MAJOR ,Fixed read-only value reflecting the MAJOR field of the RTL version."


    tree.end

tree.end



;--------------------------------------------------------------------------------
; USDHC
;--------------------------------------------------------------------------------
tree.open "USDHC"
    tree "USDHC1"
        base ad:0x02190000

width 8.
group.long 0x0++0x3
    line.long 0x00 "DS_ADDR,DMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,DMA System Address: This register contains the 32-bit system memory address for a DMA transfer."
width 8.
group.long 0x4++0x3
    line.long 0x00 "BLK_ATT,Block Attributes"
        hexmask.long.word 0x00 0.--13. 1. " BLKSIZE ,Transfer Block Size: This register specifies the block size for block data transfers."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " BLKCNT ,Blocks Count For Current Transfer: This register is enabled when the Block Count Enable bit in the Transfer Mode register is set to 1 and is valid only for multiple block transfers."
width 8.
group.long 0x8++0x3
    line.long 0x00 "CMD_ARG,Command Argument"
        hexmask.long.long 0x00 0.--32. 1. " CMDARG ,Command Argument: The SD/MMC Command Argument is specified as bits 39-8 of the Command Format in the SD or MMC Specification.This register is write protected when the Command Inhibit (CMD) bit in the Present State register is set."
width 12.
group.long 0xc++0x3
    line.long 0x00 "CMD_XFR_TYP,Command Transfer Type"
        hexmask.long.byte 0x00 16.--18. 1. " RSPTYP ,Response Type Select:"
        textline "           "
        bitfld.long 0x00 19. " CCCEN ,Command CRC Check Enable: If this bit is set to 1, the uSDHC shall check the CRC field in the response." "0,1"
        textline "           "
        bitfld.long 0x00 20. " CICEN ,Command Index Check Enable: If this bit is set to 1, the uSDHC will check the Index field in the response to see if it has the same value as the command index." "0,1"
        textline "           "
        bitfld.long 0x00 21. " DPSEL ,Data Present Select: This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line." "0,1"
        textline "           "
        hexmask.long.byte 0x00 22.--24. 1. " CMDTYP ,Command Type: There are three types of special commands: Suspend, Resume and Abort."
        textline "           "
        hexmask.long.byte 0x00 24.--30. 1. " CMDINX ,Command Index: These bits shall be set to the command number that is specified in bits 45-40 of the Command-Format in the SD Memory Card Physical Layer Specification and SDIO Card Specification."
width 9.
rgroup.long 0x10++0x3
    line.long 0x00 "CMD_RSP0,Command Response0"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP0 ,Command Response 0: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x14++0x3
    line.long 0x00 "CMD_RSP1,Command Response1"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP1 ,Command Response 1: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x18++0x3
    line.long 0x00 "CMD_RSP2,Command Response2"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP2 ,Command Response 2: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x1c++0x3
    line.long 0x00 "CMD_RSP3,Command Response3"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP3 ,Command Response 3: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 19.
group.long 0x20++0x3
    line.long 0x00 "DATA_BUFF_ACC_PORT,Data Buffer Access Port"
        hexmask.long.long 0x00 0.--32. 1. " DATCONT ,Data Content: The Buffer Data Port register is for 32-bit data access by the ARM platform or the external DMA."
width 11.
rgroup.long 0x24++0x3
    line.long 0x00 "PRES_STATE,Present State"
        bitfld.long 0x00 0. " CIHB ,Command Inhibit (CMD): If this status bit is 0, it indicates that the CMD line is not in use and the uSDHC can issue a SD/MMC Command using the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 1. " CDIHB ,Command Inhibit (DAT): This status bit is generated if either the DAT Line Active or the Read Transfer Active is set to 1." "0,1"
        textline "          "
        bitfld.long 0x00 2. " DLA ,Data Line Active This status bit indicates whether one of the DAT lines on the SD Bus is in use." "0,1"
        textline "          "
        bitfld.long 0x00 3. " SDSTB ,SD Clock Stable This status bit indicates that the internal card clock is stable." "0,1"
        textline "          "
        bitfld.long 0x00 4. " IPGOFF ,ipg_clk Gated Off Internally: This status bit indicates that the ipg_clk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 5. " HCKOFF ,hclk Gated Off Internally: This status bit indicates that the hclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 6. " PEROFF ,ipg_perclk Gated Off Internally: This status bit indicates that the ipg_perclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SDOFF ,SD Clock Gated Off Internally: This status bit indicates that the SD Clock is internally gated off, because of buffer over/under-run or read pause without read wait assertion, or the driver set FRC_SDCLK_ON bit is 0 to stop the SD clock in idle status." "0,1"
        textline "          "
        bitfld.long 0x00 8. " WTA ,Write Transfer Active: This status bit indicates a write transfer is active." "0,1"
        textline "          "
        bitfld.long 0x00 9. " RTA ,Read Transfer Active: This status bit is used for detecting completion of a read transfer." "0,1"
        textline "          "
        bitfld.long 0x00 10. " BWEN ,Buffer Write Enable: This status bit is used for non-DMA write transfers." "0,1"
        textline "          "
        bitfld.long 0x00 11. " BREN ,Buffer Read Enable: This status bit is used for non-DMA read transfers." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTR ,Re-Tuning Request: (only for SD3.0 SDR104 mode) Host Controller may request Host Driver to execute re-tuning sequence by setting this bit when the data window is shifted by temperature drift and a tuned sampling point does not have a good margin to receive correct data." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CINST ,Card Inserted: This bit indicates whether a card has been inserted." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CDPL ,Card Detect Pin Level: This bit reflects the inverse value of the CD# pin for the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 19. " WPSPL ,Write Protect Switch Pin Level: The Write Protect Switch is supported for memory and combo cards.This bit reflects the inverted value of the WP pin of the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 23. " CLSL ,CMD Line Signal Level: This status is used to check the CMD line level to recover from errors, and for debugging." "0,1"
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " DLSL ,DAT[7:0] Line Signal Level: This status is used to check the DAT line level to recover from errors, and for debugging.This is especially useful in detecting the busy signal level from DAT[0]."
width 10.
group.long 0x28++0x3
    line.long 0x00 "PROT_CTRL,Protocol Control"
        bitfld.long 0x00 0. " LCTL ,LED Control: This bit, fully controlled by the Host Driver, is used to caution the user not to remove the card while the card is being accessed." "0,1"
        textline "         "
        hexmask.long.byte 0x00 1.--3. 1. " DTW ,Data Transfer Width: This bit selects the data width of the SD bus for a data transfer."
        textline "         "
        bitfld.long 0x00 3. " D3CD ,DAT3 as Card Detection Pin: If this bit is set, DAT3 should be pulled down to act as a card detection pin." "0,1"
        textline "         "
        hexmask.long.byte 0x00 4.--6. 1. " EMODE ,Endian Mode: The uSDHC supports all three endian modes in data transfer."
        textline "         "
        bitfld.long 0x00 6. " CDTL ,Card Detect Test Level: This is bit is enabled while the Card Detection Signal Selection is set to 1 and it indicates card insertion." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CDSS ,Card Detect Signal Selection: This bit selects the source for the card detection." "0,1"
        textline "         "
        hexmask.long.byte 0x00 8.--10. 1. " DMASEL ,DMA Select: This field is valid while DMA (SDMA or ADMA) is enabled and selects the DMA operation."
        textline "         "
        bitfld.long 0x00 16. " SABGREQ ,Stop At Block Gap Request: This bit is used to stop executing a transaction at the next block gap for both DMA and non-DMA transfers." "0,1"
        textline "         "
        bitfld.long 0x00 17. " CREQ ,Continue Request: This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request." "0,1"
        textline "         "
        bitfld.long 0x00 18. " RWCTL ,Read Wait Control: The read wait function is optional for SDIO cards." "0,1"
        textline "         "
        bitfld.long 0x00 19. " IABG ,Interrupt At Block Gap: This bit is valid only in 4-bit mode, of the SDIO card, and selects a sample point in the interrupt cycle." "0,1"
        textline "         "
        bitfld.long 0x00 20. " RD_DONE_NO_8CLK ,Read done no 8 clock: According to the SD/MMC spec, for read data transaction, 8 clocks are needed after the end bit of the last data block." "0,1"
        textline "         "
        bitfld.long 0x00 24. " WECINT ,Wakeup Event Enable On Card Interrupt: This bit enables a wakeup event, via a Card Interrupt, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 25. " WECINS ,Wakeup Event Enable On SD Card Insertion: This bit enables a wakeup event, via a Card Insertion, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 26. " WECRM ,Wakeup Event Enable On SD Card Removal: This bit enables a wakeup event, via a Card Removal, in the Interrupt Status register." "0,1"
        textline "         "
        hexmask.long.byte 0x00 27.--30. 1. " BURST_LEN_EN ,BURST length enable for INCR, INCR4/INCR8/INCR16, INCR4-WRAP/INCR8-WRAP/INCR16-WRAP This is used to enable/disable the burst length for the external AHB2AXI bridge."
        textline "         "
        bitfld.long 0x00 30. " NON_EXACT_BLK_RD ,Current block read is non-exact block read." "0,1"
width 9.
group.long 0x2c++0x3
    line.long 0x00 "SYS_CTRL,System Control"
        hexmask.long.byte 0x00 4.--8. 1. " DVS ,Divisor: This register is used to provide a more exact divisor to generate the desired SD clock frequency."
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " SDCLKFS ,SDCLK Frequency Select: This register is used to select the frequency of the SDCLK pin."
        textline "        "
        hexmask.long.byte 0x00 16.--20. 1. " DTOCV ,Data Timeout Counter Value: This value determines the interval by which DAT line timeouts are detected."
        textline "        "
        bitfld.long 0x00 23. " IPP_RST_N ,This register's value will be output to CARD from pad directly for hardware reset of the card if the card supports this feature." "0,1"
        textline "        "
        bitfld.long 0x00 24. " RSTA ,Software Reset For ALL: This reset effects the entire Host Controller except for the card detection circuit." "0,1"
        textline "        "
        bitfld.long 0x00 25. " RSTC ,Software Reset For CMD Line: Only part of the command circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 26. " RSTD ,Software Reset For DAT Line: Only part of the data circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 27. " INITA ,Initialization Active: When this bit is set, 80 SD-Clocks are sent to the card." "0,1"
width 11.
group.long 0x30++0x3
    line.long 0x00 "INT_STATUS,Interrupt Status"
        bitfld.long 0x00 0. " CC ,Command Complete: This bit is set when you receive the end bit of the command response (except Auto CMD12)." "0,1"
        textline "          "
        bitfld.long 0x00 1. " TC ,Transfer Complete: This bit is set when a read or write transfer is completed." "0,1"
        textline "          "
        bitfld.long 0x00 2. " BGE ,Block Gap Event: If the Stop At Block Gap Request bit in the Protocol Control register is set, this bit is set when a read or write transaction is stopped at a block gap." "0,1"
        textline "          "
        bitfld.long 0x00 3. " DINT ,DMA Interrupt: Occurs only when the internal DMA finishes the data transfer successfully." "0,1"
        textline "          "
        bitfld.long 0x00 4. " BWR ,Buffer Write Ready: This status bit is set if the Buffer Write Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 5. " BRR ,Buffer Read Ready: This status bit is set if the Buffer Read Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 6. " CINS ,Card Insertion: This status bit is set if the Card Inserted bit in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CRM ,Card Removal: This status bit is set if the Card Inserted bit in the Present State register changes from 1 to 0." "0,1"
        textline "          "
        bitfld.long 0x00 8. " CINT ,Card Interrupt: This status bit is set when an interrupt signal is detected from the external card." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTE ,Re-Tuning Event: (only for SD3.0 SDR104 mode) This status is set if Re-Tuning Request in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 14. " TP ,Tuning Pass:(only for SD3.0 SDR104 mode) Current CMD19 transfer is done successfully." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CTOE ,Command Timeout Error: Occurs only if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "          "
        bitfld.long 0x00 17. " CCE ,Command CRC Error: Command CRC Error is generated in two cases." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CEBE ,Command End Bit Error: Occurs when detecting that the end bit of a command response is 0." "0,1"
        textline "          "
        bitfld.long 0x00 19. " CIE ,Command Index Error: Occurs if a Command Index error occurs in the command response." "0,1"
        textline "          "
        bitfld.long 0x00 20. " DTOE ,Data Timeout Error: Occurs when detecting one of following time-out conditions." "0,1"
        textline "          "
        bitfld.long 0x00 21. " DCE ,Data CRC Error: Occurs when detecting a CRC error when transferring read data, which uses the DAT line, or when detecting the Write CRC status having a value other than 010." "0,1"
        textline "          "
        bitfld.long 0x00 22. " DEBE ,Data End Bit Error: Occurs either when detecting 0 at the end bit position of read data, which uses the DAT line, or at the end bit position of the CRC." "0,1"
        textline "          "
        bitfld.long 0x00 24. " AC12E ,Auto CMD12 Error: Occurs when detecting that one of the bits in the Auto CMD12 Error Status register has changed from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 26. " TNE ,Tuning Error: (only for SD3.0 SDR104 mode) This bit is set when an unrecoverable error is detected in a tuning circuit." "0,1"
        textline "          "
        bitfld.long 0x00 28. " DMAE ,DMA Error: Occurs when an Internal DMA transfer has failed." "0,1"
width 14.
group.long 0x34++0x3
    line.long 0x00 "INT_STATUS_EN,Interrupt Status Enable"
        bitfld.long 0x00 0. " CCSEN ,Command Complete Status Enable: 1 Enabled 0 Masked" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCSEN ,Transfer Complete Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGESEN ,Block Gap Event Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTSEN ,DMA Interrupt Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRSEN ,Buffer Write Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRSEN ,Buffer Read Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSSEN ,Card Insertion Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMSEN ,Card Removal Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTSEN ,Card Interrupt Status Enable: If this bit is set to 0, the uSDHC will clear the interrupt request to the System." "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTESEN ,Re-Tuning Event Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPSEN ,Tuning Pass Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOESEN ,Command Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCESEN ,Command CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBESEN ,Command End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIESEN ,Command Index Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOESEN ,Data Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCESEN ,Data CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBESEN ,Data End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12ESEN ,Auto CMD12 Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNESEN ,Tuning Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAESEN ,DMA Error Status Enable:" "0,1"
width 14.
group.long 0x38++0x3
    line.long 0x00 "INT_SIGNAL_EN,Interrupt Signal Enable"
        bitfld.long 0x00 0. " CCIEN ,Command Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCIEN ,Transfer Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGEIEN ,Block Gap Event Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTIEN ,DMA Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRIEN ,Buffer Write Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRIEN ,Buffer Read Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSIEN ,Card Insertion Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMIEN ,Card Removal Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTIEN ,Card Interrupt Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTEIEN ,Re-Tuning Event Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPIEN ,Tuning Pass Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOEIEN ,Command Timeout Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCEIEN ,Command CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBEIEN ,Command End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIEIEN ,Command Index Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOEIEN ,Data Timeout Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCEIEN ,Data CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBEIEN ,Data End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12EIEN ,Auto CMD12 Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNEIEN ,Tuning Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAEIEN ,DMA Error Interrupt Enable:" "0,1"
width 21.
rgroup.long 0x3c++0x3
    line.long 0x00 "AUTOCMD12_ERR_STATUS,Auto CMD12 Error Status"
        bitfld.long 0x00 0. " AC12NE ,Auto CMD12 Not Executed: If memory multiple block data transfer is not started, due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12." "0,1"
        textline "                    "
        bitfld.long 0x00 1. " AC12TOE ,Auto CMD12 Timeout Error: Occurs if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "                    "
        bitfld.long 0x00 2. " AC12EBE ,Auto CMD12 End Bit Error: Occurs when detecting that the end bit of command response is 0 which should be 1." "0,1"
        textline "                    "
        bitfld.long 0x00 3. " AC12CE ,Auto CMD12 CRC Error: Occurs when detecting a CRC error in the command response." "0,1"
        textline "                    "
        bitfld.long 0x00 4. " AC12IE ,Auto CMD12 Index Error: Occurs if the Command Index error occurs in response to a command." "0,1"
        textline "                    "
        bitfld.long 0x00 7. " CNIBAC12E ,Command Not Issued By Auto CMD12 Error: Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this register." "0,1"
width 14.
rgroup.long 0x40++0x3
    line.long 0x00 "HOST_CTRL_CAP,Host Controller Capabilities"
        hexmask.long.byte 0x00 16.--19. 1. " MBL ,Max Block Length: This value indicates the maximum block size that the Host Driver can read and write to the buffer in the uSDHC."
        textline "             "
        bitfld.long 0x00 20. " ADMAS ,ADMA Support: This bit indicates whether the uSDHC supports the ADMA feature." "0,1"
        textline "             "
        bitfld.long 0x00 21. " HSS ,High Speed Support: This bit indicates whether the uSDHC supports High Speed mode and the Host System can supply a SD Clock frequency from 25 MHz to 50 MHz." "0,1"
        textline "             "
        bitfld.long 0x00 22. " DMAS ,DMA Support: This bit indicates whether the uSDHC is capable of using the internal DMA to transfer data between system memory and the data buffer directly." "0,1"
        textline "             "
        bitfld.long 0x00 23. " SRS ,Suspend / Resume Support: This bit indicates whether the uSDHC supports Suspend / Resume functionality." "0,1"
        textline "             "
        bitfld.long 0x00 24. " VS33 ,Voltage Support 3.3V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 25. " VS30 ,Voltage Support 3.0V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 26. " VS18 ,Voltage Support 1.8V: This bit shall depend on the Host System ability." "0,1"
width 9.
group.long 0x44++0x3
    line.long 0x00 "WTMK_LVL,Watermark Level"
        hexmask.long.byte 0x00 0.--8. 1. " RD_WML ,Read Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA read operation."
        textline "        "
        hexmask.long.byte 0x00 8.--13. 1. " RD_BRST_LEN ,Read Burst Length: Due to system restriction, the actual burst length may not exceed 16."
        textline "        "
        hexmask.long.byte 0x00 16.--24. 1. " WR_WML ,Write Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA write operation."
        textline "        "
        hexmask.long.byte 0x00 24.--29. 1. " WR_BRST_LEN ,Write Burst Length: Due to system restriction, the actual burst length may not exceed 16."
width 9.
group.long 0x48++0x3
    line.long 0x00 "MIX_CTRL,Mixer Control"
        bitfld.long 0x00 0. " DMAEN ,DMA Enable: This bit enables DMA functionality." "0,1"
        textline "        "
        bitfld.long 0x00 1. " BCEN ,Block Count Enable: This bit is used to enable the Block Count register, which is only relevant for multiple block transfers." "0,1"
        textline "        "
        bitfld.long 0x00 2. " AC12EN ,Auto CMD12 Enable: Multiple block transfers for memory require a CMD12 to stop the transaction." "0,1"
        textline "        "
        bitfld.long 0x00 3. " DDR_EN ,Dual Data Rate mode selection" "0,1"
        textline "        "
        bitfld.long 0x00 4. " DTDSEL ,Data Transfer Direction Select: This bit defines the direction of DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 5. " MSBSEL ,Multi / Single Block Select: This bit enables multiple block DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 6. " NIBBLE_POS ,In DDR 4-bit mode nibble position indictation." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AC23EN ,Auto CMD23 Enable When this bit is set to 1, the Host Controller issues a CMD23 automatically before issuing a command specified in the Command Register." "0,1"
        textline "        "
        bitfld.long 0x00 22. " EXE_TUNE ,Execute Tuning: (Only used for SD3.0, SDR104 mode) This bit is set to 1 to indicate the Host Driver is starting tuning procedure." "0,1"
        textline "        "
        bitfld.long 0x00 23. " SMP_CLK_SEL ,Tuned clock or Fixed clock is used to sample data/cmd (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 24. " AUTO_TUNE_EN ,Auto tuning enable (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 25. " FBCLK_SEL ,Feedback clock source selection (Only used for SD3.0, SDR104 mode)" "0,1"
width 12.
wgroup.long 0x50++0x3
    line.long 0x00 "FORCE_EVENT,Force Event"
        bitfld.long 0x00 0. " FEVTAC12NE ,Force Event Auto Command 12 Not Executed: Forces the AC12NE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 1. " FEVTAC12TOE ,Force Event Auto Command 12 Time Out Error: Forces the AC12TOE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 2. " FEVTAC12CE ,Force Event Auto Command 12 CRC Error: Forces the AC12CE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 3. " FEVTAC12EBE ,Force Event Auto Command 12 End Bit Error: Forces the AC12EBE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 4. " FEVTAC12IE ,Force Event Auto Command 12 Index Error: Forces the AC12IE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 7. " FEVTCNIBAC12E ,Force Event Command Not Executed By Auto Command 12 Error: Forces the CNIBAC12E bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 16. " FEVTCTOE ,Force Event Command Time Out Error: Forces the CTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 17. " FEVTCCE ,Force Event Command CRC Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 18. " FEVTCEBE ,Force Event Command End Bit Error: Forces the CEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 19. " FEVTCIE ,Force Event Command Index Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 20. " FEVTDTOE ,Force Event Data Time Out Error: Force the DTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 21. " FEVTDCE ,Force Event Data CRC Error: Forces the DCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 22. " FEVTDEBE ,Force Event Data End Bit Error: Forces the DEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 24. " FEVTAC12E ,Force Event Auto Command 12 Error: Forces the AC12E bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 26. " FEVTTNE ,Force Tuning Error: Forces the TNE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 28. " FEVTDMAE ,Force Event DMA Error: Forces the DMAE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 31. " FEVTCINT ,Force Event Card Interrupt: Writing 1 to this bit generates a short low-level pulse on the internal DAT[1] line, as if a self clearing interrupt was received from the external card." "0,1"
width 16.
rgroup.long 0x54++0x3
    line.long 0x00 "ADMA_ERR_STATUS,ADMA Error Status Register"
        hexmask.long.byte 0x00 0.--2. 1. " ADMAES ,ADMA Error State (when ADMA Error is occurred.): This field indicates the state of the ADMA when an error has occurred during an ADMA data transfer."
        textline "               "
        bitfld.long 0x00 2. " ADMALME ,ADMA Length Mismatch Error: This error occurs in the following 2 cases: While the Block Count Enable is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length Total data length can not be divided by the block length" "0,1"
        textline "               "
        bitfld.long 0x00 3. " ADMADCE ,ADMA Descritor Error: This error occurs when invalid descriptor fetched by ADMA:" "0,1"
width 14.
group.long 0x58++0x3
    line.long 0x00 "ADMA_SYS_ADDR,ADMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " ADS_ADDR ,ADMA System Address: This register holds the word address of the executing command in the Descriptor table."
width 9.
group.long 0x60++0x3
    line.long 0x00 "DLL_CTRL,DLL (Delay Line) Control"
        bitfld.long 0x00 0. " DLL_CTRL_ENABLE ,Set this bit to 1 to enable the DLL and delay chain; otherwise; set to 0 to bypasses DLL." "0,1"
        textline "        "
        bitfld.long 0x00 1. " DLL_CTRL_RESET ,Setting this bit to 1 force a reset on DLL." "0,1"
        textline "        "
        bitfld.long 0x00 2. " DLL_CTRL_SLV_FORCE_UPD ,Setting this bit to 1, forces the slave delay line to update to the DLL calibrated value immediately." "0,1"
        textline "        "
        hexmask.long.byte 0x00 3.--7. 1. " DLL_CTRL_SLV_DLY_TARGET0 ,The delay target for the uSDHC loopback read clock can be programmed in 1/16th increments of an ref_clock half-period."
        textline "        "
        bitfld.long 0x00 7. " DLL_CTRL_GATE_UPDATE ,Set this bit to 1 to prevent the DLL from updating (since when clock_in exists, glitches may appear during DLL updates)." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DLL_CTRL_SLV_OVERRIDE ,Set this bit to 1 to Enable manual override for slave delay chain using SLV_OVERRIDE_VAL; to set 0 to disable manual override." "0,1"
        textline "        "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_CTRL_SLV_OVERRIDE_VAL ,When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical taps manually."
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " DLL_CTRL_SLV_DLY_TARGET1 ,Refer to DLL_CTRL_SLV_DLY_TARGET0 below."
        textline "        "
        hexmask.long.byte 0x00 20.--28. 1. " DLL_CTRL_SLV_UPDATE_INT ,Slave delay line update interval."
        textline "        "
        hexmask.long.byte 0x00 28.--32. 1. " DLL_CTRL_REF_UPDATE_INT ,DLL control loop update interval."
width 11.
rgroup.long 0x64++0x3
    line.long 0x00 "DLL_STATUS,DLL Status"
        bitfld.long 0x00 0. " DLL_STS_SLV_LOCK ,Slave delay-line lock status." "0,1"
        textline "          "
        bitfld.long 0x00 1. " DLL_STS_REF_LOCK ,Reference DLL lock status." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--9. 1. " DLL_STS_SLV_SEL ,Slave delay line select status."
        textline "          "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_STS_REF_SEL ,Reference delay line select taps."
width 21.
group.long 0x68++0x3
    line.long 0x00 "CLK_TUNE_CTRL_STATUS,CLK Tuning Control and Status"
        hexmask.long.byte 0x00 0.--4. 1. " DLY_CELL_SET_POST ,Set the number of delay cells on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 4.--8. 1. " DLY_CELL_SET_OUT ,Set the number of delay cells on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 8.--15. 1. " DLY_CELL_SET_PRE ,Set the number of delay cells on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 15. " NXT_ERR ,NXT error which means the number of delay cells added on the feedback clock is too large." "0,1"
        textline "                    "
        hexmask.long.byte 0x00 16.--20. 1. " TAP_SEL_POST ,Reflect the number of delay cells added on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 20.--24. 1. " TAP_SEL_OUT ,Reflect the number of delay cells added on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 24.--31. 1. " TAP_SEL_PRE ,Reflects the number of delay cells added on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 31. " PRE_ERR ,PRE error which means the number of delay cells added on the feedback clock is too small." "0,1"
width 10.
group.long 0xc0++0x3
    line.long 0x00 "VEND_SPEC,Vendor Specific Register"
        bitfld.long 0x00 0. " EXT_DMA_EN ,External DMA Request Enable Enable the request to external DMA." "0,1"
        textline "         "
        bitfld.long 0x00 1. " VSELECT ,Voltage Selection Change the value of output signal VSELECT, to control the voltage on pads for external card." "0,1"
        textline "         "
        bitfld.long 0x00 2. " CONFLICT_CHK_EN ,It's not implemented in uSDHC IP." "0,1"
        textline "         "
        bitfld.long 0x00 3. " AC12_WR_CHKBUSY_EN ,Check busy enable after auto CMD12 for write data packet" "0,1"
        textline "         "
        bitfld.long 0x00 4. " DAT3_CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 5. " CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 6. " WP_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CLKONJ_IN_ABORT ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 8. " FRC_SDCLK_ON ,Force CLK output active:" "0,1"
        textline "         "
        bitfld.long 0x00 11. " IPG_CLK_SOFT_EN ,IPG_CLK software enable" "0,1"
        textline "         "
        bitfld.long 0x00 12. " HCLK_SOFT_EN ,Please note, hardware auto-enables the AHB clock when the internal DMA is enabled even if HCLK_SOFT_EN is 0." "0,1"
        textline "         "
        bitfld.long 0x00 13. " IPG_PERCLK_SOFT_EN ,ipg_perclk software enable" "0,1"
        textline "         "
        bitfld.long 0x00 14. " CARD_CLK_SOFT_EN ,card clock software enable" "0,1"
        textline "         "
        bitfld.long 0x00 15. " CRC_CHK_DIS ,CRC check disable" "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " INT_ST_VAL ,Internal State Value Internal state value, reflecting the corresponding state value selected by Debug Select field."
width 9.
group.long 0xc4++0x3
    line.long 0x00 "MMC_BOOT,MMC Boot Register"
        hexmask.long.byte 0x00 0.--4. 1. " DTOCV_ACK ,Boot ACK time out counter value."
        textline "        "
        bitfld.long 0x00 4. " BOOT_ACK ,Boot ack mode select." "0,1"
        textline "        "
        bitfld.long 0x00 5. " BOOT_MODE ,Boot mode select." "0,1"
        textline "        "
        bitfld.long 0x00 6. " BOOT_EN ,Boot mode enable." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AUTO_SABG_EN ,During boot, enable auto stop at block gap function." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DISABLE_TIME_OUT ,Please note, when this bit is set, there is no timeout check no matter whether boot_en is set or not." "0,1"
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " BOOT_BLK_CNT ,The value defines the Stop At Block Gap value of automatic mode."
width 11.
group.long 0xc8++0x3
    line.long 0x00 "VEND_SPEC2,Vendor Specific 2 Register"
        bitfld.long 0x00 0. " SDR104_TIMING_DIS ,Timeout counter test." "0,1"
        textline "          "
        bitfld.long 0x00 1. " SDR104_OE_DIS ,CMD_OE/DAT_OE logic generation test." "0,1"
        textline "          "
        bitfld.long 0x00 2. " SDR104_NSD_DIS ,Interrupt window after abort command is sent." "0,1"
        textline "          "
        bitfld.long 0x00 3. " CARD_INT_D3_TEST ,Card interrupt detection test." "0,1"
        textline "          "
        bitfld.long 0x00 4. " TUNING_8BIT_EN ,Enable the auto tuning circuit to check the DAT[7:0]." "0,1"
        textline "          "
        bitfld.long 0x00 5. " TUNING_1BIT_EN ,Enable the auto tuning circuit to check the DAT0 only." "0,1"
        textline "          "
        bitfld.long 0x00 6. " TUNING_CMD_EN ,Enable the auto tuning circuit to check the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CARD_INT_AUTO_CLR_DIS ,Disable the feature to clear the Card interrupt status bit when Card Interrupt status enable bit is cleared." "0,1"


    tree.end
    tree "USDHC2"
        base ad:0x02194000

width 8.
group.long 0x0++0x3
    line.long 0x00 "DS_ADDR,DMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,DMA System Address: This register contains the 32-bit system memory address for a DMA transfer."
width 8.
group.long 0x4++0x3
    line.long 0x00 "BLK_ATT,Block Attributes"
        hexmask.long.word 0x00 0.--13. 1. " BLKSIZE ,Transfer Block Size: This register specifies the block size for block data transfers."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " BLKCNT ,Blocks Count For Current Transfer: This register is enabled when the Block Count Enable bit in the Transfer Mode register is set to 1 and is valid only for multiple block transfers."
width 8.
group.long 0x8++0x3
    line.long 0x00 "CMD_ARG,Command Argument"
        hexmask.long.long 0x00 0.--32. 1. " CMDARG ,Command Argument: The SD/MMC Command Argument is specified as bits 39-8 of the Command Format in the SD or MMC Specification.This register is write protected when the Command Inhibit (CMD) bit in the Present State register is set."
width 12.
group.long 0xc++0x3
    line.long 0x00 "CMD_XFR_TYP,Command Transfer Type"
        hexmask.long.byte 0x00 16.--18. 1. " RSPTYP ,Response Type Select:"
        textline "           "
        bitfld.long 0x00 19. " CCCEN ,Command CRC Check Enable: If this bit is set to 1, the uSDHC shall check the CRC field in the response." "0,1"
        textline "           "
        bitfld.long 0x00 20. " CICEN ,Command Index Check Enable: If this bit is set to 1, the uSDHC will check the Index field in the response to see if it has the same value as the command index." "0,1"
        textline "           "
        bitfld.long 0x00 21. " DPSEL ,Data Present Select: This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line." "0,1"
        textline "           "
        hexmask.long.byte 0x00 22.--24. 1. " CMDTYP ,Command Type: There are three types of special commands: Suspend, Resume and Abort."
        textline "           "
        hexmask.long.byte 0x00 24.--30. 1. " CMDINX ,Command Index: These bits shall be set to the command number that is specified in bits 45-40 of the Command-Format in the SD Memory Card Physical Layer Specification and SDIO Card Specification."
width 9.
rgroup.long 0x10++0x3
    line.long 0x00 "CMD_RSP0,Command Response0"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP0 ,Command Response 0: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x14++0x3
    line.long 0x00 "CMD_RSP1,Command Response1"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP1 ,Command Response 1: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x18++0x3
    line.long 0x00 "CMD_RSP2,Command Response2"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP2 ,Command Response 2: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x1c++0x3
    line.long 0x00 "CMD_RSP3,Command Response3"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP3 ,Command Response 3: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 19.
group.long 0x20++0x3
    line.long 0x00 "DATA_BUFF_ACC_PORT,Data Buffer Access Port"
        hexmask.long.long 0x00 0.--32. 1. " DATCONT ,Data Content: The Buffer Data Port register is for 32-bit data access by the ARM platform or the external DMA."
width 11.
rgroup.long 0x24++0x3
    line.long 0x00 "PRES_STATE,Present State"
        bitfld.long 0x00 0. " CIHB ,Command Inhibit (CMD): If this status bit is 0, it indicates that the CMD line is not in use and the uSDHC can issue a SD/MMC Command using the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 1. " CDIHB ,Command Inhibit (DAT): This status bit is generated if either the DAT Line Active or the Read Transfer Active is set to 1." "0,1"
        textline "          "
        bitfld.long 0x00 2. " DLA ,Data Line Active This status bit indicates whether one of the DAT lines on the SD Bus is in use." "0,1"
        textline "          "
        bitfld.long 0x00 3. " SDSTB ,SD Clock Stable This status bit indicates that the internal card clock is stable." "0,1"
        textline "          "
        bitfld.long 0x00 4. " IPGOFF ,ipg_clk Gated Off Internally: This status bit indicates that the ipg_clk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 5. " HCKOFF ,hclk Gated Off Internally: This status bit indicates that the hclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 6. " PEROFF ,ipg_perclk Gated Off Internally: This status bit indicates that the ipg_perclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SDOFF ,SD Clock Gated Off Internally: This status bit indicates that the SD Clock is internally gated off, because of buffer over/under-run or read pause without read wait assertion, or the driver set FRC_SDCLK_ON bit is 0 to stop the SD clock in idle status." "0,1"
        textline "          "
        bitfld.long 0x00 8. " WTA ,Write Transfer Active: This status bit indicates a write transfer is active." "0,1"
        textline "          "
        bitfld.long 0x00 9. " RTA ,Read Transfer Active: This status bit is used for detecting completion of a read transfer." "0,1"
        textline "          "
        bitfld.long 0x00 10. " BWEN ,Buffer Write Enable: This status bit is used for non-DMA write transfers." "0,1"
        textline "          "
        bitfld.long 0x00 11. " BREN ,Buffer Read Enable: This status bit is used for non-DMA read transfers." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTR ,Re-Tuning Request: (only for SD3.0 SDR104 mode) Host Controller may request Host Driver to execute re-tuning sequence by setting this bit when the data window is shifted by temperature drift and a tuned sampling point does not have a good margin to receive correct data." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CINST ,Card Inserted: This bit indicates whether a card has been inserted." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CDPL ,Card Detect Pin Level: This bit reflects the inverse value of the CD# pin for the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 19. " WPSPL ,Write Protect Switch Pin Level: The Write Protect Switch is supported for memory and combo cards.This bit reflects the inverted value of the WP pin of the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 23. " CLSL ,CMD Line Signal Level: This status is used to check the CMD line level to recover from errors, and for debugging." "0,1"
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " DLSL ,DAT[7:0] Line Signal Level: This status is used to check the DAT line level to recover from errors, and for debugging.This is especially useful in detecting the busy signal level from DAT[0]."
width 10.
group.long 0x28++0x3
    line.long 0x00 "PROT_CTRL,Protocol Control"
        bitfld.long 0x00 0. " LCTL ,LED Control: This bit, fully controlled by the Host Driver, is used to caution the user not to remove the card while the card is being accessed." "0,1"
        textline "         "
        hexmask.long.byte 0x00 1.--3. 1. " DTW ,Data Transfer Width: This bit selects the data width of the SD bus for a data transfer."
        textline "         "
        bitfld.long 0x00 3. " D3CD ,DAT3 as Card Detection Pin: If this bit is set, DAT3 should be pulled down to act as a card detection pin." "0,1"
        textline "         "
        hexmask.long.byte 0x00 4.--6. 1. " EMODE ,Endian Mode: The uSDHC supports all three endian modes in data transfer."
        textline "         "
        bitfld.long 0x00 6. " CDTL ,Card Detect Test Level: This is bit is enabled while the Card Detection Signal Selection is set to 1 and it indicates card insertion." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CDSS ,Card Detect Signal Selection: This bit selects the source for the card detection." "0,1"
        textline "         "
        hexmask.long.byte 0x00 8.--10. 1. " DMASEL ,DMA Select: This field is valid while DMA (SDMA or ADMA) is enabled and selects the DMA operation."
        textline "         "
        bitfld.long 0x00 16. " SABGREQ ,Stop At Block Gap Request: This bit is used to stop executing a transaction at the next block gap for both DMA and non-DMA transfers." "0,1"
        textline "         "
        bitfld.long 0x00 17. " CREQ ,Continue Request: This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request." "0,1"
        textline "         "
        bitfld.long 0x00 18. " RWCTL ,Read Wait Control: The read wait function is optional for SDIO cards." "0,1"
        textline "         "
        bitfld.long 0x00 19. " IABG ,Interrupt At Block Gap: This bit is valid only in 4-bit mode, of the SDIO card, and selects a sample point in the interrupt cycle." "0,1"
        textline "         "
        bitfld.long 0x00 20. " RD_DONE_NO_8CLK ,Read done no 8 clock: According to the SD/MMC spec, for read data transaction, 8 clocks are needed after the end bit of the last data block." "0,1"
        textline "         "
        bitfld.long 0x00 24. " WECINT ,Wakeup Event Enable On Card Interrupt: This bit enables a wakeup event, via a Card Interrupt, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 25. " WECINS ,Wakeup Event Enable On SD Card Insertion: This bit enables a wakeup event, via a Card Insertion, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 26. " WECRM ,Wakeup Event Enable On SD Card Removal: This bit enables a wakeup event, via a Card Removal, in the Interrupt Status register." "0,1"
        textline "         "
        hexmask.long.byte 0x00 27.--30. 1. " BURST_LEN_EN ,BURST length enable for INCR, INCR4/INCR8/INCR16, INCR4-WRAP/INCR8-WRAP/INCR16-WRAP This is used to enable/disable the burst length for the external AHB2AXI bridge."
        textline "         "
        bitfld.long 0x00 30. " NON_EXACT_BLK_RD ,Current block read is non-exact block read." "0,1"
width 9.
group.long 0x2c++0x3
    line.long 0x00 "SYS_CTRL,System Control"
        hexmask.long.byte 0x00 4.--8. 1. " DVS ,Divisor: This register is used to provide a more exact divisor to generate the desired SD clock frequency."
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " SDCLKFS ,SDCLK Frequency Select: This register is used to select the frequency of the SDCLK pin."
        textline "        "
        hexmask.long.byte 0x00 16.--20. 1. " DTOCV ,Data Timeout Counter Value: This value determines the interval by which DAT line timeouts are detected."
        textline "        "
        bitfld.long 0x00 23. " IPP_RST_N ,This register's value will be output to CARD from pad directly for hardware reset of the card if the card supports this feature." "0,1"
        textline "        "
        bitfld.long 0x00 24. " RSTA ,Software Reset For ALL: This reset effects the entire Host Controller except for the card detection circuit." "0,1"
        textline "        "
        bitfld.long 0x00 25. " RSTC ,Software Reset For CMD Line: Only part of the command circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 26. " RSTD ,Software Reset For DAT Line: Only part of the data circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 27. " INITA ,Initialization Active: When this bit is set, 80 SD-Clocks are sent to the card." "0,1"
width 11.
group.long 0x30++0x3
    line.long 0x00 "INT_STATUS,Interrupt Status"
        bitfld.long 0x00 0. " CC ,Command Complete: This bit is set when you receive the end bit of the command response (except Auto CMD12)." "0,1"
        textline "          "
        bitfld.long 0x00 1. " TC ,Transfer Complete: This bit is set when a read or write transfer is completed." "0,1"
        textline "          "
        bitfld.long 0x00 2. " BGE ,Block Gap Event: If the Stop At Block Gap Request bit in the Protocol Control register is set, this bit is set when a read or write transaction is stopped at a block gap." "0,1"
        textline "          "
        bitfld.long 0x00 3. " DINT ,DMA Interrupt: Occurs only when the internal DMA finishes the data transfer successfully." "0,1"
        textline "          "
        bitfld.long 0x00 4. " BWR ,Buffer Write Ready: This status bit is set if the Buffer Write Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 5. " BRR ,Buffer Read Ready: This status bit is set if the Buffer Read Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 6. " CINS ,Card Insertion: This status bit is set if the Card Inserted bit in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CRM ,Card Removal: This status bit is set if the Card Inserted bit in the Present State register changes from 1 to 0." "0,1"
        textline "          "
        bitfld.long 0x00 8. " CINT ,Card Interrupt: This status bit is set when an interrupt signal is detected from the external card." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTE ,Re-Tuning Event: (only for SD3.0 SDR104 mode) This status is set if Re-Tuning Request in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 14. " TP ,Tuning Pass:(only for SD3.0 SDR104 mode) Current CMD19 transfer is done successfully." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CTOE ,Command Timeout Error: Occurs only if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "          "
        bitfld.long 0x00 17. " CCE ,Command CRC Error: Command CRC Error is generated in two cases." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CEBE ,Command End Bit Error: Occurs when detecting that the end bit of a command response is 0." "0,1"
        textline "          "
        bitfld.long 0x00 19. " CIE ,Command Index Error: Occurs if a Command Index error occurs in the command response." "0,1"
        textline "          "
        bitfld.long 0x00 20. " DTOE ,Data Timeout Error: Occurs when detecting one of following time-out conditions." "0,1"
        textline "          "
        bitfld.long 0x00 21. " DCE ,Data CRC Error: Occurs when detecting a CRC error when transferring read data, which uses the DAT line, or when detecting the Write CRC status having a value other than 010." "0,1"
        textline "          "
        bitfld.long 0x00 22. " DEBE ,Data End Bit Error: Occurs either when detecting 0 at the end bit position of read data, which uses the DAT line, or at the end bit position of the CRC." "0,1"
        textline "          "
        bitfld.long 0x00 24. " AC12E ,Auto CMD12 Error: Occurs when detecting that one of the bits in the Auto CMD12 Error Status register has changed from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 26. " TNE ,Tuning Error: (only for SD3.0 SDR104 mode) This bit is set when an unrecoverable error is detected in a tuning circuit." "0,1"
        textline "          "
        bitfld.long 0x00 28. " DMAE ,DMA Error: Occurs when an Internal DMA transfer has failed." "0,1"
width 14.
group.long 0x34++0x3
    line.long 0x00 "INT_STATUS_EN,Interrupt Status Enable"
        bitfld.long 0x00 0. " CCSEN ,Command Complete Status Enable: 1 Enabled 0 Masked" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCSEN ,Transfer Complete Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGESEN ,Block Gap Event Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTSEN ,DMA Interrupt Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRSEN ,Buffer Write Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRSEN ,Buffer Read Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSSEN ,Card Insertion Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMSEN ,Card Removal Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTSEN ,Card Interrupt Status Enable: If this bit is set to 0, the uSDHC will clear the interrupt request to the System." "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTESEN ,Re-Tuning Event Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPSEN ,Tuning Pass Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOESEN ,Command Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCESEN ,Command CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBESEN ,Command End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIESEN ,Command Index Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOESEN ,Data Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCESEN ,Data CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBESEN ,Data End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12ESEN ,Auto CMD12 Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNESEN ,Tuning Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAESEN ,DMA Error Status Enable:" "0,1"
width 14.
group.long 0x38++0x3
    line.long 0x00 "INT_SIGNAL_EN,Interrupt Signal Enable"
        bitfld.long 0x00 0. " CCIEN ,Command Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCIEN ,Transfer Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGEIEN ,Block Gap Event Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTIEN ,DMA Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRIEN ,Buffer Write Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRIEN ,Buffer Read Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSIEN ,Card Insertion Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMIEN ,Card Removal Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTIEN ,Card Interrupt Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTEIEN ,Re-Tuning Event Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPIEN ,Tuning Pass Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOEIEN ,Command Timeout Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCEIEN ,Command CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBEIEN ,Command End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIEIEN ,Command Index Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOEIEN ,Data Timeout Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCEIEN ,Data CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBEIEN ,Data End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12EIEN ,Auto CMD12 Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNEIEN ,Tuning Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAEIEN ,DMA Error Interrupt Enable:" "0,1"
width 21.
rgroup.long 0x3c++0x3
    line.long 0x00 "AUTOCMD12_ERR_STATUS,Auto CMD12 Error Status"
        bitfld.long 0x00 0. " AC12NE ,Auto CMD12 Not Executed: If memory multiple block data transfer is not started, due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12." "0,1"
        textline "                    "
        bitfld.long 0x00 1. " AC12TOE ,Auto CMD12 Timeout Error: Occurs if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "                    "
        bitfld.long 0x00 2. " AC12EBE ,Auto CMD12 End Bit Error: Occurs when detecting that the end bit of command response is 0 which should be 1." "0,1"
        textline "                    "
        bitfld.long 0x00 3. " AC12CE ,Auto CMD12 CRC Error: Occurs when detecting a CRC error in the command response." "0,1"
        textline "                    "
        bitfld.long 0x00 4. " AC12IE ,Auto CMD12 Index Error: Occurs if the Command Index error occurs in response to a command." "0,1"
        textline "                    "
        bitfld.long 0x00 7. " CNIBAC12E ,Command Not Issued By Auto CMD12 Error: Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this register." "0,1"
width 14.
rgroup.long 0x40++0x3
    line.long 0x00 "HOST_CTRL_CAP,Host Controller Capabilities"
        hexmask.long.byte 0x00 16.--19. 1. " MBL ,Max Block Length: This value indicates the maximum block size that the Host Driver can read and write to the buffer in the uSDHC."
        textline "             "
        bitfld.long 0x00 20. " ADMAS ,ADMA Support: This bit indicates whether the uSDHC supports the ADMA feature." "0,1"
        textline "             "
        bitfld.long 0x00 21. " HSS ,High Speed Support: This bit indicates whether the uSDHC supports High Speed mode and the Host System can supply a SD Clock frequency from 25 MHz to 50 MHz." "0,1"
        textline "             "
        bitfld.long 0x00 22. " DMAS ,DMA Support: This bit indicates whether the uSDHC is capable of using the internal DMA to transfer data between system memory and the data buffer directly." "0,1"
        textline "             "
        bitfld.long 0x00 23. " SRS ,Suspend / Resume Support: This bit indicates whether the uSDHC supports Suspend / Resume functionality." "0,1"
        textline "             "
        bitfld.long 0x00 24. " VS33 ,Voltage Support 3.3V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 25. " VS30 ,Voltage Support 3.0V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 26. " VS18 ,Voltage Support 1.8V: This bit shall depend on the Host System ability." "0,1"
width 9.
group.long 0x44++0x3
    line.long 0x00 "WTMK_LVL,Watermark Level"
        hexmask.long.byte 0x00 0.--8. 1. " RD_WML ,Read Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA read operation."
        textline "        "
        hexmask.long.byte 0x00 8.--13. 1. " RD_BRST_LEN ,Read Burst Length: Due to system restriction, the actual burst length may not exceed 16."
        textline "        "
        hexmask.long.byte 0x00 16.--24. 1. " WR_WML ,Write Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA write operation."
        textline "        "
        hexmask.long.byte 0x00 24.--29. 1. " WR_BRST_LEN ,Write Burst Length: Due to system restriction, the actual burst length may not exceed 16."
width 9.
group.long 0x48++0x3
    line.long 0x00 "MIX_CTRL,Mixer Control"
        bitfld.long 0x00 0. " DMAEN ,DMA Enable: This bit enables DMA functionality." "0,1"
        textline "        "
        bitfld.long 0x00 1. " BCEN ,Block Count Enable: This bit is used to enable the Block Count register, which is only relevant for multiple block transfers." "0,1"
        textline "        "
        bitfld.long 0x00 2. " AC12EN ,Auto CMD12 Enable: Multiple block transfers for memory require a CMD12 to stop the transaction." "0,1"
        textline "        "
        bitfld.long 0x00 3. " DDR_EN ,Dual Data Rate mode selection" "0,1"
        textline "        "
        bitfld.long 0x00 4. " DTDSEL ,Data Transfer Direction Select: This bit defines the direction of DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 5. " MSBSEL ,Multi / Single Block Select: This bit enables multiple block DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 6. " NIBBLE_POS ,In DDR 4-bit mode nibble position indictation." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AC23EN ,Auto CMD23 Enable When this bit is set to 1, the Host Controller issues a CMD23 automatically before issuing a command specified in the Command Register." "0,1"
        textline "        "
        bitfld.long 0x00 22. " EXE_TUNE ,Execute Tuning: (Only used for SD3.0, SDR104 mode) This bit is set to 1 to indicate the Host Driver is starting tuning procedure." "0,1"
        textline "        "
        bitfld.long 0x00 23. " SMP_CLK_SEL ,Tuned clock or Fixed clock is used to sample data/cmd (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 24. " AUTO_TUNE_EN ,Auto tuning enable (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 25. " FBCLK_SEL ,Feedback clock source selection (Only used for SD3.0, SDR104 mode)" "0,1"
width 12.
wgroup.long 0x50++0x3
    line.long 0x00 "FORCE_EVENT,Force Event"
        bitfld.long 0x00 0. " FEVTAC12NE ,Force Event Auto Command 12 Not Executed: Forces the AC12NE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 1. " FEVTAC12TOE ,Force Event Auto Command 12 Time Out Error: Forces the AC12TOE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 2. " FEVTAC12CE ,Force Event Auto Command 12 CRC Error: Forces the AC12CE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 3. " FEVTAC12EBE ,Force Event Auto Command 12 End Bit Error: Forces the AC12EBE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 4. " FEVTAC12IE ,Force Event Auto Command 12 Index Error: Forces the AC12IE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 7. " FEVTCNIBAC12E ,Force Event Command Not Executed By Auto Command 12 Error: Forces the CNIBAC12E bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 16. " FEVTCTOE ,Force Event Command Time Out Error: Forces the CTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 17. " FEVTCCE ,Force Event Command CRC Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 18. " FEVTCEBE ,Force Event Command End Bit Error: Forces the CEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 19. " FEVTCIE ,Force Event Command Index Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 20. " FEVTDTOE ,Force Event Data Time Out Error: Force the DTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 21. " FEVTDCE ,Force Event Data CRC Error: Forces the DCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 22. " FEVTDEBE ,Force Event Data End Bit Error: Forces the DEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 24. " FEVTAC12E ,Force Event Auto Command 12 Error: Forces the AC12E bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 26. " FEVTTNE ,Force Tuning Error: Forces the TNE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 28. " FEVTDMAE ,Force Event DMA Error: Forces the DMAE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 31. " FEVTCINT ,Force Event Card Interrupt: Writing 1 to this bit generates a short low-level pulse on the internal DAT[1] line, as if a self clearing interrupt was received from the external card." "0,1"
width 16.
rgroup.long 0x54++0x3
    line.long 0x00 "ADMA_ERR_STATUS,ADMA Error Status Register"
        hexmask.long.byte 0x00 0.--2. 1. " ADMAES ,ADMA Error State (when ADMA Error is occurred.): This field indicates the state of the ADMA when an error has occurred during an ADMA data transfer."
        textline "               "
        bitfld.long 0x00 2. " ADMALME ,ADMA Length Mismatch Error: This error occurs in the following 2 cases: While the Block Count Enable is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length Total data length can not be divided by the block length" "0,1"
        textline "               "
        bitfld.long 0x00 3. " ADMADCE ,ADMA Descritor Error: This error occurs when invalid descriptor fetched by ADMA:" "0,1"
width 14.
group.long 0x58++0x3
    line.long 0x00 "ADMA_SYS_ADDR,ADMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " ADS_ADDR ,ADMA System Address: This register holds the word address of the executing command in the Descriptor table."
width 9.
group.long 0x60++0x3
    line.long 0x00 "DLL_CTRL,DLL (Delay Line) Control"
        bitfld.long 0x00 0. " DLL_CTRL_ENABLE ,Set this bit to 1 to enable the DLL and delay chain; otherwise; set to 0 to bypasses DLL." "0,1"
        textline "        "
        bitfld.long 0x00 1. " DLL_CTRL_RESET ,Setting this bit to 1 force a reset on DLL." "0,1"
        textline "        "
        bitfld.long 0x00 2. " DLL_CTRL_SLV_FORCE_UPD ,Setting this bit to 1, forces the slave delay line to update to the DLL calibrated value immediately." "0,1"
        textline "        "
        hexmask.long.byte 0x00 3.--7. 1. " DLL_CTRL_SLV_DLY_TARGET0 ,The delay target for the uSDHC loopback read clock can be programmed in 1/16th increments of an ref_clock half-period."
        textline "        "
        bitfld.long 0x00 7. " DLL_CTRL_GATE_UPDATE ,Set this bit to 1 to prevent the DLL from updating (since when clock_in exists, glitches may appear during DLL updates)." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DLL_CTRL_SLV_OVERRIDE ,Set this bit to 1 to Enable manual override for slave delay chain using SLV_OVERRIDE_VAL; to set 0 to disable manual override." "0,1"
        textline "        "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_CTRL_SLV_OVERRIDE_VAL ,When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical taps manually."
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " DLL_CTRL_SLV_DLY_TARGET1 ,Refer to DLL_CTRL_SLV_DLY_TARGET0 below."
        textline "        "
        hexmask.long.byte 0x00 20.--28. 1. " DLL_CTRL_SLV_UPDATE_INT ,Slave delay line update interval."
        textline "        "
        hexmask.long.byte 0x00 28.--32. 1. " DLL_CTRL_REF_UPDATE_INT ,DLL control loop update interval."
width 11.
rgroup.long 0x64++0x3
    line.long 0x00 "DLL_STATUS,DLL Status"
        bitfld.long 0x00 0. " DLL_STS_SLV_LOCK ,Slave delay-line lock status." "0,1"
        textline "          "
        bitfld.long 0x00 1. " DLL_STS_REF_LOCK ,Reference DLL lock status." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--9. 1. " DLL_STS_SLV_SEL ,Slave delay line select status."
        textline "          "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_STS_REF_SEL ,Reference delay line select taps."
width 21.
group.long 0x68++0x3
    line.long 0x00 "CLK_TUNE_CTRL_STATUS,CLK Tuning Control and Status"
        hexmask.long.byte 0x00 0.--4. 1. " DLY_CELL_SET_POST ,Set the number of delay cells on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 4.--8. 1. " DLY_CELL_SET_OUT ,Set the number of delay cells on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 8.--15. 1. " DLY_CELL_SET_PRE ,Set the number of delay cells on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 15. " NXT_ERR ,NXT error which means the number of delay cells added on the feedback clock is too large." "0,1"
        textline "                    "
        hexmask.long.byte 0x00 16.--20. 1. " TAP_SEL_POST ,Reflect the number of delay cells added on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 20.--24. 1. " TAP_SEL_OUT ,Reflect the number of delay cells added on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 24.--31. 1. " TAP_SEL_PRE ,Reflects the number of delay cells added on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 31. " PRE_ERR ,PRE error which means the number of delay cells added on the feedback clock is too small." "0,1"
width 10.
group.long 0xc0++0x3
    line.long 0x00 "VEND_SPEC,Vendor Specific Register"
        bitfld.long 0x00 0. " EXT_DMA_EN ,External DMA Request Enable Enable the request to external DMA." "0,1"
        textline "         "
        bitfld.long 0x00 1. " VSELECT ,Voltage Selection Change the value of output signal VSELECT, to control the voltage on pads for external card." "0,1"
        textline "         "
        bitfld.long 0x00 2. " CONFLICT_CHK_EN ,It's not implemented in uSDHC IP." "0,1"
        textline "         "
        bitfld.long 0x00 3. " AC12_WR_CHKBUSY_EN ,Check busy enable after auto CMD12 for write data packet" "0,1"
        textline "         "
        bitfld.long 0x00 4. " DAT3_CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 5. " CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 6. " WP_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CLKONJ_IN_ABORT ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 8. " FRC_SDCLK_ON ,Force CLK output active:" "0,1"
        textline "         "
        bitfld.long 0x00 11. " IPG_CLK_SOFT_EN ,IPG_CLK software enable" "0,1"
        textline "         "
        bitfld.long 0x00 12. " HCLK_SOFT_EN ,Please note, hardware auto-enables the AHB clock when the internal DMA is enabled even if HCLK_SOFT_EN is 0." "0,1"
        textline "         "
        bitfld.long 0x00 13. " IPG_PERCLK_SOFT_EN ,ipg_perclk software enable" "0,1"
        textline "         "
        bitfld.long 0x00 14. " CARD_CLK_SOFT_EN ,card clock software enable" "0,1"
        textline "         "
        bitfld.long 0x00 15. " CRC_CHK_DIS ,CRC check disable" "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " INT_ST_VAL ,Internal State Value Internal state value, reflecting the corresponding state value selected by Debug Select field."
width 9.
group.long 0xc4++0x3
    line.long 0x00 "MMC_BOOT,MMC Boot Register"
        hexmask.long.byte 0x00 0.--4. 1. " DTOCV_ACK ,Boot ACK time out counter value."
        textline "        "
        bitfld.long 0x00 4. " BOOT_ACK ,Boot ack mode select." "0,1"
        textline "        "
        bitfld.long 0x00 5. " BOOT_MODE ,Boot mode select." "0,1"
        textline "        "
        bitfld.long 0x00 6. " BOOT_EN ,Boot mode enable." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AUTO_SABG_EN ,During boot, enable auto stop at block gap function." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DISABLE_TIME_OUT ,Please note, when this bit is set, there is no timeout check no matter whether boot_en is set or not." "0,1"
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " BOOT_BLK_CNT ,The value defines the Stop At Block Gap value of automatic mode."
width 11.
group.long 0xc8++0x3
    line.long 0x00 "VEND_SPEC2,Vendor Specific 2 Register"
        bitfld.long 0x00 0. " SDR104_TIMING_DIS ,Timeout counter test." "0,1"
        textline "          "
        bitfld.long 0x00 1. " SDR104_OE_DIS ,CMD_OE/DAT_OE logic generation test." "0,1"
        textline "          "
        bitfld.long 0x00 2. " SDR104_NSD_DIS ,Interrupt window after abort command is sent." "0,1"
        textline "          "
        bitfld.long 0x00 3. " CARD_INT_D3_TEST ,Card interrupt detection test." "0,1"
        textline "          "
        bitfld.long 0x00 4. " TUNING_8BIT_EN ,Enable the auto tuning circuit to check the DAT[7:0]." "0,1"
        textline "          "
        bitfld.long 0x00 5. " TUNING_1BIT_EN ,Enable the auto tuning circuit to check the DAT0 only." "0,1"
        textline "          "
        bitfld.long 0x00 6. " TUNING_CMD_EN ,Enable the auto tuning circuit to check the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CARD_INT_AUTO_CLR_DIS ,Disable the feature to clear the Card interrupt status bit when Card Interrupt status enable bit is cleared." "0,1"


    tree.end
    tree "USDHC3"
        base ad:0x02198000

width 8.
group.long 0x0++0x3
    line.long 0x00 "DS_ADDR,DMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,DMA System Address: This register contains the 32-bit system memory address for a DMA transfer."
width 8.
group.long 0x4++0x3
    line.long 0x00 "BLK_ATT,Block Attributes"
        hexmask.long.word 0x00 0.--13. 1. " BLKSIZE ,Transfer Block Size: This register specifies the block size for block data transfers."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " BLKCNT ,Blocks Count For Current Transfer: This register is enabled when the Block Count Enable bit in the Transfer Mode register is set to 1 and is valid only for multiple block transfers."
width 8.
group.long 0x8++0x3
    line.long 0x00 "CMD_ARG,Command Argument"
        hexmask.long.long 0x00 0.--32. 1. " CMDARG ,Command Argument: The SD/MMC Command Argument is specified as bits 39-8 of the Command Format in the SD or MMC Specification.This register is write protected when the Command Inhibit (CMD) bit in the Present State register is set."
width 12.
group.long 0xc++0x3
    line.long 0x00 "CMD_XFR_TYP,Command Transfer Type"
        hexmask.long.byte 0x00 16.--18. 1. " RSPTYP ,Response Type Select:"
        textline "           "
        bitfld.long 0x00 19. " CCCEN ,Command CRC Check Enable: If this bit is set to 1, the uSDHC shall check the CRC field in the response." "0,1"
        textline "           "
        bitfld.long 0x00 20. " CICEN ,Command Index Check Enable: If this bit is set to 1, the uSDHC will check the Index field in the response to see if it has the same value as the command index." "0,1"
        textline "           "
        bitfld.long 0x00 21. " DPSEL ,Data Present Select: This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line." "0,1"
        textline "           "
        hexmask.long.byte 0x00 22.--24. 1. " CMDTYP ,Command Type: There are three types of special commands: Suspend, Resume and Abort."
        textline "           "
        hexmask.long.byte 0x00 24.--30. 1. " CMDINX ,Command Index: These bits shall be set to the command number that is specified in bits 45-40 of the Command-Format in the SD Memory Card Physical Layer Specification and SDIO Card Specification."
width 9.
rgroup.long 0x10++0x3
    line.long 0x00 "CMD_RSP0,Command Response0"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP0 ,Command Response 0: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x14++0x3
    line.long 0x00 "CMD_RSP1,Command Response1"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP1 ,Command Response 1: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x18++0x3
    line.long 0x00 "CMD_RSP2,Command Response2"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP2 ,Command Response 2: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x1c++0x3
    line.long 0x00 "CMD_RSP3,Command Response3"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP3 ,Command Response 3: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 19.
group.long 0x20++0x3
    line.long 0x00 "DATA_BUFF_ACC_PORT,Data Buffer Access Port"
        hexmask.long.long 0x00 0.--32. 1. " DATCONT ,Data Content: The Buffer Data Port register is for 32-bit data access by the ARM platform or the external DMA."
width 11.
rgroup.long 0x24++0x3
    line.long 0x00 "PRES_STATE,Present State"
        bitfld.long 0x00 0. " CIHB ,Command Inhibit (CMD): If this status bit is 0, it indicates that the CMD line is not in use and the uSDHC can issue a SD/MMC Command using the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 1. " CDIHB ,Command Inhibit (DAT): This status bit is generated if either the DAT Line Active or the Read Transfer Active is set to 1." "0,1"
        textline "          "
        bitfld.long 0x00 2. " DLA ,Data Line Active This status bit indicates whether one of the DAT lines on the SD Bus is in use." "0,1"
        textline "          "
        bitfld.long 0x00 3. " SDSTB ,SD Clock Stable This status bit indicates that the internal card clock is stable." "0,1"
        textline "          "
        bitfld.long 0x00 4. " IPGOFF ,ipg_clk Gated Off Internally: This status bit indicates that the ipg_clk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 5. " HCKOFF ,hclk Gated Off Internally: This status bit indicates that the hclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 6. " PEROFF ,ipg_perclk Gated Off Internally: This status bit indicates that the ipg_perclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SDOFF ,SD Clock Gated Off Internally: This status bit indicates that the SD Clock is internally gated off, because of buffer over/under-run or read pause without read wait assertion, or the driver set FRC_SDCLK_ON bit is 0 to stop the SD clock in idle status." "0,1"
        textline "          "
        bitfld.long 0x00 8. " WTA ,Write Transfer Active: This status bit indicates a write transfer is active." "0,1"
        textline "          "
        bitfld.long 0x00 9. " RTA ,Read Transfer Active: This status bit is used for detecting completion of a read transfer." "0,1"
        textline "          "
        bitfld.long 0x00 10. " BWEN ,Buffer Write Enable: This status bit is used for non-DMA write transfers." "0,1"
        textline "          "
        bitfld.long 0x00 11. " BREN ,Buffer Read Enable: This status bit is used for non-DMA read transfers." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTR ,Re-Tuning Request: (only for SD3.0 SDR104 mode) Host Controller may request Host Driver to execute re-tuning sequence by setting this bit when the data window is shifted by temperature drift and a tuned sampling point does not have a good margin to receive correct data." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CINST ,Card Inserted: This bit indicates whether a card has been inserted." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CDPL ,Card Detect Pin Level: This bit reflects the inverse value of the CD# pin for the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 19. " WPSPL ,Write Protect Switch Pin Level: The Write Protect Switch is supported for memory and combo cards.This bit reflects the inverted value of the WP pin of the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 23. " CLSL ,CMD Line Signal Level: This status is used to check the CMD line level to recover from errors, and for debugging." "0,1"
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " DLSL ,DAT[7:0] Line Signal Level: This status is used to check the DAT line level to recover from errors, and for debugging.This is especially useful in detecting the busy signal level from DAT[0]."
width 10.
group.long 0x28++0x3
    line.long 0x00 "PROT_CTRL,Protocol Control"
        bitfld.long 0x00 0. " LCTL ,LED Control: This bit, fully controlled by the Host Driver, is used to caution the user not to remove the card while the card is being accessed." "0,1"
        textline "         "
        hexmask.long.byte 0x00 1.--3. 1. " DTW ,Data Transfer Width: This bit selects the data width of the SD bus for a data transfer."
        textline "         "
        bitfld.long 0x00 3. " D3CD ,DAT3 as Card Detection Pin: If this bit is set, DAT3 should be pulled down to act as a card detection pin." "0,1"
        textline "         "
        hexmask.long.byte 0x00 4.--6. 1. " EMODE ,Endian Mode: The uSDHC supports all three endian modes in data transfer."
        textline "         "
        bitfld.long 0x00 6. " CDTL ,Card Detect Test Level: This is bit is enabled while the Card Detection Signal Selection is set to 1 and it indicates card insertion." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CDSS ,Card Detect Signal Selection: This bit selects the source for the card detection." "0,1"
        textline "         "
        hexmask.long.byte 0x00 8.--10. 1. " DMASEL ,DMA Select: This field is valid while DMA (SDMA or ADMA) is enabled and selects the DMA operation."
        textline "         "
        bitfld.long 0x00 16. " SABGREQ ,Stop At Block Gap Request: This bit is used to stop executing a transaction at the next block gap for both DMA and non-DMA transfers." "0,1"
        textline "         "
        bitfld.long 0x00 17. " CREQ ,Continue Request: This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request." "0,1"
        textline "         "
        bitfld.long 0x00 18. " RWCTL ,Read Wait Control: The read wait function is optional for SDIO cards." "0,1"
        textline "         "
        bitfld.long 0x00 19. " IABG ,Interrupt At Block Gap: This bit is valid only in 4-bit mode, of the SDIO card, and selects a sample point in the interrupt cycle." "0,1"
        textline "         "
        bitfld.long 0x00 20. " RD_DONE_NO_8CLK ,Read done no 8 clock: According to the SD/MMC spec, for read data transaction, 8 clocks are needed after the end bit of the last data block." "0,1"
        textline "         "
        bitfld.long 0x00 24. " WECINT ,Wakeup Event Enable On Card Interrupt: This bit enables a wakeup event, via a Card Interrupt, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 25. " WECINS ,Wakeup Event Enable On SD Card Insertion: This bit enables a wakeup event, via a Card Insertion, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 26. " WECRM ,Wakeup Event Enable On SD Card Removal: This bit enables a wakeup event, via a Card Removal, in the Interrupt Status register." "0,1"
        textline "         "
        hexmask.long.byte 0x00 27.--30. 1. " BURST_LEN_EN ,BURST length enable for INCR, INCR4/INCR8/INCR16, INCR4-WRAP/INCR8-WRAP/INCR16-WRAP This is used to enable/disable the burst length for the external AHB2AXI bridge."
        textline "         "
        bitfld.long 0x00 30. " NON_EXACT_BLK_RD ,Current block read is non-exact block read." "0,1"
width 9.
group.long 0x2c++0x3
    line.long 0x00 "SYS_CTRL,System Control"
        hexmask.long.byte 0x00 4.--8. 1. " DVS ,Divisor: This register is used to provide a more exact divisor to generate the desired SD clock frequency."
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " SDCLKFS ,SDCLK Frequency Select: This register is used to select the frequency of the SDCLK pin."
        textline "        "
        hexmask.long.byte 0x00 16.--20. 1. " DTOCV ,Data Timeout Counter Value: This value determines the interval by which DAT line timeouts are detected."
        textline "        "
        bitfld.long 0x00 23. " IPP_RST_N ,This register's value will be output to CARD from pad directly for hardware reset of the card if the card supports this feature." "0,1"
        textline "        "
        bitfld.long 0x00 24. " RSTA ,Software Reset For ALL: This reset effects the entire Host Controller except for the card detection circuit." "0,1"
        textline "        "
        bitfld.long 0x00 25. " RSTC ,Software Reset For CMD Line: Only part of the command circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 26. " RSTD ,Software Reset For DAT Line: Only part of the data circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 27. " INITA ,Initialization Active: When this bit is set, 80 SD-Clocks are sent to the card." "0,1"
width 11.
group.long 0x30++0x3
    line.long 0x00 "INT_STATUS,Interrupt Status"
        bitfld.long 0x00 0. " CC ,Command Complete: This bit is set when you receive the end bit of the command response (except Auto CMD12)." "0,1"
        textline "          "
        bitfld.long 0x00 1. " TC ,Transfer Complete: This bit is set when a read or write transfer is completed." "0,1"
        textline "          "
        bitfld.long 0x00 2. " BGE ,Block Gap Event: If the Stop At Block Gap Request bit in the Protocol Control register is set, this bit is set when a read or write transaction is stopped at a block gap." "0,1"
        textline "          "
        bitfld.long 0x00 3. " DINT ,DMA Interrupt: Occurs only when the internal DMA finishes the data transfer successfully." "0,1"
        textline "          "
        bitfld.long 0x00 4. " BWR ,Buffer Write Ready: This status bit is set if the Buffer Write Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 5. " BRR ,Buffer Read Ready: This status bit is set if the Buffer Read Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 6. " CINS ,Card Insertion: This status bit is set if the Card Inserted bit in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CRM ,Card Removal: This status bit is set if the Card Inserted bit in the Present State register changes from 1 to 0." "0,1"
        textline "          "
        bitfld.long 0x00 8. " CINT ,Card Interrupt: This status bit is set when an interrupt signal is detected from the external card." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTE ,Re-Tuning Event: (only for SD3.0 SDR104 mode) This status is set if Re-Tuning Request in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 14. " TP ,Tuning Pass:(only for SD3.0 SDR104 mode) Current CMD19 transfer is done successfully." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CTOE ,Command Timeout Error: Occurs only if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "          "
        bitfld.long 0x00 17. " CCE ,Command CRC Error: Command CRC Error is generated in two cases." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CEBE ,Command End Bit Error: Occurs when detecting that the end bit of a command response is 0." "0,1"
        textline "          "
        bitfld.long 0x00 19. " CIE ,Command Index Error: Occurs if a Command Index error occurs in the command response." "0,1"
        textline "          "
        bitfld.long 0x00 20. " DTOE ,Data Timeout Error: Occurs when detecting one of following time-out conditions." "0,1"
        textline "          "
        bitfld.long 0x00 21. " DCE ,Data CRC Error: Occurs when detecting a CRC error when transferring read data, which uses the DAT line, or when detecting the Write CRC status having a value other than 010." "0,1"
        textline "          "
        bitfld.long 0x00 22. " DEBE ,Data End Bit Error: Occurs either when detecting 0 at the end bit position of read data, which uses the DAT line, or at the end bit position of the CRC." "0,1"
        textline "          "
        bitfld.long 0x00 24. " AC12E ,Auto CMD12 Error: Occurs when detecting that one of the bits in the Auto CMD12 Error Status register has changed from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 26. " TNE ,Tuning Error: (only for SD3.0 SDR104 mode) This bit is set when an unrecoverable error is detected in a tuning circuit." "0,1"
        textline "          "
        bitfld.long 0x00 28. " DMAE ,DMA Error: Occurs when an Internal DMA transfer has failed." "0,1"
width 14.
group.long 0x34++0x3
    line.long 0x00 "INT_STATUS_EN,Interrupt Status Enable"
        bitfld.long 0x00 0. " CCSEN ,Command Complete Status Enable: 1 Enabled 0 Masked" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCSEN ,Transfer Complete Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGESEN ,Block Gap Event Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTSEN ,DMA Interrupt Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRSEN ,Buffer Write Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRSEN ,Buffer Read Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSSEN ,Card Insertion Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMSEN ,Card Removal Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTSEN ,Card Interrupt Status Enable: If this bit is set to 0, the uSDHC will clear the interrupt request to the System." "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTESEN ,Re-Tuning Event Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPSEN ,Tuning Pass Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOESEN ,Command Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCESEN ,Command CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBESEN ,Command End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIESEN ,Command Index Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOESEN ,Data Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCESEN ,Data CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBESEN ,Data End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12ESEN ,Auto CMD12 Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNESEN ,Tuning Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAESEN ,DMA Error Status Enable:" "0,1"
width 14.
group.long 0x38++0x3
    line.long 0x00 "INT_SIGNAL_EN,Interrupt Signal Enable"
        bitfld.long 0x00 0. " CCIEN ,Command Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCIEN ,Transfer Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGEIEN ,Block Gap Event Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTIEN ,DMA Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRIEN ,Buffer Write Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRIEN ,Buffer Read Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSIEN ,Card Insertion Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMIEN ,Card Removal Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTIEN ,Card Interrupt Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTEIEN ,Re-Tuning Event Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPIEN ,Tuning Pass Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOEIEN ,Command Timeout Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCEIEN ,Command CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBEIEN ,Command End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIEIEN ,Command Index Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOEIEN ,Data Timeout Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCEIEN ,Data CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBEIEN ,Data End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12EIEN ,Auto CMD12 Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNEIEN ,Tuning Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAEIEN ,DMA Error Interrupt Enable:" "0,1"
width 21.
rgroup.long 0x3c++0x3
    line.long 0x00 "AUTOCMD12_ERR_STATUS,Auto CMD12 Error Status"
        bitfld.long 0x00 0. " AC12NE ,Auto CMD12 Not Executed: If memory multiple block data transfer is not started, due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12." "0,1"
        textline "                    "
        bitfld.long 0x00 1. " AC12TOE ,Auto CMD12 Timeout Error: Occurs if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "                    "
        bitfld.long 0x00 2. " AC12EBE ,Auto CMD12 End Bit Error: Occurs when detecting that the end bit of command response is 0 which should be 1." "0,1"
        textline "                    "
        bitfld.long 0x00 3. " AC12CE ,Auto CMD12 CRC Error: Occurs when detecting a CRC error in the command response." "0,1"
        textline "                    "
        bitfld.long 0x00 4. " AC12IE ,Auto CMD12 Index Error: Occurs if the Command Index error occurs in response to a command." "0,1"
        textline "                    "
        bitfld.long 0x00 7. " CNIBAC12E ,Command Not Issued By Auto CMD12 Error: Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this register." "0,1"
width 14.
rgroup.long 0x40++0x3
    line.long 0x00 "HOST_CTRL_CAP,Host Controller Capabilities"
        hexmask.long.byte 0x00 16.--19. 1. " MBL ,Max Block Length: This value indicates the maximum block size that the Host Driver can read and write to the buffer in the uSDHC."
        textline "             "
        bitfld.long 0x00 20. " ADMAS ,ADMA Support: This bit indicates whether the uSDHC supports the ADMA feature." "0,1"
        textline "             "
        bitfld.long 0x00 21. " HSS ,High Speed Support: This bit indicates whether the uSDHC supports High Speed mode and the Host System can supply a SD Clock frequency from 25 MHz to 50 MHz." "0,1"
        textline "             "
        bitfld.long 0x00 22. " DMAS ,DMA Support: This bit indicates whether the uSDHC is capable of using the internal DMA to transfer data between system memory and the data buffer directly." "0,1"
        textline "             "
        bitfld.long 0x00 23. " SRS ,Suspend / Resume Support: This bit indicates whether the uSDHC supports Suspend / Resume functionality." "0,1"
        textline "             "
        bitfld.long 0x00 24. " VS33 ,Voltage Support 3.3V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 25. " VS30 ,Voltage Support 3.0V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 26. " VS18 ,Voltage Support 1.8V: This bit shall depend on the Host System ability." "0,1"
width 9.
group.long 0x44++0x3
    line.long 0x00 "WTMK_LVL,Watermark Level"
        hexmask.long.byte 0x00 0.--8. 1. " RD_WML ,Read Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA read operation."
        textline "        "
        hexmask.long.byte 0x00 8.--13. 1. " RD_BRST_LEN ,Read Burst Length: Due to system restriction, the actual burst length may not exceed 16."
        textline "        "
        hexmask.long.byte 0x00 16.--24. 1. " WR_WML ,Write Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA write operation."
        textline "        "
        hexmask.long.byte 0x00 24.--29. 1. " WR_BRST_LEN ,Write Burst Length: Due to system restriction, the actual burst length may not exceed 16."
width 9.
group.long 0x48++0x3
    line.long 0x00 "MIX_CTRL,Mixer Control"
        bitfld.long 0x00 0. " DMAEN ,DMA Enable: This bit enables DMA functionality." "0,1"
        textline "        "
        bitfld.long 0x00 1. " BCEN ,Block Count Enable: This bit is used to enable the Block Count register, which is only relevant for multiple block transfers." "0,1"
        textline "        "
        bitfld.long 0x00 2. " AC12EN ,Auto CMD12 Enable: Multiple block transfers for memory require a CMD12 to stop the transaction." "0,1"
        textline "        "
        bitfld.long 0x00 3. " DDR_EN ,Dual Data Rate mode selection" "0,1"
        textline "        "
        bitfld.long 0x00 4. " DTDSEL ,Data Transfer Direction Select: This bit defines the direction of DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 5. " MSBSEL ,Multi / Single Block Select: This bit enables multiple block DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 6. " NIBBLE_POS ,In DDR 4-bit mode nibble position indictation." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AC23EN ,Auto CMD23 Enable When this bit is set to 1, the Host Controller issues a CMD23 automatically before issuing a command specified in the Command Register." "0,1"
        textline "        "
        bitfld.long 0x00 22. " EXE_TUNE ,Execute Tuning: (Only used for SD3.0, SDR104 mode) This bit is set to 1 to indicate the Host Driver is starting tuning procedure." "0,1"
        textline "        "
        bitfld.long 0x00 23. " SMP_CLK_SEL ,Tuned clock or Fixed clock is used to sample data/cmd (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 24. " AUTO_TUNE_EN ,Auto tuning enable (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 25. " FBCLK_SEL ,Feedback clock source selection (Only used for SD3.0, SDR104 mode)" "0,1"
width 12.
wgroup.long 0x50++0x3
    line.long 0x00 "FORCE_EVENT,Force Event"
        bitfld.long 0x00 0. " FEVTAC12NE ,Force Event Auto Command 12 Not Executed: Forces the AC12NE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 1. " FEVTAC12TOE ,Force Event Auto Command 12 Time Out Error: Forces the AC12TOE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 2. " FEVTAC12CE ,Force Event Auto Command 12 CRC Error: Forces the AC12CE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 3. " FEVTAC12EBE ,Force Event Auto Command 12 End Bit Error: Forces the AC12EBE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 4. " FEVTAC12IE ,Force Event Auto Command 12 Index Error: Forces the AC12IE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 7. " FEVTCNIBAC12E ,Force Event Command Not Executed By Auto Command 12 Error: Forces the CNIBAC12E bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 16. " FEVTCTOE ,Force Event Command Time Out Error: Forces the CTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 17. " FEVTCCE ,Force Event Command CRC Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 18. " FEVTCEBE ,Force Event Command End Bit Error: Forces the CEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 19. " FEVTCIE ,Force Event Command Index Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 20. " FEVTDTOE ,Force Event Data Time Out Error: Force the DTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 21. " FEVTDCE ,Force Event Data CRC Error: Forces the DCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 22. " FEVTDEBE ,Force Event Data End Bit Error: Forces the DEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 24. " FEVTAC12E ,Force Event Auto Command 12 Error: Forces the AC12E bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 26. " FEVTTNE ,Force Tuning Error: Forces the TNE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 28. " FEVTDMAE ,Force Event DMA Error: Forces the DMAE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 31. " FEVTCINT ,Force Event Card Interrupt: Writing 1 to this bit generates a short low-level pulse on the internal DAT[1] line, as if a self clearing interrupt was received from the external card." "0,1"
width 16.
rgroup.long 0x54++0x3
    line.long 0x00 "ADMA_ERR_STATUS,ADMA Error Status Register"
        hexmask.long.byte 0x00 0.--2. 1. " ADMAES ,ADMA Error State (when ADMA Error is occurred.): This field indicates the state of the ADMA when an error has occurred during an ADMA data transfer."
        textline "               "
        bitfld.long 0x00 2. " ADMALME ,ADMA Length Mismatch Error: This error occurs in the following 2 cases: While the Block Count Enable is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length Total data length can not be divided by the block length" "0,1"
        textline "               "
        bitfld.long 0x00 3. " ADMADCE ,ADMA Descritor Error: This error occurs when invalid descriptor fetched by ADMA:" "0,1"
width 14.
group.long 0x58++0x3
    line.long 0x00 "ADMA_SYS_ADDR,ADMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " ADS_ADDR ,ADMA System Address: This register holds the word address of the executing command in the Descriptor table."
width 9.
group.long 0x60++0x3
    line.long 0x00 "DLL_CTRL,DLL (Delay Line) Control"
        bitfld.long 0x00 0. " DLL_CTRL_ENABLE ,Set this bit to 1 to enable the DLL and delay chain; otherwise; set to 0 to bypasses DLL." "0,1"
        textline "        "
        bitfld.long 0x00 1. " DLL_CTRL_RESET ,Setting this bit to 1 force a reset on DLL." "0,1"
        textline "        "
        bitfld.long 0x00 2. " DLL_CTRL_SLV_FORCE_UPD ,Setting this bit to 1, forces the slave delay line to update to the DLL calibrated value immediately." "0,1"
        textline "        "
        hexmask.long.byte 0x00 3.--7. 1. " DLL_CTRL_SLV_DLY_TARGET0 ,The delay target for the uSDHC loopback read clock can be programmed in 1/16th increments of an ref_clock half-period."
        textline "        "
        bitfld.long 0x00 7. " DLL_CTRL_GATE_UPDATE ,Set this bit to 1 to prevent the DLL from updating (since when clock_in exists, glitches may appear during DLL updates)." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DLL_CTRL_SLV_OVERRIDE ,Set this bit to 1 to Enable manual override for slave delay chain using SLV_OVERRIDE_VAL; to set 0 to disable manual override." "0,1"
        textline "        "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_CTRL_SLV_OVERRIDE_VAL ,When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical taps manually."
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " DLL_CTRL_SLV_DLY_TARGET1 ,Refer to DLL_CTRL_SLV_DLY_TARGET0 below."
        textline "        "
        hexmask.long.byte 0x00 20.--28. 1. " DLL_CTRL_SLV_UPDATE_INT ,Slave delay line update interval."
        textline "        "
        hexmask.long.byte 0x00 28.--32. 1. " DLL_CTRL_REF_UPDATE_INT ,DLL control loop update interval."
width 11.
rgroup.long 0x64++0x3
    line.long 0x00 "DLL_STATUS,DLL Status"
        bitfld.long 0x00 0. " DLL_STS_SLV_LOCK ,Slave delay-line lock status." "0,1"
        textline "          "
        bitfld.long 0x00 1. " DLL_STS_REF_LOCK ,Reference DLL lock status." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--9. 1. " DLL_STS_SLV_SEL ,Slave delay line select status."
        textline "          "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_STS_REF_SEL ,Reference delay line select taps."
width 21.
group.long 0x68++0x3
    line.long 0x00 "CLK_TUNE_CTRL_STATUS,CLK Tuning Control and Status"
        hexmask.long.byte 0x00 0.--4. 1. " DLY_CELL_SET_POST ,Set the number of delay cells on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 4.--8. 1. " DLY_CELL_SET_OUT ,Set the number of delay cells on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 8.--15. 1. " DLY_CELL_SET_PRE ,Set the number of delay cells on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 15. " NXT_ERR ,NXT error which means the number of delay cells added on the feedback clock is too large." "0,1"
        textline "                    "
        hexmask.long.byte 0x00 16.--20. 1. " TAP_SEL_POST ,Reflect the number of delay cells added on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 20.--24. 1. " TAP_SEL_OUT ,Reflect the number of delay cells added on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 24.--31. 1. " TAP_SEL_PRE ,Reflects the number of delay cells added on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 31. " PRE_ERR ,PRE error which means the number of delay cells added on the feedback clock is too small." "0,1"
width 10.
group.long 0xc0++0x3
    line.long 0x00 "VEND_SPEC,Vendor Specific Register"
        bitfld.long 0x00 0. " EXT_DMA_EN ,External DMA Request Enable Enable the request to external DMA." "0,1"
        textline "         "
        bitfld.long 0x00 1. " VSELECT ,Voltage Selection Change the value of output signal VSELECT, to control the voltage on pads for external card." "0,1"
        textline "         "
        bitfld.long 0x00 2. " CONFLICT_CHK_EN ,It's not implemented in uSDHC IP." "0,1"
        textline "         "
        bitfld.long 0x00 3. " AC12_WR_CHKBUSY_EN ,Check busy enable after auto CMD12 for write data packet" "0,1"
        textline "         "
        bitfld.long 0x00 4. " DAT3_CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 5. " CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 6. " WP_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CLKONJ_IN_ABORT ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 8. " FRC_SDCLK_ON ,Force CLK output active:" "0,1"
        textline "         "
        bitfld.long 0x00 11. " IPG_CLK_SOFT_EN ,IPG_CLK software enable" "0,1"
        textline "         "
        bitfld.long 0x00 12. " HCLK_SOFT_EN ,Please note, hardware auto-enables the AHB clock when the internal DMA is enabled even if HCLK_SOFT_EN is 0." "0,1"
        textline "         "
        bitfld.long 0x00 13. " IPG_PERCLK_SOFT_EN ,ipg_perclk software enable" "0,1"
        textline "         "
        bitfld.long 0x00 14. " CARD_CLK_SOFT_EN ,card clock software enable" "0,1"
        textline "         "
        bitfld.long 0x00 15. " CRC_CHK_DIS ,CRC check disable" "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " INT_ST_VAL ,Internal State Value Internal state value, reflecting the corresponding state value selected by Debug Select field."
width 9.
group.long 0xc4++0x3
    line.long 0x00 "MMC_BOOT,MMC Boot Register"
        hexmask.long.byte 0x00 0.--4. 1. " DTOCV_ACK ,Boot ACK time out counter value."
        textline "        "
        bitfld.long 0x00 4. " BOOT_ACK ,Boot ack mode select." "0,1"
        textline "        "
        bitfld.long 0x00 5. " BOOT_MODE ,Boot mode select." "0,1"
        textline "        "
        bitfld.long 0x00 6. " BOOT_EN ,Boot mode enable." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AUTO_SABG_EN ,During boot, enable auto stop at block gap function." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DISABLE_TIME_OUT ,Please note, when this bit is set, there is no timeout check no matter whether boot_en is set or not." "0,1"
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " BOOT_BLK_CNT ,The value defines the Stop At Block Gap value of automatic mode."
width 11.
group.long 0xc8++0x3
    line.long 0x00 "VEND_SPEC2,Vendor Specific 2 Register"
        bitfld.long 0x00 0. " SDR104_TIMING_DIS ,Timeout counter test." "0,1"
        textline "          "
        bitfld.long 0x00 1. " SDR104_OE_DIS ,CMD_OE/DAT_OE logic generation test." "0,1"
        textline "          "
        bitfld.long 0x00 2. " SDR104_NSD_DIS ,Interrupt window after abort command is sent." "0,1"
        textline "          "
        bitfld.long 0x00 3. " CARD_INT_D3_TEST ,Card interrupt detection test." "0,1"
        textline "          "
        bitfld.long 0x00 4. " TUNING_8BIT_EN ,Enable the auto tuning circuit to check the DAT[7:0]." "0,1"
        textline "          "
        bitfld.long 0x00 5. " TUNING_1BIT_EN ,Enable the auto tuning circuit to check the DAT0 only." "0,1"
        textline "          "
        bitfld.long 0x00 6. " TUNING_CMD_EN ,Enable the auto tuning circuit to check the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CARD_INT_AUTO_CLR_DIS ,Disable the feature to clear the Card interrupt status bit when Card Interrupt status enable bit is cleared." "0,1"


    tree.end
    tree "USDHC4"
        base ad:0x0219c000

width 8.
group.long 0x0++0x3
    line.long 0x00 "DS_ADDR,DMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " DS_ADDR ,DMA System Address: This register contains the 32-bit system memory address for a DMA transfer."
width 8.
group.long 0x4++0x3
    line.long 0x00 "BLK_ATT,Block Attributes"
        hexmask.long.word 0x00 0.--13. 1. " BLKSIZE ,Transfer Block Size: This register specifies the block size for block data transfers."
        textline "       "
        hexmask.long.word 0x00 16.--32. 1. " BLKCNT ,Blocks Count For Current Transfer: This register is enabled when the Block Count Enable bit in the Transfer Mode register is set to 1 and is valid only for multiple block transfers."
width 8.
group.long 0x8++0x3
    line.long 0x00 "CMD_ARG,Command Argument"
        hexmask.long.long 0x00 0.--32. 1. " CMDARG ,Command Argument: The SD/MMC Command Argument is specified as bits 39-8 of the Command Format in the SD or MMC Specification.This register is write protected when the Command Inhibit (CMD) bit in the Present State register is set."
width 12.
group.long 0xc++0x3
    line.long 0x00 "CMD_XFR_TYP,Command Transfer Type"
        hexmask.long.byte 0x00 16.--18. 1. " RSPTYP ,Response Type Select:"
        textline "           "
        bitfld.long 0x00 19. " CCCEN ,Command CRC Check Enable: If this bit is set to 1, the uSDHC shall check the CRC field in the response." "0,1"
        textline "           "
        bitfld.long 0x00 20. " CICEN ,Command Index Check Enable: If this bit is set to 1, the uSDHC will check the Index field in the response to see if it has the same value as the command index." "0,1"
        textline "           "
        bitfld.long 0x00 21. " DPSEL ,Data Present Select: This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line." "0,1"
        textline "           "
        hexmask.long.byte 0x00 22.--24. 1. " CMDTYP ,Command Type: There are three types of special commands: Suspend, Resume and Abort."
        textline "           "
        hexmask.long.byte 0x00 24.--30. 1. " CMDINX ,Command Index: These bits shall be set to the command number that is specified in bits 45-40 of the Command-Format in the SD Memory Card Physical Layer Specification and SDIO Card Specification."
width 9.
rgroup.long 0x10++0x3
    line.long 0x00 "CMD_RSP0,Command Response0"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP0 ,Command Response 0: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x14++0x3
    line.long 0x00 "CMD_RSP1,Command Response1"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP1 ,Command Response 1: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x18++0x3
    line.long 0x00 "CMD_RSP2,Command Response2"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP2 ,Command Response 2: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 9.
rgroup.long 0x1c++0x3
    line.long 0x00 "CMD_RSP3,Command Response3"
        hexmask.long.long 0x00 0.--32. 1. " CMDRSP3 ,Command Response 3: Refer to for the mapping of command responses from the SD Bus to this register for each response type."
width 19.
group.long 0x20++0x3
    line.long 0x00 "DATA_BUFF_ACC_PORT,Data Buffer Access Port"
        hexmask.long.long 0x00 0.--32. 1. " DATCONT ,Data Content: The Buffer Data Port register is for 32-bit data access by the ARM platform or the external DMA."
width 11.
rgroup.long 0x24++0x3
    line.long 0x00 "PRES_STATE,Present State"
        bitfld.long 0x00 0. " CIHB ,Command Inhibit (CMD): If this status bit is 0, it indicates that the CMD line is not in use and the uSDHC can issue a SD/MMC Command using the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 1. " CDIHB ,Command Inhibit (DAT): This status bit is generated if either the DAT Line Active or the Read Transfer Active is set to 1." "0,1"
        textline "          "
        bitfld.long 0x00 2. " DLA ,Data Line Active This status bit indicates whether one of the DAT lines on the SD Bus is in use." "0,1"
        textline "          "
        bitfld.long 0x00 3. " SDSTB ,SD Clock Stable This status bit indicates that the internal card clock is stable." "0,1"
        textline "          "
        bitfld.long 0x00 4. " IPGOFF ,ipg_clk Gated Off Internally: This status bit indicates that the ipg_clk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 5. " HCKOFF ,hclk Gated Off Internally: This status bit indicates that the hclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 6. " PEROFF ,ipg_perclk Gated Off Internally: This status bit indicates that the ipg_perclk is internally gated off." "0,1"
        textline "          "
        bitfld.long 0x00 7. " SDOFF ,SD Clock Gated Off Internally: This status bit indicates that the SD Clock is internally gated off, because of buffer over/under-run or read pause without read wait assertion, or the driver set FRC_SDCLK_ON bit is 0 to stop the SD clock in idle status." "0,1"
        textline "          "
        bitfld.long 0x00 8. " WTA ,Write Transfer Active: This status bit indicates a write transfer is active." "0,1"
        textline "          "
        bitfld.long 0x00 9. " RTA ,Read Transfer Active: This status bit is used for detecting completion of a read transfer." "0,1"
        textline "          "
        bitfld.long 0x00 10. " BWEN ,Buffer Write Enable: This status bit is used for non-DMA write transfers." "0,1"
        textline "          "
        bitfld.long 0x00 11. " BREN ,Buffer Read Enable: This status bit is used for non-DMA read transfers." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTR ,Re-Tuning Request: (only for SD3.0 SDR104 mode) Host Controller may request Host Driver to execute re-tuning sequence by setting this bit when the data window is shifted by temperature drift and a tuned sampling point does not have a good margin to receive correct data." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CINST ,Card Inserted: This bit indicates whether a card has been inserted." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CDPL ,Card Detect Pin Level: This bit reflects the inverse value of the CD# pin for the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 19. " WPSPL ,Write Protect Switch Pin Level: The Write Protect Switch is supported for memory and combo cards.This bit reflects the inverted value of the WP pin of the card socket." "0,1"
        textline "          "
        bitfld.long 0x00 23. " CLSL ,CMD Line Signal Level: This status is used to check the CMD line level to recover from errors, and for debugging." "0,1"
        textline "          "
        hexmask.long.byte 0x00 24.--32. 1. " DLSL ,DAT[7:0] Line Signal Level: This status is used to check the DAT line level to recover from errors, and for debugging.This is especially useful in detecting the busy signal level from DAT[0]."
width 10.
group.long 0x28++0x3
    line.long 0x00 "PROT_CTRL,Protocol Control"
        bitfld.long 0x00 0. " LCTL ,LED Control: This bit, fully controlled by the Host Driver, is used to caution the user not to remove the card while the card is being accessed." "0,1"
        textline "         "
        hexmask.long.byte 0x00 1.--3. 1. " DTW ,Data Transfer Width: This bit selects the data width of the SD bus for a data transfer."
        textline "         "
        bitfld.long 0x00 3. " D3CD ,DAT3 as Card Detection Pin: If this bit is set, DAT3 should be pulled down to act as a card detection pin." "0,1"
        textline "         "
        hexmask.long.byte 0x00 4.--6. 1. " EMODE ,Endian Mode: The uSDHC supports all three endian modes in data transfer."
        textline "         "
        bitfld.long 0x00 6. " CDTL ,Card Detect Test Level: This is bit is enabled while the Card Detection Signal Selection is set to 1 and it indicates card insertion." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CDSS ,Card Detect Signal Selection: This bit selects the source for the card detection." "0,1"
        textline "         "
        hexmask.long.byte 0x00 8.--10. 1. " DMASEL ,DMA Select: This field is valid while DMA (SDMA or ADMA) is enabled and selects the DMA operation."
        textline "         "
        bitfld.long 0x00 16. " SABGREQ ,Stop At Block Gap Request: This bit is used to stop executing a transaction at the next block gap for both DMA and non-DMA transfers." "0,1"
        textline "         "
        bitfld.long 0x00 17. " CREQ ,Continue Request: This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request." "0,1"
        textline "         "
        bitfld.long 0x00 18. " RWCTL ,Read Wait Control: The read wait function is optional for SDIO cards." "0,1"
        textline "         "
        bitfld.long 0x00 19. " IABG ,Interrupt At Block Gap: This bit is valid only in 4-bit mode, of the SDIO card, and selects a sample point in the interrupt cycle." "0,1"
        textline "         "
        bitfld.long 0x00 20. " RD_DONE_NO_8CLK ,Read done no 8 clock: According to the SD/MMC spec, for read data transaction, 8 clocks are needed after the end bit of the last data block." "0,1"
        textline "         "
        bitfld.long 0x00 24. " WECINT ,Wakeup Event Enable On Card Interrupt: This bit enables a wakeup event, via a Card Interrupt, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 25. " WECINS ,Wakeup Event Enable On SD Card Insertion: This bit enables a wakeup event, via a Card Insertion, in the Interrupt Status register." "0,1"
        textline "         "
        bitfld.long 0x00 26. " WECRM ,Wakeup Event Enable On SD Card Removal: This bit enables a wakeup event, via a Card Removal, in the Interrupt Status register." "0,1"
        textline "         "
        hexmask.long.byte 0x00 27.--30. 1. " BURST_LEN_EN ,BURST length enable for INCR, INCR4/INCR8/INCR16, INCR4-WRAP/INCR8-WRAP/INCR16-WRAP This is used to enable/disable the burst length for the external AHB2AXI bridge."
        textline "         "
        bitfld.long 0x00 30. " NON_EXACT_BLK_RD ,Current block read is non-exact block read." "0,1"
width 9.
group.long 0x2c++0x3
    line.long 0x00 "SYS_CTRL,System Control"
        hexmask.long.byte 0x00 4.--8. 1. " DVS ,Divisor: This register is used to provide a more exact divisor to generate the desired SD clock frequency."
        textline "        "
        hexmask.long.byte 0x00 8.--16. 1. " SDCLKFS ,SDCLK Frequency Select: This register is used to select the frequency of the SDCLK pin."
        textline "        "
        hexmask.long.byte 0x00 16.--20. 1. " DTOCV ,Data Timeout Counter Value: This value determines the interval by which DAT line timeouts are detected."
        textline "        "
        bitfld.long 0x00 23. " IPP_RST_N ,This register's value will be output to CARD from pad directly for hardware reset of the card if the card supports this feature." "0,1"
        textline "        "
        bitfld.long 0x00 24. " RSTA ,Software Reset For ALL: This reset effects the entire Host Controller except for the card detection circuit." "0,1"
        textline "        "
        bitfld.long 0x00 25. " RSTC ,Software Reset For CMD Line: Only part of the command circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 26. " RSTD ,Software Reset For DAT Line: Only part of the data circuit is reset." "0,1"
        textline "        "
        bitfld.long 0x00 27. " INITA ,Initialization Active: When this bit is set, 80 SD-Clocks are sent to the card." "0,1"
width 11.
group.long 0x30++0x3
    line.long 0x00 "INT_STATUS,Interrupt Status"
        bitfld.long 0x00 0. " CC ,Command Complete: This bit is set when you receive the end bit of the command response (except Auto CMD12)." "0,1"
        textline "          "
        bitfld.long 0x00 1. " TC ,Transfer Complete: This bit is set when a read or write transfer is completed." "0,1"
        textline "          "
        bitfld.long 0x00 2. " BGE ,Block Gap Event: If the Stop At Block Gap Request bit in the Protocol Control register is set, this bit is set when a read or write transaction is stopped at a block gap." "0,1"
        textline "          "
        bitfld.long 0x00 3. " DINT ,DMA Interrupt: Occurs only when the internal DMA finishes the data transfer successfully." "0,1"
        textline "          "
        bitfld.long 0x00 4. " BWR ,Buffer Write Ready: This status bit is set if the Buffer Write Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 5. " BRR ,Buffer Read Ready: This status bit is set if the Buffer Read Enable bit, in the Present State register, changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 6. " CINS ,Card Insertion: This status bit is set if the Card Inserted bit in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CRM ,Card Removal: This status bit is set if the Card Inserted bit in the Present State register changes from 1 to 0." "0,1"
        textline "          "
        bitfld.long 0x00 8. " CINT ,Card Interrupt: This status bit is set when an interrupt signal is detected from the external card." "0,1"
        textline "          "
        bitfld.long 0x00 12. " RTE ,Re-Tuning Event: (only for SD3.0 SDR104 mode) This status is set if Re-Tuning Request in the Present State register changes from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 14. " TP ,Tuning Pass:(only for SD3.0 SDR104 mode) Current CMD19 transfer is done successfully." "0,1"
        textline "          "
        bitfld.long 0x00 16. " CTOE ,Command Timeout Error: Occurs only if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "          "
        bitfld.long 0x00 17. " CCE ,Command CRC Error: Command CRC Error is generated in two cases." "0,1"
        textline "          "
        bitfld.long 0x00 18. " CEBE ,Command End Bit Error: Occurs when detecting that the end bit of a command response is 0." "0,1"
        textline "          "
        bitfld.long 0x00 19. " CIE ,Command Index Error: Occurs if a Command Index error occurs in the command response." "0,1"
        textline "          "
        bitfld.long 0x00 20. " DTOE ,Data Timeout Error: Occurs when detecting one of following time-out conditions." "0,1"
        textline "          "
        bitfld.long 0x00 21. " DCE ,Data CRC Error: Occurs when detecting a CRC error when transferring read data, which uses the DAT line, or when detecting the Write CRC status having a value other than 010." "0,1"
        textline "          "
        bitfld.long 0x00 22. " DEBE ,Data End Bit Error: Occurs either when detecting 0 at the end bit position of read data, which uses the DAT line, or at the end bit position of the CRC." "0,1"
        textline "          "
        bitfld.long 0x00 24. " AC12E ,Auto CMD12 Error: Occurs when detecting that one of the bits in the Auto CMD12 Error Status register has changed from 0 to 1." "0,1"
        textline "          "
        bitfld.long 0x00 26. " TNE ,Tuning Error: (only for SD3.0 SDR104 mode) This bit is set when an unrecoverable error is detected in a tuning circuit." "0,1"
        textline "          "
        bitfld.long 0x00 28. " DMAE ,DMA Error: Occurs when an Internal DMA transfer has failed." "0,1"
width 14.
group.long 0x34++0x3
    line.long 0x00 "INT_STATUS_EN,Interrupt Status Enable"
        bitfld.long 0x00 0. " CCSEN ,Command Complete Status Enable: 1 Enabled 0 Masked" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCSEN ,Transfer Complete Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGESEN ,Block Gap Event Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTSEN ,DMA Interrupt Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRSEN ,Buffer Write Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRSEN ,Buffer Read Ready Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSSEN ,Card Insertion Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMSEN ,Card Removal Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTSEN ,Card Interrupt Status Enable: If this bit is set to 0, the uSDHC will clear the interrupt request to the System." "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTESEN ,Re-Tuning Event Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPSEN ,Tuning Pass Status Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOESEN ,Command Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCESEN ,Command CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBESEN ,Command End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIESEN ,Command Index Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOESEN ,Data Timeout Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCESEN ,Data CRC Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBESEN ,Data End Bit Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12ESEN ,Auto CMD12 Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNESEN ,Tuning Error Status Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAESEN ,DMA Error Status Enable:" "0,1"
width 14.
group.long 0x38++0x3
    line.long 0x00 "INT_SIGNAL_EN,Interrupt Signal Enable"
        bitfld.long 0x00 0. " CCIEN ,Command Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 1. " TCIEN ,Transfer Complete Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 2. " BGEIEN ,Block Gap Event Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 3. " DINTIEN ,DMA Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 4. " BWRIEN ,Buffer Write Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 5. " BRRIEN ,Buffer Read Ready Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 6. " CINSIEN ,Card Insertion Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 7. " CRMIEN ,Card Removal Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 8. " CINTIEN ,Card Interrupt Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 12. " RTEIEN ,Re-Tuning Event Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 14. " TPIEN ,Tuning Pass Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 16. " CTOEIEN ,Command Timeout Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 17. " CCEIEN ,Command CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 18. " CEBEIEN ,Command End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 19. " CIEIEN ,Command Index Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 20. " DTOEIEN ,Data Timeout Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 21. " DCEIEN ,Data CRC Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 22. " DEBEIEN ,Data End Bit Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 24. " AC12EIEN ,Auto CMD12 Error Interrupt Enable:" "0,1"
        textline "             "
        bitfld.long 0x00 26. " TNEIEN ,Tuning Error Interrupt Enable" "0,1"
        textline "             "
        bitfld.long 0x00 28. " DMAEIEN ,DMA Error Interrupt Enable:" "0,1"
width 21.
rgroup.long 0x3c++0x3
    line.long 0x00 "AUTOCMD12_ERR_STATUS,Auto CMD12 Error Status"
        bitfld.long 0x00 0. " AC12NE ,Auto CMD12 Not Executed: If memory multiple block data transfer is not started, due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12." "0,1"
        textline "                    "
        bitfld.long 0x00 1. " AC12TOE ,Auto CMD12 Timeout Error: Occurs if no response is returned within 64 SDCLK cycles from the end bit of the command." "0,1"
        textline "                    "
        bitfld.long 0x00 2. " AC12EBE ,Auto CMD12 End Bit Error: Occurs when detecting that the end bit of command response is 0 which should be 1." "0,1"
        textline "                    "
        bitfld.long 0x00 3. " AC12CE ,Auto CMD12 CRC Error: Occurs when detecting a CRC error in the command response." "0,1"
        textline "                    "
        bitfld.long 0x00 4. " AC12IE ,Auto CMD12 Index Error: Occurs if the Command Index error occurs in response to a command." "0,1"
        textline "                    "
        bitfld.long 0x00 7. " CNIBAC12E ,Command Not Issued By Auto CMD12 Error: Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this register." "0,1"
width 14.
rgroup.long 0x40++0x3
    line.long 0x00 "HOST_CTRL_CAP,Host Controller Capabilities"
        hexmask.long.byte 0x00 16.--19. 1. " MBL ,Max Block Length: This value indicates the maximum block size that the Host Driver can read and write to the buffer in the uSDHC."
        textline "             "
        bitfld.long 0x00 20. " ADMAS ,ADMA Support: This bit indicates whether the uSDHC supports the ADMA feature." "0,1"
        textline "             "
        bitfld.long 0x00 21. " HSS ,High Speed Support: This bit indicates whether the uSDHC supports High Speed mode and the Host System can supply a SD Clock frequency from 25 MHz to 50 MHz." "0,1"
        textline "             "
        bitfld.long 0x00 22. " DMAS ,DMA Support: This bit indicates whether the uSDHC is capable of using the internal DMA to transfer data between system memory and the data buffer directly." "0,1"
        textline "             "
        bitfld.long 0x00 23. " SRS ,Suspend / Resume Support: This bit indicates whether the uSDHC supports Suspend / Resume functionality." "0,1"
        textline "             "
        bitfld.long 0x00 24. " VS33 ,Voltage Support 3.3V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 25. " VS30 ,Voltage Support 3.0V: This bit shall depend on the Host System ability." "0,1"
        textline "             "
        bitfld.long 0x00 26. " VS18 ,Voltage Support 1.8V: This bit shall depend on the Host System ability." "0,1"
width 9.
group.long 0x44++0x3
    line.long 0x00 "WTMK_LVL,Watermark Level"
        hexmask.long.byte 0x00 0.--8. 1. " RD_WML ,Read Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA read operation."
        textline "        "
        hexmask.long.byte 0x00 8.--13. 1. " RD_BRST_LEN ,Read Burst Length: Due to system restriction, the actual burst length may not exceed 16."
        textline "        "
        hexmask.long.byte 0x00 16.--24. 1. " WR_WML ,Write Watermark Level: The number of words used as the watermark level (FIFO threshold) in a DMA write operation."
        textline "        "
        hexmask.long.byte 0x00 24.--29. 1. " WR_BRST_LEN ,Write Burst Length: Due to system restriction, the actual burst length may not exceed 16."
width 9.
group.long 0x48++0x3
    line.long 0x00 "MIX_CTRL,Mixer Control"
        bitfld.long 0x00 0. " DMAEN ,DMA Enable: This bit enables DMA functionality." "0,1"
        textline "        "
        bitfld.long 0x00 1. " BCEN ,Block Count Enable: This bit is used to enable the Block Count register, which is only relevant for multiple block transfers." "0,1"
        textline "        "
        bitfld.long 0x00 2. " AC12EN ,Auto CMD12 Enable: Multiple block transfers for memory require a CMD12 to stop the transaction." "0,1"
        textline "        "
        bitfld.long 0x00 3. " DDR_EN ,Dual Data Rate mode selection" "0,1"
        textline "        "
        bitfld.long 0x00 4. " DTDSEL ,Data Transfer Direction Select: This bit defines the direction of DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 5. " MSBSEL ,Multi / Single Block Select: This bit enables multiple block DAT line data transfers." "0,1"
        textline "        "
        bitfld.long 0x00 6. " NIBBLE_POS ,In DDR 4-bit mode nibble position indictation." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AC23EN ,Auto CMD23 Enable When this bit is set to 1, the Host Controller issues a CMD23 automatically before issuing a command specified in the Command Register." "0,1"
        textline "        "
        bitfld.long 0x00 22. " EXE_TUNE ,Execute Tuning: (Only used for SD3.0, SDR104 mode) This bit is set to 1 to indicate the Host Driver is starting tuning procedure." "0,1"
        textline "        "
        bitfld.long 0x00 23. " SMP_CLK_SEL ,Tuned clock or Fixed clock is used to sample data/cmd (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 24. " AUTO_TUNE_EN ,Auto tuning enable (Only used for SD3.0, SDR104 mode)" "0,1"
        textline "        "
        bitfld.long 0x00 25. " FBCLK_SEL ,Feedback clock source selection (Only used for SD3.0, SDR104 mode)" "0,1"
width 12.
wgroup.long 0x50++0x3
    line.long 0x00 "FORCE_EVENT,Force Event"
        bitfld.long 0x00 0. " FEVTAC12NE ,Force Event Auto Command 12 Not Executed: Forces the AC12NE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 1. " FEVTAC12TOE ,Force Event Auto Command 12 Time Out Error: Forces the AC12TOE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 2. " FEVTAC12CE ,Force Event Auto Command 12 CRC Error: Forces the AC12CE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 3. " FEVTAC12EBE ,Force Event Auto Command 12 End Bit Error: Forces the AC12EBE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 4. " FEVTAC12IE ,Force Event Auto Command 12 Index Error: Forces the AC12IE bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 7. " FEVTCNIBAC12E ,Force Event Command Not Executed By Auto Command 12 Error: Forces the CNIBAC12E bit in the Auto Command12 Error Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 16. " FEVTCTOE ,Force Event Command Time Out Error: Forces the CTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 17. " FEVTCCE ,Force Event Command CRC Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 18. " FEVTCEBE ,Force Event Command End Bit Error: Forces the CEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 19. " FEVTCIE ,Force Event Command Index Error: Forces the CCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 20. " FEVTDTOE ,Force Event Data Time Out Error: Force the DTOE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 21. " FEVTDCE ,Force Event Data CRC Error: Forces the DCE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 22. " FEVTDEBE ,Force Event Data End Bit Error: Forces the DEBE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 24. " FEVTAC12E ,Force Event Auto Command 12 Error: Forces the AC12E bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 26. " FEVTTNE ,Force Tuning Error: Forces the TNE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 28. " FEVTDMAE ,Force Event DMA Error: Forces the DMAE bit of Interrupt Status Register to be set" "0,1"
        textline "           "
        bitfld.long 0x00 31. " FEVTCINT ,Force Event Card Interrupt: Writing 1 to this bit generates a short low-level pulse on the internal DAT[1] line, as if a self clearing interrupt was received from the external card." "0,1"
width 16.
rgroup.long 0x54++0x3
    line.long 0x00 "ADMA_ERR_STATUS,ADMA Error Status Register"
        hexmask.long.byte 0x00 0.--2. 1. " ADMAES ,ADMA Error State (when ADMA Error is occurred.): This field indicates the state of the ADMA when an error has occurred during an ADMA data transfer."
        textline "               "
        bitfld.long 0x00 2. " ADMALME ,ADMA Length Mismatch Error: This error occurs in the following 2 cases: While the Block Count Enable is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length Total data length can not be divided by the block length" "0,1"
        textline "               "
        bitfld.long 0x00 3. " ADMADCE ,ADMA Descritor Error: This error occurs when invalid descriptor fetched by ADMA:" "0,1"
width 14.
group.long 0x58++0x3
    line.long 0x00 "ADMA_SYS_ADDR,ADMA System Address"
        hexmask.long.long 0x00 2.--32. 1. " ADS_ADDR ,ADMA System Address: This register holds the word address of the executing command in the Descriptor table."
width 9.
group.long 0x60++0x3
    line.long 0x00 "DLL_CTRL,DLL (Delay Line) Control"
        bitfld.long 0x00 0. " DLL_CTRL_ENABLE ,Set this bit to 1 to enable the DLL and delay chain; otherwise; set to 0 to bypasses DLL." "0,1"
        textline "        "
        bitfld.long 0x00 1. " DLL_CTRL_RESET ,Setting this bit to 1 force a reset on DLL." "0,1"
        textline "        "
        bitfld.long 0x00 2. " DLL_CTRL_SLV_FORCE_UPD ,Setting this bit to 1, forces the slave delay line to update to the DLL calibrated value immediately." "0,1"
        textline "        "
        hexmask.long.byte 0x00 3.--7. 1. " DLL_CTRL_SLV_DLY_TARGET0 ,The delay target for the uSDHC loopback read clock can be programmed in 1/16th increments of an ref_clock half-period."
        textline "        "
        bitfld.long 0x00 7. " DLL_CTRL_GATE_UPDATE ,Set this bit to 1 to prevent the DLL from updating (since when clock_in exists, glitches may appear during DLL updates)." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DLL_CTRL_SLV_OVERRIDE ,Set this bit to 1 to Enable manual override for slave delay chain using SLV_OVERRIDE_VAL; to set 0 to disable manual override." "0,1"
        textline "        "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_CTRL_SLV_OVERRIDE_VAL ,When SLV_OVERRIDE=1 This field is used to select 1 of 128 physical taps manually."
        textline "        "
        hexmask.long.byte 0x00 16.--19. 1. " DLL_CTRL_SLV_DLY_TARGET1 ,Refer to DLL_CTRL_SLV_DLY_TARGET0 below."
        textline "        "
        hexmask.long.byte 0x00 20.--28. 1. " DLL_CTRL_SLV_UPDATE_INT ,Slave delay line update interval."
        textline "        "
        hexmask.long.byte 0x00 28.--32. 1. " DLL_CTRL_REF_UPDATE_INT ,DLL control loop update interval."
width 11.
rgroup.long 0x64++0x3
    line.long 0x00 "DLL_STATUS,DLL Status"
        bitfld.long 0x00 0. " DLL_STS_SLV_LOCK ,Slave delay-line lock status." "0,1"
        textline "          "
        bitfld.long 0x00 1. " DLL_STS_REF_LOCK ,Reference DLL lock status." "0,1"
        textline "          "
        hexmask.long.byte 0x00 2.--9. 1. " DLL_STS_SLV_SEL ,Slave delay line select status."
        textline "          "
        hexmask.long.byte 0x00 9.--16. 1. " DLL_STS_REF_SEL ,Reference delay line select taps."
width 21.
group.long 0x68++0x3
    line.long 0x00 "CLK_TUNE_CTRL_STATUS,CLK Tuning Control and Status"
        hexmask.long.byte 0x00 0.--4. 1. " DLY_CELL_SET_POST ,Set the number of delay cells on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 4.--8. 1. " DLY_CELL_SET_OUT ,Set the number of delay cells on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 8.--15. 1. " DLY_CELL_SET_PRE ,Set the number of delay cells on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 15. " NXT_ERR ,NXT error which means the number of delay cells added on the feedback clock is too large." "0,1"
        textline "                    "
        hexmask.long.byte 0x00 16.--20. 1. " TAP_SEL_POST ,Reflect the number of delay cells added on the feedback clock between CLK_OUT and CLK_POST."
        textline "                    "
        hexmask.long.byte 0x00 20.--24. 1. " TAP_SEL_OUT ,Reflect the number of delay cells added on the feedback clock between CLK_PRE and CLK_OUT."
        textline "                    "
        hexmask.long.byte 0x00 24.--31. 1. " TAP_SEL_PRE ,Reflects the number of delay cells added on the feedback clock between the feedback clock and CLK_PRE."
        textline "                    "
        bitfld.long 0x00 31. " PRE_ERR ,PRE error which means the number of delay cells added on the feedback clock is too small." "0,1"
width 10.
group.long 0xc0++0x3
    line.long 0x00 "VEND_SPEC,Vendor Specific Register"
        bitfld.long 0x00 0. " EXT_DMA_EN ,External DMA Request Enable Enable the request to external DMA." "0,1"
        textline "         "
        bitfld.long 0x00 1. " VSELECT ,Voltage Selection Change the value of output signal VSELECT, to control the voltage on pads for external card." "0,1"
        textline "         "
        bitfld.long 0x00 2. " CONFLICT_CHK_EN ,It's not implemented in uSDHC IP." "0,1"
        textline "         "
        bitfld.long 0x00 3. " AC12_WR_CHKBUSY_EN ,Check busy enable after auto CMD12 for write data packet" "0,1"
        textline "         "
        bitfld.long 0x00 4. " DAT3_CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 5. " CD_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 6. " WP_POL ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 7. " CLKONJ_IN_ABORT ,Only for debug." "0,1"
        textline "         "
        bitfld.long 0x00 8. " FRC_SDCLK_ON ,Force CLK output active:" "0,1"
        textline "         "
        bitfld.long 0x00 11. " IPG_CLK_SOFT_EN ,IPG_CLK software enable" "0,1"
        textline "         "
        bitfld.long 0x00 12. " HCLK_SOFT_EN ,Please note, hardware auto-enables the AHB clock when the internal DMA is enabled even if HCLK_SOFT_EN is 0." "0,1"
        textline "         "
        bitfld.long 0x00 13. " IPG_PERCLK_SOFT_EN ,ipg_perclk software enable" "0,1"
        textline "         "
        bitfld.long 0x00 14. " CARD_CLK_SOFT_EN ,card clock software enable" "0,1"
        textline "         "
        bitfld.long 0x00 15. " CRC_CHK_DIS ,CRC check disable" "0,1"
        textline "         "
        hexmask.long.byte 0x00 16.--24. 1. " INT_ST_VAL ,Internal State Value Internal state value, reflecting the corresponding state value selected by Debug Select field."
width 9.
group.long 0xc4++0x3
    line.long 0x00 "MMC_BOOT,MMC Boot Register"
        hexmask.long.byte 0x00 0.--4. 1. " DTOCV_ACK ,Boot ACK time out counter value."
        textline "        "
        bitfld.long 0x00 4. " BOOT_ACK ,Boot ack mode select." "0,1"
        textline "        "
        bitfld.long 0x00 5. " BOOT_MODE ,Boot mode select." "0,1"
        textline "        "
        bitfld.long 0x00 6. " BOOT_EN ,Boot mode enable." "0,1"
        textline "        "
        bitfld.long 0x00 7. " AUTO_SABG_EN ,During boot, enable auto stop at block gap function." "0,1"
        textline "        "
        bitfld.long 0x00 8. " DISABLE_TIME_OUT ,Please note, when this bit is set, there is no timeout check no matter whether boot_en is set or not." "0,1"
        textline "        "
        hexmask.long.word 0x00 16.--32. 1. " BOOT_BLK_CNT ,The value defines the Stop At Block Gap value of automatic mode."
width 11.
group.long 0xc8++0x3
    line.long 0x00 "VEND_SPEC2,Vendor Specific 2 Register"
        bitfld.long 0x00 0. " SDR104_TIMING_DIS ,Timeout counter test." "0,1"
        textline "          "
        bitfld.long 0x00 1. " SDR104_OE_DIS ,CMD_OE/DAT_OE logic generation test." "0,1"
        textline "          "
        bitfld.long 0x00 2. " SDR104_NSD_DIS ,Interrupt window after abort command is sent." "0,1"
        textline "          "
        bitfld.long 0x00 3. " CARD_INT_D3_TEST ,Card interrupt detection test." "0,1"
        textline "          "
        bitfld.long 0x00 4. " TUNING_8BIT_EN ,Enable the auto tuning circuit to check the DAT[7:0]." "0,1"
        textline "          "
        bitfld.long 0x00 5. " TUNING_1BIT_EN ,Enable the auto tuning circuit to check the DAT0 only." "0,1"
        textline "          "
        bitfld.long 0x00 6. " TUNING_CMD_EN ,Enable the auto tuning circuit to check the CMD line." "0,1"
        textline "          "
        bitfld.long 0x00 7. " CARD_INT_AUTO_CLR_DIS ,Disable the feature to clear the Card interrupt status bit when Card Interrupt status enable bit is cleared." "0,1"


    tree.end

tree.end



;--------------------------------------------------------------------------------
; VDOA
;--------------------------------------------------------------------------------
tree "VDOA"
    base ad:0x021e4000

width 6.
group.long 0x0++0x3
    line.long 0x00 "VDOAC,VDOA Control Register"
        hexmask.long.byte 0x00 0.--2. 1. " BNDM ,BNDM Band Size"
        textline "     "
        bitfld.long 0x00 2. " NF ,Number of frames - Determines whether to transfer 1 frame or three frames" "0,1"
        textline "     "
        bitfld.long 0x00 3. " SYNC ,SYNC MODE - defines whether the VDOA will transfer a full frame (or 2 frames) continuously or will transfer a band at a time and wait for IPU signal to continue" "0,1"
        textline "     "
        bitfld.long 0x00 4. " SO ,Scan Order" "0,1"
        textline "     "
        bitfld.long 0x00 5. " PFS ,Pixel Format Select - Pixel format of data written to / read from IPU." "0,1"
        textline "     "
        bitfld.long 0x00 6. " ISEL ,IPU SELECT - determines in sync mode which of the two sets of hand shake pins is used" "0,1"
width 8.
group.long 0x4++0x3
    line.long 0x00 "VDOASRR,VDOA Start and Reset"
        bitfld.long 0x00 0. " SWRST ,Software reset - Finish outstanding AXI transfer and reset all internal registers the configuration registers are mnot cleared" "0,1"
        textline "       "
        bitfld.long 0x00 1. " START ,Start Transfer - Strat a VDOA data transfer according to all parameters." "0,1"
width 7.
group.long 0x8++0x3
    line.long 0x00 "VDOAIE,VDOA Interrupt Enable Register"
        bitfld.long 0x00 0. " EIEOT ,EIEOT - Enable Interrupt End Of Transfer- Enables Interrupt on end of transfer" "0,1"
        textline "      "
        bitfld.long 0x00 1. " EITERR ,EITERR - Enable Interrupt Transfer access Error - Enables Interrupt on AXI access Error" "0,1"
width 8.
group.long 0xc++0x3
    line.long 0x00 "VDOAIST,VDOA Interrupt Status Register"
        bitfld.long 0x00 0. " EOT ,End Of transfer - Transfer was completed if EIEOT is set an interrupt will be generated" "0,1"
        textline "       "
        bitfld.long 0x00 1. " TERR ,Axi Access had an access error see ERRW bit in 0XBASE_0044 (VDOASR) for type of access (read write) if EITERR is set an interrupt will be generated" "0,1"
width 7.
group.long 0x10++0x3
    line.long 0x00 "VDOAFP,VDOA Frame Parameters Register"
        hexmask.long.word 0x00 0.--14. 1. " FW ,Number of pixels in one row, of the frame."
        textline "      "
        hexmask.long.word 0x00 16.--29. 1. " FH ,Number of pixels in one column, of the frame."
width 11.
group.long 0x14++0x3
    line.long 0x00 "VDOAIEBA00,VDOA IPU External Buffer 0 Frame 0 Address Register"
        hexmask.long.long 0x00 0.--32. 1. " IEBA00 ,External Address of Frame 0 output (IPU) buffer 0 - Note that the 3 LSB are always 0 (aligned to 8 address) Used for all transfer types"
width 11.
group.long 0x18++0x3
    line.long 0x00 "VDOAIEBA01,VDOA IPU External Buffer 0 Frame 1 Address Register"
        hexmask.long.long 0x00 0.--32. 1. " IEBA01 ,External Address of Frame 1 output (IPU) buffer 0 - Note that the 3 LSB are always 0 (aligned to 8 address) Used when transfering 3 frames (NF=1) only"
width 11.
group.long 0x1c++0x3
    line.long 0x00 "VDOAIEBA02,VDOA IPU External Buffer 0 Frame 2 Address Register"
        hexmask.long.long 0x00 0.--32. 1. " IEBA02 ,External Address of Frame 2 output (IPU) buffer 0 - Note that the 3 LSB are always 0 (aligned to 8 address) Used when transfering 3 frames (NF=1) only"
width 11.
group.long 0x20++0x3
    line.long 0x00 "VDOAIEBA10,VDOA IPU External Buffer 1 Frame 0 Address Register"
        hexmask.long.long 0x00 0.--32. 1. " IEBA10 ,External Address of Frame 0 output (IPU) buffer 1 - Note that the 3 LSB are always 0 (aligned to 8 address) Used in sync mode (SYNC=1) only"
width 11.
group.long 0x24++0x3
    line.long 0x00 "VDOAIEBA11,VDOA IPU External Buffer 1 Frame 1 Address Register"
        hexmask.long.long 0x00 0.--32. 1. " IEBA11 ,External Address of Frame 1 output (IPU) buffer 1 - Note that the 3 LSB are always 0 (aligned to 8 address) This register is used only in sync mode (SYNC=1), 3 frames transfer (NF=1)"
width 11.
group.long 0x28++0x3
    line.long 0x00 "VDOAIEBA12,VDOA IPU External Buffer 1 Frame 2 Address Register"
        hexmask.long.long 0x00 0.--32. 1. " IEBA12 ,External Address of Frame 2 output (IPU) buffer 1 - Note that the 3 LSB are always 0 (aligned to 8 address) This register is used only in sync mode (SYNC=1), 3 frames transfer (NF=1)"
width 7.
group.long 0x2c++0x3
    line.long 0x00 "VDOASL,VDOA IPU Stride Line Register"
        hexmask.long.word 0x00 0.--15. 1. " ISLY ,IPU Stride Line - Address vertical scaling factor in bytes for memory access."
        textline "      "
        hexmask.long.word 0x00 16.--30. 1. " VSLY ,VPU Stride Line - Address vertical scaling factor in bytes for memory access."
width 9.
group.long 0x30++0x3
    line.long 0x00 "VDOAIUBO,VDOA IPU U (Chroma) Buffer Offset Register"
        hexmask.long.long 0x00 0.--27. 1. " IUBO ,The offset of Chroma (UV) Buffer for all IPU output frames i.e Buffer Chroma address will be VDOAIEBAnm+VDOAIUBO - Note that the 3 LSB are always 0 (aligned to 8 address) used only for PFL = 4:2:0"
width 10.
group.long 0x34++0x3
    line.long 0x00 "VDOAVEBA0,VDOA VPU External Buffer 0 Address Register"
        hexmask.long.long 0x00 0.--32. 1. " VEBA0 ,Address of Frame 0 VPU buffers - Note that the 3 LSB are always 0 (aligned to 8 address) Used for all transfers"
width 10.
group.long 0x38++0x3
    line.long 0x00 "VDOAVEBA1,VDOA VPU External Buffer 1 Address Register"
        hexmask.long.long 0x00 0.--32. 1. " VEBA1 ,Address of Frame 1 VPU buffers - Note that the 3 LSB are always 0 (aligned to 8 address) Used when transfering three frame (NF=1) only"
width 10.
group.long 0x3c++0x3
    line.long 0x00 "VDOAVEBA2,VDOA VPU External Buffer 2 Address Register"
        hexmask.long.long 0x00 0.--32. 1. " VEBA2 ,Address of Frame 2 VPU buffers - Note that the 3 LSB are always 0 (aligned to 8 address) Used when transfering three frame (NF=1) only"
width 9.
group.long 0x40++0x3
    line.long 0x00 "VDOAVUBO,VDOA VPU U (Chroma) Buffer Offset Register"
        hexmask.long.long 0x00 0.--27. 1. " VUBO ,The offset of Chroma (UV) Buffer for all VPU input frames i.e Chroma Buffer address will be VDOAVEBAm+VDOAVUBO - Note that the 3 LSB are always 0 (aligned to 8 address)"
width 7.
rgroup.long 0x44++0x3
    line.long 0x00 "VDOASR,VDOA Status Register"
        bitfld.long 0x00 0. " CURRENT_BUFFER ,Current Buffer - for Double buffer shows the number of buffer currently transferred" "0,1"
        textline "      "
        hexmask.long.byte 0x00 1.--3. 1. " CURRENT_FRAME ,Current Frame - When working on 3 frames the number of frame currently transferred"
        textline "      "
        bitfld.long 0x00 3. " EOB ,End of Band- Indicates that the VDOA has finished transferring a band in SYNC mode and is waiting to IPU to continue" "0,1"
        textline "      "
        bitfld.long 0x00 4. " ERRW ,Error Write - Indicates that the last access that failed was a read or a write.This field is valid only when TERR bit is set in VDOA Interrupt Status Register - VDOAIST" "0,1"


tree.end



;--------------------------------------------------------------------------------
; VPU
;--------------------------------------------------------------------------------
tree "VPU"
    base ad:0x02040000

width 8.
wgroup.long 0x0++0x3
    line.long 0x00 "CODERUN,BIT Processor run start"
        bitfld.long 0x00 0. " CODERUN ,VPU_CodeRun." "0,1"
width 9.
wgroup.long 0x4++0x3
    line.long 0x00 "CODEDOWN,BIT Boot Code Download Data register"
        hexmask.long.word 0x00 0.--16. 1. " CODEDATA ,CodeData[15:0] Download data of VPU BIT boot code."
        textline "        "
        hexmask.long.word 0x00 16.--29. 1. " CODEADDR ,CodeAddr[12:0] Download address of VPU BIT boot code, which is VPU internal address of BIT processor."
width 11.
wgroup.long 0x8++0x3
    line.long 0x00 "HOSTINTREQ,Host Interrupt Request to BIT"
        bitfld.long 0x00 0. " INTREQ ,IntReq." "0,1"
width 12.
wgroup.long 0xc++0x3
    line.long 0x00 "BITINTCLEAR,BIT Interrupt Clear"
        bitfld.long 0x00 0. " INTCLEAR ,IntClear." "0,1"
width 10.
rgroup.long 0x10++0x3
    line.long 0x00 "BITINTSTS,BIT Interrupt Status"
        bitfld.long 0x00 0. " INTSTS ,IntSts." "0,1"
width 9.
rgroup.long 0x18++0x3
    line.long 0x00 "BITCURPC,BIT Current PC"
        hexmask.long.word 0x00 0.--14. 1. " CURPC ,CurPc[13:0]."
width 13.
rgroup.long 0x20++0x3
    line.long 0x00 "BITCODECBUSY,BIT CODEC Busy"
        bitfld.long 0x00 0. " CODECBUSY ,Codec busy flag for Bit processor.BIT processor write ""1""to this register when the processor is running.""0""means processor is waiting for a command.This value is connected to the o_vpu_idle." "0,1"


tree.end



;--------------------------------------------------------------------------------
; WDOG
;--------------------------------------------------------------------------------
tree.open "WDOG"
    tree "WDOG1"
        base ad:0x020bc000

width 4.
group.word 0x0++0x1
    line.word 0x00 "WCR,Watchdog Control Register"
        bitfld.word 0x00 0. " WDZST ,Watchdog Low Power." "0,1"
        textline "   "
        bitfld.word 0x00 1. " WDBG ,Watchdog DEBUG Enable." "0,1"
        textline "   "
        bitfld.word 0x00 2. " WDE ,Watchdog Enable." "0,1"
        textline "   "
        bitfld.word 0x00 3. " WDT ,WDOG Time-out assertion." "0,1"
        textline "   "
        bitfld.word 0x00 4. " SRS ,Software Reset Signal." "0,1"
        textline "   "
        bitfld.word 0x00 5. " WDA ,WDOG assertion." "0,1"
        textline "   "
        bitfld.word 0x00 6. " SRE ,adopt a new way to generate a more robust software reset." "0,1"
        textline "   "
        bitfld.word 0x00 7. " WDW ,Watchdog Disable for Wait." "0,1"
        textline "   "
        hexmask.word.byte 0x00 8.--16. 1. " WT ,Watchdog Time-out Field."
width 4.
group.word 0x2++0x1
    line.word 0x00 "WSR,Watchdog Service Register"
        hexmask.word.word 0x00 0.--16. 1. " WSR ,Watchdog Service Register."
width 5.
rgroup.word 0x4++0x1
    line.word 0x00 "WRSR,Watchdog Reset Status Register"
        bitfld.word 0x00 0. " SFTW ,Software Reset." "0,1"
        textline "    "
        bitfld.word 0x00 1. " TOUT ,Timeout." "0,1"
        textline "    "
        bitfld.word 0x00 4. " POR ,Power On Reset." "0,1"
width 5.
group.word 0x6++0x1
    line.word 0x00 "WICR,Watchdog Interrupt Control Register"
        hexmask.word.byte 0x00 0.--8. 1. " WICT ,Watchdog Interrupt Count Time-out (WICT) field determines, how long before the counter time-out must the interrupt occur."
        textline "    "
        bitfld.word 0x00 14. " WTIS ,Watchdog TImer Interrupt Status bit will reflect the timer interrupt status, whether interrupt has occurred or not." "0,1"
        textline "    "
        bitfld.word 0x00 15. " WIE ,Watchdog Timer Interrupt enable bit." "0,1"
width 5.
group.word 0x8++0x1
    line.word 0x00 "WMCR,Watchdog Miscellaneous Control Register"
        bitfld.word 0x00 0. " PDE ,Power Down Enable bit." "0,1"


    tree.end
    tree "WDOG2"
        base ad:0x020c0000

width 4.
group.word 0x0++0x1
    line.word 0x00 "WCR,Watchdog Control Register"
        bitfld.word 0x00 0. " WDZST ,Watchdog Low Power." "0,1"
        textline "   "
        bitfld.word 0x00 1. " WDBG ,Watchdog DEBUG Enable." "0,1"
        textline "   "
        bitfld.word 0x00 2. " WDE ,Watchdog Enable." "0,1"
        textline "   "
        bitfld.word 0x00 3. " WDT ,WDOG Time-out assertion." "0,1"
        textline "   "
        bitfld.word 0x00 4. " SRS ,Software Reset Signal." "0,1"
        textline "   "
        bitfld.word 0x00 5. " WDA ,WDOG assertion." "0,1"
        textline "   "
        bitfld.word 0x00 6. " SRE ,adopt a new way to generate a more robust software reset." "0,1"
        textline "   "
        bitfld.word 0x00 7. " WDW ,Watchdog Disable for Wait." "0,1"
        textline "   "
        hexmask.word.byte 0x00 8.--16. 1. " WT ,Watchdog Time-out Field."
width 4.
group.word 0x2++0x1
    line.word 0x00 "WSR,Watchdog Service Register"
        hexmask.word.word 0x00 0.--16. 1. " WSR ,Watchdog Service Register."
width 5.
rgroup.word 0x4++0x1
    line.word 0x00 "WRSR,Watchdog Reset Status Register"
        bitfld.word 0x00 0. " SFTW ,Software Reset." "0,1"
        textline "    "
        bitfld.word 0x00 1. " TOUT ,Timeout." "0,1"
        textline "    "
        bitfld.word 0x00 4. " POR ,Power On Reset." "0,1"
width 5.
group.word 0x6++0x1
    line.word 0x00 "WICR,Watchdog Interrupt Control Register"
        hexmask.word.byte 0x00 0.--8. 1. " WICT ,Watchdog Interrupt Count Time-out (WICT) field determines, how long before the counter time-out must the interrupt occur."
        textline "    "
        bitfld.word 0x00 14. " WTIS ,Watchdog TImer Interrupt Status bit will reflect the timer interrupt status, whether interrupt has occurred or not." "0,1"
        textline "    "
        bitfld.word 0x00 15. " WIE ,Watchdog Timer Interrupt enable bit." "0,1"
width 5.
group.word 0x8++0x1
    line.word 0x00 "WMCR,Watchdog Miscellaneous Control Register"
        bitfld.word 0x00 0. " PDE ,Power Down Enable bit." "0,1"


    tree.end

tree.end



;--------------------------------------------------------------------------------
; XTALOSC24M
;--------------------------------------------------------------------------------
tree "XTALOSC24M"
    base ad:0x020c8000

width 6.
group.long 0x150++0x3
    line.long 0x00 "MISC0,Miscellaneous Register 0"
        bitfld.long 0x00 0. " REFTOP_PWD ,Control bit to power-down the analog bandgap reference circuitry." "0,1"
        textline "     "
        bitfld.long 0x00 3. " REFTOP_SELFBIASOFF ,Control bit to disable the self-bias circuit in the analog bandgap." "0,1"
        textline "     "
        hexmask.long.byte 0x00 4.--7. 1. " REFTOP_VBGADJ ,Not related to oscillator."
        textline "     "
        bitfld.long 0x00 7. " REFTOP_VBGUP ,Status bit which signals that the analog bandgap voltage is up and stable." "0,1"
        textline "     "
        bitfld.long 0x00 12. " STOP_MODE_CONFIG ,Configure the analog behavior in stop mode." "0,1"
        textline "     "
        hexmask.long.byte 0x00 14.--16. 1. " OSC_I ,This bit field determines the bias current in the 24MHz oscillator."
        textline "     "
        bitfld.long 0x00 16. " OSC_XTALOK ,Status bit which signals that the output of the 24MHz crystal oscillator is stable." "0,1"
        textline "     "
        bitfld.long 0x00 17. " OSC_XTALOK_EN ,Enable bit for the xtal_ok module(24 MHz)" "0,1"
        textline "     "
        hexmask.long.byte 0x00 18.--20. 1. " WBCP_VPW_THRESH ,This signal alters the voltage that the pwell is charged pumped to."
        textline "     "
        bitfld.long 0x00 25. " CLKGATE_CTRL ,This bit allows disabling the clock gate (always un-gated) for the xtal 24MHz clock that clocks the digital logic in the analog block." "0,1"
        textline "     "
        hexmask.long.byte 0x00 26.--29. 1. " CLKGATE_DELAY ,This field specifies the delay between powering up the XTAL 24MHz clock and release the clock to the digital logic inside the analog block."


tree.end



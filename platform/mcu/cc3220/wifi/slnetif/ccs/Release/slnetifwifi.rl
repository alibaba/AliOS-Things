L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/slnetif/slnetifwifi.c"
N/*
N * Copyright (c) 2017, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N 
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N
N#include <ti/drivers/net/wifi/slnetifwifi.h>
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/slnetifwifi.h" 1
N/*
N * Copyright (c) 2017, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N#include <ti/net/slnetsock.h>
L 1 "/vagrant/Q4_04/sdk_root/source/ti/net/slnetsock.h" 1
N/*
N * Copyright (c) 2017, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N /*!
N
N
N  \page SlNetSock_overview SlNetSock
N
N  \section intro_sec Introduction
N
NSlNetSock provides a standard BSD API for TCP and UDP transport
Nlayers, and a lower-level SlNetSock API for basic and extended
Nusage. Supported use cases include:
N
N - Support of multi interface (WiFi NS, Ethernet NDK)
N - Selecting which interfaces the host will use, one or more.
N - Support of different types of sockets (TCP, TLS, UDP, RAW, RF, etc.)
N - BSD and proprietary errors
N
N The SlNetSock API's lead to easier portability to microcontrollers,
N without compromising the capabilities and robustness of the final
N application.
N
N
N \section modules_sec Module Names
N TI's SlNetSock layer is divided into the following software modules:
N     -# \ref SlNetSock  - Controls standard client/server sockets options and capabilities
N     -# \ref SlNetIf    - Controls standard stack/interface options and capabilities
N     -# \ref SlNetUtils - Provides sockets related commands and configuration
N     -# \ref SlNetErr   - Provide BSD and proprietary errors
N
NIn addition, SlNetSock provides a standard BSD API, built atop the
NSlNet* APIs.  The BSD headers are placed in ti/net/bsd directory,
Nwhich users should place on their include path.
N
NAlso, there is a light
N\subpage porting_guide "SL Interface Porting Guide"
Nwith information available for adding SlNetSock support for other stacks.
N
N  \page porting_guide SL Interface Porting Guide
N
N \section Introduction
N
NThe generic SlNetSock layer sits between the application/service and
Nthe interface stack.  This guide describes the details of adding a network stack into the SlNetSock environment.
N
NThe porting steps for adding new interface:
N    -# Create slnetifxxx file for the new interface
N    -# Select the capabilities set
N    -# Adding the interface to your application/service
N    -# Add the relevant functions to your application/service
N    -# Test your code to validate the correctness of your porting
N
N  \subsection porting_step1   Step 1 - slnetifxxx.c and slnetifxxx.h file for your interface
N
N - Create slnetifxxx file (replace xxx with your interface/stack
N   name).  Likely you will copy from an existing port.
N
N - Implement the needed API's.
N
NEach interface needs to provide a set of API's to work with the
Ninterface.  Some are mandatory, others are optional (but recommended).
N
N - Mandatory API's:
N  - \ref SlNetIf_Config_t.sockCreate            "sockCreate"
N  - \ref SlNetIf_Config_t.sockClose             "sockClose"
N  - \ref SlNetIf_Config_t.sockSelect            "sockSelect"
N  - \ref SlNetIf_Config_t.sockSetOpt            "sockSetOpt"
N  - \ref SlNetIf_Config_t.sockGetOpt            "sockGetOpt"
N  - \ref SlNetIf_Config_t.sockRecvFrom          "sockRecvFrom"
N  - \ref SlNetIf_Config_t.sockSendTo            "sockSendTo"
N  - \ref SlNetIf_Config_t.ifGetIPAddr           "ifGetIPAddr"
N  - \ref SlNetIf_Config_t.ifGetConnectionStatus "ifGetConnectionStatus"
N
N - The non-mandatory API's set:
N  - \ref SlNetIf_Config_t.sockShutdown          "sockShutdown"
N  - \ref SlNetIf_Config_t.sockAccept            "sockAccept"
N  - \ref SlNetIf_Config_t.sockBind              "sockBind"
N  - \ref SlNetIf_Config_t.sockListen            "sockListen"
N  - \ref SlNetIf_Config_t.sockConnect           "sockConnect"
N  - \ref SlNetIf_Config_t.sockGetPeerName       "sockGetPeerName"
N  - \ref SlNetIf_Config_t.sockGetLocalName      "sockGetLocalName"
N  - \ref SlNetIf_Config_t.sockRecv              "sockRecv"
N  - \ref SlNetIf_Config_t.sockSend              "sockSend"
N  - \ref SlNetIf_Config_t.sockstartSec          "sockstartSec"
N  - \ref SlNetIf_Config_t.utilGetHostByName     "utilGetHostByName"
N  - \ref SlNetIf_Config_t.ifLoadSecObj          "ifLoadSecOjb"
N  - \ref SlNetIf_Config_t.ifCreateContext       "ifCreateContext"
N
N
N  \note The list of API's and more data can be found in ::SlNetIf_Config_t structure in SlNetIf module \n \n
N
N \subsection    porting_step2   Step 2 - Select the capabilities set
N
N The capabilities prototype should be declared in your slnetifxxx.h and implemented in your slnetifxxx.c
N
N Each mandatory API's must be set, additional API's can be set or must
N be set to NULL.
N
N An example config declaration for TI's SimpleLink CC31XX/CC32xx
N
N \code
N SlNetIfConfig SlNetIfConfigWiFi =
N {
N    SlNetIfWifi_socket,              // Callback function sockCreate in slnetif module
N    SlNetIfWifi_close,               // Callback function sockClose in slnetif module
N    NULL,                            // Callback function sockShutdown in slnetif module
N    SlNetIfWifi_accept,              // Callback function sockAccept in slnetif module
N    SlNetIfWifi_bind,                // Callback function sockBind in slnetif module
N    SlNetIfWifi_listen,              // Callback function sockListen in slnetif module
N    SlNetIfWifi_connect,             // Callback function sockConnect in slnetif module
N    NULL,                            // Callback function sockGetPeerName in slnetif module
N    NULL,                            // Callback function sockGetLocalName in slnetif module
N    SlNetIfWifi_select,              // Callback function sockSelect in slnetif module
N    SlNetIfWifi_setSockOpt,          // Callback function sockSetOpt in slnetif module
N    SlNetIfWifi_getSockOpt,          // Callback function sockGetOpt in slnetif module
N    SlNetIfWifi_recv,                // Callback function sockRecv in slnetif module
N    SlNetIfWifi_recvFrom,            // Callback function sockRecvFrom in slnetif module
N    SlNetIfWifi_send,                // Callback function sockSend in slnetif module
N    SlNetIfWifi_sendTo,              // Callback function sockSendTo in slnetif module
N    SlNetIfWifi_sockstartSec,        // Callback function sockstartSec in slnetif module
N    SlNetIfWifi_getHostByName,       // Callback function utilGetHostByName in slnetif module
N    SlNetIfWifi_getIPAddr,           // Callback function ifGetIPAddr in slnetif module
N    SlNetIfWifi_getConnectionStatus, // Callback function ifGetConnectionStatus in slnetif module
N    SlNetIfWifi_loadSecObj,          // Callback function ifLoadSecObj in slnetif module
N    NULL                             // Callback function ifCreateContext in slnetif module
N };
N \endcode
N
N In the example above the following API's are not supported by the interface,
N and are set to NULL:
N - sockShutdown
N - sockGetPeerName
N - sockGetLocalName
N - utilGetHostByName
N - ifCreateContext
N
N \subsection    porting_step3   Step 3 - Adding the interface to your application/service
N
N \b Include the new file in the board header file in the application.
N
N \subsection    porting_step4   Step 4 - Add the relevant functions to your application/service
N
N  After configuring the capabilities of the interface, Adding the interface to the SlNetSock
N  is required.
N
N  Use ::SlNetIf_add in order to add the interface and set his ID, Name, function list and priority.
N  Later on you need to use the BSD API's or SlNetSock API's for socket handling.
N
N \subsection    porting_step5   Step 5 - Test your code to validate the correctness of your porting
N
N After porting the layer into your setup, validate that your code work as expected
N
N*/
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N
N#ifndef __SL_NET_SOCK_H__
N#define __SL_NET_SOCK_H__
N
N
N#ifdef    __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
L 1 "/opt/ti/ccs-latest/ccsv7/tools/compiler/ti-cgt-arm_16.9.6.LTS/include/stdint.h" 1
N/*****************************************************************************/
N/* STDINT.H v16.9.6                                                          */
N/*                                                                           */
N/* Copyright (c) 2002-2017 Texas Instruments Incorporated                    */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N#ifndef _STDINT_H_
N#define _STDINT_H_
N
N/* 7.18.1.1 Exact-width integer types */
N
N    typedef   signed char   int8_t;
N    typedef unsigned char  uint8_t;
N    typedef          short  int16_t;
N    typedef unsigned short uint16_t;
N    typedef          int    int32_t;
N    typedef unsigned int   uint32_t;
N
N
N    typedef          long long  int64_t;
N    typedef unsigned long long uint64_t;
N
N/* 7.18.1.2 Minimum-width integer types */
N
N    typedef  int8_t   int_least8_t;
N    typedef uint8_t  uint_least8_t;
N
N    typedef  int16_t  int_least16_t;
N    typedef uint16_t uint_least16_t;
N    typedef  int32_t  int_least32_t;
N    typedef uint32_t uint_least32_t;
N
N
N    typedef  int64_t  int_least64_t;
N    typedef uint64_t uint_least64_t;
N
N/* 7.18.1.3 Fastest minimum-width integer types */
N
N    typedef  int32_t  int_fast8_t;
N    typedef uint32_t uint_fast8_t;
N    typedef  int32_t  int_fast16_t;
N    typedef uint32_t uint_fast16_t;
N
N    typedef  int32_t  int_fast32_t;
N    typedef uint32_t uint_fast32_t;
N
N
N    typedef  int64_t  int_fast64_t;
N    typedef uint64_t uint_fast64_t;
N
N/* 7.18.1.4 Integer types capable of holding object pointers */
N    typedef          int intptr_t;
N    typedef unsigned int uintptr_t;
N
N/* 7.18.1.5 Greatest-width integer types */
N    typedef          long long intmax_t;
N    typedef unsigned long long uintmax_t;
N
N/* 
N   According to footnotes in the 1999 C standard, "C++ implementations
N   should define these macros only when __STDC_LIMIT_MACROS is defined
N   before <stdint.h> is included." 
N*/
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N/* 7.18.2 Limits of specified width integer types */
N
N    #define  INT8_MAX   0x7f
N    #define  INT8_MIN   (-INT8_MAX-1)
N    #define UINT8_MAX   0xff
N
N    #define  INT16_MAX  0x7fff
N    #define  INT16_MIN  (-INT16_MAX-1)
N    #define UINT16_MAX  0xffff
N
N    #define  INT32_MAX  0x7fffffff
N    #define  INT32_MIN  (-INT32_MAX-1)
N    #define UINT32_MAX  0xffffffff
N
N
N    #define  INT64_MAX  0x7fffffffffffffff
N    #define  INT64_MIN  (-INT64_MAX-1)
N    #define UINT64_MAX  0xffffffffffffffff
N
N    #define  INT_LEAST8_MAX   (INT8_MAX)
N    #define  INT_LEAST8_MIN   (INT8_MIN)
N    #define UINT_LEAST8_MAX   (UINT8_MAX)
N
N    #define  INT_LEAST16_MAX  (INT16_MAX)
N    #define  INT_LEAST16_MIN  (INT16_MIN)
N    #define UINT_LEAST16_MAX  (UINT16_MAX)
N    #define  INT_LEAST32_MAX  (INT32_MAX)
N    #define  INT_LEAST32_MIN  (INT32_MIN)
N    #define UINT_LEAST32_MAX  (UINT32_MAX)
N
N
N    #define  INT_LEAST64_MAX  (INT64_MAX)
N    #define  INT_LEAST64_MIN  (INT64_MIN)
N    #define UINT_LEAST64_MAX  (UINT64_MAX)
N
N    #define  INT_FAST8_MAX   (INT32_MAX)
N    #define  INT_FAST8_MIN   (INT32_MIN)
N    #define UINT_FAST8_MAX   (UINT32_MAX)
N    #define  INT_FAST16_MAX  (INT32_MAX)
N    #define  INT_FAST16_MIN  (INT32_MIN)
N    #define UINT_FAST16_MAX  (UINT32_MAX)
N
N    #define  INT_FAST32_MAX  (INT32_MAX)
N    #define  INT_FAST32_MIN  (INT32_MIN)
N    #define UINT_FAST32_MAX  (UINT32_MAX)
N
N
N    #define  INT_FAST64_MAX  (INT64_MAX)
N    #define  INT_FAST64_MIN  (INT64_MIN)
N    #define UINT_FAST64_MAX  (UINT64_MAX)
N
N    #define INTPTR_MAX   (INT32_MAX)
N    #define INTPTR_MIN   (INT32_MIN)
N    #define UINTPTR_MAX  (UINT32_MAX)
N
N    #define INTMAX_MIN   (INT64_MIN)
N    #define INTMAX_MAX   (INT64_MAX)
N    #define UINTMAX_MAX  (UINT64_MAX)
N
N/* 7.18.3 Limits of other integer types */
N
N    #define PTRDIFF_MAX (INT32_MAX)
N    #define PTRDIFF_MIN (INT32_MIN)
N
N    #define SIG_ATOMIC_MIN (INT32_MIN)
N    #define SIG_ATOMIC_MAX (INT32_MAX)
N
N    #define SIZE_MAX (UINT32_MAX)
N
N#ifndef WCHAR_MAX
N#if !defined(__TI_WCHAR_T_BITS__) || __TI_WCHAR_T_BITS__ == 16
X#if !1L || 16 == 16
N#define WCHAR_MAX 0xffffu
N#else 
S#define WCHAR_MAX 0xffffffffu
N#endif
N#endif
N
N#ifndef WCHAR_MIN
N#define WCHAR_MIN 0
N#endif
N
N    #define WINT_MIN (INT32_MIN)
N    #define WINT_MAX (INT32_MAX)
N
N/* 7.18.4.1 Macros for minimum-width integer constants */
N
N/*
N   There is a defect report filed against the C99 standard concerning how 
N   the (U)INTN_C macros should be implemented.  Please refer to --
N   http://wwwold.dkuug.dk/JTC1/SC22/WG14/www/docs/dr_209.htm 
N   for more information.  These macros are implemented according to the
N   suggestion given at this web site.
N*/
N
N    #define  INT8_C(value)  ((int_least8_t)(value))
N    #define UINT8_C(value)  ((uint_least8_t)(value))
N    #define  INT16_C(value) ((int_least16_t)(value))
N    #define UINT16_C(value) ((uint_least16_t)(value))
N    #define  INT32_C(value) ((int_least32_t)(value))
N    #define UINT32_C(value) ((uint_least32_t)(value))
N
N
N    #define  INT64_C(value) ((int_least64_t)(value))
N    #define UINT64_C(value) ((uint_least64_t)(value))
N
N/* 7.18.4.2 Macros for greatest-width integer constants */
N
N    #define  INTMAX_C(value) ((intmax_t)(value))
N    #define UINTMAX_C(value) ((uintmax_t)(value))
N
N#endif /* !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) */
N
N#endif /* _STDINT_H_ */
L 198 "/vagrant/Q4_04/sdk_root/source/ti/net/slnetsock.h" 2
N
N/*!
N    \defgroup SlNetSock SlNetSock group
N
N    \short Controls standard client/server sockets options and capabilities
N
N*/
N/*!
N
N    \addtogroup SlNetSock
N    @{
N
N*/
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N
N#define SLNETSOCK_MAX_CONCURRENT_SOCKETS                                    (32)  /**< Declares the maximum sockets that can be opened */
N
N/* Address families.  */
N#define SLNETSOCK_AF_UNSPEC                                                 (0)   /**< Unspecified address family      */
N#define SLNETSOCK_AF_INET                                                   (2)   /**< IPv4 socket (UDP, TCP, etc)     */
N#define SLNETSOCK_AF_INET6                                                  (3)   /**< IPv6 socket (UDP, TCP, etc)     */
N#define SLNETSOCK_AF_RF                                                     (6)   /**< Data include RF parameter, All layer by user (Wifi could be disconnected) */
N#define SLNETSOCK_AF_PACKET                                                 (17)  /**< Network bypass                  */
N
N/* Protocol families, same as address families. */
N#define SLNETSOCK_PF_UNSPEC                                                 SLNETSOCK_AF_UNSPEC
N#define SLNETSOCK_PF_INET                                                   SLNETSOCK_AF_INET
N#define SLNETSOCK_PF_INET6                                                  SLNETSOCK_AF_INET6
N
N/* Define argument types specifies the socket type.  */
N#define SLNETSOCK_SOCK_STREAM                                               (1)   /**< TCP Socket                      */
N#define SLNETSOCK_SOCK_DGRAM                                                (2)   /**< UDP Socket                      */
N#define SLNETSOCK_SOCK_RAW                                                  (3)   /**< Raw socket                      */
N#define SLNETSOCK_SOCK_RX_MTR                                               (4)   /**< RX Metrics socket               */
N#define SLNETSOCK_SOCK_MAC_WITH_CCA                                         (5)
N#define SLNETSOCK_SOCK_MAC_WITH_NO_CCA                                      (6)
N#define SLNETSOCK_SOCK_BRIDGE                                               (7)
N#define SLNETSOCK_SOCK_ROUTER                                               (8)
N
N/* Define some BSD protocol constants.  */
N#define SLNETSOCK_PROTO_TCP                                                 (6)   /**< TCP Raw Socket                  */
N#define SLNETSOCK_PROTO_UDP                                                 (17)  /**< UDP Raw Socket                  */
N#define SLNETSOCK_PROTO_RAW                                                 (255) /**< Raw Socket                      */
N#define SLNETSOCK_PROTO_SECURE                                              (100) /**< Secured Socket Layer (SSL,TLS)  */
N
N/* bind any addresses */
N#define SLNETSOCK_INADDR_ANY                                                (0)
N#define SLNETSOCK_IN6ADDR_ANY                                               (0)
N
N
N/* socket options */
N
N/* possible values for the level parameter in slNetSock_setOpt / slNetSock_getOpt */
N#define SLNETSOCK_LVL_SOCKET                                                (1)   /**< Define the socket option category. */
N#define SLNETSOCK_LVL_IP                                                    (2)   /**< Define the IP option category.     */
N#define SLNETSOCK_LVL_PHY                                                   (3)   /**< Define the PHY option category.    */
N
N/* possible values for the option parameter in slNetSock_setOpt / slNetSock_getOpt */
N
N/* socket level options (SLNETSOCK_LVL_SOCKET) */
N#define SLNETSOCK_OPSOCK_RCV_BUF                                            (8)   /**< Setting TCP receive buffer size (window size) - This options takes SlNetSock_Winsize_t struct as parameter                 */
N#define SLNETSOCK_OPSOCK_RCV_TIMEO                                          (20)  /**< Enable receive timeout - This options takes SlNetSock_Timeval_t struct as parameter                                        */
N#define SLNETSOCK_OPSOCK_KEEPALIVE                                          (9)   /**< Connections are kept alive with periodic messages - This options takes SlNetSock_Keepalive_t struct as parameter           */
N#define SLNETSOCK_OPSOCK_KEEPALIVE_TIME                                     (37)  /**< keepalive time out - This options takes <b>uint32_t</b> as parameter                                                       */
N#define SLNETSOCK_OPSOCK_LINGER                                             (13)  /**< Socket lingers on close pending remaining send/receive packets - This options takes SlNetSock_linger_t struct as parameter */
N#define SLNETSOCK_OPSOCK_NON_BLOCKING                                       (24)  /**< Enable/disable nonblocking mode - This options takes SlNetSock_Nonblocking_t struct as parameter                           */
N#define SLNETSOCK_OPSOCK_NON_IP_BOUNDARY                                    (39)  /**< connectionless socket disable rx boundary - This options takes SlNetSock_NonIpBoundary_t struct as parameter               */
N#define SLNETSOCK_OPSOCK_ERROR                                              (58)  /**< Socket level error code                                                                                                    */
N#define SLNETSOCK_OPSOCK_SLNETSOCKSD                                        (59)  /**< Used by the BSD layer in order to retrieve the slnetsock sd                                                                */
N
N/* IP level options (SLNETSOCK_LVL_IP) */
N#define SLNETSOCK_OPIP_MULTICAST_TTL                                        (61)  /**< Specify the TTL value to use for outgoing multicast packet. - This options takes <b>uint8_t</b> as parameter                                                      */
N#define SLNETSOCK_OPIP_ADD_MEMBERSHIP                                       (65)  /**< Join IPv4 multicast membership - This options takes SlNetSock_IpMreq_t struct as parameter                                                                        */
N#define SLNETSOCK_OPIP_DROP_MEMBERSHIP                                      (66)  /**< Leave IPv4 multicast membership - This options takes SlNetSock_IpMreq_t struct as parameter                                                                       */
N#define SLNETSOCK_OPIP_HDRINCL                                              (67)  /**< Raw socket IPv4 header included - This options takes <b>uint32_t</b> as parameter                                                                                 */
N#define SLNETSOCK_OPIP_RAW_RX_NO_HEADER                                     (68)  /**< Proprietary socket option that does not includeIPv4/IPv6 header (and extension headers) on received raw sockets - This options takes <b>uint32_t</b> as parameter */
N#define SLNETSOCK_OPIP_RAW_IPV6_HDRINCL                                     (69)  /**< Transmitted buffer over IPv6 socket contains IPv6 header - This options takes <b>uint32_t</b> as parameter                                                        */
N#define SLNETSOCK_OPIPV6_ADD_MEMBERSHIP                                     (70)  /**< Join IPv6 multicast membership - This options takes SlNetSock_IpV6Mreq_t struct as parameter                                                                      */
N#define SLNETSOCK_OPIPV6_DROP_MEMBERSHIP                                    (71)  /**< Leave IPv6 multicast membership - This options takes SlNetSock_IpV6Mreq_t struct as parameter                                                                     */
N#define SLNETSOCK_OPIPV6_MULTICAST_HOPS                                     (72)  /**< Specify the hops value to use for outgoing multicast packet.                                                                                                      */
N
N/* PHY level options (SLNETSOCK_LVL_PHY) */
N#define SLNETSOCK_OPPHY_CHANNEL                                             (28)  /**< This option is available only when transceiver started - This options takes <b>uint32_t</b> as channel number parameter            */
N#define SLNETSOCK_OPPHY_RATE                                                (100) /**< WLAN Transmit rate - This options takes <b>uint32_t</b> as parameter based on SlWlanRateIndex_e                                    */
N#define SLNETSOCK_OPPHY_TX_POWER                                            (101) /**< TX Power level - This options takes <b>uint32_t</b> as parameter                                                                   */
N#define SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX                                    (102) /**< Number of frames to transmit - This options takes <b>uint32_t</b> as parameter                                                     */
N#define SLNETSOCK_OPPHY_PREAMBLE                                            (103) /**< Preamble for transmission - This options takes <b>uint32_t</b> as parameter                                                        */
N#define SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD                                (104) /**< TX Inhibit Threshold (CCA) - This options takes <b>uint32_t</b> as parameter based on SlNetSockTxInhibitThreshold_e                */
N#define SLNETSOCK_OPPHY_TX_TIMEOUT                                          (105) /**< TX timeout for Transceiver frames (lifetime) in miliseconds (max value is 100ms) - This options takes <b>uint32_t</b> as parameter */
N#define SLNETSOCK_OPPHY_ALLOW_ACKS                                          (106) /**< Enable sending ACKs in transceiver mode - This options takes <b>uint32_t</b> as parameter                                          */
N
N/*!
N    \brief The SlNetSockTxInhibitThreshold_e enumerations is used in SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD PHY level option
N*/
Ntypedef enum
N{
N    SLNETSOCK_TX_INHIBIT_THRESHOLD_MIN     = 1,
N    SLNETSOCK_TX_INHIBIT_THRESHOLD_LOW     = 2,
N    SLNETSOCK_TX_INHIBIT_THRESHOLD_DEFAULT = 3,
N    SLNETSOCK_TX_INHIBIT_THRESHOLD_MED     = 4,
N    SLNETSOCK_TX_INHIBIT_THRESHOLD_HIGH    = 5,
N    SLNETSOCK_TX_INHIBIT_THRESHOLD_MAX     = 6
N} SlNetSockTxInhibitThreshold_e;
N
N/*!
N    \brief  The SlNetSockSecAttrib_e enumerations are used to declare security
N            attribute objects in SlNetSock_secAttribSet().
N
N    \sa     SlNetSock_secAttribSet()
N*/
Ntypedef enum
N{
N     SLNETSOCK_SEC_ATTRIB_PRIVATE_KEY               = 0,
N     SLNETSOCK_SEC_ATTRIB_LOCAL_CERT                = 1,
N     SLNETSOCK_SEC_ATTRIB_PEER_ROOT_CA              = 2,
N     SLNETSOCK_SEC_ATTRIB_DH_KEY                    = 3,
N     SLNETSOCK_SEC_ATTRIB_METHOD                    = 4,
N     SLNETSOCK_SEC_ATTRIB_CIPHERS                   = 5,
N     SLNETSOCK_SEC_ATTRIB_ALPN                      = 6,
N     SLNETSOCK_SEC_ATTRIB_EXT_CLIENT_CHLNG_RESP     = 7,
N     SLNETSOCK_SEC_ATTRIB_DOMAIN_NAME               = 8,
N
N     /*!
N            @c SLNETSOCK_SEC_ATTRIB_DISABLE_CERT_STORE is
N            currently only supported on CC3x20 devices.
N
N            The certificate store is a file, provided by TI,
N            containing a list of known and trusted root CAs by TI.
N            For more information, see the CC3x20 documentation.
N
N            The certificate store is used only in client mode. Servers
N            use a proprietary root CA to authenticate clients, and
N            therefore cannot use the certificate store.
N
N            Using this attribute allows using root CA which isn't a
N            part of the provided certificate store.
N     */
N
N     SLNETSOCK_SEC_ATTRIB_DISABLE_CERT_STORE = 9
N} SlNetSockSecAttrib_e;
N
N/* available values for SLNETSOCK_SEC_ATTRIB_METHOD */
N#define SLNETSOCK_SEC_METHOD_SSLV3                                          (0)   /**< security metohd SSL v3                            */
N#define SLNETSOCK_SEC_METHOD_TLSV1                                          (1)   /**< security metohd TLS v1                            */
N#define SLNETSOCK_SEC_METHOD_TLSV1_1                                        (2)   /**< security metohd TLS v1_1                          */
N#define SLNETSOCK_SEC_METHOD_TLSV1_2                                        (3)   /**< security metohd TLS v1_2                          */
N#define SLNETSOCK_SEC_METHOD_SSLv3_TLSV1_2                                  (4)   /**< use highest possible version from SSLv3 - TLS 1.2 */
N#define SLNETSOCK_SEC_METHOD_DLSV1                                          (5)   /**< security metohd DTL v1                            */
N
N/* available values for SLNETSOCK_SEC_ATTRIB_CIPHERS. The value is bitmap! */
N#define SLNETSOCK_SEC_CIPHER_SSL_RSA_WITH_RC4_128_SHA                       (1 << 0)
N#define SLNETSOCK_SEC_CIPHER_SSL_RSA_WITH_RC4_128_MD5                       (1 << 1)
N#define SLNETSOCK_SEC_CIPHER_TLS_RSA_WITH_AES_256_CBC_SHA                   (1 << 2)
N#define SLNETSOCK_SEC_CIPHER_TLS_DHE_RSA_WITH_AES_256_CBC_SHA               (1 << 3)
N#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA             (1 << 4)
N#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_RSA_WITH_RC4_128_SHA                 (1 << 5)
N#define SLNETSOCK_SEC_CIPHER_TLS_RSA_WITH_AES_128_CBC_SHA256                (1 << 6)
N#define SLNETSOCK_SEC_CIPHER_TLS_RSA_WITH_AES_256_CBC_SHA256                (1 << 7)
N#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256          (1 << 8)
N#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256        (1 << 9)
N#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA           (1 << 10)
N#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA           (1 << 11)
N#define SLNETSOCK_SEC_CIPHER_TLS_RSA_WITH_AES_128_GCM_SHA256                (1 << 12)
N#define SLNETSOCK_SEC_CIPHER_TLS_RSA_WITH_AES_256_GCM_SHA384                (1 << 13)
N#define SLNETSOCK_SEC_CIPHER_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256            (1 << 14)
N#define SLNETSOCK_SEC_CIPHER_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384            (1 << 15)
N#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256          (1 << 16)
N#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384          (1 << 17)
N#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256        (1 << 18)
N#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384        (1 << 19)
N#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256  (1 << 20)
N#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256    (1 << 21)
N#define SLNETSOCK_SEC_CIPHER_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256      (1 << 22)
N#define SLNETSOCK_SEC_CIPHER_FULL_LIST                                      (0xFFFFFFFF)
N
N/* available values for SLNETSOCK_SEC_ATTRIB_ALPN */
N#define SLNETSOCK_SEC_ALPN_H1                                               (1 << 0)
N#define SLNETSOCK_SEC_ALPN_H2                                               (1 << 1)
N#define SLNETSOCK_SEC_ALPN_H2C                                              (1 << 2)
N#define SLNETSOCK_SEC_ALPN_H2_14                                            (1 << 3)
N#define SLNETSOCK_SEC_ALPN_H2_16                                            (1 << 4)
N#define SLNETSOCK_SEC_ALPN_FULL_LIST                                        ((SLNETSOCK_SEC_ALPN_H2_16 << 1 ) - 1)
N
N/* available values for the flags of the SlNetSock_startSec function */
N#define SLNETSOCK_SEC_START_SECURITY_SESSION_ONLY                           (1 << 0) /**< Sends the command that will start the security session for a specific socket descriptor */
N#define SLNETSOCK_SEC_BIND_CONTEXT_ONLY                                     (1 << 1) /**< Binds the security context to a specific socket descriptor */
N#define SLNETSOCK_SEC_IS_SERVER                                             (1 << 2) /**< Used to define if the socket is client/server socket       */
N
N/* available values for the flags of the SlNetSock_create function */
N
N#define SLNETSOCK_CREATE_IF_STATE_ENABLE                                    (1 << 0) /**< Creation of the socket will be on enabled state      */
N#define SLNETSOCK_CREATE_IF_STATUS_CONNECTED                                (1 << 1) /**< Creation of the socket will be on status connected   */
N#define SLNETSOCK_CREATE_ALLOW_PARTIAL_MATCH                                (1 << 2) /**< Creation of the socket will be on the interface with
N                                                                                        the highest priority if the other flags will fail    */
N
N/* Definitions for shutting down some or all parts of a full duplex connection */
N#define SLNETSOCK_SHUT_RD                                                   (0) /**< Further receptions will be disallowed                   */
N#define SLNETSOCK_SHUT_WR                                                   (1) /**< Further transmissions will be disallowed                */
N#define SLNETSOCK_SHUT_RDWR                                                 (2) /**< Further receptions and transmissions will be disallowed */
N
N/* Length of address string representation  */
N#define SLNETSOCK_INET6_ADDRSTRLEN                                          (40)
N#define SLNETSOCK_INET_ADDRSTRLEN                                           (15)
N
N/* flags used in send/recv and friends.
N *
N * Note these flags must not exceed 24-bits.  The implementation will
N * OR the 8-bits of security flags into the remaining high 8 bits of
N * 32-bit flag variables.
N */
N#define SLNETSOCK_MSG_OOB         (0x0001)
N#define SLNETSOCK_MSG_PEEK        (0x0002)
N#define SLNETSOCK_MSG_WAITALL     (0x0004)
N#define SLNETSOCK_MSG_DONTWAIT    (0x0008)
N#define SLNETSOCK_MSG_DONTROUTE   (0x0010)
N#define SLNETSOCK_MSG_NOSIGNAL    (0x0020)
N
N
N/*****************************************************************************/
N/* Structure/Enum declarations                                               */
N/*****************************************************************************/
N
N/*!
N    \brief Internet address
N*/
Ntypedef struct SlNetSock_InAddr_t
N{
N#ifndef s_addr
N    uint32_t s_addr;  /* Internet address 32 bits */
N#else
S/*!
S    \brief Different representations for in addr for different hosts.
S*/
S    union S_un
S    {
S        uint32_t S_addr;
S        struct
S        {
S            uint8_t s_b1,s_b2,s_b3,s_b4;
S        } S_un_b;
S        struct
S        {
S            uint16_t s_w1,s_w2;
S        } S_un_w;
S    } S_un;
N#endif
N} SlNetSock_InAddr_t;
N
N/*!
N    \brief IpV6 or Ipv6 EUI64
N*/
Ntypedef struct SlNetSock_In6Addr_t
N{
N    union
N    {
N        uint8_t  _S6_u8[16];
N        uint16_t _S6_u16[8];
N        uint32_t _S6_u32[4];
N    } _S6_un;
N} SlNetSock_In6Addr_t;
N
N/*!
N    \brief The SlNetSock_Keepalive_t structure is used in #SLNETSOCK_OPSOCK_KEEPALIVE socket level option
N*/
Ntypedef struct SlNetSock_Keepalive_t
N{
N    uint32_t keepaliveEnabled;      /**< 0 = disabled;1 = enabled; default = 1 */
N} SlNetSock_Keepalive_t;
N
N/*!
N    \brief The SlNetSock_NonIpBoundary_t structure is used in #SLNETSOCK_OPSOCK_NON_IP_BOUNDARY socket level option
N*/
Ntypedef struct SlNetSock_NonIpBoundary_t
N{
N    int32_t nonIpBoundaryEnabled;   /**< 0 = keep IP boundary; 1 = don`t keep ip boundary; default = 0; */
N} SlNetSock_NonIpBoundary_t;
N
N/*!
N    \brief The SlNetSock_Winsize_t structure is used in #SLNETSOCK_OPSOCK_RCV_BUF socket level option
N*/
Ntypedef struct SlNetSock_Winsize_t
N{
N    uint32_t winSize;               /**< receive window size for tcp sockets   */
N} SlNetSock_Winsize_t;
N
N/*!
N    \brief The SlNetSock_Nonblocking_t structure is used in #SLNETSOCK_OPSOCK_NON_BLOCKING socket level option
N*/
Ntypedef struct SlNetSock_Nonblocking_t
N{
N    uint32_t nonBlockingEnabled;    /**< 0 = disabled, 1 = enabled, default = 1*/
N} SlNetSock_Nonblocking_t;
N
N/*!
N    \brief Secure socket attribute context
N*/
Ntypedef struct SlNetSock_SecAttribNode_t
N{
N    SlNetSockSecAttrib_e              attribName;    /**< Security attribute name          */
N    uint8_t                          *attribBuff;    /**< Security attribute buffer        */
N    uint16_t                          attribBuffLen; /**< Security attribute buffer length */
N    struct SlNetSock_SecAttribNode_t *next;
N} SlNetSock_SecAttribNode_t;
N
N/*!
N    \brief Secure socket attribute handler
N*/
Ntypedef SlNetSock_SecAttribNode_t * SlNetSockSecAttrib_t;
N
N/*!
N    \brief Secure ALPN structure
N*/
Ntypedef struct SlNetSock_SecureALPN_t
N{
N    uint32_t secureALPN;
N} SlNetSock_SecureALPN_t;
N
N/*!
N    \brief Secure Mask structure
N*/
Ntypedef struct SlNetSock_SecureMask_t
N{
N    uint32_t secureMask;
N} SlNetSock_SecureMask_t;
N
N/*!
N    \brief Secure Method structure
N*/
Ntypedef struct SlNetSock_SecureMethod_t
N{
N    uint8_t secureMethod;
N} SlNetSock_SecureMethod_t;
N
N/*!
N    \brief The SlNetSock_IpMreq_t structure is used in #SLNETSOCK_OPIP_ADD_MEMBERSHIP and #SLNETSOCK_OPIP_DROP_MEMBERSHIP IP level option
N*/
Ntypedef struct SlNetSock_IpMreq_t
N{
N    SlNetSock_InAddr_t imr_multiaddr;     /**< The IPv4 multicast address to join  */
N    uint32_t           imr_interface;     /**< The interface to use for this group */
N} SlNetSock_IpMreq_t;
N
N/*!
N    \brief The SlNetSock_IpV6Mreq_t structure is used in #SLNETSOCK_OPIPV6_ADD_MEMBERSHIP and #SLNETSOCK_OPIPV6_DROP_MEMBERSHIP IP level option
N*/
Ntypedef struct SlNetSock_IpV6Mreq_t
N{
N    SlNetSock_In6Addr_t ipv6mr_multiaddr; /**< IPv6 multicast address of group                       */
N    uint32_t            ipv6mr_interface; /**< should be 0 to choose the default multicast interface */
N} SlNetSock_IpV6Mreq_t;
N
N/*!
N    \brief The SlNetSock_linger_t structure is used in #SLNETSOCK_OPSOCK_LINGER socket level option
N*/
Ntypedef struct SlNetSock_linger_t
N{
N    uint32_t l_onoff;                    /**< 0 = disabled; 1 = enabled; default = 0; */
N    uint32_t l_linger;                   /**< linger time in seconds; default = 0;    */
N} SlNetSock_linger_t;
N
N/*!
N    \brief The SlNetSockTime_t is used for setting/getting time in seconds
N*/
Ntypedef int32_t SlNetSockTime_t;
N/*!
N    \brief The SlNetSockuseconds_t is used for setting/getting time in micro-seconds
N*/
Ntypedef int32_t SlNetSockuseconds_t;
N
N/*!
N    \brief The SlNetSock_Timeval_t structure is used in #SLNETSOCK_OPSOCK_RCV_TIMEO socket level option
N*/
Ntypedef struct SlNetSock_Timeval_t
N{
N    SlNetSockTime_t      tv_sec;         /**< Seconds      */
N    SlNetSockuseconds_t  tv_usec;        /**< Microseconds */
N} SlNetSock_Timeval_t;
N
N/*!
N    \brief The SlNetSocklen_t is used for declaring the socket length parameter
N*/
Ntypedef uint16_t SlNetSocklen_t;
N
N/*!
N    \brief IpV4 socket address
N*/
Ntypedef struct SlNetSock_Addr_t
N{
N    uint16_t sa_family;                  /**< Address family (e.g. , AF_INET)        */
N    uint8_t  sa_data[14];                /**< Protocol- specific address information */
N} SlNetSock_Addr_t;
N
N/*!
N    \brief SlNetSock IPv6 address, Internet style
N*/
Ntypedef struct SlNetSock_AddrIn6_t
N{
N    uint16_t            sin6_family;     /**< SLNETSOCK_AF_INET6             */
N    uint16_t            sin6_port;       /**< Transport layer port.          */
N    uint32_t            sin6_flowinfo;   /**< IPv6 flow information.         */
N    SlNetSock_In6Addr_t sin6_addr;       /**< IPv6 address.                  */
N    uint32_t            sin6_scope_id;   /**< set of interfaces for a scope. */
N} SlNetSock_AddrIn6_t;
N
N/*!
N    \brief SlNetSock IPv4 address, Internet style
N*/
Ntypedef struct SlNetSock_AddrIn_t
N{
N    uint16_t           sin_family;       /**< Internet Protocol (AF_INET). */
N    uint16_t           sin_port;         /**< Address port (16 bits).      */
N    SlNetSock_InAddr_t sin_addr;         /**< Internet address (32 bits).  */
N    int8_t             sin_zero[8];      /**< Not used.                    */
N} SlNetSock_AddrIn_t;
N
N/*!
N    \brief The SlNetSock_SdSet_t structure holds the sd array for SlNetSock_select function
N*/
Ntypedef struct SlNetSock_SdSet_t         /**< The select socket array manager */
N{
N    uint32_t sdSetBitmap[(SLNETSOCK_MAX_CONCURRENT_SOCKETS + (uint8_t)31)/(uint8_t)32]; /* Bitmap of SOCKET Descriptors */
X    uint32_t sdSetBitmap[((32) + (uint8_t)31)/(uint8_t)32];  
N} SlNetSock_SdSet_t;
N
N
N/*!
N    \brief The SlNetSock_TransceiverRxOverHead_t structure holds the data for Rx transceiver mode using a raw socket when using SlNetSock_recv function
N*/
Ntypedef struct SlNetSock_TransceiverRxOverHead_t
N{
N    uint8_t  rate;                       /**< Received Rate                                  */
N    uint8_t  channel;                    /**< The received channel                           */
N    int8_t   rssi;                       /**< The computed RSSI value in db of current frame */
N    uint8_t  padding;                    /**< pad to align to 32 bits                        */
N    uint32_t timestamp;                  /**< Timestamp in microseconds                      */
N} SlNetSock_TransceiverRxOverHead_t;
N
N
N/* SlNetSock modules include */
N
N#include "slnetif.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/net/slnetif.h" 1
N/*
N * Copyright (c) 2017, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N
N#ifndef __SL_NET_IF_H__
N#define __SL_NET_IF_H__
N
N
N#ifdef    __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
L 1 "/opt/ti/ccs-latest/ccsv7/tools/compiler/ti-cgt-arm_16.9.6.LTS/include/stdbool.h" 1
N/*
N * Copyright (c) 2000 Jeroen Ruigrok van der Werven <asmodai@FreeBSD.org>
N * All rights reserved.
N *
N * Copyright (c) 2014-2014 Texas Instruments Incorporated
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * $FreeBSD: release/10.0.0/include/stdbool.h 228878 2011-12-25 20:15:41Z ed $
N */
N
N#ifndef __bool_true_false_are_defined
N#define	__bool_true_false_are_defined	1
N
N#ifndef __cplusplus
N
N#define	false	0
N#define	true	1
N
N#define	bool	_Bool
N#if __TI_STRICT_ANSI_MODE__ && 199901L > __STDC_VERSION__
X#if 0 && 199901L > 199409L
Stypedef unsigned char _Bool;
N#endif
N
N#endif /* !__cplusplus */
N#endif /* __bool_true_false_are_defined */
L 47 "/vagrant/Q4_04/sdk_root/source/ti/net/slnetif.h" 2
N
N#include <ti/net/slnetsock.h>
L 1 "/vagrant/Q4_04/sdk_root/source/ti/net/slnetsock.h" 1
N/*
N * Copyright (c) 2017, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N /*!
N
N
N  \page SlNetSock_overview SlNetSock
N
N  \section intro_sec Introduction
N
NSlNetSock provides a standard BSD API for TCP and UDP transport
Nlayers, and a lower-level SlNetSock API for basic and extended
Nusage. Supported use cases include:
N
N - Support of multi interface (WiFi NS, Ethernet NDK)
N - Selecting which interfaces the host will use, one or more.
N - Support of different types of sockets (TCP, TLS, UDP, RAW, RF, etc.)
N - BSD and proprietary errors
N
N The SlNetSock API's lead to easier portability to microcontrollers,
N without compromising the capabilities and robustness of the final
N application.
N
N
N \section modules_sec Module Names
N TI's SlNetSock layer is divided into the following software modules:
N     -# \ref SlNetSock  - Controls standard client/server sockets options and capabilities
N     -# \ref SlNetIf    - Controls standard stack/interface options and capabilities
N     -# \ref SlNetUtils - Provides sockets related commands and configuration
N     -# \ref SlNetErr   - Provide BSD and proprietary errors
N
NIn addition, SlNetSock provides a standard BSD API, built atop the
NSlNet* APIs.  The BSD headers are placed in ti/net/bsd directory,
Nwhich users should place on their include path.
N
NAlso, there is a light
N\subpage porting_guide "SL Interface Porting Guide"
Nwith information available for adding SlNetSock support for other stacks.
N
N  \page porting_guide SL Interface Porting Guide
N
N \section Introduction
N
NThe generic SlNetSock layer sits between the application/service and
Nthe interface stack.  This guide describes the details of adding a network stack into the SlNetSock environment.
N
NThe porting steps for adding new interface:
N    -# Create slnetifxxx file for the new interface
N    -# Select the capabilities set
N    -# Adding the interface to your application/service
N    -# Add the relevant functions to your application/service
N    -# Test your code to validate the correctness of your porting
N
N  \subsection porting_step1   Step 1 - slnetifxxx.c and slnetifxxx.h file for your interface
N
N - Create slnetifxxx file (replace xxx with your interface/stack
N   name).  Likely you will copy from an existing port.
N
N - Implement the needed API's.
N
NEach interface needs to provide a set of API's to work with the
Ninterface.  Some are mandatory, others are optional (but recommended).
N
N - Mandatory API's:
N  - \ref SlNetIf_Config_t.sockCreate            "sockCreate"
N  - \ref SlNetIf_Config_t.sockClose             "sockClose"
N  - \ref SlNetIf_Config_t.sockSelect            "sockSelect"
N  - \ref SlNetIf_Config_t.sockSetOpt            "sockSetOpt"
N  - \ref SlNetIf_Config_t.sockGetOpt            "sockGetOpt"
N  - \ref SlNetIf_Config_t.sockRecvFrom          "sockRecvFrom"
N  - \ref SlNetIf_Config_t.sockSendTo            "sockSendTo"
N  - \ref SlNetIf_Config_t.ifGetIPAddr           "ifGetIPAddr"
N  - \ref SlNetIf_Config_t.ifGetConnectionStatus "ifGetConnectionStatus"
N
N - The non-mandatory API's set:
N  - \ref SlNetIf_Config_t.sockShutdown          "sockShutdown"
N  - \ref SlNetIf_Config_t.sockAccept            "sockAccept"
N  - \ref SlNetIf_Config_t.sockBind              "sockBind"
N  - \ref SlNetIf_Config_t.sockListen            "sockListen"
N  - \ref SlNetIf_Config_t.sockConnect           "sockConnect"
N  - \ref SlNetIf_Config_t.sockGetPeerName       "sockGetPeerName"
N  - \ref SlNetIf_Config_t.sockGetLocalName      "sockGetLocalName"
N  - \ref SlNetIf_Config_t.sockRecv              "sockRecv"
N  - \ref SlNetIf_Config_t.sockSend              "sockSend"
N  - \ref SlNetIf_Config_t.sockstartSec          "sockstartSec"
N  - \ref SlNetIf_Config_t.utilGetHostByName     "utilGetHostByName"
N  - \ref SlNetIf_Config_t.ifLoadSecObj          "ifLoadSecOjb"
N  - \ref SlNetIf_Config_t.ifCreateContext       "ifCreateContext"
N
N
N  \note The list of API's and more data can be found in ::SlNetIf_Config_t structure in SlNetIf module \n \n
N
N \subsection    porting_step2   Step 2 - Select the capabilities set
N
N The capabilities prototype should be declared in your slnetifxxx.h and implemented in your slnetifxxx.c
N
N Each mandatory API's must be set, additional API's can be set or must
N be set to NULL.
N
N An example config declaration for TI's SimpleLink CC31XX/CC32xx
N
N \code
N SlNetIfConfig SlNetIfConfigWiFi =
N {
N    SlNetIfWifi_socket,              // Callback function sockCreate in slnetif module
N    SlNetIfWifi_close,               // Callback function sockClose in slnetif module
N    NULL,                            // Callback function sockShutdown in slnetif module
N    SlNetIfWifi_accept,              // Callback function sockAccept in slnetif module
N    SlNetIfWifi_bind,                // Callback function sockBind in slnetif module
N    SlNetIfWifi_listen,              // Callback function sockListen in slnetif module
N    SlNetIfWifi_connect,             // Callback function sockConnect in slnetif module
N    NULL,                            // Callback function sockGetPeerName in slnetif module
N    NULL,                            // Callback function sockGetLocalName in slnetif module
N    SlNetIfWifi_select,              // Callback function sockSelect in slnetif module
N    SlNetIfWifi_setSockOpt,          // Callback function sockSetOpt in slnetif module
N    SlNetIfWifi_getSockOpt,          // Callback function sockGetOpt in slnetif module
N    SlNetIfWifi_recv,                // Callback function sockRecv in slnetif module
N    SlNetIfWifi_recvFrom,            // Callback function sockRecvFrom in slnetif module
N    SlNetIfWifi_send,                // Callback function sockSend in slnetif module
N    SlNetIfWifi_sendTo,              // Callback function sockSendTo in slnetif module
N    SlNetIfWifi_sockstartSec,        // Callback function sockstartSec in slnetif module
N    SlNetIfWifi_getHostByName,       // Callback function utilGetHostByName in slnetif module
N    SlNetIfWifi_getIPAddr,           // Callback function ifGetIPAddr in slnetif module
N    SlNetIfWifi_getConnectionStatus, // Callback function ifGetConnectionStatus in slnetif module
N    SlNetIfWifi_loadSecObj,          // Callback function ifLoadSecObj in slnetif module
N    NULL                             // Callback function ifCreateContext in slnetif module
N };
N \endcode
N
N In the example above the following API's are not supported by the interface,
N and are set to NULL:
N - sockShutdown
N - sockGetPeerName
N - sockGetLocalName
N - utilGetHostByName
N - ifCreateContext
N
N \subsection    porting_step3   Step 3 - Adding the interface to your application/service
N
N \b Include the new file in the board header file in the application.
N
N \subsection    porting_step4   Step 4 - Add the relevant functions to your application/service
N
N  After configuring the capabilities of the interface, Adding the interface to the SlNetSock
N  is required.
N
N  Use ::SlNetIf_add in order to add the interface and set his ID, Name, function list and priority.
N  Later on you need to use the BSD API's or SlNetSock API's for socket handling.
N
N \subsection    porting_step5   Step 5 - Test your code to validate the correctness of your porting
N
N After porting the layer into your setup, validate that your code work as expected
N
N*/
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N
N#ifndef __SL_NET_SOCK_H__
S#define __SL_NET_SOCK_H__
S
S
S#ifdef    __cplusplus
Sextern "C" {
S#endif
S
S#include <stdint.h>
S
S/*!
S    \defgroup SlNetSock SlNetSock group
S
S    \short Controls standard client/server sockets options and capabilities
S
S*/
S/*!
S
S    \addtogroup SlNetSock
S    @{
S
S*/
S
S/*****************************************************************************/
S/* Macro declarations                                                        */
S/*****************************************************************************/
S
S#define SLNETSOCK_MAX_CONCURRENT_SOCKETS                                    (32)  /**< Declares the maximum sockets that can be opened */
S
S/* Address families.  */
S#define SLNETSOCK_AF_UNSPEC                                                 (0)   /**< Unspecified address family      */
S#define SLNETSOCK_AF_INET                                                   (2)   /**< IPv4 socket (UDP, TCP, etc)     */
S#define SLNETSOCK_AF_INET6                                                  (3)   /**< IPv6 socket (UDP, TCP, etc)     */
S#define SLNETSOCK_AF_RF                                                     (6)   /**< Data include RF parameter, All layer by user (Wifi could be disconnected) */
S#define SLNETSOCK_AF_PACKET                                                 (17)  /**< Network bypass                  */
S
S/* Protocol families, same as address families. */
S#define SLNETSOCK_PF_UNSPEC                                                 SLNETSOCK_AF_UNSPEC
S#define SLNETSOCK_PF_INET                                                   SLNETSOCK_AF_INET
S#define SLNETSOCK_PF_INET6                                                  SLNETSOCK_AF_INET6
S
S/* Define argument types specifies the socket type.  */
S#define SLNETSOCK_SOCK_STREAM                                               (1)   /**< TCP Socket                      */
S#define SLNETSOCK_SOCK_DGRAM                                                (2)   /**< UDP Socket                      */
S#define SLNETSOCK_SOCK_RAW                                                  (3)   /**< Raw socket                      */
S#define SLNETSOCK_SOCK_RX_MTR                                               (4)   /**< RX Metrics socket               */
S#define SLNETSOCK_SOCK_MAC_WITH_CCA                                         (5)
S#define SLNETSOCK_SOCK_MAC_WITH_NO_CCA                                      (6)
S#define SLNETSOCK_SOCK_BRIDGE                                               (7)
S#define SLNETSOCK_SOCK_ROUTER                                               (8)
S
S/* Define some BSD protocol constants.  */
S#define SLNETSOCK_PROTO_TCP                                                 (6)   /**< TCP Raw Socket                  */
S#define SLNETSOCK_PROTO_UDP                                                 (17)  /**< UDP Raw Socket                  */
S#define SLNETSOCK_PROTO_RAW                                                 (255) /**< Raw Socket                      */
S#define SLNETSOCK_PROTO_SECURE                                              (100) /**< Secured Socket Layer (SSL,TLS)  */
S
S/* bind any addresses */
S#define SLNETSOCK_INADDR_ANY                                                (0)
S#define SLNETSOCK_IN6ADDR_ANY                                               (0)
S
S
S/* socket options */
S
S/* possible values for the level parameter in slNetSock_setOpt / slNetSock_getOpt */
S#define SLNETSOCK_LVL_SOCKET                                                (1)   /**< Define the socket option category. */
S#define SLNETSOCK_LVL_IP                                                    (2)   /**< Define the IP option category.     */
S#define SLNETSOCK_LVL_PHY                                                   (3)   /**< Define the PHY option category.    */
S
S/* possible values for the option parameter in slNetSock_setOpt / slNetSock_getOpt */
S
S/* socket level options (SLNETSOCK_LVL_SOCKET) */
S#define SLNETSOCK_OPSOCK_RCV_BUF                                            (8)   /**< Setting TCP receive buffer size (window size) - This options takes SlNetSock_Winsize_t struct as parameter                 */
S#define SLNETSOCK_OPSOCK_RCV_TIMEO                                          (20)  /**< Enable receive timeout - This options takes SlNetSock_Timeval_t struct as parameter                                        */
S#define SLNETSOCK_OPSOCK_KEEPALIVE                                          (9)   /**< Connections are kept alive with periodic messages - This options takes SlNetSock_Keepalive_t struct as parameter           */
S#define SLNETSOCK_OPSOCK_KEEPALIVE_TIME                                     (37)  /**< keepalive time out - This options takes <b>uint32_t</b> as parameter                                                       */
S#define SLNETSOCK_OPSOCK_LINGER                                             (13)  /**< Socket lingers on close pending remaining send/receive packets - This options takes SlNetSock_linger_t struct as parameter */
S#define SLNETSOCK_OPSOCK_NON_BLOCKING                                       (24)  /**< Enable/disable nonblocking mode - This options takes SlNetSock_Nonblocking_t struct as parameter                           */
S#define SLNETSOCK_OPSOCK_NON_IP_BOUNDARY                                    (39)  /**< connectionless socket disable rx boundary - This options takes SlNetSock_NonIpBoundary_t struct as parameter               */
S#define SLNETSOCK_OPSOCK_ERROR                                              (58)  /**< Socket level error code                                                                                                    */
S#define SLNETSOCK_OPSOCK_SLNETSOCKSD                                        (59)  /**< Used by the BSD layer in order to retrieve the slnetsock sd                                                                */
S
S/* IP level options (SLNETSOCK_LVL_IP) */
S#define SLNETSOCK_OPIP_MULTICAST_TTL                                        (61)  /**< Specify the TTL value to use for outgoing multicast packet. - This options takes <b>uint8_t</b> as parameter                                                      */
S#define SLNETSOCK_OPIP_ADD_MEMBERSHIP                                       (65)  /**< Join IPv4 multicast membership - This options takes SlNetSock_IpMreq_t struct as parameter                                                                        */
S#define SLNETSOCK_OPIP_DROP_MEMBERSHIP                                      (66)  /**< Leave IPv4 multicast membership - This options takes SlNetSock_IpMreq_t struct as parameter                                                                       */
S#define SLNETSOCK_OPIP_HDRINCL                                              (67)  /**< Raw socket IPv4 header included - This options takes <b>uint32_t</b> as parameter                                                                                 */
S#define SLNETSOCK_OPIP_RAW_RX_NO_HEADER                                     (68)  /**< Proprietary socket option that does not includeIPv4/IPv6 header (and extension headers) on received raw sockets - This options takes <b>uint32_t</b> as parameter */
S#define SLNETSOCK_OPIP_RAW_IPV6_HDRINCL                                     (69)  /**< Transmitted buffer over IPv6 socket contains IPv6 header - This options takes <b>uint32_t</b> as parameter                                                        */
S#define SLNETSOCK_OPIPV6_ADD_MEMBERSHIP                                     (70)  /**< Join IPv6 multicast membership - This options takes SlNetSock_IpV6Mreq_t struct as parameter                                                                      */
S#define SLNETSOCK_OPIPV6_DROP_MEMBERSHIP                                    (71)  /**< Leave IPv6 multicast membership - This options takes SlNetSock_IpV6Mreq_t struct as parameter                                                                     */
S#define SLNETSOCK_OPIPV6_MULTICAST_HOPS                                     (72)  /**< Specify the hops value to use for outgoing multicast packet.                                                                                                      */
S
S/* PHY level options (SLNETSOCK_LVL_PHY) */
S#define SLNETSOCK_OPPHY_CHANNEL                                             (28)  /**< This option is available only when transceiver started - This options takes <b>uint32_t</b> as channel number parameter            */
S#define SLNETSOCK_OPPHY_RATE                                                (100) /**< WLAN Transmit rate - This options takes <b>uint32_t</b> as parameter based on SlWlanRateIndex_e                                    */
S#define SLNETSOCK_OPPHY_TX_POWER                                            (101) /**< TX Power level - This options takes <b>uint32_t</b> as parameter                                                                   */
S#define SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX                                    (102) /**< Number of frames to transmit - This options takes <b>uint32_t</b> as parameter                                                     */
S#define SLNETSOCK_OPPHY_PREAMBLE                                            (103) /**< Preamble for transmission - This options takes <b>uint32_t</b> as parameter                                                        */
S#define SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD                                (104) /**< TX Inhibit Threshold (CCA) - This options takes <b>uint32_t</b> as parameter based on SlNetSockTxInhibitThreshold_e                */
S#define SLNETSOCK_OPPHY_TX_TIMEOUT                                          (105) /**< TX timeout for Transceiver frames (lifetime) in miliseconds (max value is 100ms) - This options takes <b>uint32_t</b> as parameter */
S#define SLNETSOCK_OPPHY_ALLOW_ACKS                                          (106) /**< Enable sending ACKs in transceiver mode - This options takes <b>uint32_t</b> as parameter                                          */
S
S/*!
S    \brief The SlNetSockTxInhibitThreshold_e enumerations is used in SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD PHY level option
S*/
Stypedef enum
S{
S    SLNETSOCK_TX_INHIBIT_THRESHOLD_MIN     = 1,
S    SLNETSOCK_TX_INHIBIT_THRESHOLD_LOW     = 2,
S    SLNETSOCK_TX_INHIBIT_THRESHOLD_DEFAULT = 3,
S    SLNETSOCK_TX_INHIBIT_THRESHOLD_MED     = 4,
S    SLNETSOCK_TX_INHIBIT_THRESHOLD_HIGH    = 5,
S    SLNETSOCK_TX_INHIBIT_THRESHOLD_MAX     = 6
S} SlNetSockTxInhibitThreshold_e;
S
S/*!
S    \brief  The SlNetSockSecAttrib_e enumerations are used to declare security
S            attribute objects in SlNetSock_secAttribSet().
S
S    \sa     SlNetSock_secAttribSet()
S*/
Stypedef enum
S{
S     SLNETSOCK_SEC_ATTRIB_PRIVATE_KEY               = 0,
S     SLNETSOCK_SEC_ATTRIB_LOCAL_CERT                = 1,
S     SLNETSOCK_SEC_ATTRIB_PEER_ROOT_CA              = 2,
S     SLNETSOCK_SEC_ATTRIB_DH_KEY                    = 3,
S     SLNETSOCK_SEC_ATTRIB_METHOD                    = 4,
S     SLNETSOCK_SEC_ATTRIB_CIPHERS                   = 5,
S     SLNETSOCK_SEC_ATTRIB_ALPN                      = 6,
S     SLNETSOCK_SEC_ATTRIB_EXT_CLIENT_CHLNG_RESP     = 7,
S     SLNETSOCK_SEC_ATTRIB_DOMAIN_NAME               = 8,
S
S     /*!
S            @c SLNETSOCK_SEC_ATTRIB_DISABLE_CERT_STORE is
S            currently only supported on CC3x20 devices.
S
S            The certificate store is a file, provided by TI,
S            containing a list of known and trusted root CAs by TI.
S            For more information, see the CC3x20 documentation.
S
S            The certificate store is used only in client mode. Servers
S            use a proprietary root CA to authenticate clients, and
S            therefore cannot use the certificate store.
S
S            Using this attribute allows using root CA which isn't a
S            part of the provided certificate store.
S     */
S
S     SLNETSOCK_SEC_ATTRIB_DISABLE_CERT_STORE = 9
S} SlNetSockSecAttrib_e;
S
S/* available values for SLNETSOCK_SEC_ATTRIB_METHOD */
S#define SLNETSOCK_SEC_METHOD_SSLV3                                          (0)   /**< security metohd SSL v3                            */
S#define SLNETSOCK_SEC_METHOD_TLSV1                                          (1)   /**< security metohd TLS v1                            */
S#define SLNETSOCK_SEC_METHOD_TLSV1_1                                        (2)   /**< security metohd TLS v1_1                          */
S#define SLNETSOCK_SEC_METHOD_TLSV1_2                                        (3)   /**< security metohd TLS v1_2                          */
S#define SLNETSOCK_SEC_METHOD_SSLv3_TLSV1_2                                  (4)   /**< use highest possible version from SSLv3 - TLS 1.2 */
S#define SLNETSOCK_SEC_METHOD_DLSV1                                          (5)   /**< security metohd DTL v1                            */
S
S/* available values for SLNETSOCK_SEC_ATTRIB_CIPHERS. The value is bitmap! */
S#define SLNETSOCK_SEC_CIPHER_SSL_RSA_WITH_RC4_128_SHA                       (1 << 0)
S#define SLNETSOCK_SEC_CIPHER_SSL_RSA_WITH_RC4_128_MD5                       (1 << 1)
S#define SLNETSOCK_SEC_CIPHER_TLS_RSA_WITH_AES_256_CBC_SHA                   (1 << 2)
S#define SLNETSOCK_SEC_CIPHER_TLS_DHE_RSA_WITH_AES_256_CBC_SHA               (1 << 3)
S#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA             (1 << 4)
S#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_RSA_WITH_RC4_128_SHA                 (1 << 5)
S#define SLNETSOCK_SEC_CIPHER_TLS_RSA_WITH_AES_128_CBC_SHA256                (1 << 6)
S#define SLNETSOCK_SEC_CIPHER_TLS_RSA_WITH_AES_256_CBC_SHA256                (1 << 7)
S#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256          (1 << 8)
S#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256        (1 << 9)
S#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA           (1 << 10)
S#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA           (1 << 11)
S#define SLNETSOCK_SEC_CIPHER_TLS_RSA_WITH_AES_128_GCM_SHA256                (1 << 12)
S#define SLNETSOCK_SEC_CIPHER_TLS_RSA_WITH_AES_256_GCM_SHA384                (1 << 13)
S#define SLNETSOCK_SEC_CIPHER_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256            (1 << 14)
S#define SLNETSOCK_SEC_CIPHER_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384            (1 << 15)
S#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256          (1 << 16)
S#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384          (1 << 17)
S#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256        (1 << 18)
S#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384        (1 << 19)
S#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256  (1 << 20)
S#define SLNETSOCK_SEC_CIPHER_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256    (1 << 21)
S#define SLNETSOCK_SEC_CIPHER_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256      (1 << 22)
S#define SLNETSOCK_SEC_CIPHER_FULL_LIST                                      (0xFFFFFFFF)
S
S/* available values for SLNETSOCK_SEC_ATTRIB_ALPN */
S#define SLNETSOCK_SEC_ALPN_H1                                               (1 << 0)
S#define SLNETSOCK_SEC_ALPN_H2                                               (1 << 1)
S#define SLNETSOCK_SEC_ALPN_H2C                                              (1 << 2)
S#define SLNETSOCK_SEC_ALPN_H2_14                                            (1 << 3)
S#define SLNETSOCK_SEC_ALPN_H2_16                                            (1 << 4)
S#define SLNETSOCK_SEC_ALPN_FULL_LIST                                        ((SLNETSOCK_SEC_ALPN_H2_16 << 1 ) - 1)
S
S/* available values for the flags of the SlNetSock_startSec function */
S#define SLNETSOCK_SEC_START_SECURITY_SESSION_ONLY                           (1 << 0) /**< Sends the command that will start the security session for a specific socket descriptor */
S#define SLNETSOCK_SEC_BIND_CONTEXT_ONLY                                     (1 << 1) /**< Binds the security context to a specific socket descriptor */
S#define SLNETSOCK_SEC_IS_SERVER                                             (1 << 2) /**< Used to define if the socket is client/server socket       */
S
S/* available values for the flags of the SlNetSock_create function */
S
S#define SLNETSOCK_CREATE_IF_STATE_ENABLE                                    (1 << 0) /**< Creation of the socket will be on enabled state      */
S#define SLNETSOCK_CREATE_IF_STATUS_CONNECTED                                (1 << 1) /**< Creation of the socket will be on status connected   */
S#define SLNETSOCK_CREATE_ALLOW_PARTIAL_MATCH                                (1 << 2) /**< Creation of the socket will be on the interface with
S                                                                                        the highest priority if the other flags will fail    */
S
S/* Definitions for shutting down some or all parts of a full duplex connection */
S#define SLNETSOCK_SHUT_RD                                                   (0) /**< Further receptions will be disallowed                   */
S#define SLNETSOCK_SHUT_WR                                                   (1) /**< Further transmissions will be disallowed                */
S#define SLNETSOCK_SHUT_RDWR                                                 (2) /**< Further receptions and transmissions will be disallowed */
S
S/* Length of address string representation  */
S#define SLNETSOCK_INET6_ADDRSTRLEN                                          (40)
S#define SLNETSOCK_INET_ADDRSTRLEN                                           (15)
S
S/* flags used in send/recv and friends.
S *
S * Note these flags must not exceed 24-bits.  The implementation will
S * OR the 8-bits of security flags into the remaining high 8 bits of
S * 32-bit flag variables.
S */
S#define SLNETSOCK_MSG_OOB         (0x0001)
S#define SLNETSOCK_MSG_PEEK        (0x0002)
S#define SLNETSOCK_MSG_WAITALL     (0x0004)
S#define SLNETSOCK_MSG_DONTWAIT    (0x0008)
S#define SLNETSOCK_MSG_DONTROUTE   (0x0010)
S#define SLNETSOCK_MSG_NOSIGNAL    (0x0020)
S
S
S/*****************************************************************************/
S/* Structure/Enum declarations                                               */
S/*****************************************************************************/
S
S/*!
S    \brief Internet address
S*/
Stypedef struct SlNetSock_InAddr_t
S{
S#ifndef s_addr
S    uint32_t s_addr;  /* Internet address 32 bits */
S#else
S/*!
S    \brief Different representations for in addr for different hosts.
S*/
S    union S_un
S    {
S        uint32_t S_addr;
S        struct
S        {
S            uint8_t s_b1,s_b2,s_b3,s_b4;
S        } S_un_b;
S        struct
S        {
S            uint16_t s_w1,s_w2;
S        } S_un_w;
S    } S_un;
S#endif
S} SlNetSock_InAddr_t;
S
S/*!
S    \brief IpV6 or Ipv6 EUI64
S*/
Stypedef struct SlNetSock_In6Addr_t
S{
S    union
S    {
S        uint8_t  _S6_u8[16];
S        uint16_t _S6_u16[8];
S        uint32_t _S6_u32[4];
S    } _S6_un;
S} SlNetSock_In6Addr_t;
S
S/*!
S    \brief The SlNetSock_Keepalive_t structure is used in #SLNETSOCK_OPSOCK_KEEPALIVE socket level option
S*/
Stypedef struct SlNetSock_Keepalive_t
S{
S    uint32_t keepaliveEnabled;      /**< 0 = disabled;1 = enabled; default = 1 */
S} SlNetSock_Keepalive_t;
S
S/*!
S    \brief The SlNetSock_NonIpBoundary_t structure is used in #SLNETSOCK_OPSOCK_NON_IP_BOUNDARY socket level option
S*/
Stypedef struct SlNetSock_NonIpBoundary_t
S{
S    int32_t nonIpBoundaryEnabled;   /**< 0 = keep IP boundary; 1 = don`t keep ip boundary; default = 0; */
S} SlNetSock_NonIpBoundary_t;
S
S/*!
S    \brief The SlNetSock_Winsize_t structure is used in #SLNETSOCK_OPSOCK_RCV_BUF socket level option
S*/
Stypedef struct SlNetSock_Winsize_t
S{
S    uint32_t winSize;               /**< receive window size for tcp sockets   */
S} SlNetSock_Winsize_t;
S
S/*!
S    \brief The SlNetSock_Nonblocking_t structure is used in #SLNETSOCK_OPSOCK_NON_BLOCKING socket level option
S*/
Stypedef struct SlNetSock_Nonblocking_t
S{
S    uint32_t nonBlockingEnabled;    /**< 0 = disabled, 1 = enabled, default = 1*/
S} SlNetSock_Nonblocking_t;
S
S/*!
S    \brief Secure socket attribute context
S*/
Stypedef struct SlNetSock_SecAttribNode_t
S{
S    SlNetSockSecAttrib_e              attribName;    /**< Security attribute name          */
S    uint8_t                          *attribBuff;    /**< Security attribute buffer        */
S    uint16_t                          attribBuffLen; /**< Security attribute buffer length */
S    struct SlNetSock_SecAttribNode_t *next;
S} SlNetSock_SecAttribNode_t;
S
S/*!
S    \brief Secure socket attribute handler
S*/
Stypedef SlNetSock_SecAttribNode_t * SlNetSockSecAttrib_t;
S
S/*!
S    \brief Secure ALPN structure
S*/
Stypedef struct SlNetSock_SecureALPN_t
S{
S    uint32_t secureALPN;
S} SlNetSock_SecureALPN_t;
S
S/*!
S    \brief Secure Mask structure
S*/
Stypedef struct SlNetSock_SecureMask_t
S{
S    uint32_t secureMask;
S} SlNetSock_SecureMask_t;
S
S/*!
S    \brief Secure Method structure
S*/
Stypedef struct SlNetSock_SecureMethod_t
S{
S    uint8_t secureMethod;
S} SlNetSock_SecureMethod_t;
S
S/*!
S    \brief The SlNetSock_IpMreq_t structure is used in #SLNETSOCK_OPIP_ADD_MEMBERSHIP and #SLNETSOCK_OPIP_DROP_MEMBERSHIP IP level option
S*/
Stypedef struct SlNetSock_IpMreq_t
S{
S    SlNetSock_InAddr_t imr_multiaddr;     /**< The IPv4 multicast address to join  */
S    uint32_t           imr_interface;     /**< The interface to use for this group */
S} SlNetSock_IpMreq_t;
S
S/*!
S    \brief The SlNetSock_IpV6Mreq_t structure is used in #SLNETSOCK_OPIPV6_ADD_MEMBERSHIP and #SLNETSOCK_OPIPV6_DROP_MEMBERSHIP IP level option
S*/
Stypedef struct SlNetSock_IpV6Mreq_t
S{
S    SlNetSock_In6Addr_t ipv6mr_multiaddr; /**< IPv6 multicast address of group                       */
S    uint32_t            ipv6mr_interface; /**< should be 0 to choose the default multicast interface */
S} SlNetSock_IpV6Mreq_t;
S
S/*!
S    \brief The SlNetSock_linger_t structure is used in #SLNETSOCK_OPSOCK_LINGER socket level option
S*/
Stypedef struct SlNetSock_linger_t
S{
S    uint32_t l_onoff;                    /**< 0 = disabled; 1 = enabled; default = 0; */
S    uint32_t l_linger;                   /**< linger time in seconds; default = 0;    */
S} SlNetSock_linger_t;
S
S/*!
S    \brief The SlNetSockTime_t is used for setting/getting time in seconds
S*/
Stypedef int32_t SlNetSockTime_t;
S/*!
S    \brief The SlNetSockuseconds_t is used for setting/getting time in micro-seconds
S*/
Stypedef int32_t SlNetSockuseconds_t;
S
S/*!
S    \brief The SlNetSock_Timeval_t structure is used in #SLNETSOCK_OPSOCK_RCV_TIMEO socket level option
S*/
Stypedef struct SlNetSock_Timeval_t
S{
S    SlNetSockTime_t      tv_sec;         /**< Seconds      */
S    SlNetSockuseconds_t  tv_usec;        /**< Microseconds */
S} SlNetSock_Timeval_t;
S
S/*!
S    \brief The SlNetSocklen_t is used for declaring the socket length parameter
S*/
Stypedef uint16_t SlNetSocklen_t;
S
S/*!
S    \brief IpV4 socket address
S*/
Stypedef struct SlNetSock_Addr_t
S{
S    uint16_t sa_family;                  /**< Address family (e.g. , AF_INET)        */
S    uint8_t  sa_data[14];                /**< Protocol- specific address information */
S} SlNetSock_Addr_t;
S
S/*!
S    \brief SlNetSock IPv6 address, Internet style
S*/
Stypedef struct SlNetSock_AddrIn6_t
S{
S    uint16_t            sin6_family;     /**< SLNETSOCK_AF_INET6             */
S    uint16_t            sin6_port;       /**< Transport layer port.          */
S    uint32_t            sin6_flowinfo;   /**< IPv6 flow information.         */
S    SlNetSock_In6Addr_t sin6_addr;       /**< IPv6 address.                  */
S    uint32_t            sin6_scope_id;   /**< set of interfaces for a scope. */
S} SlNetSock_AddrIn6_t;
S
S/*!
S    \brief SlNetSock IPv4 address, Internet style
S*/
Stypedef struct SlNetSock_AddrIn_t
S{
S    uint16_t           sin_family;       /**< Internet Protocol (AF_INET). */
S    uint16_t           sin_port;         /**< Address port (16 bits).      */
S    SlNetSock_InAddr_t sin_addr;         /**< Internet address (32 bits).  */
S    int8_t             sin_zero[8];      /**< Not used.                    */
S} SlNetSock_AddrIn_t;
S
S/*!
S    \brief The SlNetSock_SdSet_t structure holds the sd array for SlNetSock_select function
S*/
Stypedef struct SlNetSock_SdSet_t         /**< The select socket array manager */
S{
S    uint32_t sdSetBitmap[(SLNETSOCK_MAX_CONCURRENT_SOCKETS + (uint8_t)31)/(uint8_t)32]; /* Bitmap of SOCKET Descriptors */
S} SlNetSock_SdSet_t;
S
S
S/*!
S    \brief The SlNetSock_TransceiverRxOverHead_t structure holds the data for Rx transceiver mode using a raw socket when using SlNetSock_recv function
S*/
Stypedef struct SlNetSock_TransceiverRxOverHead_t
S{
S    uint8_t  rate;                       /**< Received Rate                                  */
S    uint8_t  channel;                    /**< The received channel                           */
S    int8_t   rssi;                       /**< The computed RSSI value in db of current frame */
S    uint8_t  padding;                    /**< pad to align to 32 bits                        */
S    uint32_t timestamp;                  /**< Timestamp in microseconds                      */
S} SlNetSock_TransceiverRxOverHead_t;
S
S
S/* SlNetSock modules include */
S
S#include "slnetif.h"
S#include "slnetutils.h"
S#include "slneterr.h"
S
S
S/*****************************************************************************/
S/* Function prototypes                                                       */
S/*****************************************************************************/
S
S/*!
S
S    \brief Initialize the SlNetSock module
S
S    \param[in] flags            Reserved
S
S    \return                     Zero on success, or negative error code on failure
S*/
Sint32_t SlNetSock_init(int32_t flags);
S
S/*!
S
S    \brief Create an endpoint for communication
S
S    SlNetSock_create() creates a new socket of a certain socket type,
S    identified by an integer number, and allocates system resources to it.\n
S    This function is called by the application layer to obtain a socket descriptor (handle).
S
S    \param[in] domain           Specifies the protocol family of the created socket.
S                                For example:
S                                   - #SLNETSOCK_AF_INET for network protocol IPv4
S                                   - #SLNETSOCK_AF_INET6 for network protocol IPv6
S                                   - #SLNETSOCK_AF_RF for starting transceiver mode.
S                                        Notes:
S                                        - sending and receiving any packet overriding 802.11 header
S                                        - for optimized power consumption the socket will be started in TX
S                                            only mode until receive command is activated
S    \param[in] type             Specifies the socket type, which determines the semantics of communication over
S                                the socket. The socket types supported by the system are implementation-dependent.
S                                Possible socket types include:
S                                   - #SLNETSOCK_SOCK_STREAM (reliable stream-oriented service or Stream Sockets)
S                                   - #SLNETSOCK_SOCK_DGRAM  (datagram service or Datagram Sockets)
S                                   - #SLNETSOCK_SOCK_RAW    (raw protocols atop the network layer)
S                                   - when used with AF_RF:
S                                      - #SLNETSOCK_SOCK_RX_MTR
S                                      - #SLNETSOCK_SOCK_MAC_WITH_CCA
S                                      - #SLNETSOCK_SOCK_MAC_WITH_NO_CCA
S                                      - #SLNETSOCK_SOCK_BRIDGE
S                                      - #SLNETSOCK_SOCK_ROUTER
S    \param[in] protocol         Specifies a particular transport to be used with the socket.\n
S                                The most common are
S                                    - #SLNETSOCK_PROTO_TCP
S                                    - #SLNETSOCK_PROTO_UDP
S                                    - #SLNETSOCK_PROTO_RAW
S                                    - #SLNETSOCK_PROTO_SECURE
S    \param[in] ifBitmap         Specifies the interface(s) which the socket will be create on
S                                according to the priority until one of them will return an answer.\n
S                                Value 0 is used in order to choose automatic interfaces selection
S                                according to the priority interface list.
S                                Value can be combination of interfaces by OR'ing multiple interfaces bit identifiers
S                                (SLNETIFC_IDENT_ defined in slnetif.h)
S                                Note: interface identifier bit must be configured prior to this socket creation
S                                using SlNetIf_add().
S    \param[in] flags            Specifies flags.
S                                   - #SLNETSOCK_CREATE_IF_STATE_ENABLE     - Creation of the socket will be on enabled state
S                                   - #SLNETSOCK_CREATE_IF_STATUS_CONNECTED - Creation of the socket will be on status connected
S                                   - #SLNETSOCK_CREATE_ALLOW_PARTIAL_MATCH - Creation of the socket will be on the interface with
S                                                                            the highest priority if the other flags will fail
S                                The value 0 may be used in order to run the default flags:
S                                   - #SLNETSOCK_CREATE_IF_STATE_ENABLE
S                                   - #SLNETSOCK_CREATE_IF_STATUS_CONNECTED
S
S    \return                     On success, socket descriptor (handle) that is used for consequent socket operations. \n
S                                A successful return code should be a positive number\n
S                                On error, a negative value will be returned specifying the error code.
S                                   - #SLNETERR_BSD_EAFNOSUPPORT    - illegal domain parameter
S                                   - #SLNETERR_BSD_EPROTOTYPE      - illegal type parameter
S                                   - #SLNETERR_BSD_EACCES          - permission denied
S                                   - #SLNETERR_BSD_ENSOCK          - exceeded maximal number of socket
S                                   - #SLNETERR_BSD_ENOMEM          - memory allocation error
S                                   - #SLNETERR_BSD_EINVAL          - error in socket configuration
S                                   - #SLNETERR_BSD_EPROTONOSUPPORT - illegal protocol parameter
S                                   - #SLNETERR_BSD_EOPNOTSUPP      - illegal combination of protocol and type parameters
S
S    \slnetsock_init_precondition
S
S    \remark     Not all platforms support all options.
S
S    \remark     A @c protocol value of zero can be used to select the default protocol from the selected @c domain and @c type.
S
S    \sa         SlNetSock_close()
S*/
Sint16_t SlNetSock_create(int16_t domain, int16_t type, int16_t protocol, uint32_t ifBitmap, int16_t flags);
S
S
S/*!
S    \brief Gracefully close socket
S
S    Release resources allocated to a socket.
S
S    \param[in] sd               Socket descriptor (handle), received in SlNetSock_create()
S
S    \return                     Zero on success, or negative error code on failure
S
S    \slnetsock_init_precondition
S
S    \remark     In the case of TCP, the connection is terminated.
S
S    \sa                         SlNetSock_create()
S*/
Sint32_t SlNetSock_close(int16_t sd);
S
S
S/*!
S    \brief Shutting down parts of a full-duplex connection
S
S    Shuts down parts of a full-duplex connection according to how parameter.\n
S
S    \param[in] sd               Socket descriptor (handle), received in SlNetSock_create
S    \param[in] how              Specifies which part of a full-duplex connection to shutdown. \n
S                                The options are
S                                    - #SLNETSOCK_SHUT_RD   - further receptions will be disallowed
S                                    - #SLNETSOCK_SHUT_WR   - further transmissions will be disallowed
S                                    - #SLNETSOCK_SHUT_RDWR - further receptions and transmissions will be disallowed
S
S    \return                     Zero on success, or negative error code on failure
S
S    \slnetsock_init_precondition
S
S    \sa                         SlNetSock_create()
S    \sa                         SlNetSock_connect()
S    \sa                         SlNetSock_accept()
S*/
Sint32_t SlNetSock_shutdown(int16_t sd, int16_t how);
S
S
S/*!
S    \brief Accept a connection on a socket
S
S    The SlNetSock_accept function is used with connection-based socket types (#SLNETSOCK_SOCK_STREAM).
S
S    It extracts the first connection request on the queue of pending
S    connections, creates a new connected socket, and returns a new file
S    descriptor referring to that socket.
S
S    The newly created socket is not in the listening state. The
S    original socket sd is unaffected by this call.
S
S    The argument sd is a socket that has been created with
S    SlNetSock_create(), bound to a local address with
S    SlNetSock_bind(), and is listening for connections after a
S    SlNetSock_listen().
S
S    The argument \c addr is a pointer to a sockaddr structure. This
S    structure is filled in with the address of the peer socket, as
S    known to the communications layer.
S
S    The exact format of the address returned \c addr is determined by the socket's address family.
S
S    \c addrlen is a value-result argument: it should initially contain
S    the size of the structure pointed to by addr, on return it will
S    contain the actual length (in bytes) of the address returned.
S
S    \param[in]  sd              Socket descriptor (handle)
S    \param[out] addr            The argument addr is a pointer
S                                to a sockaddr structure. This
S                                structure is filled in with the
S                                address of the peer socket, as
S                                known to the communications
S                                layer. The exact format of the
S                                address returned addr is
S                                determined by the socket's
S                                address\n
S                                sockaddr:\n - code for the
S                                address format.\n -
S                                socket address, the length
S                                depends on the code format
S    \param[out] addrlen         The addrlen argument is a value-result
S                                argument: it should initially contain the
S                                size of the structure pointed to by addr
S
S    \return                     On success, a socket descriptor.\n
S                                On a non-blocking accept a possible negative value is #SLNETERR_BSD_EAGAIN.\n
S                                On failure, negative error code.\n
S                                #SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system
S
S    \slnetsock_init_precondition
S
S    \sa                         SlNetSock_create()
S    \sa                         SlNetSock_bind()
S    \sa                         SlNetSock_listen()
S*/
Sint16_t SlNetSock_accept(int16_t sd, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen);
S
S
S/*!
S    \brief Assign a name to a socket
S
S    This SlNetSock_bind function gives the socket the local address
S    addr.  addr is addrlen bytes long.
S
S    Traditionally, this is called when a socket is created with
S    socket, it exists in a name space (address family) but has no name
S    assigned.
S
S    It is necessary to assign a local address before a #SLNETSOCK_SOCK_STREAM
S    socket may receive connections.
S
S    \param[in] sd               Socket descriptor (handle)
S    \param[in] addr             Specifies the destination
S                                addrs\n sockaddr:\n - code for
S                                the address format.\n - socket address,
S                                the length depends on the code
S                                format
S    \param[in] addrlen          Contains the size of the structure pointed to by addr
S
S    \return                     Zero on success, or negative error code on failure
S
S    \slnetsock_init_precondition
S
S    \sa                         SlNetSock_create()
S    \sa                         SlNetSock_accept()
S    \sa                         SlNetSock_listen()
S*/
Sint32_t SlNetSock_bind(int16_t sd, const SlNetSock_Addr_t *addr, int16_t addrlen);
S
S
S/*!
S    \brief Listen for connections on a socket
S
S    The willingness to accept incoming connections and a queue
S    limit for incoming connections are specified with SlNetSock_listen(),
S    and then the connections are accepted with SlNetSock_accept().
S
S    \param[in] sd               Socket descriptor (handle)
S    \param[in] backlog          Specifies the listen queue depth.
S
S    \return                     Zero on success, or negative error code on failure
S
S    \slnetsock_init_precondition
S
S    \remark     The SlNetSock_listen() call applies only to sockets of
S                type #SLNETSOCK_SOCK_STREAM.
S
S    \remark     The \c backlog parameter defines the maximum length the queue of
S                pending connections may grow to.
S
S    \sa                         SlNetSock_create()
S    \sa                         SlNetSock_accept()
S    \sa                         SlNetSock_bind()
S*/
Sint32_t SlNetSock_listen(int16_t sd, int16_t backlog);
S
S
S/*!
S    \brief Initiate a connection on a socket
S
S    Function connects the socket referred to by the socket
S    descriptor sd, to the address specified by \c addr.
S
S    The format of the address in addr is determined by the address
S    space of the socket.
S
S    If it is of type #SLNETSOCK_SOCK_DGRAM, this call specifies the
S    peer with which the socket is to be associated; this address is
S    that to which datagrams are to be sent, and the only address from
S    which datagrams are to be received.
S
S    If the socket is of type #SLNETSOCK_SOCK_STREAM, this call
S    attempts to make a connection to another socket.
S
S    The other socket is specified by address, which is an address in
S    the communications space of the socket.
S
S    \param[in] sd               Socket descriptor (handle)
S    \param[in] addr             Specifies the destination addr\n
S                                sockaddr:\n - code for the
S                                address format.\n -
S                                socket address, the length
S                                depends on the code format
S    \param[in] addrlen          Contains the size of the structure pointed
S                                to by addr
S
S    \return                     On success, a socket descriptor (handle).\n
S                                On failure, negative value.\n
S                                On a non-blocking connect a possible negative value is #SLNETERR_BSD_EALREADY.
S                                #SLNETERR_POOL_IS_EMPTY may be returned in case there are no resources in the system
S
S    \slnetsock_init_precondition
S
S    \sa                         SlNetSock_create()
S    \note
S    \warning
S*/
Sint32_t SlNetSock_connect(int16_t sd, const SlNetSock_Addr_t *addr, SlNetSocklen_t addrlen);
S
S/*!
S    \brief Return address info about the remote side of the connection
S
S    Returns a struct SlNetSock_AddrIn_t
S    filled with information about the peer device that is connected
S    on the other side of the socket descriptor.
S
S    \param[in]  sd              Socket descriptor (handle)
S    \param[out] addr            returns the struct addr\n
S                                SlNetSockAddrIn filled with information
S                                about the peer device:\n - code for the
S                                address format.\n -
S                                socket address, the length
S                                depends on the code format
S    \param[out] addrlen         Contains the size of the structure pointed
S                                to by addr
S
S    \return                     Zero on success, or negative error code on failure
S
S    \slnetsock_init_precondition
S
S    \sa                         SlNetSock_accept()
S    \sa                         SlNetSock_connect()
S*/
Sint32_t SlNetSock_getPeerName(int16_t sd, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen);
S
S
S/*!
S    \brief Get local address info by socket descriptor
S
S    Returns the local address info of the socket descriptor.
S
S    \param[in]  sd              Socket descriptor (handle)
S    \param[out] addr            The argument addr is a pointer
S                                to a SlNetSock_Addr_t structure. This
S                                structure is filled in with the
S                                address of the peer socket, as
S                                known to the communications
S                                layer. The exact format of the
S                                address returned addr is
S                                determined by the socket's
S                                address\n
S                                SlNetSock_Addr_t:\n - code for the
S                                address format.\n -
S                                socket address, the length
S                                depends on the code format
S    \param[out] addrlen         The addrlen argument is a value-result
S                                argument: it should initially contain the
S                                size of the structure pointed to by addr
S
S    \return                     Zero on success, or negative on failure.
S
S    \slnetsock_init_precondition
S
S    \remark     If the provided buffer is too small the returned address
S                will be truncated and \c addrlen will contain the
S                actual size of the socket address.
S
S    \sa         SlNetSock_create()
S    \sa         SlNetSock_bind()
S*/
Sint32_t SlNetSock_getSockName(int16_t sd, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen);
S
S
S/*!
S    \brief Monitor socket activity
S
S    SlNetSock_select() allow a program to monitor multiple file descriptors,
S    waiting until one or more of the file descriptors become
S    "ready" for some class of I/O operation.
S
S    \param[in]     nsds        The highest-numbered file descriptor in any of the
S                               three sets, plus 1.
S    \param[in,out] readsds     Socket descriptors list for read monitoring and accept monitoring
S    \param[in,out] writesds    Socket descriptors list for connect monitoring only, write monitoring is not supported
S    \param[in,out] exceptsds   Socket descriptors list for exception monitoring, not supported.
S    \param[in]     timeout     Is an upper bound on the amount of time elapsed
S                               before SlNetSock_select() returns. Null or above 0xffff seconds means
S                               infinity timeout. The minimum timeout is 10 milliseconds,
S                               less than 10 milliseconds will be set automatically to 10 milliseconds.
S                               Max microseconds supported is 0xfffc00.
S                               In trigger mode the timeout fields must be set to zero.
S
S    \return                    On success, SlNetSock_select() returns the number of
S                               file descriptors contained in the three returned
S                               descriptor sets (that is, the total number of bits that
S                               are set in readsds, writesds, exceptsds) which may be
S                               zero if the timeout expires before anything interesting
S                               happens.\n On error, a negative value is returned.
S                               readsds - return the sockets on which Read request will
S                               return without delay with valid data.\n
S                               writesds - return the sockets on which Write request
S                               will return without delay.\n
S                               exceptsds - return the sockets closed recently. \n
S                               #SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system
S
S    \slnetsock_init_precondition
S
S    \remark     If \c timeout is set to less than 10ms it will
S                automatically set to 10ms to prevent overload of the
S                system
S
S    \sa         SlNetSock_create()
S*/
Sint32_t SlNetSock_select(int16_t nsds, SlNetSock_SdSet_t *readsds, SlNetSock_SdSet_t *writesds, SlNetSock_SdSet_t *exceptsds, SlNetSock_Timeval_t *timeout);
S
S
S/*!
S    \brief SlNetSock_select's SlNetSock_SdSet_t SET function
S
S    Sets current socket descriptor on SlNetSock_SdSet_t container
S*/
Sint32_t SlNetSock_sdsSet(int16_t sd, SlNetSock_SdSet_t *sdset);
S
S
S/*!
S    \brief SlNetSock_select's SlNetSock_SdSet_t CLR function
S
S    Clears current socket descriptor on SlNetSock_SdSet_t container
S*/
Sint32_t SlNetSock_sdsClr(int16_t sd, SlNetSock_SdSet_t *sdset);
S
S
S/*!
S    \brief SlNetSock_select's SlNetSock_SdSet_t ZERO function
S
S    Clears all socket descriptors from SlNetSock_SdSet_t
S*/
Sint32_t SlNetSock_sdsClrAll(SlNetSock_SdSet_t *sdset);
S
S
S/*!
S    \brief SlNetSock_select's SlNetSock_SdSet_t ISSET function
S
S    Checks if current socket descriptor is set (true/false)
S
S    \return            Returns true if set, false if unset
S
S*/
Sint32_t SlNetSock_sdsIsSet(int16_t sd, SlNetSock_SdSet_t *sdset);
S
S
S/*!
S    \brief Set socket options
S
S    SlNetSock_setOpt() manipulates the options associated with a socket.
S
S    Options may exist at multiple protocol levels; they are always
S    present at the uppermost socket level.
S
S    When manipulating socket options the level at which the option resides
S    and the name of the option must be specified.  To manipulate options at
S    the socket level, level is specified as #SLNETSOCK_LVL_SOCKET.  To manipulate
S    options at any other level the protocol number of the appropriate protocol
S    controlling the option is supplied.  For example, to indicate that an
S    option is to be interpreted by the TCP protocol, level should be set to
S    the protocol number of TCP.
S
S    \c optval and \c optlen are used to access opt_values
S    for SlNetSock_setOpt().  For SlNetSock_getOpt() they identify a
S    buffer in which the value for the requested option(s) are to
S    be returned.  For SlNetSock_getOpt(), \c optlen is a value-result
S    parameter, initially containing the size of the buffer
S    pointed to by option_value, and modified on return to
S    indicate the actual size of the value returned.  If no option
S    value is to be supplied or returned, \c optval may be \c NULL.
S
S    \param[in] sd               Socket descriptor (handle)
S    \param[in] level            Defines the protocol level for this option
S                                - #SLNETSOCK_LVL_SOCKET - Socket level configurations (L4, transport layer)
S                                - #SLNETSOCK_LVL_IP - IP level configurations (L3, network layer)
S                                - #SLNETSOCK_LVL_PHY - Link level configurations (L2, link layer)
S    \param[in] optname          Defines the option name to interrogate
S                                - #SLNETSOCK_LVL_SOCKET
S                                  - #SLNETSOCK_OPSOCK_RCV_BUF\n
S                                                 Sets tcp max recv window size.\n
S                                                 This options takes SlNetSock_Winsize_t struct as parameter
S                                  - #SLNETSOCK_OPSOCK_RCV_TIMEO\n
S                                                 Sets the timeout value that specifies the maximum amount of time an input function waits until it completes.\n
S                                                 Default: No timeout\n
S                                                 This options takes SlNetSock_Timeval_t struct as parameter
S                                  - #SLNETSOCK_OPSOCK_KEEPALIVE\n
S                                                 Enable or Disable periodic keep alive.
S                                                 Keeps TCP connections active by enabling the periodic transmission of messages \n
S                                                 Timeout is 5 minutes.\n
S                                                 Default: Enabled \n
S                                                 This options takes SlNetSock_Keepalive_t struct as parameter
S                                  - #SLNETSOCK_OPSOCK_KEEPALIVE_TIME\n
S                                                 Set keep alive timeout.
S                                                 Value is in seconds \n
S                                                 Default: 5 minutes \n
S                                  - #SLNETSOCK_OPSOCK_LINGER\n
S                                                 Socket lingers on close pending remaining send/receive packets\n
S                                  - #SLNETSOCK_OPSOCK_NON_BLOCKING\n
S                                                 Sets socket to non-blocking operation Impacts: connect, accept, send, sendto, recv and recvfrom. \n
S                                                 Default: Blocking.
S                                                 This options takes SlNetSock_Nonblocking_t struct as parameter
S                                  - #SLNETSOCK_OPSOCK_NON_IP_BOUNDARY\n
S                                                 Enable or Disable rx ip boundary.
S                                                 In connectionless socket (udp/raw), unread data is dropped (when SlNetSock_recvFrom() len parameter < data size), Enable this option in order to read the left data on the next SlNetSock_recvFrom() iteration\n
S                                                 Default: Disabled, IP boundary kept\n
S                                                 This options takes SlNetSock_NonIpBoundary_t struct as parameter
S                                - #SLNETSOCK_LVL_IP
S                                  - #SLNETSOCK_OPIP_MULTICAST_TTL\n
S                                                 Set the time-to-live value of outgoing multicast packets for this socket. \n
S                                                 This options takes <b>uint8_t</b> as parameter
S                                  - #SLNETSOCK_OPIP_ADD_MEMBERSHIP \n
S                                                 UDP socket, Join a multicast group. \n
S                                                 This options takes SlNetSock_IpMreq_t struct as parameter
S                                  - #SLNETSOCK_OPIP_DROP_MEMBERSHIP \n
S                                                 UDP socket, Leave a multicast group \n
S                                                 This options takes SlNetSock_IpMreq_t struct as parameter
S                                  - #SLNETSOCK_OPIP_HDRINCL \n
S                                                 RAW socket only, the IPv4 layer generates an IP header when sending a packet unless \n
S                                                 the IP_HDRINCL socket option is enabled on the socket.    \n
S                                                 When it is enabled, the packet must contain an IP header. \n
S                                                 Default: disabled, IPv4 header generated by Network Stack \n
S                                                 This options takes <b>uint32_t</b> as parameter
S                                  - #SLNETSOCK_OPIP_RAW_RX_NO_HEADER \n
S                                                 Raw socket remove IP header from received data. \n
S                                                 Default: data includes ip header \n
S                                                 This options takes <b>uint32_t</b> as parameter
S                                  - #SLNETSOCK_OPIP_RAW_IPV6_HDRINCL (inactive) \n
S                                                 RAW socket only, the IPv6 layer generates an IP header when sending a packet unless \n
S                                                 the IP_HDRINCL socket option is enabled on the socket. When it is enabled, the packet must contain an IP header \n
S                                                 Default: disabled, IPv4 header generated by Network Stack \n
S                                                 This options takes <b>uint32_t</b> as parameter
S                                - #SLNETSOCK_LVL_PHY
S                                  - #SLNETSOCK_OPPHY_CHANNEL \n
S                                                 Sets channel in transceiver mode.
S                                                 This options takes <b>uint32_t</b> as channel number parameter
S                                  - #SLNETSOCK_OPPHY_RATE \n
S                                                 RAW socket, set WLAN PHY transmit rate \n
S                                                 The values are based on SlWlanRateIndex_e    \n
S                                                 This options takes <b>uint32_t</b> as parameter
S                                  - #SLNETSOCK_OPPHY_TX_POWER \n
S                                                 RAW socket, set WLAN PHY TX power \n
S                                                 Valid rage is 1-15 \n
S                                                 This options takes <b>uint32_t</b> as parameter
S                                  - #SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX \n
S                                                 RAW socket, set number of frames to transmit in transceiver mode.
S                                                 Default: 1 packet
S                                                 This options takes <b>uint32_t</b> as parameter
S                                  - #SLNETSOCK_OPPHY_PREAMBLE \n
S                                                 RAW socket, set WLAN PHY preamble for Long/Short\n
S                                                 This options takes <b>uint32_t</b> as parameter
S                                  - #SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD \n
S                                                 RAW socket, set WLAN Tx - Set CCA threshold. \n
S                                                 The values are based on SlNetSockTxInhibitThreshold_e \n
S                                                 This options takes <b>uint32_t</b> as parameter
S                                  - #SLNETSOCK_OPPHY_TX_TIMEOUT \n
S                                                 RAW socket, set WLAN Tx - changes the TX timeout (lifetime) of transceiver frames. \n
S                                                 Value in Ms, maximum value is 10ms \n
S                                                 This options takes <b>uint32_t</b> as parameter
S                                  - #SLNETSOCK_OPPHY_ALLOW_ACKS  \n
S                                                 RAW socket, set WLAN Tx - Enable or Disable sending ACKs in transceiver mode \n
S                                                 0 = disabled / 1 = enabled \n
S                                                 This options takes <b>uint32_t</b> as parameter
S
S
S    \param[in] optval           Specifies a value for the option
S    \param[in] optlen           Specifies the length of the
S        option value
S
S    \return                     Zero on success, or negative error code on failure
S
S    \par Persistent
S                All params are <b>Non- Persistent</b>
S
S    \slnetsock_init_precondition
S
S    \par    Examples
S
S    - SLNETSOCK_OPSOCK_RCV_BUF:
S    \code
S           SlNetSock_Winsize_t size;
S           size.winsize = 3000; // bytes
S           SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_RCV_BUF, (uint8_t *)&size, sizeof(size));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPSOCK_RCV_TIMEO:
S    \code
S        struct SlNetSock_Timeval_t timeVal;
S        timeVal.tv_sec =  1; // Seconds
S        timeVal.tv_usec = 0; // Microseconds. 10000 microseconds resolution
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_RCV_TIMEO, (uint8_t *)&timeVal, sizeof(timeVal)); // Enable receive timeout
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPSOCK_KEEPALIVE: //disable Keepalive
S    \code
S        SlNetSock_Keepalive_t enableOption;
S        enableOption.keepaliveEnabled = 0;
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_KEEPALIVE, (uint8_t *)&enableOption, sizeof(enableOption));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPSOCK_KEEPALIVE_TIME: //Set Keepalive timeout
S    \code
S        int16_t Status;
S        uint32_t TimeOut = 120;
S        SlNetSock_setOpt(Sd, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_KEEPALIVE_TIME, (uint8_t *)&TimeOut, sizeof(TimeOut));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPSOCK_NON_BLOCKING: //Enable or disable nonblocking mode
S    \code
S           SlNetSock_Nonblocking_t enableOption;
S           enableOption.nonBlockingEnabled = 1;
S           SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_NON_BLOCKING, (uint8_t *)&enableOption, sizeof(enableOption));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPSOCK_NON_IP_BOUNDARY: //disable boundary
S    \code
S        SlNetSock_NonIpBoundary_t enableOption;
S        enableOption.nonIpBoundaryEnabled = 1;
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_NON_IP_BOUNDARY, (uint8_t *)&enableOption, sizeof(enableOption));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPSOCK_LINGER:
S    \code
S        SlNetSock_linger_t linger;
S        linger.l_onoff = 1;
S        linger.l_linger = 10;
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_LINGER, &linger, sizeof(linger));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPIP_MULTICAST_TTL:
S     \code
S           uint8_t ttl = 20;
S           SlNetSock_setOpt(SockID, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_MULTICAST_TTL, &ttl, sizeof(ttl));
S     \endcode
S     <br>
S
S    - SLNETSOCK_OPIP_ADD_MEMBERSHIP:
S     \code
S           SlNetSock_IpMreq_t mreq;
S           SlNetSock_setOpt(SockID, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPIP_DROP_MEMBERSHIP:
S    \code
S        SlNetSock_IpMreq_t mreq;
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_DROP_MEMBERSHIP, &mreq, sizeof(mreq));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPIP_RAW_RX_NO_HEADER:
S    \code
S        uint32_t header = 1;  // remove ip header
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_RAW_RX_NO_HEADER, &header, sizeof(header));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPIP_HDRINCL:
S    \code
S        uint32_t header = 1;
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_HDRINCL, &header, sizeof(header));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPIP_RAW_IPV6_HDRINCL:
S    \code
S        uint32_t header = 1;
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_RAW_IPV6_HDRINCL, &header, sizeof(header));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPPHY_CHANNEL:
S    \code
S        uint32_t newChannel = 6; // range is 1-13
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPPHY_CHANNEL, &newChannel, sizeof(newChannel));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPPHY_RATE:
S    \code
S        uint32_t rate = 6; // see wlan.h SlWlanRateIndex_e for values
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_RATE, &rate, sizeof(rate));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPPHY_TX_POWER:
S    \code
S        uint32_t txpower = 1; // valid range is 1-15
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_TX_POWER, &txpower, sizeof(txpower));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX:
S    \code
S        uint32_t numframes = 1;
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX, &numframes, sizeof(numframes));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPPHY_PREAMBLE:
S    \code
S        uint32_t preamble = 1;
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_PREAMBLE, &preamble, sizeof(preamble));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD:
S    \code
S        uint32_t thrshld = SLNETSOCK_TX_INHIBIT_THRESHOLD_MED;
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD , &thrshld, sizeof(thrshld));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPPHY_TX_TIMEOUT:
S    \code
S        uint32_t timeout = 50;
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_TX_TIMEOUT  , &timeout, sizeof(timeout));
S    \endcode
S    <br>
S
S    - SLNETSOCK_OPPHY_ALLOW_ACKS:
S    \code
S        uint32_t acks = 1; // 0 = disabled / 1 = enabled
S        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_ALLOW_ACKS, &acks, sizeof(acks));
S    \endcode
S
S    \sa     slNetSock_create()
S    \sa     SlNetSock_getOpt()
S*/
Sint32_t SlNetSock_setOpt(int16_t sd, int16_t level, int16_t optname, void *optval, SlNetSocklen_t optlen);
S
S
S/*!
S    \brief Get socket options
S
S    The SlNetSock_getOpt function gets the options associated with a socket.
S    Options may exist at multiple protocol levels; they are always
S    present at the uppermost socket level.
S
S    The parameters optval and optlen identify a
S    buffer in which the value for the requested option(s) are to
S    be returned.  \c optlen is a value-result
S    parameter, initially containing the size of the buffer
S    pointed to by option_value, and modified on return to
S    indicate the actual size of the value returned.  If no option
S    value is to be supplied or returned, \c optval may be \c NULL.
S
S
S    \param[in]  sd              Socket descriptor (handle)
S    \param[in]  level           Defines the protocol level for this option
S    \param[in]  optname         defines the option name to interrogate
S    \param[out] optval          Specifies a value for the option
S    \param[out] optlen          Specifies the length of the
S                                option value
S
S    \return                     Zero on success, or negative error code on failure
S
S    \slnetsock_init_precondition
S
S    \sa     SlNetSock_create()
S    \sa     SlNetSock_setOpt()
S*/
Sint32_t SlNetSock_getOpt(int16_t sd, int16_t level, int16_t optname, void *optval, SlNetSocklen_t *optlen);
S
S
S/*!
S    \brief Read data from TCP socket
S
S    The SlNetSock_recv function receives a message from a connection-mode socket
S
S    \param[in]  sd              Socket descriptor (handle)
S    \param[out] buf             Points to the buffer where the
S                                message should be stored.
S    \param[in]  len             Specifies the length in bytes of
S                                the buffer pointed to by the buffer argument.
S                                Range: 1-16000 bytes
S    \param[in]  flags           Specifies the type of message
S                                reception. On this version, this parameter is not
S                                supported.
S
S    \return                     Return the number of bytes received,
S                                or a negative value if an error occurred.\n
S                                Using a non-blocking recv a possible negative value is SLNETERR_BSD_EAGAIN.\n
S                                SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system
S
S    \slnetsock_init_precondition
S
S    \par    Examples
S
S    - Receiving data using TCP socket:
S    \code
S        SlNetSock_AddrIn_t  Addr;
S        SlNetSock_AddrIn_t  LocalAddr;
S        int16_t AddrSize = sizeof(SlNetSock_AddrIn_t);
S        int16_t SockID, newSockID;
S        int16_t Status;
S        int8_t Buf[RECV_BUF_LEN];
S
S        LocalAddr.sin_family = SLNETSOCK_AF_INET;
S        LocalAddr.sin_port = SlNetSock_htons(5001);
S        LocalAddr.sin_addr.s_addr = 0;
S
S        Addr.sin_family = SLNETSOCK_AF_INET;
S        Addr.sin_port = SlNetSock_htons(5001);
S        Addr.sin_addr.s_addr = SlNetSock_htonl(SLNETSOCK_IPV4_VAL(10,1,1,200));
S
S        SockID = SlNetSock_create(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_STREAM, 0, 0, 0);
S        Status = SlNetSock_bind(SockID, (SlNetSock_Addr_t *)&LocalAddr, AddrSize);
S        Status = SlNetSock_listen(SockID, 0);
S        newSockID = SlNetSock_accept(SockID, (SlNetSock_Addr_t*)&Addr, (SlNetSocklen_t*) &AddrSize);
S        Status = SlNetSock_recv(newSockID, Buf, 1460, 0);
S    \endcode
S    <br>
S
S    - Rx transceiver mode using a raw socket:
S    \code
S        int8_t buffer[1536];
S        int16_t sd;
S        uint16_t size;
S        SlNetSock_TransceiverRxOverHead_t *transHeader;
S        sd = SlNetSock_create(SLNETSOCK_AF_RF, SLNETSOCK_SOCK_RAW, 11, 0, 0); // channel 11
S        while(1)
S        {
S            size = SlNetSock_recv(sd,buffer,1536,0);
S            transHeader = (SlNetSock_TransceiverRxOverHead_t *)buffer;
S            printf("RSSI is %d frame type is 0x%x size %d\n",transHeader->rssi,buffer[sizeof(SlNetSock_TransceiverRxOverHead_t)],size);
S        }
S    \endcode
S
S    \sa     SlNetSock_create()
S    \sa     SlNetSock_recvFrom()
S*/
Sint32_t SlNetSock_recv(int16_t sd, void *buf, uint32_t len, uint32_t flags);
S
S
S/*!
S    \brief Read data from socket
S
S    SlNetSock_recvFrom function receives a message from a connection-mode or
S    connectionless-mode socket
S
S    \param[in]  sd              Socket descriptor (handle)
S    \param[out] buf             Points to the buffer where the message should be stored.
S    \param[in]  len             Specifies the length in bytes of the buffer pointed to by the buffer argument.
S                                Range: 1-16000 bytes
S    \param[in]  flags           Specifies the type of message
S                                reception. On this version, this parameter is not
S                                supported
S    \param[in]  from            Pointer to an address structure
S                                indicating the source
S                                address.\n sockaddr:\n - code
S                                for the address format.\n - socket address,
S                                the length depends on the code
S                                format
S    \param[in]  fromlen         Source address structure
S                                size. This parameter MUST be set to the size of the structure pointed to by addr.
S
S
S    \return                     Return the number of bytes received,
S                                or a negative value if an error occurred.\n
S                                Using a non-blocking recv a possible negative value is #SLNETERR_BSD_EAGAIN.
S                                #SLNETERR_RET_CODE_INVALID_INPUT will be returned if fromlen has incorrect length.\n
S                                #SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system
S
S    \slnetsock_init_precondition
S
S    \par        Example
S
S    - Receiving data:
S    \code
S        SlNetSock_AddrIn_t  Addr;
S        SlNetSock_AddrIn_t  LocalAddr;
S        int16_t AddrSize = sizeof(SlNetSock_AddrIn_t);
S        int16_t SockID;
S        int16_t Status;
S        int8_t Buf[RECV_BUF_LEN];
S
S        LocalAddr.sin_family = SLNETSOCK_AF_INET;
S        LocalAddr.sin_port = SlNetSock_htons(5001);
S        LocalAddr.sin_addr.s_addr = 0;
S
S        SockID = SlNetSock_create(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_DGRAM, 0, 0, 0);
S        Status = SlNetSock_bind(SockID, (SlNetSock_Addr_t *)&LocalAddr, AddrSize);
S        Status = SlNetSock_recvFrom(SockID, Buf, 1472, 0, (SlNetSock_Addr_t *)&Addr, (SlNetSocklen_t*)&AddrSize);
S
S    \endcode
S
S    \sa     SlNetSock_create()
S    \sa     SlNetSock_recv()
S*/
Sint32_t SlNetSock_recvFrom(int16_t sd, void *buf, uint32_t len, uint32_t flags, SlNetSock_Addr_t *from, SlNetSocklen_t *fromlen);
S
S
S/*!
S    \brief Write data to TCP socket
S
S    Transmits a message to another socket.
S    Returns immediately after sending data to device.
S    In case of a RAW socket (transceiver mode), extra 4 bytes should be reserved at the end of the
S    frame data buffer for WLAN FCS
S
S    \param[in] sd               Socket descriptor (handle)
S    \param[in] buf              Points to a buffer containing
S                                the message to be sent
S    \param[in] len              Message size in bytes.
S    \param[in] flags            Specifies the type of message
S                                transmission. On this version, this parameter is not
S                                supported for TCP.
S
S    \return                     Return the number of bytes sent,
S                                or a negative value if an error occurred.
S
S    \slnetsock_init_precondition
S
S    \par        Example
S
S    - Sending data:
S    \code
S        SlNetSock_AddrIn_t  Addr;
S        int16_t AddrSize = sizeof(SlNetSock_AddrIn_t);
S        int16_t SockID;
S        int16_t Status;
S        int8_t Buf[SEND_BUF_LEN];
S
S        Addr.sin_family = SLNETSOCK_AF_INET;
S        Addr.sin_port = SlNetSock_htons(5001);
S        Addr.sin_addr.s_addr = SlNetSock_htonl(SLNETSOCK_IPV4_VAL(10,1,1,200));
S
S        SockID = SlNetSock_create(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_STREAM, 0, 0, 0);
S        Status = SlNetSock_connect(SockID, (SlNetSock_Addr_t *)&Addr, AddrSize);
S        Status = SlNetSock_send(SockID, Buf, 1460, 0 );
S    \endcode
S
S    \sa     SlNetSock_create()
S    \sa     SlNetSock_sendTo()
S*/
Sint32_t SlNetSock_send(int16_t sd, const void *buf, uint32_t len, uint32_t flags);
S
S
S/*!
S    \brief Write data to socket
S
S    The SlNetSock_sendTo function is used to transmit a message on a connectionless socket
S    (connection less socket #SLNETSOCK_SOCK_DGRAM, #SLNETSOCK_SOCK_RAW).
S
S    Returns immediately after sending data to device.
S
S    \param[in] sd               Socket descriptor (handle)
S    \param[in] buf              Points to a buffer containing
S                                the message to be sent
S    \param[in] len              message size in bytes.
S    \param[in] flags            Specifies the type of message
S                                transmission. On this version, this parameter is not
S                                supported
S    \param[in] to               Pointer to an address structure
S                                indicating the destination
S                                address.\n sockaddr:\n - code
S                                for the address format.\n - socket address,
S                                the length depends on the code
S                                format
S    \param[in] tolen            Destination address structure size
S
S    \return                     Return the number of bytes sent,
S                                or a negative value if an error occurred.\n
S
S    \slnetsock_init_precondition
S
S    \par    Example
S
S    - Sending data:
S    \code
S        SlNetSock_AddrIn_t  Addr;
S        int16_t AddrSize = sizeof(SlNetSock_AddrIn_t);
S        int16_t SockID;
S        int16_t Status;
S        int8_t Buf[SEND_BUF_LEN];
S
S        Addr.sin_family = SLNETSOCK_AF_INET;
S        Addr.sin_port = SlNetSock_htons(5001);
S        Addr.sin_addr.s_addr = SlNetSock_htonl(SLNETSOCK_IPV4_VAL(10,1,1,200));
S
S        SockID = SlNetSock_create(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_DGRAM, 0, 0, 0);
S        Status = SlNetSock_sendTo(SockID, Buf, 1472, 0, (SlNetSock_Addr_t *)&Addr, AddrSize);
S    \endcode
S
S    \sa     SlNetSock_create()
S    \sa     SlNetSock_send()
S*/
Sint32_t SlNetSock_sendTo(int16_t sd, const void *buf, uint32_t len, uint32_t flags, const SlNetSock_Addr_t *to, SlNetSocklen_t tolen);
S
S
S/*!
S    \brief Get interface ID from socket descriptor (sd)
S
S    Retrieves the priority of the requested interface.
S
S    \param[in] sd         Specifies the socket descriptor which its
S                          interface identifier needs to be retrieved.\n
S
S    \return               The interface identifier value of the
S                          interface on success, or negative error code
S                          on failure The values of the interface
S                          identifier is defined with the prefix
S                          SLNETIF_ID_ which defined in slnetif.h
S
S    \slnetsock_init_precondition
S
S    \par    Examples
S
S    \code
S        int16_t InterfaceID;
S        InterfaceID = SlNetSock_getIfID(SLNETIF_ID_1);
S    \endcode
S
S    \sa         SlNetSock_create()
S    \sa         SlNetIf_add()
S    \sa         SlNetIf_getIDByName()
S*/
Sint32_t SlNetSock_getIfID(uint16_t sd);
S
S
S/*!
S    \brief Creates a security attributes object
S
S    Create a security attribute, which is required in order to start a secure session.
S
S    \remark     When the security attributes object is no longer needed, call
S                SlNetSock_secAttribDelete() to destroy it.
S
S    \remark     A single security object can be used to initiate several secure
S                sessions (provided they all have the same security attributes).
S
S    \slnetsock_init_precondition
S
S    \sa         SlNetSock_startSec()
S    \sa         SlNetSock_secAttribDelete()
S*/
SSlNetSockSecAttrib_t *SlNetSock_secAttribCreate(void);
S
S
S/*!
S    \brief Deletes a security attributes object
S
S    \param[in] secAttrib        Secure attribute handle
S
S    \return                     Zero on success, or negative error code
S                                on failure
S
S    \slnetsock_init_precondition
S
S    \remark     \c secAttrib must be created using SlNetSock_secAttribCreate()
S
S    \sa         SlNetSock_secAttribCreate()
S    \sa         SlNetSock_secAttribSet()
S    \sa         SlNetSock_startSec()
S*/
Sint32_t SlNetSock_secAttribDelete(SlNetSockSecAttrib_t *secAttrib);
S
S
S/*!
S    \brief set a security attributes
S
S    The SlNetSock_secAttribSet function is used to set a security
S    attribute of a security attributes object.
S
S    \param[in] secAttrib        Secure attribute handle
S    \param[in] attribName       Define the actual attribute to set. Applicable values:
S                                    - #SLNETSOCK_SEC_ATTRIB_PRIVATE_KEY
S                                    - #SLNETSOCK_SEC_ATTRIB_LOCAL_CERT
S                                    - #SLNETSOCK_SEC_ATTRIB_PEER_ROOT_CA
S                                    - #SLNETSOCK_SEC_ATTRIB_DH_KEY
S                                    - #SLNETSOCK_SEC_ATTRIB_METHOD
S                                    - #SLNETSOCK_SEC_ATTRIB_CIPHERS
S                                    - #SLNETSOCK_SEC_ATTRIB_ALPN
S                                    - #SLNETSOCK_SEC_ATTRIB_EXT_CLIENT_CHLNG_RESP
S                                    - #SLNETSOCK_SEC_ATTRIB_DOMAIN_NAME
S                                    - #SLNETSOCK_SEC_ATTRIB_DISABLE_CERT_STORE
S    \param[in] val
S    \param[in] len
S
S    \return                     Zero on success, or negative error code
S                                on failure
S
S    \slnetsock_init_precondition
S
S    \note   The @c SLNETSOCK_SEC_ATTRIB_DISABLE_CERT_STORE value
S            is currently being evaluated, and may be removed in a
S            future release.  It is currently only supported on CC3x20
S            devices.  For more details, see
S            #SLNETSOCK_SEC_ATTRIB_DISABLE_CERT_STORE.
S
S    \sa         SlNetSock_secAttribCreate()
S*/
Sint32_t SlNetSock_secAttribSet(SlNetSockSecAttrib_t *secAttrib , SlNetSockSecAttrib_e attribName , void *val, uint16_t len);
S
S
S/*!
S    \brief Start a security session on an opened socket
S
S    \param[in] sd               Socket descriptor (handle)
S    \param[in] secAttrib        Secure attribute handle
S    \param[in] flags            Specifies flags. \n
S                                The available flags are:
S                                    - #SLNETSOCK_SEC_START_SECURITY_SESSION_ONLY
S                                    - #SLNETSOCK_SEC_BIND_CONTEXT_ONLY
S                                    - #SLNETSOCK_SEC_IS_SERVER
S
S    \return                     Zero on success, or negative error code
S                                on failure
S
S    \slnetsock_init_precondition
S
S    \remark     If \c secAttrib is \c NULL, the session will be started with
S                default security settings.
S
S    \sa         SlNetSock_create()
S    \sa         SlNetSock_secAttribCreate()
S*/
Sint32_t SlNetSock_startSec(int16_t sd, SlNetSockSecAttrib_t *secAttrib, uint8_t flags);
S
S
S/*!
S
S Close the Doxygen group.
S @}
S
S*/
S
S
S#ifdef  __cplusplus
S}
S#endif /* __cplusplus */
S
N#endif /* __NET_SOCK_H__ */
L 49 "/vagrant/Q4_04/sdk_root/source/ti/net/slnetif.h" 2
N
N/*!
N    \defgroup SlNetIf SlNetIf group
N
N    \short Controls standard stack/interface options and capabilities
N
N*/
N/*!
N
N    \addtogroup SlNetIf
N    @{
N
N*/
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N
N/* Interface ID bit pool to be used in interface add and in socket creation  */
N#define SLNETIF_ID_1                (1 << 0) //can be used for wifi interface
N#define SLNETIF_ID_2                (1 << 1) //can be used for eth interface
N#define SLNETIF_ID_3                (1 << 2)
N#define SLNETIF_ID_4                (1 << 3)
N#define SLNETIF_ID_5                (1 << 4)
N#define SLNETIF_ID_6                (1 << 5)
N#define SLNETIF_ID_7                (1 << 6)
N#define SLNETIF_ID_8                (1 << 7)
N#define SLNETIF_ID_9                (1 << 8)
N#define SLNETIF_ID_10               (1 << 9)
N#define SLNETIF_ID_11               (1 << 10)
N#define SLNETIF_ID_12               (1 << 11)
N#define SLNETIF_ID_13               (1 << 12)
N#define SLNETIF_ID_14               (1 << 13)
N#define SLNETIF_ID_15               (1 << 14)
N#define SLNETIF_ID_16               (1 << 15)
N
N/* Maximum interfaces                                                       */
N#define SLNETIF_MAX_IF              (16)
N
N/* this macro returns 0 when only one bit is set and a number when it isn't */
N#define ONLY_ONE_BIT_IS_SET(x)      (((x > 0) && ((x & (x - 1)) == 0))?true:false)
N
N
N/* Interface connection status bit pool to be used in set interface connection status function */
N
N#define SLNETIF_STATUS_DISCONNECTED (0)
N#define SLNETIF_STATUS_CONNECTED    (1)
N
N/*!
N    \brief Interface state bit pool to be used in set interface state function
N*/
Ntypedef enum
N{
N    SLNETIF_STATE_DISABLE = 0,
N    SLNETIF_STATE_ENABLE  = 1
N} SlNetIfState_e;
N
N/*!
N    \brief Address type enum to be used in get ip address function
N*/
Ntypedef enum
N{
N    SLNETIF_IPV4_ADDR        = 0,
N    SLNETIF_IPV6_ADDR_LOCAL  = 1,
N    SLNETIF_IPV6_ADDR_GLOBAL = 2
N} SlNetIfAddressType_e;
N
N/* Address config return values that can be retrieved in get ip address function */
N#define SLNETIF_ADDR_CFG_UNKNOWN   (0)
N#define SLNETIF_ADDR_CFG_DHCP      (1)
N#define SLNETIF_ADDR_CFG_DHCP_LLA  (2)
N#define SLNETIF_ADDR_CFG_STATIC    (4)
N#define SLNETIF_ADDR_CFG_STATELESS (5)
N#define SLNETIF_ADDR_CFG_STATEFUL  (6)
N
N/* Security object types for load Sec Obj function */
N#define SLNETIF_SEC_OBJ_TYPE_RSA_PRIVATE_KEY (1)
N#define SLNETIF_SEC_OBJ_TYPE_CERTIFICATE     (2)
N#define SLNETIF_SEC_OBJ_TYPE_DH_KEY          (3)
N
N
N/* The 32bit queryBitmap structure - SlNetIf_queryIf function:
N   Bit     0 : Interface state - Check if interface state set to enable
N   Bit     1 : Interface connection status - Check if interface connection status is up
N   Bit     2 : Force answer - Return last found netIf, if none of the existing interfaces answers  the query
N   Bits 3-31 : Reserved
N*/
N#define SLNETIF_QUERY_IF_STATE_BIT               (1 << 0)
N#define SLNETIF_QUERY_IF_CONNECTION_STATUS_BIT   (1 << 1)
N#define SLNETIF_QUERY_IF_ALLOW_PARTIAL_MATCH_BIT (1 << 2)
N
N/*****************************************************************************/
N/* Structure/Enum declarations                                               */
N/*****************************************************************************/
N
N/*!
N    \brief SlNetIf_Config_t structure contains all the function callbacks that are expected to be filled by the relevant network stack interface \n
N           Each interface has different capabilities, so not all the API's must be supported therefore an API's can be defined as:
N           - <b>Mandatory API's</b>     - must be supported by the interface in order to be part of SlNetSock layer
N           - <b>Non-Mandatory API's</b> - can be supported, but not mandatory for basic SlNetSock proper operation
N
N    \note  Interface that is not supporting a non-mandatory API should set it to \b NULL in its function list
N
N    \sa SlNetIf_Config_t
N*/
Ntypedef struct SlNetIf_Config_t
N{
N    /* socket related API's */
N    int16_t (*sockCreate)        (void *ifContext, int16_t domain, int16_t type, int16_t protocol, void **sdContext);                /*!< \b Mandatory API \n The actual implementation of the interface for ::SlNetSock_create           */
N    int32_t (*sockClose)         (int16_t sd, void *sdContext);                                                                      /*!< \b Mandatory API \n The actual implementation of the interface for ::SlNetSock_close            */
N    int32_t (*sockShutdown)      (int16_t sd, void *sdContext, int16_t how);                                                         /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetSock_shutdown     */
N    int16_t (*sockAccept)        (int16_t sd, void *sdContext, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen, uint8_t flags, void **acceptedSdContext);        /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetSock_accept   */
N    int32_t (*sockBind)          (int16_t sd, void *sdContext, const SlNetSock_Addr_t *addr, int16_t addrlen);                       /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetSock_bind         */
N    int32_t (*sockListen)        (int16_t sd, void *sdContext, int16_t backlog);                                                     /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetSock_listen       */
N    int32_t (*sockConnect)       (int16_t sd, void *sdContext, const SlNetSock_Addr_t *addr, SlNetSocklen_t addrlen, uint8_t flags); /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetSock_connect      */
N    int32_t (*sockGetPeerName)   (int16_t sd, void *sdContext, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen);                     /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetSock_getPeerName  */
N    int32_t (*sockGetLocalName)  (int16_t sd, void *sdContext, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen);                     /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetSock_getSockName  */
N    int32_t (*sockSelect)        (void *ifContext, int16_t nsds, SlNetSock_SdSet_t *readsds, SlNetSock_SdSet_t *writesds, SlNetSock_SdSet_t *exceptsds, SlNetSock_Timeval_t *timeout); /*!< \b Mandatory API \n The actual implementation of the interface for ::SlNetSock_select  */
N    int32_t (*sockSetOpt)        (int16_t sd, void *sdContext, int16_t level, int16_t optname, void *optval, SlNetSocklen_t optlen);                             /*!< \b Mandatory API \n The actual implementation of the interface for ::SlNetSock_setOpt       */
N    int32_t (*sockGetOpt)        (int16_t sd, void *sdContext, int16_t level, int16_t optname, void *optval, SlNetSocklen_t *optlen);                            /*!< \b Mandatory API \n The actual implementation of the interface for ::SlNetSock_getOpt       */
N    int32_t (*sockRecv)          (int16_t sd, void *sdContext, void *buf, uint32_t len, uint32_t flags);                                                         /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetSock_recv     */
N    int32_t (*sockRecvFrom)      (int16_t sd, void *sdContext, void *buf, uint32_t len, uint32_t flags, SlNetSock_Addr_t *from, SlNetSocklen_t *fromlen);        /*!< \b Mandatory API \n The actual implementation of the interface for ::SlNetSock_recvFrom     */
N    int32_t (*sockSend)          (int16_t sd, void *sdContext, const void *buf, uint32_t len, uint32_t flags);                                                   /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetSock_send     */
N    int32_t (*sockSendTo)        (int16_t sd, void *sdContext, const void *buf, uint32_t len, uint32_t flags, const SlNetSock_Addr_t *to, SlNetSocklen_t tolen); /*!< \b Mandatory API \n The actual implementation of the interface for ::SlNetSock_sendTo       */
N    int32_t (*sockstartSec)      (int16_t sd, void *sdContext, SlNetSockSecAttrib_t *secAttrib, uint8_t flags);                                                  /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetSock_startSec */
N
N    /* util related API's */
N    int32_t (*utilGetHostByName) (void *ifContext, char *name, const uint16_t nameLen, uint32_t *ipAddr, uint16_t *ipAddrLen, const uint8_t family);  /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetUtil_getHostByName */
N
N    /* if related API's */
N    int32_t (*ifGetIPAddr)           (void *ifContext, SlNetIfAddressType_e addrType, uint16_t *addrConfig, uint32_t *ipAddr);                      /*!< \b Mandatory API \n The actual implementation of the interface for ::SlNetIf_getIPAddr           */
N    int32_t (*ifGetConnectionStatus) (void *ifContext);                                                                                             /*!< \b Mandatory API \n The actual implementation of the interface for ::SlNetIf_getConnectionStatus */
N    int32_t (*ifLoadSecObj)          (void *ifContext, uint16_t objType, char *objName, int16_t objNameLen, uint8_t *objBuff, int16_t objBuffLen);  /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetIf_loadSecObj      */
N    int32_t (*ifCreateContext)       (uint16_t ifID, const char *ifName, void **ifContext);                                                         /*!< \b Non-Mandatory API \n The actual implementation of the interface for ::SlNetIf_add             */
N
N} SlNetIf_Config_t;
N
N
N/*!
N    \brief The SlNetIf_t structure holds the configuration of the interface
N           Its ID, name, flags and the configuration list - ::SlNetIf_Config_t.
N*/
Ntypedef struct SlNetIf_t
N{
N    uint32_t          ifID;
N    char             *ifName;
N    int32_t           flags;
N    SlNetIf_Config_t *ifConf;
N    void             *ifContext;
N} SlNetIf_t;
N
N/*****************************************************************************/
N/* Function prototypes                                                       */
N/*****************************************************************************/
N
N/*!
N
N    \brief Initialize the SlNetIf module
N
N    \param[in] flags            For future usage,
N                                The value 0 may be used in order to run the
N                                default flags
N
N    \return                     Zero on success, or negative error code on failure
N
N*/
Nint32_t SlNetIf_init(int32_t flags);
N
N/*!
N    \brief Add a new SlNetIf-compatible interface to the system
N
N    The SlNetIf_add function allows the application to add specific interfaces
N    with their priorities and function list.\n
N    This function gives full control to the application on the interfaces.
N
N    \param[in] ifID            Specifies the interface which needs
N                               to be added.\n
N                               The values of the interface identifier
N                               is defined with the prefix SLNETIF_ID_
N                               which defined in slnetif.h
N    \param[in] ifName          Specifies the name of the interface,
N                               \b Note: Can be set to NULL, but when set to NULL
N                                     cannot be used with SlNetIf_getIDByName
N    \param[in] ifConf          Specifies the function list for the
N                               interface
N    \param[in] priority        Specifies the priority needs to be
N                               set (In ascending order).
N                               Note: maximum priority is 15
N
N    \return                    Zero on success, or negative error code on failure
N
N    \slnetif_not_threadsafe
N
N    \par    Examples
N
N    \code
N        uint8_t priority = 10;
N        SlNetIf_add(SLNETIF_ID_1, "WiFi_Interface", &SlNetIfConfigWifi, priority);
N    \endcode
N    <br>
N*/
Nint32_t SlNetIf_add(uint16_t ifID, char *ifName, const SlNetIf_Config_t *ifConf, uint8_t priority);
N
N
N/*!
N    \brief Get interface configuration from interface ID
N
N    The SlNetIf_getIfByID function retrieves the configuration of the
N    requested interface.
N
N    \param[in] ifID      Specifies the interface which its configuration
N                         needs to be retrieved.\n
N                         The values of the interface identifier is
N                         defined with the prefix SLNETIF_ID_ which
N                         defined in slnetif.h
N
N    \return              A pointer to the configuration of the
N                         interface on success, or NULL on failure
N
N    \sa     SlNetIf_add()
N
N    \slnetif_not_threadsafe
N
N    \par    Examples
N
N    \code
N        SlNetIf_t *InterfaceName;
N        InterfaceName = SlNetIf_getNameByID(SLNETIF_ID_1);
N    \endcode
N    <br>
N*/
NSlNetIf_t * SlNetIf_getIfByID(uint16_t ifID);
N
N
N/*!
N    \brief Get highest priority interface configuration using interface bitmap
N
N    The SlNetIf_getIfByID function retrieves highest priority interface
N    configuration that can be found in the interface bitmap, or the highest
N    exists when ifBitmap is zero.
N
N    \param[in,out] ifBitmap  Specifies the interface that needs to be checked
N                             according to the queryBitmap and return the
N                             interface with the highest priority.\n
N                             The values of the interface Bitmap is a combination
N                             of the interface identifiers defined with the prefix
N                             SLNETIF_ID_ which defined in slnetif.h
N                             Note: Zero is not a valid parameter, an error will
N                             be returned
N    \param[in]  queryBitmap  Specifies the additional criterias for the query
N                             that will be use along the interface priority and
N                             interface ID.\n
N                             queryBitmap bits:
N                                - #SLNETIF_QUERY_IF_STATE_BIT
N                                - #SLNETIF_QUERY_IF_CONNECTION_STATUS_BIT
N
N    \return                  A pointer to the configuration of the
N                             interface on success, or NULL on failure
N
N    \sa     SlNetIf_add()
N    \slnetif_not_threadsafe
N
N    \par    Examples
N
N    \code
N        SlNetIf_t *InterfaceName;
N        InterfaceName = SlNetIf_queryIf(SLNETIF_ID_1 | SLNETIF_ID_2 | SLNETIF_ID_3, SLNETIF_QUERY_IF_STATE_BIT | SLNETIF_QUERY_IF_CONNECTION_STATUS_BIT);
N    \endcode
N    <br>
N*/
NSlNetIf_t * SlNetIf_queryIf(uint32_t ifBitmap, uint32_t queryBitmap);
N
N
N/*!
N    \brief Get interface Name from interface ID
N
N    The SlNetIf_getNameByID function retrieves the name of the requested
N    interface.
N
N    \param[in] ifID      Specifies the interface which its name needs
N                         to be retrieved.\n
N                         The values of the interface identifier is
N                         defined with the prefix SLNETIF_ID_ which
N                         defined in slnetif.h
N
N    \return              A pointer to the name of the interface on
N                         success, or NULL on failure
N
N    \sa     SlNetIf_add()
N    \sa     SlNetIf_getIDByName()
N
N    \slnetif_not_threadsafe
N
N    \par    Examples
N
N    \code
N        char *InterfaceName;
N        InterfaceName = SlNetIf_getNameByID(SLNETIF_ID_1);
N    \endcode
N    <br>
N*/
Nconst char * SlNetIf_getNameByID(uint16_t ifID);
N
N
N/*!
N    \brief Get interface ID from interface name
N
N    The SlNetIf_getIDByName function retrieves the interface identifier of the
N    requested interface name.
N
N    \param[in] ifName    Specifies the interface which its interface
N                         identifier needs to be retrieved.\n
N
N    \return              The interface identifier value of the interface
N                         on success, or negative error code on failure
N                         The values of the interface identifier is
N                         defined with the prefix SLNETIF_ID_ which
N                         defined in slnetif.h
N
N    \sa     SlNetIf_add()
N    \sa     SlNetIf_getNameByID()
N    \sa     SlNetSock_getIfID()
N
N    \note                - Input NULL as ifName will return error code.
N                         - When using more than one interface with the same
N                           name, the ID of the highest priority interface
N                           will be returned
N    \slnetif_not_threadsafe
N
N    \par    Examples
N
N    \code
N        int16_t InterfaceID;
N        InterfaceID = SlNetIf_getIDByName("WiFi_Interface");
N    \endcode
N    <br>
N*/
Nint32_t SlNetIf_getIDByName(char *ifName);
N
N
N/*!
N    \brief Get interface priority
N
N    The SlNetIf_getPriority function retrieves the priority of the
N    interface.
N
N    \param[in] ifID      Specifies the interface which its priority
N                         needs to be retrieved.\n
N                         The values of the interface identifier is
N                         defined with the prefix SLNETIF_ID_ which
N                         defined in slnetif.h
N
N    \return              The priority value of the interface on success,
N                         or negative error code on failure
N
N    \sa     SlNetIf_add()
N    \sa     SlNetIf_setPriority()
N
N    \slnetif_not_threadsafe
N
N    \par    Examples
N
N    \code
N        int16_t Priority;
N        Priority = SlNetIf_getPriority(SLNETIF_ID_1);
N    \endcode
N    <br>
N*/
Nint32_t SlNetIf_getPriority(uint16_t ifID);
N
N
N/*!
N    \brief Set interface priority
N
N    The SlNetIf_setPriority function sets new priority to the requested interface.
N
N    \param[in] ifID          Specifies the interface which its priority
N                             needs to be changed.\n
N                             The values of the interface identifier is
N                             defined with the prefix SLNETIF_ID_ which
N                             defined in slnetif.h
N    \param[in] priority      Specifies the priority needs to be set.
N                             (In ascending order)
N                             Note: maximum priority is 15
N
N    \return                  Zero on success, or negative error code on
N                             failure
N
N    \sa     SlNetIf_add()
N    \sa     SlNetIf_getPriority()
N
N    \slnetif_not_threadsafe
N
N    \par    Examples
N
N    \code
N        uint8_t priority = 10;
N        SlNetIf_setPriority(SLNETIF_ID_1, priority);
N    \endcode
N    <br>
N*/
Nint32_t SlNetIf_setPriority(uint16_t ifID, uint8_t priority);
N
N
N/*!
N    \brief Set interface state
N
N    Enable or disable the interface.
N
N    \param[in] ifID       Specifies the interface which its state
N                          needs to be changed.\n
N                          The values of the interface identifier is
N                          defined with the prefix SLNETIF_ID_ which
N                          defined in slnetif.h
N    \param[in] ifState    Specifies the interface state.\n
N                          The values of the interface state are defined
N                          with the prefix SLNETIF_INTERFACE_ which
N                          defined in slnetif.h
N
N    \return               Zero on success, or negative error code on
N                          failure
N
N    \sa     SlNetIf_add()
N    \sa     SlNetIf_getState()
N
N    \slnetif_not_threadsafe
N
N    \par    Examples
N
N    \code
N        SlNetIf_setState(SLNETIF_STATE_ENABLE);
N    \endcode
N    <br>
N*/
Nint32_t SlNetIf_setState(uint16_t ifID, SlNetIfState_e ifState);
N
N
N/*!
N    \brief Get interface state
N
N    Obtain the current state of the interface.
N
N    \param[in] ifID      Specifies the interface which its state needs
N                         to be retrieved.\n
N                         The values of the interface identifier is
N                         defined with the prefix SLNETIF_ID_ which
N                         defined in slnetif.h
N
N    \return              State of the interface on success, or negative
N                         error code on failure
N
N    \sa     SlNetIf_add()
N    \sa     SlNetIf_setState()
N
N    \slnetif_not_threadsafe
N
N    \par    Examples
N
N    \code
N        int16_t InterfaceState
N        InterfaceState = SlNetIf_getState(SLNETIF_ID_1);
N    \endcode
N    <br>
N*/
Nint32_t SlNetIf_getState(uint16_t ifID);
N
N
N/*!
N    \brief Get interface connection status
N
N    Obtain the connection status of the interface.
N
N    \param[in] ifID      Specifies the interface which its connection
N                         status needs to be retrieved.\n
N                         The values of the interface identifier is
N                         defined with the prefix SLNETIF_ID_ which
N                         defined in slnetif.h
N
N    \return              Connection status of the interface on success,
N                         or negative error code on failure
N
N    \sa     SlNetIf_add()
N
N    \slnetif_not_threadsafe
N
N    \par    Examples
N
N    \code
N        int16_t connection_status
N        connection_status = SlNetIf_getConnectionStatus(SLNETIF_ID_1);
N    \endcode
N    <br>
N*/
Nint32_t SlNetIf_getConnectionStatus(uint16_t ifID);
N
N
N/*!
N    \brief Get IP Address of specific interface
N
N    The SlNetIf_getIPAddr function retrieve the IP address of a specific
N    interface according to the Address Type, IPv4, IPv6 LOCAL
N    or IPv6 GLOBAL.
N
N    \param[in]  ifID          Specifies the interface which its connection
N                              state needs to be retrieved.\n
N                              The values of the interface identifier is
N                              defined with the prefix SLNETIF_ID_ which
N                              defined in slnetif.h
N    \param[in]  addrType      Address type:
N                                          - #SLNETIF_IPV4_ADDR
N                                          - #SLNETIF_IPV6_ADDR_LOCAL
N                                          - #SLNETIF_IPV6_ADDR_GLOBAL
N    \param[out] addrConfig    Address config:
N                                          - #SLNETIF_ADDR_CFG_UNKNOWN
N                                          - #SLNETIF_ADDR_CFG_DHCP
N                                          - #SLNETIF_ADDR_CFG_DHCP_LLA
N                                          - #SLNETIF_ADDR_CFG_STATIC
N                                          - #SLNETIF_ADDR_CFG_STATELESS
N                                          - #SLNETIF_ADDR_CFG_STATEFUL
N    \param[out] ipAddr        IP Address according to the Address Type
N
N    \return                   Zero on success, or negative error code on failure
N
N    \sa     SlNetIfAddressType_e
N
N    \slnetif_not_threadsafe
N
N    \par    Examples
N
N    \code
N        SlNetSock_In6Addr_t IPAdd;
N        uint16_t addressConfig = 0;
N        SlNetIf_getIPAddr(SLNETIF_ID_1 ,SLNETIF_IPV6_ADDR_LOCAL ,&addressConfig ,(uint8_t *)ipAddr);
N    \endcode
N    <br>
N*/
Nint32_t SlNetIf_getIPAddr(uint16_t ifID, SlNetIfAddressType_e addrType, uint16_t *addrConfig, uint32_t *ipAddr);
N
N
N/*!
N    \brief Load secured buffer to the network stack
N
N    The SlNetSock_secLoadObj function loads buffer/files into the inputted
N    network stack for future usage of the socket SSL/TLS connection.
N    This option is relevant for network stacks with file system and also for
N    network stacks that lack file system that can store the secured files.
N
N    \param[in] objType          Specifies the security object type which
N                                could be one of the following:\n
N                                   - #SLNETIF_SEC_OBJ_TYPE_RSA_PRIVATE_KEY
N                                   - #SLNETIF_SEC_OBJ_TYPE_CERTIFICATE
N                                   - #SLNETIF_SEC_OBJ_TYPE_DH_KEY
N    \param[in] objName          Specifies the name/input identifier of the
N                                secured buffer loaded
N                                for file systems - this can be the file name
N                                for plain text buffer loading this can be the
N                                name of the object
N    \param[in] objNameLen       Specifies the buffer name length to be loaded.\n
N    \param[in] objBuff          Specifies the pointer to the secured buffer to
N                                be loaded.\n
N    \param[in] objBuffLen       Specifies the buffer length to be loaded.\n
N    \param[in] ifBitmap         Specifies the interfaces which the security
N                                objects needs to be added to.\n
N                                The values of the interface identifiers
N                                is defined with the prefix SLNETIF_ID_
N                                which defined in slnetif.h
N
N    \return                     On success, buffer type handler index to be
N                                used when attaching the secured buffer to a
N                                socket.\n
N                                A successful return code should be a positive
N                                number (int16)\n
N                                On error, a negative value will be returned
N                                specifying the error code.
N                                - #SLNETERR_STATUS_ERROR - load operation failed
N
N    \sa                         SlNetSock_setOpt()
N
N    \slnetif_not_threadsafe
N
N*/
Nint32_t SlNetIf_loadSecObj(uint16_t objType, char *objName, int16_t objNameLen, uint8_t *objBuff, int16_t objBuffLen, uint32_t ifBitmap);
N
N/*!
N
N Close the Doxygen group.
N @}
N
N*/
N
N#ifdef  __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __SL_NET_IF_H__ */
L 641 "/vagrant/Q4_04/sdk_root/source/ti/net/slnetsock.h" 2
N#include "slnetutils.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/net/slnetutils.h" 1
N/*
N * Copyright (c) 2017, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N
N#ifndef __SL_NET_UTILS_H__
N#define __SL_NET_UTILS_H__
N
N
N#ifdef    __cplusplus
Sextern "C" {
N#endif
N
N#include "slnetsock.h"
N
N/*!
N    \defgroup SlNetUtils SlNetUtils group
N
N    \short Sockets related commands and configuration
N
N*/
N/*!
N
N    \addtogroup SlNetUtils
N    @{
N
N*/
N
N/*****************************************************************************/
N/* Structure/Enum declarations                                               */
N/*****************************************************************************/
N
N/* Creating one address parameter from 4 separate address parameters */
N#define SLNETUTIL_IPV4_VAL(add_3,add_2,add_1,add_0)                         ((((uint32_t)add_3 << 24) & 0xFF000000) | (((uint32_t)add_2 << 16) & 0xFF0000) | (((uint32_t)add_1 << 8) & 0xFF00) | ((uint32_t)add_0 & 0xFF) )
N
N/*****************************************************************************/
N/* Function prototypes                                                       */
N/*****************************************************************************/
N
N/*!
N
N    \brief Initialize the SlNetUtil module
N
N    \param[in] flags            Reserved
N
N    \return                     Zero on success, or negative error code on failure
N*/
Nint32_t SlNetUtil_init(int32_t flags);
N
N/*!
N    \brief Get host IP by name\n
N    Obtain the IP Address of machine on network, by machine name.
N
N    \param[in]     ifBitmap     Specifies the interfaces which the the host ip
N                                needs to be retrieved from according tothe
N                                priority until one of them will return an answer.\n
N                                Value 0 is used in order to choose automatic
N                                interfaces selection according to the priority
N                                interface list.
N                                Value can be combination of interfaces by OR'ing
N                                multiple interfaces bit identifiers (SLNETIFC_IDENT_
N                                defined in slnetif.h)
N                                Note: interface identifier bit must be configured
N                                prior to this socket creation using SlNetIf_add().
N    \param[in]     name         Host name
N    \param[in]     nameLen      Name length
N    \param[out]    ipAddr       This parameter is filled in with an array of
N                                IP addresses. In case that host name is not
N                                resolved, ipAddrLen is zero.
N    \param[in,out] ipAddrLen    Holds the size of the ipAddr array, when function
N                                successful, the ipAddrLen parameter will be updated with
N                                the number of the IP addresses found.
N    \param[in]     family       Protocol family
N
N    \return                     The interface ID of the interface which run
N                                successfully the function, or negative on failure.\n
N                                #SLNETERR_POOL_IS_EMPTY may be return in case
N                                there are no resources in the system\n
N                                Possible DNS error codes:
N                                - #SLNETERR_NET_APP_DNS_QUERY_NO_RESPONSE
N                                - #SLNETERR_NET_APP_DNS_NO_SERVER
N                                - #SLNETERR_NET_APP_DNS_QUERY_FAILED
N                                - #SLNETERR_NET_APP_DNS_MALFORMED_PACKET
N                                - #SLNETERR_NET_APP_DNS_MISMATCHED_RESPONSE
N
N    \slnetutil_init_precondition
N
N    \warning
N            In case an IP address in a string format is set as input, without
N            any prefix (e.g. "1.2.3.4") the device will not try to access the
N            DNS and it will return the input address in the \c ipAddr field
N    \par  Example
N    - Getting IPv4 using get host by name:
N    \code
N    uint16_t DestIPListSize = 1;
N    uint32_t DestIP[1];
N    uint32_t ifID;
N    int16_t  SockId;
N    SlNetSock_AddrIn_t LocalAddr; //address of the server to connect to
N    int32_t LocalAddrSize;
N
N    ifID = SlNetUtil_getHostByName(0, "www.google.com", strlen("www.google.com"), DestIP, &DestIPListSize, SLNETSOCK_PF_INET);
N
N    LocalAddr.sin_family = SLNETSOCK_AF_INET;
N    LocalAddr.sin_addr.s_addr = SlNetUtil_htonl(DestIP[0]);
N    LocalAddr.sin_port = SlNetUtil_htons(80);
N    LocalAddrSize = sizeof(SlNetSock_AddrIn_t);
N
N    SockId = SlNetSock_create(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_STREAM, ifID, 0);
N
N    if (SockId >= 0)
N    {
N        status = SlNetSock_connect(SockId, (SlNetSock_Addr_t *) &LocalAddr, LocalAddrSize);
N    }
N    \endcode
N*/
Nint32_t SlNetUtil_getHostByName(uint32_t ifBitmap, char *name, const uint16_t nameLen, uint32_t *ipAddr, uint16_t *ipAddrLen, const uint8_t family);
N
N
N/*!
N    \brief Reorder the bytes of a 32-bit unsigned value
N
N    This function is used to reorder the bytes of a 32-bit unsigned value
N    from host order to network order.
N
N    \param[in] val              Variable in host order
N
N    \return                     Return the variable in network order
N
N    \slnetutil_init_precondition
N
N    \sa         SlNetSock_bind()
N    \sa         SlNetSock_connect()
N    \sa         SlNetSock_recvFrom()
N    \sa         SlNetSock_accept()
N*/
Nuint32_t SlNetUtil_htonl(uint32_t val);
N
N
N/*!
N    \brief Reorder the bytes of a 32-bit unsigned value
N
N    This function is used to reorder the bytes of a 32-bit unsigned
N    value from network order to host order.
N
N    \param[in] val              Variable in network order
N
N    \return                     Return the variable in host order
N
N    \slnetutil_init_precondition
N
N    \sa         SlNetSock_bind()
N    \sa         SlNetSock_connect()
N    \sa         SlNetSock_recvFrom()
N    \sa         SlNetSock_accept()
N*/
Nuint32_t SlNetUtil_ntohl(uint32_t val);
N
N
N/*!
N    \brief Reorder the bytes of a 16-bit unsigned value
N
N    This functions is used to reorder the bytes of a 16-bit unsigned
N    value from host order to network order.
N
N    \param[in] val              Variable in host order
N
N    \return                     Return the variable in network order
N
N    \slnetutil_init_precondition
N
N    \sa         SlNetSock_bind()
N    \sa         SlNetSock_connect()
N    \sa         SlNetSock_recvFrom()
N    \sa         SlNetSock_accept()
N*/
Nuint16_t SlNetUtil_htons(uint16_t val);
N
N
N/*!
N    \brief Reorder the bytes of a 16-bit unsigned value
N
N    This functions is used to reorder the bytes of a 16-bit unsigned value
N    from network order to host order.
N
N    \param[in] val              Variable in network order
N
N    \return                     Return the variable in host order
N
N    \slnetutil_init_precondition
N
N    \sa         SlNetSock_bind()
N    \sa         SlNetSock_connect()
N    \sa         SlNetSock_recvFrom()
N    \sa         SlNetSock_accept()
N*/
Nuint16_t SlNetUtil_ntohs(uint16_t val);
N
N
N/*!
N    \brief Converts IP address in binary representation to string representation
N
N    This functions is used to converts IP address in binary representation
N    to IP address in string representation.
N
N    \param[in]  addrFamily     Specifies the address family of the created
N                               socket
N                               For example:
N                                 - #SLNETSOCK_AF_INET for network address IPv4
N                                 - #SLNETSOCK_AF_INET6 for network address IPv6
N    \param[in]  binaryAddr     Pointer to an IP address structure indicating the
N                               address in binary representation
N    \param[out] strAddr        Pointer to the address string representation
N                               for IPv4 or IPv6 according to the address
N                               family
N    \param[in]  strAddrLen     Specifies the length of the StrAddress_dst,
N                               the maximum length of the address in string
N                               representation for IPv4 or IPv6 according to
N                               the address family
N
N    \return                    strAddr on success, or NULL on failure
N
N    \slnetutil_init_precondition
N
N    \par    Example
N    - IPv4 demo of inet_ntop()
N    \code
N        SlNetSock_AddrIn_t sa;
N        char str[SLNETSOCK_INET_ADDRSTRLEN];
N
N        // store this IP address in sa:
N        SlNetSock_inet_pton(SLNETSOCK_AF_INET, "192.0.2.33", &(sa.sin_addr));
N        // now get it back and print it
N        SlNetSock_inet_ntop(SLNETSOCK_AF_INET, &(sa.sin_addr), str, SLNETSOCK_INET_ADDRSTRLEN);
N    \endcode
N*/
Nconst char *SlNetUtil_inetNtop(int16_t addrFamily, const void *binaryAddr, char *strAddr, SlNetSocklen_t strAddrLen);
N
N
N/*!
N    \brief Converts IP address in string representation to binary representation
N
N    This functions is used to converts IP address in string representation
N    to IP address in binary representation.
N
N    \param[in]  addrFamily     Specifies the address family of the created
N                               socket
N                               For example:
N                                 - #SLNETSOCK_AF_INET for network address IPv4
N                                 - #SLNETSOCK_AF_INET6 for network address IPv6
N    \param[out] strAddr        Specifies the IP address in string representation
N                               for IPv4 or IPv6 according to the address
N                               family
N    \param[in]  binaryAddr     Pointer to an address structure that will be
N                               filled by the IP address in Binary representation
N
N    \return                    1 on success, -1 on failure, or 0 if the input
N                               isn't a valid IP address
N
N    \slnetutil_init_precondition
N
N    \par    Example
N    - IPv6 demo of inet_pton()
N    \code
N        SlNetSock_AddrIn6_t sa;
N
N        // store this IP address in sa:
N        SlNetSock_inet_pton(SLNETSOCK_AF_INET6, "SLNETSOCK_AF_INET6", &(sa.sin6_addr));
N    \endcode
N*/
Nint32_t SlNetUtil_inetPton(int16_t addrFamily, const char *strAddr, void *binaryAddr);
N
N/*!
N
N Close the Doxygen group.
N @}
N
N*/
N
N
N#ifdef  __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __SL_NET_UTILS_H__ */
L 642 "/vagrant/Q4_04/sdk_root/source/ti/net/slnetsock.h" 2
N#include "slneterr.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/net/slneterr.h" 1
N/*
N * Copyright (c) 2017, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N
N#ifndef __SL_NET_ERR_H__
N#define __SL_NET_ERR_H__
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*!
N    \defgroup SlNetErr SlNetErr group
N
N    \short Provide BSD and proprietary errors
N
N*/
N/*!
N
N    \addtogroup SlNetErr
N    @{
N
N*/
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N
N#define SLNETERR_RET_CODE_OK                                            (0L)     /**< Success                                                                 */
N
N#define SLNETERR_GENERAL_DEVICE                                         (-6L)    /**< General device error                                                    */
N
N/* BSD SOCKET ERRORS CODES */
N
N#define SLNETERR_BSD_SOC_ERROR                                          (-1L)    /**< Failure                                                                 */
N#define SLNETERR_BSD_ENXIO                                              (-6L)    /**< No such device or address                                               */
N#define SLNETERR_BSD_INEXE                                              (-8L)    /**< socket command in execution                                             */
N#define SLNETERR_BSD_EBADF                                              (-9L)    /**< Bad file number                                                         */
N#define SLNETERR_BSD_ENSOCK                                             (-10L)   /**< The system limit on the total number of open socket, has been reached   */
N#define SLNETERR_BSD_EAGAIN                                             (-11L)   /**< Try again                                                               */
N#define SLNETERR_BSD_EWOULDBLOCK                                        SLNETERR_BSD_EAGAIN
N#define SLNETERR_BSD_ENOMEM                                             (-12L)   /**< Out of memory                                                           */
N#define SLNETERR_BSD_EACCES                                             (-13L)   /**< Permission denied                                                       */
N#define SLNETERR_BSD_EFAULT                                             (-14L)   /**< Bad address                                                             */
N#define SLNETERR_BSD_ECLOSE                                             (-15L)   /**< close socket operation failed to transmit all queued packets            */
N#define SLNETERR_BSD_EALREADY_ENABLED                                   (-21L)   /**< Transceiver - Transceiver already ON. there could be only one           */
N#define SLNETERR_BSD_EINVAL                                             (-22L)   /**< Invalid argument                                                        */
N#define SLNETERR_BSD_EAUTO_CONNECT_OR_CONNECTING                        (-69L)   /**< Transceiver - During connection, connected or auto mode started         */
N#define SLNETERR_BSD_CONNECTION_PENDING                                 (-72L)   /**< Transceiver - Device is connected, disconnect first to open transceiver */
N#define SLNETERR_BSD_EUNSUPPORTED_ROLE                                  (-86L)   /**< Transceiver - Trying to start when WLAN role is AP or P2P GO            */
N#define SLNETERR_BSD_ENOTSOCK                                           (-88L)   /**< Socket operation on non-socket                                          */
N#define SLNETERR_BSD_EDESTADDRREQ                                       (-89L)   /**< Destination address required                                            */
N#define SLNETERR_BSD_EMSGSIZE                                           (-90L)   /**< Message too long                                                        */
N#define SLNETERR_BSD_EPROTOTYPE                                         (-91L)   /**< Protocol wrong type for socket                                          */
N#define SLNETERR_BSD_ENOPROTOOPT                                        (-92L)   /**< Protocol not available                                                  */
N#define SLNETERR_BSD_EPROTONOSUPPORT                                    (-93L)   /**< Protocol not supported                                                  */
N#define SLNETERR_BSD_ESOCKTNOSUPPORT                                    (-94L)   /**< Socket type not supported                                               */
N#define SLNETERR_BSD_EOPNOTSUPP                                         (-95L)   /**< Operation not supported on transport endpoint                           */
N#define SLNETERR_BSD_EAFNOSUPPORT                                       (-97L)   /**< Address family not supported by protocol                                */
N#define SLNETERR_BSD_EADDRINUSE                                         (-98L)   /**< Address already in use                                                  */
N#define SLNETERR_BSD_EADDRNOTAVAIL                                      (-99L)   /**< Cannot assign requested address                                         */
N#define SLNETERR_BSD_ENETUNREACH                                        (-101L)  /**< Network is unreachable                                                  */
N#define SLNETERR_BSD_ECONNABORTED                                       (-103L)  /**< Software caused connection abort                                        */
N#define SLNETERR_BSD_ECONNRESET                                         (-104L)  /**< Connection reset by peer                                                */
N#define SLNETERR_BSD_ENOBUFS                                            (-105L)  /**< No buffer space available                                               */
N#define SLNETERR_BSD_EOBUFF                                             SLNETERR_BSD_ENOBUFS
N#define SLNETERR_BSD_EISCONN                                            (-106L)  /**< Transport endpoint is already connected                                 */
N#define SLNETERR_BSD_ENOTCONN                                           (-107L)  /**< Transport endpoint is not connected                                     */
N#define SLNETERR_BSD_ESHUTDOWN                                          (-108L)  /**< Cannot send after transport endpoint shutdown                           */
N#define SLNETERR_BSD_ETIMEDOUT                                          (-110L)  /**< Connection timed out                                                    */
N#define SLNETERR_BSD_ECONNREFUSED                                       (-111L)  /**< Connection refused                                                      */
N#define SLNETERR_BSD_EHOSTDOWN                                          (-112L)  /**< Host is down                                                            */
N#define SLNETERR_BSD_EHOSTUNREACH                                       (-113L)  /**< No route to host                                                        */
N#define SLNETERR_BSD_EALREADY                                           (-114L)  /**< Non blocking connect in progress, try again                             */
N
N/* ssl tls security start with -300 offset */
N#define SLNETERR_ESEC_CLOSE_NOTIFY                                      (-300L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_UNEXPECTED_MESSAGE                                (-310L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_BAD_RECORD_MAC                                    (-320L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_DECRYPTION_FAILED                                 (-321L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_RECORD_OVERFLOW                                   (-322L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_DECOMPRESSION_FAILURE                             (-330L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_HANDSHAKE_FAILURE                                 (-340L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_NO_CERTIFICATE                                    (-341L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_BAD_CERTIFICATE                                   (-342L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_UNSUPPORTED_CERTIFICATE                           (-343L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_ILLEGAL_PARAMETER                                 (-347L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_ACCESS_DENIED                                     (-349L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_DECODE_ERROR                                      (-350L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_DECRYPT_ERROR1                                    (-351L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_EXPORT_RESTRICTION                                (-360L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_PROTOCOL_VERSION                                  (-370L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_INSUFFICIENT_SECURITY                             (-371L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_INTERNAL_ERROR                                    (-380L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_USER_CANCELLED                                    (-390L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_NO_RENEGOTIATION                                  (-400L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_UNSUPPORTED_EXTENSION                             (-410L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_CERTIFICATE_UNOBTAINABLE                          (-411L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_UNRECOGNIZED_NAME                                 (-412L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_BAD_CERTIFICATE_STATUS_RESPONSE                   (-413L)  /**< ssl/tls alerts */
N#define SLNETERR_ESEC_BAD_CERTIFICATE_HASH_VALUE                        (-414L)  /**< ssl/tls alerts */
N
N
N/* proprietary secure */
N#define SLNETERR_ESEC_GENERAL                                           (-450L)  /**< error secure level general error                                               */
N#define SLNETERR_ESEC_DECRYPT                                           (-451L)  /**< error secure level, decrypt recv packet fail                                   */
N#define SLNETERR_ESEC_CLOSED                                            (-452L)  /**< secure layrer is closed by other size , tcp is still connected                 */
N#define SLNETERR_ESEC_SNO_VERIFY                                        (-453L)  /**< Connected without server verification                                          */
N#define SLNETERR_ESEC_NO_CA_FILE                                        (-454L)  /**< error secure level CA file not found                                           */
N#define SLNETERR_ESEC_MEMORY                                            (-455L)  /**< error secure level No memory  space available                                  */
N#define SLNETERR_ESEC_BAD_CA_FILE                                       (-456L)  /**< error secure level bad CA file                                                 */
N#define SLNETERR_ESEC_BAD_CERT_FILE                                     (-457L)  /**< error secure level bad Certificate file                                        */
N#define SLNETERR_ESEC_BAD_PRIVATE_FILE                                  (-458L)  /**< error secure level bad private file                                            */
N#define SLNETERR_ESEC_BAD_DH_FILE                                       (-459L)  /**< error secure level bad DH file                                                 */
N#define SLNETERR_ESEC_T00_MANY_SSL_OPENED                               (-460L)  /**< MAX SSL Sockets are opened                                                     */
N#define SLNETERR_ESEC_DATE_ERROR                                        (-461L)  /**< connected with certificate date verification error                             */
N#define SLNETERR_ESEC_HAND_SHAKE_TIMED_OUT                              (-462L)  /**< connection timed out due to handshake time                                     */
N#define SLNETERR_ESEC_TX_BUFFER_NOT_EMPTY                               (-463L)  /**< cannot start ssl connection while send buffer is full                          */
N#define SLNETERR_ESEC_RX_BUFFER_NOT_EMPTY                               (-464L)  /**< cannot start ssl connection while recv buffer is full                          */
N#define SLNETERR_ESEC_SSL_DURING_HAND_SHAKE                             (-465L)  /**< cannot use while in hanshaking                                                 */
N#define SLNETERR_ESEC_NOT_ALLOWED_WHEN_LISTENING                        (-466L)  /**< the operation is not allowed when listening, do before listen                  */
N#define SLNETERR_ESEC_CERTIFICATE_REVOKED                               (-467L)  /**< connected but on of the certificates in the chain is revoked                   */
N#define SLNETERR_ESEC_UNKNOWN_ROOT_CA                                   (-468L)  /**< connected but the root CA used to validate the peer is unknown                 */
N#define SLNETERR_ESEC_WRONG_PEER_CERT                                   (-469L)  /**< wrong peer cert (server cert) was received while trying to connect to server   */
N#define SLNETERR_ESEC_TCP_DISCONNECTED_UNCOMPLETE_RECORD                (-470L)  /**< the other side disconnected the TCP layer and didn't send the whole ssl record */
N#define SLNETERR_ESEC_HELLO_VERIFY_ERROR                                (-471L)  /**< Hello verification failed in DTLS                                              */
N
N#define SLNETERR_ESEC_BUFFER_E                                          (-632L)  /**< output buffer too small or input too large */
N#define SLNETERR_ESEC_ALGO_ID_E                                         (-633L)  /**< setting algo id error                      */
N#define SLNETERR_ESEC_PUBLIC_KEY_E                                      (-634L)  /**< setting public key error                   */
N#define SLNETERR_ESEC_DATE_E                                            (-635L)  /**< setting date validity error                */
N#define SLNETERR_ESEC_SUBJECT_E                                         (-636L)  /**< setting subject name error                 */
N#define SLNETERR_ESEC_ISSUER_E                                          (-637L)  /**< setting issuer  name error                 */
N#define SLNETERR_ESEC_CA_TRUE_E                                         (-638L)  /**< setting CA basic constraint true error     */
N#define SLNETERR_ESEC_EXTENSIONS_E                                      (-639L)  /**< setting extensions error                   */
N#define SLNETERR_ESEC_ASN_PARSE_E                                       (-640L)  /**< ASN parsing error, invalid input           */
N#define SLNETERR_ESEC_ASN_VERSION_E                                     (-641L)  /**< ASN version error, invalid number          */
N#define SLNETERR_ESEC_ASN_GETINT_E                                      (-642L)  /**< ASN get big int error, invalid data        */
N#define SLNETERR_ESEC_ASN_RSA_KEY_E                                     (-643L)  /**< ASN key init error, invalid input          */
N#define SLNETERR_ESEC_ASN_OBJECT_ID_E                                   (-644L)  /**< ASN object id error, invalid id            */
N#define SLNETERR_ESEC_ASN_TAG_NULL_E                                    (-645L)  /**< ASN tag error, not null                    */
N#define SLNETERR_ESEC_ASN_EXPECT_0_E                                    (-646L)  /**< ASN expect error, not zero                 */
N#define SLNETERR_ESEC_ASN_BITSTR_E                                      (-647L)  /**< ASN bit string error, wrong id             */
N#define SLNETERR_ESEC_ASN_UNKNOWN_OID_E                                 (-648L)  /**< ASN oid error, unknown sum id              */
N#define SLNETERR_ESEC_ASN_DATE_SZ_E                                     (-649L)  /**< ASN date error, bad size                   */
N#define SLNETERR_ESEC_ASN_BEFORE_DATE_E                                 (-650L)  /**< ASN date error, current date before        */
N#define SLNETERR_ESEC_ASN_AFTER_DATE_E                                  (-651L)  /**< ASN date error, current date after         */
N#define SLNETERR_ESEC_ASN_SIG_OID_E                                     (-652L)  /**< ASN signature error, mismatched oid        */
N#define SLNETERR_ESEC_ASN_TIME_E                                        (-653L)  /**< ASN time error, unknown time type          */
N#define SLNETERR_ESEC_ASN_INPUT_E                                       (-654L)  /**< ASN input error, not enough data           */
N#define SLNETERR_ESEC_ASN_SIG_CONFIRM_E                                 (-655L)  /**< ASN sig error, confirm failure             */
N#define SLNETERR_ESEC_ASN_SIG_HASH_E                                    (-656L)  /**< ASN sig error, unsupported hash type       */
N#define SLNETERR_ESEC_ASN_SIG_KEY_E                                     (-657L)  /**< ASN sig error, unsupported key type        */
N#define SLNETERR_ESEC_ASN_DH_KEY_E                                      (-658L)  /**< ASN key init error, invalid input          */
N#define SLNETERR_ESEC_ASN_NTRU_KEY_E                                    (-659L)  /**< ASN ntru key decode error, invalid input   */
N#define SLNETERR_ESEC_ASN_CRIT_EXT_E                                    (-660L)  /**< ASN unsupported critical extension         */
N#define SLNETERR_ESEC_ECC_BAD_ARG_E                                     (-670L)  /**< ECC input argument of wrong type           */
N#define SLNETERR_ESEC_ASN_ECC_KEY_E                                     (-671L)  /**< ASN ECC bad input                          */
N#define SLNETERR_ESEC_ECC_CURVE_OID_E                                   (-672L)  /**< Unsupported ECC OID curve type             */
N#define SLNETERR_ESEC_BAD_FUNC_ARG                                      (-673L)  /**< Bad function argument provided             */
N#define SLNETERR_ESEC_NOT_COMPILED_IN                                   (-674L)  /**< Feature not compiled in                    */
N#define SLNETERR_ESEC_UNICODE_SIZE_E                                    (-675L)  /**< Unicode password too big                   */
N#define SLNETERR_ESEC_NO_PASSWORD                                       (-676L)  /**< no password provided by user               */
N#define SLNETERR_ESEC_ALT_NAME_E                                        (-677L)  /**< alt name size problem, too big             */
N#define SLNETERR_ESEC_ASN_NO_SIGNER_E                                   (-688L)  /**< ASN no signer to confirm failure           */
N#define SLNETERR_ESEC_ASN_CRL_CONFIRM_E                                 (-689L)  /**< ASN CRL signature confirm failure          */
N#define SLNETERR_ESEC_ASN_CRL_NO_SIGNER_E                               (-690L)  /**< ASN CRL no signer to confirm failure       */
N#define SLNETERR_ESEC_ASN_OCSP_CONFIRM_E                                (-691L)  /**< ASN OCSP signature confirm failure         */
N#define SLNETERR_ESEC_VERIFY_FINISHED_ERROR                             (-704L)  /**< verify problem on finished                 */
N#define SLNETERR_ESEC_VERIFY_MAC_ERROR                                  (-705L)  /**< verify mac problem                         */
N#define SLNETERR_ESEC_PARSE_ERROR                                       (-706L)  /**< parse error on header                      */
N#define SLNETERR_ESEC_UNKNOWN_HANDSHAKE_TYPE                            (-707L)  /**< weird handshake type                       */
N#define SLNETERR_ESEC_SOCKET_ERROR_E                                    (-708L)  /**< error state on socket                      */
N#define SLNETERR_ESEC_SOCKET_NODATA                                     (-709L)  /**< expected data, not there                   */
N#define SLNETERR_ESEC_INCOMPLETE_DATA                                   (-710L)  /**< don't have enough data to complete task    */
N#define SLNETERR_ESEC_UNKNOWN_RECORD_TYPE                               (-711L)  /**< unknown type in record hdr                 */
N#define SLNETERR_ESEC_INNER_DECRYPT_ERROR                               (-712L)  /**< error during decryption                    */
N#define SLNETERR_ESEC_FATAL_ERROR                                       (-713L)  /**< recvd alert fatal error                    */
N#define SLNETERR_ESEC_ENCRYPT_ERROR                                     (-714L)  /**< error during encryption                    */
N#define SLNETERR_ESEC_FREAD_ERROR                                       (-715L)  /**< fread problem                              */
N#define SLNETERR_ESEC_NO_PEER_KEY                                       (-716L)  /**< need peer's key                            */
N#define SLNETERR_ESEC_NO_PRIVATE_KEY                                    (-717L)  /**< need the private key                       */
N#define SLNETERR_ESEC_RSA_PRIVATE_ERROR                                 (-718L)  /**< error during rsa priv op                   */
N#define SLNETERR_ESEC_NO_DH_PARAMS                                      (-719L)  /**< server missing DH params                   */
N#define SLNETERR_ESEC_BUILD_MSG_ERROR                                   (-720L)  /**< build message failure                      */
N#define SLNETERR_ESEC_BAD_HELLO                                         (-721L)  /**< client hello malformed                     */
N#define SLNETERR_ESEC_DOMAIN_NAME_MISMATCH                              (-722L)  /**< peer subject name mismatch                 */
N#define SLNETERR_ESEC_WANT_READ                                         (-723L)  /**< want read, call again                      */
N#define SLNETERR_ESEC_NOT_READY_ERROR                                   (-724L)  /**< handshake layer not ready                  */
N#define SLNETERR_ESEC_PMS_VERSION_ERROR                                 (-725L)  /**< pre m secret version error                 */
N#define SLNETERR_ESEC_WANT_WRITE                                        (-727L)  /**< want write, call again                     */
N#define SLNETERR_ESEC_BUFFER_ERROR                                      (-728L)  /**< malformed buffer input                     */
N#define SLNETERR_ESEC_VERIFY_CERT_ERROR                                 (-729L)  /**< verify cert error                          */
N#define SLNETERR_ESEC_VERIFY_SIGN_ERROR                                 (-730L)  /**< verify sign error                          */
N#define SLNETERR_ESEC_LENGTH_ERROR                                      (-741L)  /**< record layer length error                  */
N#define SLNETERR_ESEC_PEER_KEY_ERROR                                    (-742L)  /**< can't decode peer key                      */
N#define SLNETERR_ESEC_ZERO_RETURN                                       (-743L)  /**< peer sent close notify                     */
N#define SLNETERR_ESEC_SIDE_ERROR                                        (-744L)  /**< wrong client/server type                   */
N#define SLNETERR_ESEC_NO_PEER_CERT                                      (-745L)  /**< peer didn't send key                       */
N#define SLNETERR_ESEC_ECC_CURVETYPE_ERROR                               (-750L)  /**< Bad ECC Curve Type                         */
N#define SLNETERR_ESEC_ECC_CURVE_ERROR                                   (-751L)  /**< Bad ECC Curve                              */
N#define SLNETERR_ESEC_ECC_PEERKEY_ERROR                                 (-752L)  /**< Bad Peer ECC Key                           */
N#define SLNETERR_ESEC_ECC_MAKEKEY_ERROR                                 (-753L)  /**< Bad Make ECC Key                           */
N#define SLNETERR_ESEC_ECC_EXPORT_ERROR                                  (-754L)  /**< Bad ECC Export Key                         */
N#define SLNETERR_ESEC_ECC_SHARED_ERROR                                  (-755L)  /**< Bad ECC Shared Secret                      */
N#define SLNETERR_ESEC_NOT_CA_ERROR                                      (-757L)  /**< Not a CA cert error                        */
N#define SLNETERR_ESEC_BAD_PATH_ERROR                                    (-758L)  /**< Bad path for opendir                       */
N#define SLNETERR_ESEC_BAD_CERT_MANAGER_ERROR                            (-759L)  /**< Bad Cert Manager                           */
N#define SLNETERR_ESEC_OCSP_CERT_REVOKED                                 (-760L)  /**< OCSP Certificate revoked                   */
N#define SLNETERR_ESEC_CRL_CERT_REVOKED                                  (-761L)  /**< CRL Certificate revoked                    */
N#define SLNETERR_ESEC_CRL_MISSING                                       (-762L)  /**< CRL Not loaded                             */
N#define SLNETERR_ESEC_MONITOR_RUNNING_E                                 (-763L)  /**< CRL Monitor already running                */
N#define SLNETERR_ESEC_THREAD_CREATE_E                                   (-764L)  /**< Thread Create Error                        */
N#define SLNETERR_ESEC_OCSP_NEED_URL                                     (-765L)  /**< OCSP need an URL for lookup                */
N#define SLNETERR_ESEC_OCSP_CERT_UNKNOWN                                 (-766L)  /**< OCSP responder doesn't know                */
N#define SLNETERR_ESEC_OCSP_LOOKUP_FAIL                                  (-767L)  /**< OCSP lookup not successful                 */
N#define SLNETERR_ESEC_MAX_CHAIN_ERROR                                   (-768L)  /**< max chain depth exceeded                   */
N#define SLNETERR_ESEC_NO_PEER_VERIFY                                    (-778L)  /**< Need peer cert verify Error                */
N#define SLNETERR_ESEC_UNSUPPORTED_SUITE                                 (-790L)  /**< unsupported cipher suite                   */
N#define SLNETERR_ESEC_MATCH_SUITE_ERROR                                 (-791L)  /**< can't match cipher suite                   */
N
N
N
N/* WLAN ERRORS CODES*/
N
N#define SLNETERR_WLAN_KEY_ERROR                                         (-2049L)
N#define SLNETERR_WLAN_INVALID_ROLE                                      (-2050L)
N#define SLNETERR_WLAN_PREFERRED_NETWORKS_FILE_LOAD_FAILED               (-2051L)
N#define SLNETERR_WLAN_CANNOT_CONFIG_SCAN_DURING_PROVISIONING            (-2052L)
N#define SLNETERR_WLAN_INVALID_SECURITY_TYPE                             (-2054L)
N#define SLNETERR_WLAN_PASSPHRASE_TOO_LONG                               (-2055L)
N#define SLNETERR_WLAN_EAP_WRONG_METHOD                                  (-2057L)
N#define SLNETERR_WLAN_PASSWORD_ERROR                                    (-2058L)
N#define SLNETERR_WLAN_EAP_ANONYMOUS_LEN_ERROR                           (-2059L)
N#define SLNETERR_WLAN_SSID_LEN_ERROR                                    (-2060L)
N#define SLNETERR_WLAN_USER_ID_LEN_ERROR                                 (-2061L)
N#define SLNETERR_WLAN_PREFERRED_NETWORK_LIST_FULL                       (-2062L)
N#define SLNETERR_WLAN_PREFERRED_NETWORKS_FILE_WRITE_FAILED              (-2063L)
N#define SLNETERR_WLAN_ILLEGAL_WEP_KEY_INDEX                             (-2064L)
N#define SLNETERR_WLAN_INVALID_DWELL_TIME_VALUES                         (-2065L)
N#define SLNETERR_WLAN_INVALID_POLICY_TYPE                               (-2066L)
N#define SLNETERR_WLAN_PM_POLICY_INVALID_OPTION                          (-2067L)
N#define SLNETERR_WLAN_PM_POLICY_INVALID_PARAMS                          (-2068L)
N#define SLNETERR_WLAN_WIFI_NOT_CONNECTED                                (-2069L)
N#define SLNETERR_WLAN_ILLEGAL_CHANNEL                                   (-2070L)
N#define SLNETERR_WLAN_WIFI_ALREADY_DISCONNECTED                         (-2071L)
N#define SLNETERR_WLAN_TRANSCEIVER_ENABLED                               (-2072L)
N#define SLNETERR_WLAN_GET_NETWORK_LIST_EAGAIN                           (-2073L)
N#define SLNETERR_WLAN_GET_PROFILE_INVALID_INDEX                         (-2074L)
N#define SLNETERR_WLAN_FAST_CONN_DATA_INVALID                            (-2075L)
N#define SLNETERR_WLAN_NO_FREE_PROFILE                                   (-2076L)
N#define SLNETERR_WLAN_AP_SCAN_INTERVAL_TOO_LOW                          (-2077L)
N#define SLNETERR_WLAN_SCAN_POLICY_INVALID_PARAMS                        (-2078L)
N
N#define SLNETERR_RXFL_OK                                                (0L)     /**< O.K                                                                                     */
N#define SLNETERR_RXFL_RANGE_COMPARE_PARAMS_ARE_INVALID                  (-2079L)
N#define SLNETERR_RXFL_RXFL_INVALID_PATTERN_LENGTH                       (-2080L) /**< requested length for L1/L4 payload matching must not exceed 16 bytes                    */
N#define SLNETERR_RXFL_ACTION_USER_EVENT_ID_TOO_BIG                      (-2081L) /**< user action id for host event must not exceed SLNETERR_WLAN_RX_FILTER_MAX_USER_EVENT_ID */
N#define SLNETERR_RXFL_OFFSET_TOO_BIG                                    (-2082L) /**< requested offset for L1/L4 payload matching must not exceed 1535 bytes                  */
N#define SLNETERR_RXFL_STAT_UNSUPPORTED                                  (-2083L) /**< get rx filters statistics not supported                                                 */
N#define SLNETERR_RXFL_INVALID_FILTER_ARG_UPDATE                         (-2084L) /**< invalid filter args request                                                             */
N#define SLNETERR_RXFL_INVALID_SYSTEM_STATE_TRIGGER_FOR_FILTER_TYPE      (-2085L) /**< system state not supported for this filter type                                         */
N#define SLNETERR_RXFL_INVALID_FUNC_ID_FOR_FILTER_TYPE                   (-2086L) /**< function id not supported for this filter type                                          */
N#define SLNETERR_RXFL_DEPENDENT_FILTER_DO_NOT_EXIST_3                   (-2087L) /**< filter parent doesn't exist                                                             */
N#define SLNETERR_RXFL_OUTPUT_OR_INPUT_BUFFER_LENGTH_TOO_SMALL           (-2088L) /**< ! The output buffer length is smaller than required for that operation                  */
N#define SLNETERR_RXFL_DEPENDENT_FILTER_SOFTWARE_FILTER_NOT_FIT          (-2089L) /**< Node filter can't be child of software filter and vice_versa                            */
N#define SLNETERR_RXFL_DEPENDENCY_IS_NOT_PERSISTENT                      (-2090L) /**< Dependency filter is not persistent                                                     */
N#define SLNETERR_RXFL_RXFL_ALLOCATION_PROBLEM                           (-2091L)
N#define SLNETERR_RXFL_SYSTEM_STATE_NOT_SUPPORTED_FOR_THIS_FILTER        (-2092L) /**< System state is not supported                                                           */
N#define SLNETERR_RXFL_TRIGGER_USE_REG5_TO_REG8                          (-2093L) /**< Only counters 5 - 8 are allowed, for Tigger                                             */
N#define SLNETERR_RXFL_TRIGGER_USE_REG1_TO_REG4                          (-2094L) /**< Only counters 1 - 4 are allowed, for trigger                                            */
N#define SLNETERR_RXFL_ACTION_USE_REG5_TO_REG8                           (-2095L) /**< Only counters 5 - 8 are allowed, for action                                             */
N#define SLNETERR_RXFL_ACTION_USE_REG1_TO_REG4                           (-2096L) /**< Only counters 1 - 4 are allowed, for action                                             */
N#define SLNETERR_RXFL_FIELD_SUPPORT_ONLY_EQUAL_AND_NOTEQUAL             (-2097L) /**< Rule compare function Id is out of range                                                */
N#define SLNETERR_RXFL_WRONG_MULTICAST_BROADCAST_ADDRESS                 (-2098L) /**< The address should be of type mutlicast or broadcast                                    */
N#define SLNETERR_RXFL_THE_FILTER_IS_NOT_OF_HEADER_TYPE                  (-2099L) /**< The filter should be of header type                                                     */
N#define SLNETERR_RXFL_WRONG_COMPARE_FUNC_FOR_BROADCAST_ADDRESS          (-2100L) /**< The compare funcion is not suitable for broadcast address                               */
N#define SLNETERR_RXFL_WRONG_MULTICAST_ADDRESS                           (-2101L) /**< The address should be of muticast type                                                  */
N#define SLNETERR_RXFL_DEPENDENT_FILTER_IS_NOT_PERSISTENT                (-2102L) /**< The dependency filter is not persistent                                                 */
N#define SLNETERR_RXFL_DEPENDENT_FILTER_IS_NOT_ENABLED                   (-2103L) /**< The dependency filter is not enabled                                                    */
N#define SLNETERR_RXFL_FILTER_HAS_CHILDS                                 (-2104L) /**< The filter has childs and can't be removed                                              */
N#define SLNETERR_RXFL_CHILD_IS_ENABLED                                  (-2105L) /**< Can't disable filter while the child is enabled                                         */
N#define SLNETERR_RXFL_DEPENDENCY_IS_DISABLED                            (-2106L) /**< Can't enable filetr in case its depndency filter is disabled                            */
N#define SLNETERR_RXFL_MAC_SEND_MATCHDB_FAILED                           (-2107L)
N#define SLNETERR_RXFL_MAC_SEND_ARG_DB_FAILED                            (-2108L)
N#define SLNETERR_RXFL_MAC_SEND_NODEDB_FAILED                            (-2109L)
N#define SLNETERR_RXFL_MAC_OPERTATION_RESUME_FAILED                      (-2110L)
N#define SLNETERR_RXFL_MAC_OPERTATION_HALT_FAILED                        (-2111L)
N#define SLNETERR_RXFL_NUMBER_OF_CONNECTION_POINTS_EXCEEDED              (-2112L) /**< Number of connection points exceeded                                                    */
N#define SLNETERR_RXFL_DEPENDENT_FILTER_DEPENDENCY_ACTION_IS_DROP        (-2113L) /**< The dependent filter has Drop action, thus the filter can't be created                  */
N#define SLNETERR_RXFL_FILTER_DO_NOT_EXISTS                              (-2114L) /**< The filter doesn't exists                                                               */
N#define SLNETERR_RXFL_DEPEDENCY_NOT_ON_THE_SAME_LAYER                   (-2115L) /**< The filter and its dependency must be on the same layer                                 */
N#define SLNETERR_RXFL_NUMBER_OF_ARGS_EXCEEDED                           (-2116L) /**< Number of arguments excceded                                                            */
N#define SLNETERR_RXFL_ACTION_NO_REG_NUMBER                              (-2117L) /**< Action require counter number                                                           */
N#define SLNETERR_RXFL_DEPENDENT_FILTER_LAYER_DO_NOT_FIT                 (-2118L) /**< the filter and its dependency should be from the same layer                             */
N#define SLNETERR_RXFL_DEPENDENT_FILTER_SYSTEM_STATE_DO_NOT_FIT          (-2119L) /**< The filter and its dependency system state don't fit                                    */
N#define SLNETERR_RXFL_DEPENDENT_FILTER_DO_NOT_EXIST_2                   (-2120L) /**< The parent filter don't exist                                                           */
N#define SLNETERR_RXFL_DEPENDENT_FILTER_DO_NOT_EXIST_1                   (-2121L) /**< The parent filter is null                                                               */
N#define SLNETERR_RXFL_RULE_HEADER_ACTION_TYPE_NOT_SUPPORTED             (-2122L) /**< The action type is not supported                                                        */
N#define SLNETERR_RXFL_RULE_HEADER_TRIGGER_COMPARE_FUNC_OUT_OF_RANGE     (-2123L) /**< The Trigger comparision function is out of range                                        */
N#define SLNETERR_RXFL_RULE_HEADER_TRIGGER_OUT_OF_RANGE                  (-2124L) /**< The Trigger is out of range                                                             */
N#define SLNETERR_RXFL_RULE_HEADER_COMPARE_FUNC_OUT_OF_RANGE             (-2125L) /**< The rule compare function is out of range                                               */
N#define SLNETERR_RXFL_FRAME_TYPE_NOT_SUPPORTED                          (-2126L) /**< ASCII frame type string is illegal                                                      */
N#define SLNETERR_RXFL_RULE_FIELD_ID_NOT_SUPPORTED                       (-2127L) /**< Rule field ID is out of range                                                           */
N#define SLNETERR_RXFL_RULE_HEADER_FIELD_ID_ASCII_NOT_SUPPORTED          (-2128L) /**< This ASCII field ID is not supported                                                    */
N#define SLNETERR_RXFL_RULE_HEADER_NOT_SUPPORTED                         (-2129L) /**< The header rule is not supported on current release                                     */
N#define SLNETERR_RXFL_RULE_HEADER_OUT_OF_RANGE                          (-2130L) /**< The header rule is out of range                                                         */
N#define SLNETERR_RXFL_RULE_HEADER_COMBINATION_OPERATOR_OUT_OF_RANGE     (-2131L) /**< Combination function Id is out of ramge                                                 */
N#define SLNETERR_RXFL_RULE_HEADER_FIELD_ID_OUT_OF_RANGE                 (-2132L) /**< rule field Id is out of range                                                           */
N#define SLNETERR_RXFL_UPDATE_NOT_SUPPORTED                              (-2133L) /**< Update not supported                                                                    */
N#define SLNETERR_RXFL_NO_FILTER_DATABASE_ALLOCATE                       (-2134L)
N#define SLNETERR_RXFL_ALLOCATION_FOR_GLOBALS_STRUCTURE_FAILED           (-2135L)
N#define SLNETERR_RXFL_ALLOCATION_FOR_DB_NODE_FAILED                     (-2136L)
N#define SLNETERR_RXFL_READ_FILE_FILTER_ID_ILLEGAL                       (-2137L)
N#define SLNETERR_RXFL_READ_FILE_NUMBER_OF_FILTER_FAILED                 (-2138L)
N#define SLNETERR_RXFL_READ_FILE_FAILED                                  (-2139L)
N#define SLNETERR_RXFL_NO_FILTERS_ARE_DEFINED                            (-2140L) /**< No filters are defined in the system                                                    */
N#define SLNETERR_RXFL_NUMBER_OF_FILTER_EXCEEDED                         (-2141L) /**< Number of max filters excceded                                                          */
N#define SLNETERR_RXFL_BAD_FILE_MODE                                     (-2142L)
N#define SLNETERR_RXFL_FAILED_READ_NVFILE                                (-2143L)
N#define SLNETERR_RXFL_FAILED_INIT_STORAGE                               (-2144L)
N#define SLNETERR_RXFL_CONTINUE_WRITE_MUST_BE_MOD_4                      (-2145L)
N#define SLNETERR_RXFL_FAILED_LOAD_FILE                                  (-2146L)
N#define SLNETERR_RXFL_INVALID_HANDLE                                    (-2147L)
N#define SLNETERR_RXFL_FAILED_TO_WRITE                                   (-2148L)
N#define SLNETERR_RXFL_OFFSET_OUT_OF_RANGE                               (-2149L)
N#define SLNETERR_RXFL_ALLOC                                             (-2150L)
N#define SLNETERR_RXFL_READ_DATA_LENGTH                                  (-2151L)
N#define SLNETERR_RXFL_INVALID_FILE_ID                                   (-2152L)
N#define SLNETERR_RXFL_FILE_FILTERS_NOT_EXISTS                           (-2153L)
N#define SLNETERR_RXFL_FILE_ALREADY_IN_USE                               (-2154L)
N#define SLNETERR_RXFL_INVALID_ARGS                                      (-2155L)
N#define SLNETERR_RXFL_FAILED_TO_CREATE_FILE                             (-2156L)
N#define SLNETERR_RXFL_FS_ALREADY_LOADED                                 (-2157L)
N#define SLNETERR_RXFL_UNKNOWN                                           (-2158L)
N#define SLNETERR_RXFL_FAILED_TO_CREATE_LOCK_OBJ                         (-2159L)
N#define SLNETERR_RXFL_DEVICE_NOT_LOADED                                 (-2160L)
N#define SLNETERR_RXFL_INVALID_MAGIC_NUM                                 (-2161L)
N#define SLNETERR_RXFL_FAILED_TO_READ                                    (-2162L)
N#define SLNETERR_RXFL_NOT_SUPPORTED                                     (-2163L)
N#define SLNETERR_WLAN_INVALID_COUNTRY_CODE                              (-2164L)
N#define SLNETERR_WLAN_NVMEM_ACCESS_FAILED                               (-2165L)
N#define SLNETERR_WLAN_OLD_FILE_VERSION                                  (-2166L)
N#define SLNETERR_WLAN_TX_POWER_OUT_OF_RANGE                             (-2167L)
N#define SLNETERR_WLAN_INVALID_AP_PASSWORD_LENGTH                        (-2168L)
N#define SLNETERR_WLAN_PROVISIONING_ABORT_PROVISIONING_ALREADY_STARTED   (-2169L)
N#define SLNETERR_WLAN_PROVISIONING_ABORT_HTTP_SERVER_DISABLED           (-2170L)
N#define SLNETERR_WLAN_PROVISIONING_ABORT_PROFILE_LIST_FULL              (-2171L)
N#define SLNETERR_WLAN_PROVISIONING_ABORT_INVALID_PARAM                  (-2172L)
N#define SLNETERR_WLAN_PROVISIONING_ABORT_GENERAL_ERROR                  (-2173L)
N#define SLNETERR_WLAN_MULTICAST_EXCEED_MAX_ADDR                         (-2174L)
N#define SLNETERR_WLAN_MULTICAST_INVAL_ADDR                              (-2175L)
N#define SLNETERR_WLAN_AP_SCAN_INTERVAL_TOO_SHORT                        (-2176L)
N#define SLNETERR_WLAN_PROVISIONING_CMD_NOT_EXPECTED                     (-2177L)
N
N
N#define SLNETERR_WLAN_AP_ACCESS_LIST_NO_ADDRESS_TO_DELETE               (-2178L) /**< List is empty, no address to delete                 */
N#define SLNETERR_WLAN_AP_ACCESS_LIST_FULL                               (-2179L) /**< access list is full                                 */
N#define SLNETERR_WLAN_AP_ACCESS_LIST_DISABLED                           (-2180L) /**< access list is disabled                             */
N#define SLNETERR_WLAN_AP_ACCESS_LIST_MODE_NOT_SUPPORTED                 (-2181L) /**< Trying to switch to unsupported mode                */
N#define SLNETERR_WLAN_AP_STA_NOT_FOUND                                  (-2182L) /**< trying to disconnect station which is not connected */
N
N
N
N/* DEVICE ERRORS CODES*/
N#define SLNETERR_SUPPLICANT_ERROR                                       (-4097L)
N#define SLNETERR_HOSTAPD_INIT_FAIL                                      (-4098L)
N#define SLNETERR_HOSTAPD_INIT_IF_FAIL                                   (-4099L)
N#define SLNETERR_WLAN_DRV_INIT_FAIL                                     (-4100L)
N#define SLNETERR_MDNS_ENABLE_FAIL                                       (-4103L) /**< mDNS enable failed                                                                                            */
N#define SLNETERR_ROLE_STA_ERR                                           (-4107L) /**< Failure to load MAC/PHY in STA role                                                                           */
N#define SLNETERR_ROLE_AP_ERR                                            (-4108L) /**< Failure to load MAC/PHY in AP role                                                                            */
N#define SLNETERR_ROLE_P2P_ERR                                           (-4109L) /**< Failure to load MAC/PHY in P2P role                                                                           */
N#define SLNETERR_CALIB_FAIL                                             (-4110L) /**< Failure of calibration                                                                                        */
N#define SLNETERR_RESTORE_IMAGE_COMPLETE                                 (-4113L) /**< Return to factory image completed, perform reset                                                              */
N#define SLNETERR_UNKNOWN_ERR                                            (-4114L)
N#define SLNETERR_GENERAL_ERR                                            (-4115L) /**< General error during init                                                                                     */
N#define SLNETERR_WRONG_ROLE                                             (-4116L)
N#define SLNETERR_INCOMPLETE_PROGRAMMING                                 (-4117L) /**< Error during programming, Program new image should be invoked (see sl_FsProgram)                              */
N
N
N#define SLNETERR_PENDING_TXRX_STOP_TIMEOUT_EXP                          (-4118L) /**< Timeout expired before completing all TX/RX                                                                   */
N#define SLNETERR_PENDING_TXRX_NO_TIMEOUT                                (-4119L) /**< No Timeout , still have pending  TX/RX                                                                        */
N#define SLNETERR_INVALID_PERSISTENT_CONFIGURATION                       (-4120L) /**< persistency configuration can only be set to 0 (disabled) or 1 (enabled)                                      */
N
N
N
N/* NETAPP ERRORS CODES*/
N#define SLNETERR_MDNS_CREATE_FAIL                                       (-6145L) /**< mDNS create failed                                   */
N#define SLNETERR_DEVICE_NAME_LEN_ERR                                    (-6146L) /**< Set Dev name error codes                             */
N#define SLNETERR_DEVICE_NAME_INVALID                                    (-6147L) /**< Set Dev name error codes                             */
N#define SLNETERR_DOMAIN_NAME_LEN_ERR                                    (-6148L) /**< Set domain name error codes                          */
N#define SLNETERR_DOMAIN_NAME_INVALID                                    (-6149L) /**< Set domain name error codes                          */
N#define SLNETERR_NET_APP_DNS_QUERY_NO_RESPONSE                          (-6150L) /**< DNS query failed, no response                        */
N#define SLNETERR_NET_APP_DNS_ERROR                                      (-6151L) /**< DNS internal error                                   */
N#define SLNETERR_NET_APP_DNS_NO_SERVER                                  (-6152L) /**< No DNS server was specified                          */
N#define SLNETERR_NET_APP_DNS_TIMEOUTR                                   (-6153L) /**< mDNS parameters error                                */
N#define SLNETERR_NET_APP_DNS_QUERY_FAILED                               (-6154L) /**< DNS query failed; no DNS server sent an 'answer'     */
N#define SLNETERR_NET_APP_DNS_BAD_ADDRESS_ERROR                          (-6155L) /**< Improperly formatted IPv4 or IPv6 address            */
N#define SLNETERR_NET_APP_DNS_SIZE_ERROR                                 (-6156L) /**< DNS destination size is too small                    */
N#define SLNETERR_NET_APP_DNS_MALFORMED_PACKET                           (-6157L) /**< Improperly formed or corrupted DNS packet received   */
N#define SLNETERR_NET_APP_DNS_BAD_ID_ERROR                               (-6158L) /**< DNS packet from server does not match query ID       */
N#define SLNETERR_NET_APP_DNS_PARAM_ERROR                                (-6159L) /**< Invalid params                                       */
N#define SLNETERR_NET_APP_DNS_SERVER_NOT_FOUND                           (-6160L) /**< Server not found in Client list of DNS servers       */
N#define SLNETERR_NET_APP_DNS_PACKET_CREATE_ERROR                        (-6161L) /**< Error creating DNS packet                            */
N#define SLNETERR_NET_APP_DNS_EMPTY_DNS_SERVER_LIST                      (-6162L) /**< DNS Client's list of DNS servers is empty            */
N#define SLNETERR_NET_APP_DNS_SERVER_AUTH_ERROR                          (-6163L) /**< Server not able to authenticate answer/authority data*/
N#define SLNETERR_NET_APP_DNS_ZERO_GATEWAY_IP_ADDRESS                    (-6164L) /**< DNS Client IP instance has a zero gateway IP address */
N#define SLNETERR_NET_APP_DNS_MISMATCHED_RESPONSE                        (-6165L) /**< Server response type does not match the query request*/
N#define SLNETERR_NET_APP_DNS_DUPLICATE_ENTRY                            (-6166L) /**< Duplicate entry exists in DNS server table           */
N#define SLNETERR_NET_APP_DNS_RETRY_A_QUERY                              (-6167L) /**< SOA status returned; web site only exists as IPv4    */
N#define SLNETERR_NET_APP_DNS_INVALID_ADDRESS_TYPE                       (-6168L) /**< IP address type (e.g. IPv6L) not supported           */
N#define SLNETERR_NET_APP_DNS_IPV6_NOT_SUPPORTED                         (-6169L) /**< IPv6 disabled                                        */
N#define SLNETERR_NET_APP_DNS_NEED_MORE_RECORD_BUFFER                    (-6170L) /**< The buffer size is not enough.                       */
N#define SLNETERR_NET_APP_MDNS_ERROR                                     (-6171L) /**< MDNS internal error.                                 */
N#define SLNETERR_NET_APP_MDNS_PARAM_ERROR                               (-6172L) /**< MDNS parameters error.                               */
N#define SLNETERR_NET_APP_MDNS_CACHE_ERROR                               (-6173L) /**< The Cache size is not enough.                        */
N#define SLNETERR_NET_APP_MDNS_UNSUPPORTED_TYPE                          (-6174L) /**< The unsupported resource record type.                */
N#define SLNETERR_NET_APP_MDNS_DATA_SIZE_ERROR                           (-6175L) /**< The data size is too big.                            */
N#define SLNETERR_NET_APP_MDNS_AUTH_ERROR                                (-6176L) /**< Attempting to parse too large a data.                */
N#define SLNETERR_NET_APP_MDNS_PACKET_ERROR                              (-6177L) /**< The packet can not add the resource record.          */
N#define SLNETERR_NET_APP_MDNS_DEST_ADDRESS_ERROR                        (-6178L) /**< The destination address error.                       */
N#define SLNETERR_NET_APP_MDNS_UDP_PORT_ERROR                            (-6179L) /**< The udp port error.                                  */
N#define SLNETERR_NET_APP_MDNS_NOT_LOCAL_LINK                            (-6180L) /**< The message that not originate from the local link.  */
N#define SLNETERR_NET_APP_MDNS_EXCEED_MAX_LABEL                          (-6181L) /**< The data exceed the max laber size.                  */
N#define SLNETERR_NET_APP_MDNS_EXIST_UNIQUE_RR                           (-6182L) /**< At least one Unqiue record in the cache.             */
N#define SLNETERR_NET_APP_MDNS_EXIST_ANSWER                              (-6183L) /**< At least one answer record in the cache.             */
N#define SLNETERR_NET_APP_MDNS_EXIST_SAME_QUERY                          (-6184L) /**< Exist the same query.                                */
N#define SLNETERR_NET_APP_MDNS_DUPLICATE_SERVICE                         (-6185L) /**< Duplicate service.                                   */
N#define SLNETERR_NET_APP_MDNS_NO_ANSWER                                 (-6186L) /**< No response for one-shot query.                      */
N#define SLNETERR_NET_APP_MDNS_NO_KNOWN_ANSWER                           (-6187L) /**< No known answer for query.                           */
N#define SLNETERR_NET_APP_MDNS_NAME_MISMATCH                             (-6188L) /**< The name mismatch.                                   */
N#define SLNETERR_NET_APP_MDNS_NOT_STARTED                               (-6189L) /**< MDNS does not start.                                 */
N#define SLNETERR_NET_APP_MDNS_HOST_NAME_ERROR                           (-6190L) /**< MDNS host name error.                                */
N#define SLNETERR_NET_APP_MDNS_NO_MORE_ENTRIES                           (-6191L) /**< No more entries be found.                            */
N#define SLNETERR_NET_APP_MDNS_SERVICE_TYPE_MISMATCH                     (-6192L) /**< The service type mismatch                            */
N#define SLNETERR_NET_APP_MDNS_LOOKUP_INDEX_ERROR                        (-6193L) /**< Index is bigger than number of services.             */
N#define SLNETERR_NET_APP_MDNS_MAX_SERVICES_ERROR                        (-6194L)
N#define SLNETERR_NET_APP_MDNS_IDENTICAL_SERVICES_ERROR                  (-6195L)
N#define SLNETERR_NET_APP_MDNS_EXISTED_SERVICE_ERROR                     (-6196L)
N#define SLNETERR_NET_APP_MDNS_ERROR_SERVICE_NAME_ERROR                  (-6197L)
N#define SLNETERR_NET_APP_MDNS_RX_PACKET_ALLOCATION_ERROR                (-6198L)
N#define SLNETERR_NET_APP_MDNS_BUFFER_SIZE_ERROR                         (-6199L)
N#define SLNETERR_NET_APP_MDNS_NET_APP_SET_ERROR                         (-6200L)
N#define SLNETERR_NET_APP_MDNS_GET_SERVICE_LIST_FLAG_ERROR               (-6201L)
N#define SLNETERR_NET_APP_MDNS_MDNS_NO_CONFIGURATION_ERROR               (-6202L)
N#define SLNETERR_NET_APP_MDNS_STATUS_ERROR                              (-6203L)
N#define SLNETERR_NET_APP_ENOBUFS                                        (-6204L)
N#define SLNETERR_NET_APP_DNS_IPV6_REQ_BUT_IPV6_DISABLED                 (-6205L) /**< trying to issue ipv6 DNS request but ipv6 is disabled                          */
N#define SLNETERR_NET_APP_DNS_INVALID_FAMILY_TYPE                        (-6206L) /**< Family type is not ipv4 and not ipv6                                           */
N#define SLNETERR_NET_APP_DNS_REQ_TOO_BIG                                (-6207L) /**< DNS request size is too big                                                    */
N#define SLNETERR_NET_APP_DNS_ALLOC_ERROR                                (-6208L) /**< Allocation error                                                               */
N#define SLNETERR_NET_APP_DNS_EXECUTION_ERROR                            (-6209L) /**< Execution error                                                                */
N#define SLNETERR_NET_APP_P2P_ROLE_IS_NOT_CONFIGURED                     (-6210L) /**< role p2p is not configured yet, should be CL or GO in order to execute command */
N#define SLNETERR_NET_APP_INCORECT_ROLE_FOR_APP                          (-6211L) /**< incorrect role for specific application                                        */
N#define SLNETERR_NET_APP_INCORECT_APP_MASK                              (-6212L) /**< mask does not match any app                                                    */
N#define SLNETERR_NET_APP_MDNS_ALREADY_STARTED                           (-6213L) /**< mdns application already started                                               */
N#define SLNETERR_NET_APP_HTTP_SERVER_ALREADY_STARTED                    (-6214L) /**< http server application already started                                        */
N
N#define SLNETERR_NET_APP_HTTP_GENERAL_ERROR                             (-6216L) /**< New error - Http handle request failed                                         */
N#define SLNETERR_NET_APP_HTTP_INVALID_TIMEOUT                           (-6217L) /**< New error - Http timeout invalid argument                                      */
N#define SLNETERR_NET_APP_INVALID_URN_LENGTH                             (-6218L) /**< invalid URN length                                                             */
N#define SLNETERR_NET_APP_RX_BUFFER_LENGTH                               (-6219L) /**< size of the requested services is smaller than size of the user buffer */
N
N
N
N/*< NETCFG ERRORS CODES*/
N#define SLNETERR_STATIC_ADDR_SUBNET_ERROR                               (-8193L)
N#define SLNETERR_INCORRECT_IPV6_STATIC_LOCAL_ADDR                       (-8194L) /**< Ipv6 Local address perfix is wrong */
N#define SLNETERR_INCORRECT_IPV6_STATIC_GLOBAL_ADDR                      (-8195L) /**< Ipv6 Global address perfix is wrong */
N#define SLNETERR_IPV6_LOCAL_ADDR_SHOULD_BE_SET_FIRST                    (-8195L) /**< Attempt to set ipv6 global address before ipv6 local address is set */
N
N
N
N/* NETUTIL ERRORS CODES */
N#define SLNETERR_NETUTIL_CRYPTO_GENERAL                                 (-12289L)
N#define SLNETERR_NETUTIL_CRYPTO_INVALID_INDEX                           (-12290L)
N#define SLNETERR_NETUTIL_CRYPTO_INVALID_PARAM                           (-12291L)
N#define SLNETERR_NETUTIL_CRYPTO_MEM_ALLOC                               (-12292L)
N#define SLNETERR_NETUTIL_CRYPTO_INVALID_DB_VER                          (-12293L)
N#define SLNETERR_NETUTIL_CRYPTO_UNSUPPORTED_OPTION                      (-12294L)
N#define SLNETERR_NETUTIL_CRYPTO_BUFFER_TOO_SMALL                        (-12295L)
N#define SLNETERR_NETUTIL_CRYPTO_EMPTY_DB_ENTRY                          (-12296L)
N#define SLNETERR_NETUTIL_CRYPTO_NON_TEMPORARY_KEY                       (-12297L)
N#define SLNETERR_NETUTIL_CRYPTO_DB_ENTRY_NOT_FREE                       (-12298L)
N#define SLNETERR_NETUTIL_CRYPTO_CORRUPTED_DB_FILE                       (-12299L)
N
N
N
N/* GENERAL ERRORS CODES*/
N#define SLNETERR_INVALID_OPCODE                                         (-14337L)
N#define SLNETERR_INVALID_PARAM                                          (-14338L)
N#define SLNETERR_STATUS_ERROR                                           (-14341L)
N#define SLNETERR_NVMEM_ACCESS_FAILED                                    (-14342L)
N#define SLNETERR_NOT_ALLOWED_NWP_LOCKED                                 (-14343L) /**< Device is locked, Return to Factory Image or Program new image should be invoked (see sl_FsCtl, sl_FsProgram) */
N
N/* SECURITY ERRORS CODE */
N#define SLNETERR_LOADING_CERTIFICATE_STORE                              (-28673L)
N
N/* Device is Locked! Return to Factory Image or Program new
N   image should be invoked (see sl_FsCtl, sl_FsProgram) */
N#define SLNETERR_DEVICE_LOCKED_SECURITY_ALERT                           (-28674L)
N
N
N
N/* INTERNAL HOST ERRORS CODES*/
N
N/* Receive this error in case there are no resources to issue the command
N   If possible, increase the number of MAX_CONCURRENT_ACTIONS (result in memory increase)
N   If not, try again later */
N#define SLNETERR_POOL_IS_EMPTY                                          (-2000L)
N
N/* Receive this error in case a given length for RX buffer was too small.
N   Receive payload was bigger than the given buffer size. Therefore, payload is cut according to receive size
N   Recommend to increase buffer size */
N#define SLNETERR_ESMALLBUF                                              (-2001L)
N
N/* Receive this error in case zero length is supplied to a "get" API
N   Recommend to supply length according to requested information (view options defines for helpL) */
N#define SLNETERR_EZEROLEN                                               (-2002L)
N
N/* User supplied invalid parameter */
N#define SLNETERR_INVALPARAM                                             (-2003L)
N
N/* Failed to open interface  */
N#define SLNETERR_BAD_INTERFACE                                          (-2004L)
N
N/* API has been aborted due to an error detected by host driver */
N#define SLNETERR_API_ABORTED                                            (-2005L)
N
N/* Parameters are invalid */
N#define SLNETERR_RET_CODE_INVALID_INPUT                                 (-2006L)
N
N/* Driver internal error */
N#define SLNETERR_RET_CODE_SELF_ERROR                                    (-2007L)
N
N/* NWP internal error */
N#define SLNETERR_RET_CODE_NWP_IF_ERROR                                  (-2008L)
N
N/* malloc error */
N#define SLNETERR_RET_CODE_MALLOC_ERROR                                  (-2009L)
N
N/* protocol error */
N#define SLNETERR_RET_CODE_PROTOCOL_ERROR                                (-2010L)
N
N/* API has been aborted, command is not allowed in device lock state */
N#define SLNETERR_RET_CODE_DEV_LOCKED                                    (-2011L)
N
N/* SlNetSock_Start cannot be invoked twice */
N#define SLNETERR_RET_CODE_DEV_ALREADY_STARTED                           (-2012L)
N
N/* SL Net API is in progress */
N#define SLNETERR_RET_CODE_API_COMMAND_IN_PROGRESS                       (-2013L)
N
N/* Provisioning is in progress -  */
N#define SLNETERR_RET_CODE_PROVISIONING_IN_PROGRESS                      (-2014L)
N
N/* Wrong ping parameters - ping cannot be called with the following parameters:
N1. infinite ping packet
N2. report only when finished
N3. no callback supplied  */
N#define SLNETERR_RET_CODE_NET_APP_PING_INVALID_PARAMS                   (-2015L)
N
N
N/* SlNetSock select already in progress.
N   this error will be returned if app will try to call
N   SlNetSock_select blocking when there is already select trigger in progress */
N#define SLNETERR_RET_CODE_SOCKET_SELECT_IN_PROGRESS_ERROR               (-2016L)
N
N#define SLNETERR_RET_CODE_STOP_IN_PROGRESS                              (-2017L)
N
N
N/* The device has not been started yet */
N#define SLNETERR_RET_CODE_DEV_NOT_STARTED                               (-2018L)
N
N/* The event link was not found in the list */
N#define SLNETERR_RET_CODE_EVENT_LINK_NOT_FOUND                          (-2019L)
N
N/* Function couldn't find any free space/location */
N#define SLNETERR_RET_CODE_NO_FREE_SPACE                                 (-2020L)
N
N/* Function couldn't execute correctly */
N#define SLNETERR_RET_CODE_FUNCTION_FAILED                               (-2021L)
N
N/* Mutex creation failed */
N#define SLNETERR_RET_CODE_MUTEX_CREATION_FAILED                         (-2022L)
N
N/* Function couldn't find the requested resource */
N#define SLNETERR_RET_CODE_COULDNT_FIND_RESOURCE                         (-2023L)
N
N/* Interface doesn't support the non mandatory function */
N#define SLNETERR_RET_CODE_DOESNT_SUPPORT_NON_MANDATORY_FXN              (-2024L)
N
N/* Socket creation in progress */
N#define SLNETERR_RET_CODE_SOCKET_CREATION_IN_PROGRESS                   (-2025L)
N
N/* Unsupported scenario, option or feature */
N#define SLNETERR_RET_CODE_UNSUPPORTED                                   (-2026L)
N
N
N/* sock related API's from SlNetIf_Config_t failed */
N#define SLNETSOCK_ERR_SOCKCREATE_FAILED                                 (-3000L)
N#define SLNETSOCK_ERR_SOCKCLOSE_FAILED                                  (-3001L)
N#define SLNETSOCK_ERR_SOCKSELECT_FAILED                                 (-3002L)
N#define SLNETSOCK_ERR_SOCKSETOPT_FAILED                                 (-3003L)
N#define SLNETSOCK_ERR_SOCKGETOPT_FAILED                                 (-3004L)
N#define SLNETSOCK_ERR_SOCKRECVFROM_FAILED                               (-3005L)
N#define SLNETSOCK_ERR_SOCKSENDTO_FAILED                                 (-3006L)
N#define SLNETSOCK_ERR_SOCKSHUTDOWN_FAILED                               (-3007L)
N#define SLNETSOCK_ERR_SOCKACCEPT_FAILED                                 (-3008L)
N#define SLNETSOCK_ERR_SOCKBIND_FAILED                                   (-3009L)
N#define SLNETSOCK_ERR_SOCKLISTEN_FAILED                                 (-3000L)
N#define SLNETSOCK_ERR_SOCKCONNECT_FAILED                                (-3001L)
N#define SLNETSOCK_ERR_SOCKGETPEERNAME_FAILED                            (-3002L)
N#define SLNETSOCK_ERR_SOCKGETLOCALNAME_FAILED                           (-3003L)
N#define SLNETSOCK_ERR_SOCKRECV_FAILED                                   (-3004L)
N#define SLNETSOCK_ERR_SOCKSEND_FAILED                                   (-3005L)
N#define SLNETSOCK_ERR_SOCKSTARTSEC_FAILED                               (-3006L)
N
N/* util related API's from SlNetIf_Config_t failed */
N#define SLNETUTIL_ERR_UTILGETHOSTBYNAME_FAILED                          (-3100L)
N
N/* if related API's from SlNetIf_Config_t failed */
N#define SLNETIF_ERR_IFLOADSECOBJ_FAILED                                 (-3200L)
N#define SLNETIF_ERR_IFGETIPADDR_FAILED                                  (-3201L)
N#define SLNETIF_ERR_IFGETCONNECTIONSTATUS_FAILED                        (-3202L)
N#define SLNETIF_ERR_IFCREATECONTEXT_FAILED                              (-3203L)
N
N/*!
N
N Close the Doxygen group.
N @}
N
N*/
N
N#ifdef  __cplusplus
S}
N#endif /*  __cplusplus */
N
N#endif  /*  __SL_NET_ERR_H__ */
L 643 "/vagrant/Q4_04/sdk_root/source/ti/net/slnetsock.h" 2
N
N
N/*****************************************************************************/
N/* Function prototypes                                                       */
N/*****************************************************************************/
N
N/*!
N
N    \brief Initialize the SlNetSock module
N
N    \param[in] flags            Reserved
N
N    \return                     Zero on success, or negative error code on failure
N*/
Nint32_t SlNetSock_init(int32_t flags);
N
N/*!
N
N    \brief Create an endpoint for communication
N
N    SlNetSock_create() creates a new socket of a certain socket type,
N    identified by an integer number, and allocates system resources to it.\n
N    This function is called by the application layer to obtain a socket descriptor (handle).
N
N    \param[in] domain           Specifies the protocol family of the created socket.
N                                For example:
N                                   - #SLNETSOCK_AF_INET for network protocol IPv4
N                                   - #SLNETSOCK_AF_INET6 for network protocol IPv6
N                                   - #SLNETSOCK_AF_RF for starting transceiver mode.
N                                        Notes:
N                                        - sending and receiving any packet overriding 802.11 header
N                                        - for optimized power consumption the socket will be started in TX
N                                            only mode until receive command is activated
N    \param[in] type             Specifies the socket type, which determines the semantics of communication over
N                                the socket. The socket types supported by the system are implementation-dependent.
N                                Possible socket types include:
N                                   - #SLNETSOCK_SOCK_STREAM (reliable stream-oriented service or Stream Sockets)
N                                   - #SLNETSOCK_SOCK_DGRAM  (datagram service or Datagram Sockets)
N                                   - #SLNETSOCK_SOCK_RAW    (raw protocols atop the network layer)
N                                   - when used with AF_RF:
N                                      - #SLNETSOCK_SOCK_RX_MTR
N                                      - #SLNETSOCK_SOCK_MAC_WITH_CCA
N                                      - #SLNETSOCK_SOCK_MAC_WITH_NO_CCA
N                                      - #SLNETSOCK_SOCK_BRIDGE
N                                      - #SLNETSOCK_SOCK_ROUTER
N    \param[in] protocol         Specifies a particular transport to be used with the socket.\n
N                                The most common are
N                                    - #SLNETSOCK_PROTO_TCP
N                                    - #SLNETSOCK_PROTO_UDP
N                                    - #SLNETSOCK_PROTO_RAW
N                                    - #SLNETSOCK_PROTO_SECURE
N    \param[in] ifBitmap         Specifies the interface(s) which the socket will be create on
N                                according to the priority until one of them will return an answer.\n
N                                Value 0 is used in order to choose automatic interfaces selection
N                                according to the priority interface list.
N                                Value can be combination of interfaces by OR'ing multiple interfaces bit identifiers
N                                (SLNETIFC_IDENT_ defined in slnetif.h)
N                                Note: interface identifier bit must be configured prior to this socket creation
N                                using SlNetIf_add().
N    \param[in] flags            Specifies flags.
N                                   - #SLNETSOCK_CREATE_IF_STATE_ENABLE     - Creation of the socket will be on enabled state
N                                   - #SLNETSOCK_CREATE_IF_STATUS_CONNECTED - Creation of the socket will be on status connected
N                                   - #SLNETSOCK_CREATE_ALLOW_PARTIAL_MATCH - Creation of the socket will be on the interface with
N                                                                            the highest priority if the other flags will fail
N                                The value 0 may be used in order to run the default flags:
N                                   - #SLNETSOCK_CREATE_IF_STATE_ENABLE
N                                   - #SLNETSOCK_CREATE_IF_STATUS_CONNECTED
N
N    \return                     On success, socket descriptor (handle) that is used for consequent socket operations. \n
N                                A successful return code should be a positive number\n
N                                On error, a negative value will be returned specifying the error code.
N                                   - #SLNETERR_BSD_EAFNOSUPPORT    - illegal domain parameter
N                                   - #SLNETERR_BSD_EPROTOTYPE      - illegal type parameter
N                                   - #SLNETERR_BSD_EACCES          - permission denied
N                                   - #SLNETERR_BSD_ENSOCK          - exceeded maximal number of socket
N                                   - #SLNETERR_BSD_ENOMEM          - memory allocation error
N                                   - #SLNETERR_BSD_EINVAL          - error in socket configuration
N                                   - #SLNETERR_BSD_EPROTONOSUPPORT - illegal protocol parameter
N                                   - #SLNETERR_BSD_EOPNOTSUPP      - illegal combination of protocol and type parameters
N
N    \slnetsock_init_precondition
N
N    \remark     Not all platforms support all options.
N
N    \remark     A @c protocol value of zero can be used to select the default protocol from the selected @c domain and @c type.
N
N    \sa         SlNetSock_close()
N*/
Nint16_t SlNetSock_create(int16_t domain, int16_t type, int16_t protocol, uint32_t ifBitmap, int16_t flags);
N
N
N/*!
N    \brief Gracefully close socket
N
N    Release resources allocated to a socket.
N
N    \param[in] sd               Socket descriptor (handle), received in SlNetSock_create()
N
N    \return                     Zero on success, or negative error code on failure
N
N    \slnetsock_init_precondition
N
N    \remark     In the case of TCP, the connection is terminated.
N
N    \sa                         SlNetSock_create()
N*/
Nint32_t SlNetSock_close(int16_t sd);
N
N
N/*!
N    \brief Shutting down parts of a full-duplex connection
N
N    Shuts down parts of a full-duplex connection according to how parameter.\n
N
N    \param[in] sd               Socket descriptor (handle), received in SlNetSock_create
N    \param[in] how              Specifies which part of a full-duplex connection to shutdown. \n
N                                The options are
N                                    - #SLNETSOCK_SHUT_RD   - further receptions will be disallowed
N                                    - #SLNETSOCK_SHUT_WR   - further transmissions will be disallowed
N                                    - #SLNETSOCK_SHUT_RDWR - further receptions and transmissions will be disallowed
N
N    \return                     Zero on success, or negative error code on failure
N
N    \slnetsock_init_precondition
N
N    \sa                         SlNetSock_create()
N    \sa                         SlNetSock_connect()
N    \sa                         SlNetSock_accept()
N*/
Nint32_t SlNetSock_shutdown(int16_t sd, int16_t how);
N
N
N/*!
N    \brief Accept a connection on a socket
N
N    The SlNetSock_accept function is used with connection-based socket types (#SLNETSOCK_SOCK_STREAM).
N
N    It extracts the first connection request on the queue of pending
N    connections, creates a new connected socket, and returns a new file
N    descriptor referring to that socket.
N
N    The newly created socket is not in the listening state. The
N    original socket sd is unaffected by this call.
N
N    The argument sd is a socket that has been created with
N    SlNetSock_create(), bound to a local address with
N    SlNetSock_bind(), and is listening for connections after a
N    SlNetSock_listen().
N
N    The argument \c addr is a pointer to a sockaddr structure. This
N    structure is filled in with the address of the peer socket, as
N    known to the communications layer.
N
N    The exact format of the address returned \c addr is determined by the socket's address family.
N
N    \c addrlen is a value-result argument: it should initially contain
N    the size of the structure pointed to by addr, on return it will
N    contain the actual length (in bytes) of the address returned.
N
N    \param[in]  sd              Socket descriptor (handle)
N    \param[out] addr            The argument addr is a pointer
N                                to a sockaddr structure. This
N                                structure is filled in with the
N                                address of the peer socket, as
N                                known to the communications
N                                layer. The exact format of the
N                                address returned addr is
N                                determined by the socket's
N                                address\n
N                                sockaddr:\n - code for the
N                                address format.\n -
N                                socket address, the length
N                                depends on the code format
N    \param[out] addrlen         The addrlen argument is a value-result
N                                argument: it should initially contain the
N                                size of the structure pointed to by addr
N
N    \return                     On success, a socket descriptor.\n
N                                On a non-blocking accept a possible negative value is #SLNETERR_BSD_EAGAIN.\n
N                                On failure, negative error code.\n
N                                #SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system
N
N    \slnetsock_init_precondition
N
N    \sa                         SlNetSock_create()
N    \sa                         SlNetSock_bind()
N    \sa                         SlNetSock_listen()
N*/
Nint16_t SlNetSock_accept(int16_t sd, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen);
N
N
N/*!
N    \brief Assign a name to a socket
N
N    This SlNetSock_bind function gives the socket the local address
N    addr.  addr is addrlen bytes long.
N
N    Traditionally, this is called when a socket is created with
N    socket, it exists in a name space (address family) but has no name
N    assigned.
N
N    It is necessary to assign a local address before a #SLNETSOCK_SOCK_STREAM
N    socket may receive connections.
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] addr             Specifies the destination
N                                addrs\n sockaddr:\n - code for
N                                the address format.\n - socket address,
N                                the length depends on the code
N                                format
N    \param[in] addrlen          Contains the size of the structure pointed to by addr
N
N    \return                     Zero on success, or negative error code on failure
N
N    \slnetsock_init_precondition
N
N    \sa                         SlNetSock_create()
N    \sa                         SlNetSock_accept()
N    \sa                         SlNetSock_listen()
N*/
Nint32_t SlNetSock_bind(int16_t sd, const SlNetSock_Addr_t *addr, int16_t addrlen);
N
N
N/*!
N    \brief Listen for connections on a socket
N
N    The willingness to accept incoming connections and a queue
N    limit for incoming connections are specified with SlNetSock_listen(),
N    and then the connections are accepted with SlNetSock_accept().
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] backlog          Specifies the listen queue depth.
N
N    \return                     Zero on success, or negative error code on failure
N
N    \slnetsock_init_precondition
N
N    \remark     The SlNetSock_listen() call applies only to sockets of
N                type #SLNETSOCK_SOCK_STREAM.
N
N    \remark     The \c backlog parameter defines the maximum length the queue of
N                pending connections may grow to.
N
N    \sa                         SlNetSock_create()
N    \sa                         SlNetSock_accept()
N    \sa                         SlNetSock_bind()
N*/
Nint32_t SlNetSock_listen(int16_t sd, int16_t backlog);
N
N
N/*!
N    \brief Initiate a connection on a socket
N
N    Function connects the socket referred to by the socket
N    descriptor sd, to the address specified by \c addr.
N
N    The format of the address in addr is determined by the address
N    space of the socket.
N
N    If it is of type #SLNETSOCK_SOCK_DGRAM, this call specifies the
N    peer with which the socket is to be associated; this address is
N    that to which datagrams are to be sent, and the only address from
N    which datagrams are to be received.
N
N    If the socket is of type #SLNETSOCK_SOCK_STREAM, this call
N    attempts to make a connection to another socket.
N
N    The other socket is specified by address, which is an address in
N    the communications space of the socket.
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] addr             Specifies the destination addr\n
N                                sockaddr:\n - code for the
N                                address format.\n -
N                                socket address, the length
N                                depends on the code format
N    \param[in] addrlen          Contains the size of the structure pointed
N                                to by addr
N
N    \return                     On success, a socket descriptor (handle).\n
N                                On failure, negative value.\n
N                                On a non-blocking connect a possible negative value is #SLNETERR_BSD_EALREADY.
N                                #SLNETERR_POOL_IS_EMPTY may be returned in case there are no resources in the system
N
N    \slnetsock_init_precondition
N
N    \sa                         SlNetSock_create()
N    \note
N    \warning
N*/
Nint32_t SlNetSock_connect(int16_t sd, const SlNetSock_Addr_t *addr, SlNetSocklen_t addrlen);
N
N/*!
N    \brief Return address info about the remote side of the connection
N
N    Returns a struct SlNetSock_AddrIn_t
N    filled with information about the peer device that is connected
N    on the other side of the socket descriptor.
N
N    \param[in]  sd              Socket descriptor (handle)
N    \param[out] addr            returns the struct addr\n
N                                SlNetSockAddrIn filled with information
N                                about the peer device:\n - code for the
N                                address format.\n -
N                                socket address, the length
N                                depends on the code format
N    \param[out] addrlen         Contains the size of the structure pointed
N                                to by addr
N
N    \return                     Zero on success, or negative error code on failure
N
N    \slnetsock_init_precondition
N
N    \sa                         SlNetSock_accept()
N    \sa                         SlNetSock_connect()
N*/
Nint32_t SlNetSock_getPeerName(int16_t sd, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen);
N
N
N/*!
N    \brief Get local address info by socket descriptor
N
N    Returns the local address info of the socket descriptor.
N
N    \param[in]  sd              Socket descriptor (handle)
N    \param[out] addr            The argument addr is a pointer
N                                to a SlNetSock_Addr_t structure. This
N                                structure is filled in with the
N                                address of the peer socket, as
N                                known to the communications
N                                layer. The exact format of the
N                                address returned addr is
N                                determined by the socket's
N                                address\n
N                                SlNetSock_Addr_t:\n - code for the
N                                address format.\n -
N                                socket address, the length
N                                depends on the code format
N    \param[out] addrlen         The addrlen argument is a value-result
N                                argument: it should initially contain the
N                                size of the structure pointed to by addr
N
N    \return                     Zero on success, or negative on failure.
N
N    \slnetsock_init_precondition
N
N    \remark     If the provided buffer is too small the returned address
N                will be truncated and \c addrlen will contain the
N                actual size of the socket address.
N
N    \sa         SlNetSock_create()
N    \sa         SlNetSock_bind()
N*/
Nint32_t SlNetSock_getSockName(int16_t sd, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen);
N
N
N/*!
N    \brief Monitor socket activity
N
N    SlNetSock_select() allow a program to monitor multiple file descriptors,
N    waiting until one or more of the file descriptors become
N    "ready" for some class of I/O operation.
N
N    \param[in]     nsds        The highest-numbered file descriptor in any of the
N                               three sets, plus 1.
N    \param[in,out] readsds     Socket descriptors list for read monitoring and accept monitoring
N    \param[in,out] writesds    Socket descriptors list for connect monitoring only, write monitoring is not supported
N    \param[in,out] exceptsds   Socket descriptors list for exception monitoring, not supported.
N    \param[in]     timeout     Is an upper bound on the amount of time elapsed
N                               before SlNetSock_select() returns. Null or above 0xffff seconds means
N                               infinity timeout. The minimum timeout is 10 milliseconds,
N                               less than 10 milliseconds will be set automatically to 10 milliseconds.
N                               Max microseconds supported is 0xfffc00.
N                               In trigger mode the timeout fields must be set to zero.
N
N    \return                    On success, SlNetSock_select() returns the number of
N                               file descriptors contained in the three returned
N                               descriptor sets (that is, the total number of bits that
N                               are set in readsds, writesds, exceptsds) which may be
N                               zero if the timeout expires before anything interesting
N                               happens.\n On error, a negative value is returned.
N                               readsds - return the sockets on which Read request will
N                               return without delay with valid data.\n
N                               writesds - return the sockets on which Write request
N                               will return without delay.\n
N                               exceptsds - return the sockets closed recently. \n
N                               #SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system
N
N    \slnetsock_init_precondition
N
N    \remark     If \c timeout is set to less than 10ms it will
N                automatically set to 10ms to prevent overload of the
N                system
N
N    \sa         SlNetSock_create()
N*/
Nint32_t SlNetSock_select(int16_t nsds, SlNetSock_SdSet_t *readsds, SlNetSock_SdSet_t *writesds, SlNetSock_SdSet_t *exceptsds, SlNetSock_Timeval_t *timeout);
N
N
N/*!
N    \brief SlNetSock_select's SlNetSock_SdSet_t SET function
N
N    Sets current socket descriptor on SlNetSock_SdSet_t container
N*/
Nint32_t SlNetSock_sdsSet(int16_t sd, SlNetSock_SdSet_t *sdset);
N
N
N/*!
N    \brief SlNetSock_select's SlNetSock_SdSet_t CLR function
N
N    Clears current socket descriptor on SlNetSock_SdSet_t container
N*/
Nint32_t SlNetSock_sdsClr(int16_t sd, SlNetSock_SdSet_t *sdset);
N
N
N/*!
N    \brief SlNetSock_select's SlNetSock_SdSet_t ZERO function
N
N    Clears all socket descriptors from SlNetSock_SdSet_t
N*/
Nint32_t SlNetSock_sdsClrAll(SlNetSock_SdSet_t *sdset);
N
N
N/*!
N    \brief SlNetSock_select's SlNetSock_SdSet_t ISSET function
N
N    Checks if current socket descriptor is set (true/false)
N
N    \return            Returns true if set, false if unset
N
N*/
Nint32_t SlNetSock_sdsIsSet(int16_t sd, SlNetSock_SdSet_t *sdset);
N
N
N/*!
N    \brief Set socket options
N
N    SlNetSock_setOpt() manipulates the options associated with a socket.
N
N    Options may exist at multiple protocol levels; they are always
N    present at the uppermost socket level.
N
N    When manipulating socket options the level at which the option resides
N    and the name of the option must be specified.  To manipulate options at
N    the socket level, level is specified as #SLNETSOCK_LVL_SOCKET.  To manipulate
N    options at any other level the protocol number of the appropriate protocol
N    controlling the option is supplied.  For example, to indicate that an
N    option is to be interpreted by the TCP protocol, level should be set to
N    the protocol number of TCP.
N
N    \c optval and \c optlen are used to access opt_values
N    for SlNetSock_setOpt().  For SlNetSock_getOpt() they identify a
N    buffer in which the value for the requested option(s) are to
N    be returned.  For SlNetSock_getOpt(), \c optlen is a value-result
N    parameter, initially containing the size of the buffer
N    pointed to by option_value, and modified on return to
N    indicate the actual size of the value returned.  If no option
N    value is to be supplied or returned, \c optval may be \c NULL.
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] level            Defines the protocol level for this option
N                                - #SLNETSOCK_LVL_SOCKET - Socket level configurations (L4, transport layer)
N                                - #SLNETSOCK_LVL_IP - IP level configurations (L3, network layer)
N                                - #SLNETSOCK_LVL_PHY - Link level configurations (L2, link layer)
N    \param[in] optname          Defines the option name to interrogate
N                                - #SLNETSOCK_LVL_SOCKET
N                                  - #SLNETSOCK_OPSOCK_RCV_BUF\n
N                                                 Sets tcp max recv window size.\n
N                                                 This options takes SlNetSock_Winsize_t struct as parameter
N                                  - #SLNETSOCK_OPSOCK_RCV_TIMEO\n
N                                                 Sets the timeout value that specifies the maximum amount of time an input function waits until it completes.\n
N                                                 Default: No timeout\n
N                                                 This options takes SlNetSock_Timeval_t struct as parameter
N                                  - #SLNETSOCK_OPSOCK_KEEPALIVE\n
N                                                 Enable or Disable periodic keep alive.
N                                                 Keeps TCP connections active by enabling the periodic transmission of messages \n
N                                                 Timeout is 5 minutes.\n
N                                                 Default: Enabled \n
N                                                 This options takes SlNetSock_Keepalive_t struct as parameter
N                                  - #SLNETSOCK_OPSOCK_KEEPALIVE_TIME\n
N                                                 Set keep alive timeout.
N                                                 Value is in seconds \n
N                                                 Default: 5 minutes \n
N                                  - #SLNETSOCK_OPSOCK_LINGER\n
N                                                 Socket lingers on close pending remaining send/receive packets\n
N                                  - #SLNETSOCK_OPSOCK_NON_BLOCKING\n
N                                                 Sets socket to non-blocking operation Impacts: connect, accept, send, sendto, recv and recvfrom. \n
N                                                 Default: Blocking.
N                                                 This options takes SlNetSock_Nonblocking_t struct as parameter
N                                  - #SLNETSOCK_OPSOCK_NON_IP_BOUNDARY\n
N                                                 Enable or Disable rx ip boundary.
N                                                 In connectionless socket (udp/raw), unread data is dropped (when SlNetSock_recvFrom() len parameter < data size), Enable this option in order to read the left data on the next SlNetSock_recvFrom() iteration\n
N                                                 Default: Disabled, IP boundary kept\n
N                                                 This options takes SlNetSock_NonIpBoundary_t struct as parameter
N                                - #SLNETSOCK_LVL_IP
N                                  - #SLNETSOCK_OPIP_MULTICAST_TTL\n
N                                                 Set the time-to-live value of outgoing multicast packets for this socket. \n
N                                                 This options takes <b>uint8_t</b> as parameter
N                                  - #SLNETSOCK_OPIP_ADD_MEMBERSHIP \n
N                                                 UDP socket, Join a multicast group. \n
N                                                 This options takes SlNetSock_IpMreq_t struct as parameter
N                                  - #SLNETSOCK_OPIP_DROP_MEMBERSHIP \n
N                                                 UDP socket, Leave a multicast group \n
N                                                 This options takes SlNetSock_IpMreq_t struct as parameter
N                                  - #SLNETSOCK_OPIP_HDRINCL \n
N                                                 RAW socket only, the IPv4 layer generates an IP header when sending a packet unless \n
N                                                 the IP_HDRINCL socket option is enabled on the socket.    \n
N                                                 When it is enabled, the packet must contain an IP header. \n
N                                                 Default: disabled, IPv4 header generated by Network Stack \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - #SLNETSOCK_OPIP_RAW_RX_NO_HEADER \n
N                                                 Raw socket remove IP header from received data. \n
N                                                 Default: data includes ip header \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - #SLNETSOCK_OPIP_RAW_IPV6_HDRINCL (inactive) \n
N                                                 RAW socket only, the IPv6 layer generates an IP header when sending a packet unless \n
N                                                 the IP_HDRINCL socket option is enabled on the socket. When it is enabled, the packet must contain an IP header \n
N                                                 Default: disabled, IPv4 header generated by Network Stack \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                - #SLNETSOCK_LVL_PHY
N                                  - #SLNETSOCK_OPPHY_CHANNEL \n
N                                                 Sets channel in transceiver mode.
N                                                 This options takes <b>uint32_t</b> as channel number parameter
N                                  - #SLNETSOCK_OPPHY_RATE \n
N                                                 RAW socket, set WLAN PHY transmit rate \n
N                                                 The values are based on SlWlanRateIndex_e    \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - #SLNETSOCK_OPPHY_TX_POWER \n
N                                                 RAW socket, set WLAN PHY TX power \n
N                                                 Valid rage is 1-15 \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - #SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX \n
N                                                 RAW socket, set number of frames to transmit in transceiver mode.
N                                                 Default: 1 packet
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - #SLNETSOCK_OPPHY_PREAMBLE \n
N                                                 RAW socket, set WLAN PHY preamble for Long/Short\n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - #SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD \n
N                                                 RAW socket, set WLAN Tx - Set CCA threshold. \n
N                                                 The values are based on SlNetSockTxInhibitThreshold_e \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - #SLNETSOCK_OPPHY_TX_TIMEOUT \n
N                                                 RAW socket, set WLAN Tx - changes the TX timeout (lifetime) of transceiver frames. \n
N                                                 Value in Ms, maximum value is 10ms \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - #SLNETSOCK_OPPHY_ALLOW_ACKS  \n
N                                                 RAW socket, set WLAN Tx - Enable or Disable sending ACKs in transceiver mode \n
N                                                 0 = disabled / 1 = enabled \n
N                                                 This options takes <b>uint32_t</b> as parameter
N
N
N    \param[in] optval           Specifies a value for the option
N    \param[in] optlen           Specifies the length of the
N        option value
N
N    \return                     Zero on success, or negative error code on failure
N
N    \par Persistent
N                All params are <b>Non- Persistent</b>
N
N    \slnetsock_init_precondition
N
N    \par    Examples
N
N    - SLNETSOCK_OPSOCK_RCV_BUF:
N    \code
N           SlNetSock_Winsize_t size;
N           size.winsize = 3000; // bytes
N           SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_RCV_BUF, (uint8_t *)&size, sizeof(size));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPSOCK_RCV_TIMEO:
N    \code
N        struct SlNetSock_Timeval_t timeVal;
N        timeVal.tv_sec =  1; // Seconds
N        timeVal.tv_usec = 0; // Microseconds. 10000 microseconds resolution
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_RCV_TIMEO, (uint8_t *)&timeVal, sizeof(timeVal)); // Enable receive timeout
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPSOCK_KEEPALIVE: //disable Keepalive
N    \code
N        SlNetSock_Keepalive_t enableOption;
N        enableOption.keepaliveEnabled = 0;
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_KEEPALIVE, (uint8_t *)&enableOption, sizeof(enableOption));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPSOCK_KEEPALIVE_TIME: //Set Keepalive timeout
N    \code
N        int16_t Status;
N        uint32_t TimeOut = 120;
N        SlNetSock_setOpt(Sd, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_KEEPALIVE_TIME, (uint8_t *)&TimeOut, sizeof(TimeOut));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPSOCK_NON_BLOCKING: //Enable or disable nonblocking mode
N    \code
N           SlNetSock_Nonblocking_t enableOption;
N           enableOption.nonBlockingEnabled = 1;
N           SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_NON_BLOCKING, (uint8_t *)&enableOption, sizeof(enableOption));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPSOCK_NON_IP_BOUNDARY: //disable boundary
N    \code
N        SlNetSock_NonIpBoundary_t enableOption;
N        enableOption.nonIpBoundaryEnabled = 1;
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_NON_IP_BOUNDARY, (uint8_t *)&enableOption, sizeof(enableOption));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPSOCK_LINGER:
N    \code
N        SlNetSock_linger_t linger;
N        linger.l_onoff = 1;
N        linger.l_linger = 10;
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_LINGER, &linger, sizeof(linger));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPIP_MULTICAST_TTL:
N     \code
N           uint8_t ttl = 20;
N           SlNetSock_setOpt(SockID, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_MULTICAST_TTL, &ttl, sizeof(ttl));
N     \endcode
N     <br>
N
N    - SLNETSOCK_OPIP_ADD_MEMBERSHIP:
N     \code
N           SlNetSock_IpMreq_t mreq;
N           SlNetSock_setOpt(SockID, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPIP_DROP_MEMBERSHIP:
N    \code
N        SlNetSock_IpMreq_t mreq;
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_DROP_MEMBERSHIP, &mreq, sizeof(mreq));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPIP_RAW_RX_NO_HEADER:
N    \code
N        uint32_t header = 1;  // remove ip header
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_RAW_RX_NO_HEADER, &header, sizeof(header));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPIP_HDRINCL:
N    \code
N        uint32_t header = 1;
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_HDRINCL, &header, sizeof(header));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPIP_RAW_IPV6_HDRINCL:
N    \code
N        uint32_t header = 1;
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_RAW_IPV6_HDRINCL, &header, sizeof(header));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_CHANNEL:
N    \code
N        uint32_t newChannel = 6; // range is 1-13
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPPHY_CHANNEL, &newChannel, sizeof(newChannel));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_RATE:
N    \code
N        uint32_t rate = 6; // see wlan.h SlWlanRateIndex_e for values
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_RATE, &rate, sizeof(rate));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_TX_POWER:
N    \code
N        uint32_t txpower = 1; // valid range is 1-15
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_TX_POWER, &txpower, sizeof(txpower));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX:
N    \code
N        uint32_t numframes = 1;
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX, &numframes, sizeof(numframes));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_PREAMBLE:
N    \code
N        uint32_t preamble = 1;
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_PREAMBLE, &preamble, sizeof(preamble));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD:
N    \code
N        uint32_t thrshld = SLNETSOCK_TX_INHIBIT_THRESHOLD_MED;
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD , &thrshld, sizeof(thrshld));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_TX_TIMEOUT:
N    \code
N        uint32_t timeout = 50;
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_TX_TIMEOUT  , &timeout, sizeof(timeout));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_ALLOW_ACKS:
N    \code
N        uint32_t acks = 1; // 0 = disabled / 1 = enabled
N        SlNetSock_setOpt(SockID, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_ALLOW_ACKS, &acks, sizeof(acks));
N    \endcode
N
N    \sa     slNetSock_create()
N    \sa     SlNetSock_getOpt()
N*/
Nint32_t SlNetSock_setOpt(int16_t sd, int16_t level, int16_t optname, void *optval, SlNetSocklen_t optlen);
N
N
N/*!
N    \brief Get socket options
N
N    The SlNetSock_getOpt function gets the options associated with a socket.
N    Options may exist at multiple protocol levels; they are always
N    present at the uppermost socket level.
N
N    The parameters optval and optlen identify a
N    buffer in which the value for the requested option(s) are to
N    be returned.  \c optlen is a value-result
N    parameter, initially containing the size of the buffer
N    pointed to by option_value, and modified on return to
N    indicate the actual size of the value returned.  If no option
N    value is to be supplied or returned, \c optval may be \c NULL.
N
N
N    \param[in]  sd              Socket descriptor (handle)
N    \param[in]  level           Defines the protocol level for this option
N    \param[in]  optname         defines the option name to interrogate
N    \param[out] optval          Specifies a value for the option
N    \param[out] optlen          Specifies the length of the
N                                option value
N
N    \return                     Zero on success, or negative error code on failure
N
N    \slnetsock_init_precondition
N
N    \sa     SlNetSock_create()
N    \sa     SlNetSock_setOpt()
N*/
Nint32_t SlNetSock_getOpt(int16_t sd, int16_t level, int16_t optname, void *optval, SlNetSocklen_t *optlen);
N
N
N/*!
N    \brief Read data from TCP socket
N
N    The SlNetSock_recv function receives a message from a connection-mode socket
N
N    \param[in]  sd              Socket descriptor (handle)
N    \param[out] buf             Points to the buffer where the
N                                message should be stored.
N    \param[in]  len             Specifies the length in bytes of
N                                the buffer pointed to by the buffer argument.
N                                Range: 1-16000 bytes
N    \param[in]  flags           Specifies the type of message
N                                reception. On this version, this parameter is not
N                                supported.
N
N    \return                     Return the number of bytes received,
N                                or a negative value if an error occurred.\n
N                                Using a non-blocking recv a possible negative value is SLNETERR_BSD_EAGAIN.\n
N                                SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system
N
N    \slnetsock_init_precondition
N
N    \par    Examples
N
N    - Receiving data using TCP socket:
N    \code
N        SlNetSock_AddrIn_t  Addr;
N        SlNetSock_AddrIn_t  LocalAddr;
N        int16_t AddrSize = sizeof(SlNetSock_AddrIn_t);
N        int16_t SockID, newSockID;
N        int16_t Status;
N        int8_t Buf[RECV_BUF_LEN];
N
N        LocalAddr.sin_family = SLNETSOCK_AF_INET;
N        LocalAddr.sin_port = SlNetSock_htons(5001);
N        LocalAddr.sin_addr.s_addr = 0;
N
N        Addr.sin_family = SLNETSOCK_AF_INET;
N        Addr.sin_port = SlNetSock_htons(5001);
N        Addr.sin_addr.s_addr = SlNetSock_htonl(SLNETSOCK_IPV4_VAL(10,1,1,200));
N
N        SockID = SlNetSock_create(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_STREAM, 0, 0, 0);
N        Status = SlNetSock_bind(SockID, (SlNetSock_Addr_t *)&LocalAddr, AddrSize);
N        Status = SlNetSock_listen(SockID, 0);
N        newSockID = SlNetSock_accept(SockID, (SlNetSock_Addr_t*)&Addr, (SlNetSocklen_t*) &AddrSize);
N        Status = SlNetSock_recv(newSockID, Buf, 1460, 0);
N    \endcode
N    <br>
N
N    - Rx transceiver mode using a raw socket:
N    \code
N        int8_t buffer[1536];
N        int16_t sd;
N        uint16_t size;
N        SlNetSock_TransceiverRxOverHead_t *transHeader;
N        sd = SlNetSock_create(SLNETSOCK_AF_RF, SLNETSOCK_SOCK_RAW, 11, 0, 0); // channel 11
N        while(1)
N        {
N            size = SlNetSock_recv(sd,buffer,1536,0);
N            transHeader = (SlNetSock_TransceiverRxOverHead_t *)buffer;
N            printf("RSSI is %d frame type is 0x%x size %d\n",transHeader->rssi,buffer[sizeof(SlNetSock_TransceiverRxOverHead_t)],size);
N        }
N    \endcode
N
N    \sa     SlNetSock_create()
N    \sa     SlNetSock_recvFrom()
N*/
Nint32_t SlNetSock_recv(int16_t sd, void *buf, uint32_t len, uint32_t flags);
N
N
N/*!
N    \brief Read data from socket
N
N    SlNetSock_recvFrom function receives a message from a connection-mode or
N    connectionless-mode socket
N
N    \param[in]  sd              Socket descriptor (handle)
N    \param[out] buf             Points to the buffer where the message should be stored.
N    \param[in]  len             Specifies the length in bytes of the buffer pointed to by the buffer argument.
N                                Range: 1-16000 bytes
N    \param[in]  flags           Specifies the type of message
N                                reception. On this version, this parameter is not
N                                supported
N    \param[in]  from            Pointer to an address structure
N                                indicating the source
N                                address.\n sockaddr:\n - code
N                                for the address format.\n - socket address,
N                                the length depends on the code
N                                format
N    \param[in]  fromlen         Source address structure
N                                size. This parameter MUST be set to the size of the structure pointed to by addr.
N
N
N    \return                     Return the number of bytes received,
N                                or a negative value if an error occurred.\n
N                                Using a non-blocking recv a possible negative value is #SLNETERR_BSD_EAGAIN.
N                                #SLNETERR_RET_CODE_INVALID_INPUT will be returned if fromlen has incorrect length.\n
N                                #SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system
N
N    \slnetsock_init_precondition
N
N    \par        Example
N
N    - Receiving data:
N    \code
N        SlNetSock_AddrIn_t  Addr;
N        SlNetSock_AddrIn_t  LocalAddr;
N        int16_t AddrSize = sizeof(SlNetSock_AddrIn_t);
N        int16_t SockID;
N        int16_t Status;
N        int8_t Buf[RECV_BUF_LEN];
N
N        LocalAddr.sin_family = SLNETSOCK_AF_INET;
N        LocalAddr.sin_port = SlNetSock_htons(5001);
N        LocalAddr.sin_addr.s_addr = 0;
N
N        SockID = SlNetSock_create(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_DGRAM, 0, 0, 0);
N        Status = SlNetSock_bind(SockID, (SlNetSock_Addr_t *)&LocalAddr, AddrSize);
N        Status = SlNetSock_recvFrom(SockID, Buf, 1472, 0, (SlNetSock_Addr_t *)&Addr, (SlNetSocklen_t*)&AddrSize);
N
N    \endcode
N
N    \sa     SlNetSock_create()
N    \sa     SlNetSock_recv()
N*/
Nint32_t SlNetSock_recvFrom(int16_t sd, void *buf, uint32_t len, uint32_t flags, SlNetSock_Addr_t *from, SlNetSocklen_t *fromlen);
N
N
N/*!
N    \brief Write data to TCP socket
N
N    Transmits a message to another socket.
N    Returns immediately after sending data to device.
N    In case of a RAW socket (transceiver mode), extra 4 bytes should be reserved at the end of the
N    frame data buffer for WLAN FCS
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] buf              Points to a buffer containing
N                                the message to be sent
N    \param[in] len              Message size in bytes.
N    \param[in] flags            Specifies the type of message
N                                transmission. On this version, this parameter is not
N                                supported for TCP.
N
N    \return                     Return the number of bytes sent,
N                                or a negative value if an error occurred.
N
N    \slnetsock_init_precondition
N
N    \par        Example
N
N    - Sending data:
N    \code
N        SlNetSock_AddrIn_t  Addr;
N        int16_t AddrSize = sizeof(SlNetSock_AddrIn_t);
N        int16_t SockID;
N        int16_t Status;
N        int8_t Buf[SEND_BUF_LEN];
N
N        Addr.sin_family = SLNETSOCK_AF_INET;
N        Addr.sin_port = SlNetSock_htons(5001);
N        Addr.sin_addr.s_addr = SlNetSock_htonl(SLNETSOCK_IPV4_VAL(10,1,1,200));
N
N        SockID = SlNetSock_create(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_STREAM, 0, 0, 0);
N        Status = SlNetSock_connect(SockID, (SlNetSock_Addr_t *)&Addr, AddrSize);
N        Status = SlNetSock_send(SockID, Buf, 1460, 0 );
N    \endcode
N
N    \sa     SlNetSock_create()
N    \sa     SlNetSock_sendTo()
N*/
Nint32_t SlNetSock_send(int16_t sd, const void *buf, uint32_t len, uint32_t flags);
N
N
N/*!
N    \brief Write data to socket
N
N    The SlNetSock_sendTo function is used to transmit a message on a connectionless socket
N    (connection less socket #SLNETSOCK_SOCK_DGRAM, #SLNETSOCK_SOCK_RAW).
N
N    Returns immediately after sending data to device.
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] buf              Points to a buffer containing
N                                the message to be sent
N    \param[in] len              message size in bytes.
N    \param[in] flags            Specifies the type of message
N                                transmission. On this version, this parameter is not
N                                supported
N    \param[in] to               Pointer to an address structure
N                                indicating the destination
N                                address.\n sockaddr:\n - code
N                                for the address format.\n - socket address,
N                                the length depends on the code
N                                format
N    \param[in] tolen            Destination address structure size
N
N    \return                     Return the number of bytes sent,
N                                or a negative value if an error occurred.\n
N
N    \slnetsock_init_precondition
N
N    \par    Example
N
N    - Sending data:
N    \code
N        SlNetSock_AddrIn_t  Addr;
N        int16_t AddrSize = sizeof(SlNetSock_AddrIn_t);
N        int16_t SockID;
N        int16_t Status;
N        int8_t Buf[SEND_BUF_LEN];
N
N        Addr.sin_family = SLNETSOCK_AF_INET;
N        Addr.sin_port = SlNetSock_htons(5001);
N        Addr.sin_addr.s_addr = SlNetSock_htonl(SLNETSOCK_IPV4_VAL(10,1,1,200));
N
N        SockID = SlNetSock_create(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_DGRAM, 0, 0, 0);
N        Status = SlNetSock_sendTo(SockID, Buf, 1472, 0, (SlNetSock_Addr_t *)&Addr, AddrSize);
N    \endcode
N
N    \sa     SlNetSock_create()
N    \sa     SlNetSock_send()
N*/
Nint32_t SlNetSock_sendTo(int16_t sd, const void *buf, uint32_t len, uint32_t flags, const SlNetSock_Addr_t *to, SlNetSocklen_t tolen);
N
N
N/*!
N    \brief Get interface ID from socket descriptor (sd)
N
N    Retrieves the priority of the requested interface.
N
N    \param[in] sd         Specifies the socket descriptor which its
N                          interface identifier needs to be retrieved.\n
N
N    \return               The interface identifier value of the
N                          interface on success, or negative error code
N                          on failure The values of the interface
N                          identifier is defined with the prefix
N                          SLNETIF_ID_ which defined in slnetif.h
N
N    \slnetsock_init_precondition
N
N    \par    Examples
N
N    \code
N        int16_t InterfaceID;
N        InterfaceID = SlNetSock_getIfID(SLNETIF_ID_1);
N    \endcode
N
N    \sa         SlNetSock_create()
N    \sa         SlNetIf_add()
N    \sa         SlNetIf_getIDByName()
N*/
Nint32_t SlNetSock_getIfID(uint16_t sd);
N
N
N/*!
N    \brief Creates a security attributes object
N
N    Create a security attribute, which is required in order to start a secure session.
N
N    \remark     When the security attributes object is no longer needed, call
N                SlNetSock_secAttribDelete() to destroy it.
N
N    \remark     A single security object can be used to initiate several secure
N                sessions (provided they all have the same security attributes).
N
N    \slnetsock_init_precondition
N
N    \sa         SlNetSock_startSec()
N    \sa         SlNetSock_secAttribDelete()
N*/
NSlNetSockSecAttrib_t *SlNetSock_secAttribCreate(void);
N
N
N/*!
N    \brief Deletes a security attributes object
N
N    \param[in] secAttrib        Secure attribute handle
N
N    \return                     Zero on success, or negative error code
N                                on failure
N
N    \slnetsock_init_precondition
N
N    \remark     \c secAttrib must be created using SlNetSock_secAttribCreate()
N
N    \sa         SlNetSock_secAttribCreate()
N    \sa         SlNetSock_secAttribSet()
N    \sa         SlNetSock_startSec()
N*/
Nint32_t SlNetSock_secAttribDelete(SlNetSockSecAttrib_t *secAttrib);
N
N
N/*!
N    \brief set a security attributes
N
N    The SlNetSock_secAttribSet function is used to set a security
N    attribute of a security attributes object.
N
N    \param[in] secAttrib        Secure attribute handle
N    \param[in] attribName       Define the actual attribute to set. Applicable values:
N                                    - #SLNETSOCK_SEC_ATTRIB_PRIVATE_KEY
N                                    - #SLNETSOCK_SEC_ATTRIB_LOCAL_CERT
N                                    - #SLNETSOCK_SEC_ATTRIB_PEER_ROOT_CA
N                                    - #SLNETSOCK_SEC_ATTRIB_DH_KEY
N                                    - #SLNETSOCK_SEC_ATTRIB_METHOD
N                                    - #SLNETSOCK_SEC_ATTRIB_CIPHERS
N                                    - #SLNETSOCK_SEC_ATTRIB_ALPN
N                                    - #SLNETSOCK_SEC_ATTRIB_EXT_CLIENT_CHLNG_RESP
N                                    - #SLNETSOCK_SEC_ATTRIB_DOMAIN_NAME
N                                    - #SLNETSOCK_SEC_ATTRIB_DISABLE_CERT_STORE
N    \param[in] val
N    \param[in] len
N
N    \return                     Zero on success, or negative error code
N                                on failure
N
N    \slnetsock_init_precondition
N
N    \note   The @c SLNETSOCK_SEC_ATTRIB_DISABLE_CERT_STORE value
N            is currently being evaluated, and may be removed in a
N            future release.  It is currently only supported on CC3x20
N            devices.  For more details, see
N            #SLNETSOCK_SEC_ATTRIB_DISABLE_CERT_STORE.
N
N    \sa         SlNetSock_secAttribCreate()
N*/
Nint32_t SlNetSock_secAttribSet(SlNetSockSecAttrib_t *secAttrib , SlNetSockSecAttrib_e attribName , void *val, uint16_t len);
N
N
N/*!
N    \brief Start a security session on an opened socket
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] secAttrib        Secure attribute handle
N    \param[in] flags            Specifies flags. \n
N                                The available flags are:
N                                    - #SLNETSOCK_SEC_START_SECURITY_SESSION_ONLY
N                                    - #SLNETSOCK_SEC_BIND_CONTEXT_ONLY
N                                    - #SLNETSOCK_SEC_IS_SERVER
N
N    \return                     Zero on success, or negative error code
N                                on failure
N
N    \slnetsock_init_precondition
N
N    \remark     If \c secAttrib is \c NULL, the session will be started with
N                default security settings.
N
N    \sa         SlNetSock_create()
N    \sa         SlNetSock_secAttribCreate()
N*/
Nint32_t SlNetSock_startSec(int16_t sd, SlNetSockSecAttrib_t *secAttrib, uint8_t flags);
N
N
N/*!
N
N Close the Doxygen group.
N @}
N
N*/
N
N
N#ifdef  __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __NET_SOCK_H__ */
L 38 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/slnetifwifi.h" 2
N#include <ti/drivers/net/wifi/simplelink.h>
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 1
N/*
N * simplelink.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/
N *
N *
N *  Redistribution and use in source and binary forms, with or without
N *  modification, are permitted provided that the following conditions
N *  are met:
N *
N *  Redistributions of source code must retain the above copyright
N *  notice, this list of conditions and the following disclaimer.
N *
N *  Redistributions in binary form must reproduce the above copyright
N *  notice, this list of conditions and the following disclaimer in the
N *  documentation and/or other materials provided with the
N *  distribution.
N *
N *  Neither the name of Texas Instruments Incorporated nor the names of
N *  its contributors may be used to endorse or promote products derived
N *  from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N
N/*!
N    \mainpage SimpleLink Driver
N
N    \section intro_sec Introduction
N
N The SimpleLink(tm) CC31xx/CC32xx family allows to add Wi-Fi and networking capabilities
N to low-cost embedded products without having prior Wi-Fi, RF or networking expertise.\n
N The CC31xx/CC32xx is an ideal solution for microcontroller-based sensor and control
N applications such as home appliances, home automation and smart metering.\n
N The CC31xx/CC32xx has integrated a comprehensive TCP/IP network stack, Wi-Fi driver and
N security supplicant leading to easier portability to microcontrollers, to an
N ultra-low memory footprint, all without compromising the capabilities and robustness
N of the final application.
N
N
N
N \section modules_sec Module Names
N To make it simple, TI's SimpleLink CC31xx/CC32xx platform capabilities were divided into modules by topic (Silo).\n
N These capabilities range from basic device management through wireless
N network configuration, standard BSD socket and much more.\n
N Listed below are the various modules in the SimpleLink CC31xx/CC32xx driver:
N     -# \ref Device     - Controls the behaviour of the CC31xx/CC32xx device (start/stop, events masking and obtaining specific device status)
N     -# \ref FileSystem - Provides file system capabilities to TI's CC31XX that can be used by both the CC31XX device and the user.
N     -# \ref NetApp     - Activates networking applications, such as: HTTP Server, DHCP Server, Ping, DNS and mDNS.
N     -# \ref NetCfg     - Controls the configuration of the device addresses (i.e. IP and MAC addresses)
N     -# \ref NetUtil    - Networking related commands and configuration
N     -# \ref Socket     - Controls standard client/server sockets programming options and capabilities
N     -# \ref Wlan       - Controls the use of the WiFi WLAN module including:
N                            - Connection features, such as: profiles, policies, SmartConfig(tm)
N                            - Advanced WLAN features, such as: scans, rx filters and rx statistics collection
N     -# \ref UserEvents - Function prototypes for event callback handlers
N
N    \section persistency_sec Persistency
N            The SimpleLink(tm) device support few different persistency types for settings and configurations:\n
N            - <b>Temporary</b>             -    Effective immediately but returned to default after reset\n
N            - <b>System Persistent</b>     -    Effective immediately and kept after reset according\n
N                                                to system persistent mode\n
N            - <b>Persistent</b>            -    Effective immediately and kept after reset regardless the system persistent mode\n
N            - <b>Optionally Persistent</b> -    Effective immediately and kept after reset according to a parameter in the API call\n
N            - <b>Reset</b>                 -    Persistent but effective only after reset\n
N            \n
N            For all Set/Get function in this guide, the type of persistency per relevant parameters will be
N            described as part of the function description\n
N
N    \section    proting_sec     Porting Guide
N
N The porting of the SimpleLink host driver to any new platform is based on few simple steps.\n
N This guide takes you through this process step by step. Please follow the instructions
N carefully to avoid any problems during this process and to enable efficient and proper
N work with the device.\n
N Please notice that all modifications and porting adjustments of the driver should be
N made in the user.h header file only. Keeping this method ensure smoothly
Ntransaction to new versions of the driver in the future!\n
N
NThe porting process consists of few simple steps:
N-# Create user.h for the target platform
N-# Select the capabilities set
N-# Bind the device enable/disable line
N-# Writing your interface communication driver
N-# Choose your memory management model
N-# OS adaptation
N-# Set your asynchronous event handlers
N-# Testing
N
NFor host interface details please refer to:
Nhttp://processors.wiki.ti.com/index.php/CC31xx_Host_Interface
N
NPlease see the rest of the page for more details about the different steps.
N
N \subsection     porting_step1   Step 1 - Create your own user.h file
N
N The first step is to create a <b><i>user.h</i></b> file that will include your configurations and
N adjustments. \n
N The file should be located in the porting directory (the porting directory is in the same level as the source directory)\n
N It is recommended to use the empty template provided as part of this driver or
N file of other platform such as MSP432 or CC3220, from one of the wide range
N of example applications provided by Texas Instruments.
N
N \subsection    porting_step2   Step 2 - Select the capabilities set required for your application
N
N Texas Instruments built 3 different predefined sets of capabilities that would fit most of
N the target applications.\n
N It is recommended to try and choose one of this predefined capabilities set before going to
N build your own customized set. If you find compatible set you can skip the rest of this step.
N
N The available sets are:
N     -# SL_TINY     -   Compatible to be used on platforms with very limited resources. Provides
N                        the best in class low foot print in terms of Code and Data consumption.
N     -# SL_SMALL    -   Compatible to most common networking applications. Provide the most
N                        common APIs with decent balance between code size, data size, functionality
N                        and performances
N     -# SL_FULL     -   Provide access to all SimpleLink functionalities
N
N \subsection    porting_step3   Step 3 - Bind the device enable/disable output line
N
N The CC3120 has two external hardware lines that can be used to enable/disable the device.
N - <b>nReset</b>
N - <b>nHib</b> - provides mechanism to enter the device into the least current consumption mode. In
N this mode the RTC value is kept.
N
N The driver manipulates the enable/disable line automatically during sl_Start / sl_Stop.\n
N Not connecting one these lines means that the driver could start only once (sl_Stop will not
N work correctly and might lead to failure latter on) and the internal provisioning mechanism
N could not be used.\n
N
N To bind these lines the following defines should be defined correctly:
N - <b>sl_DeviceEnable</b>
N - <b>sl_DeviceDisable</b>
N
N If some initializations required before the enable/disable macros are called the user can use also the following <i>optional</i> define
N - <b>sl_DeviceEnablePreamble</b>
N
N \subsection    porting_step4   Step 4 - Writing your interface communication driver
N
N The SimpleLink CC3120 has two standard communication interfaces
N    - SPI
N    - UART
N
N The device detects automatically the active interface during initialization. After the detection, the second interface could not be used.\n
N
N To wrap the driver for the communication channel the following functions should be implemented:
N -# sl_IfOpen
N -# sl_IfClose
N -# sl_IfRead
N -# sl_IfWrite
N -# sl_IfRegIntHdlr
N
N The way these functions are implemented has direct effect on the performances of the SimpleLink
N device on this target platform. DMA and Jitter Buffer should be considered.\n
N
N In some platforms the user need to mask the IRQ line when this interrupt could be masked. \n
N The driver can call the mask/unmask whenever is needed. To allow this functionality the
N user should implement also the following defines:
N    - sl_IfMaskIntHdlr
N    - sl_IfUnMaskIntHdlr
N
N By default the driver is writing the command in few transactions to allow zero-copy mechanism. \n
N To enable a Jitter buffer for improving the communication line utilization, the can implement
N also the following defines:
N    - sl_IfStartWriteSequence
N    - sl_IfEndWriteSequence
N
N \subsection     porting_step5   Step 5 - Choose your memory management model
N
N The SimpleLink driver support two memory models:
N     - Static (default)
N     - Dynamic
N
N To enable the dynamic memory, the following pre-processor define should be set: \n
N #define SL_MEMORY_MGMT_DYNAMIC
N
N And the following macros should be defined and supplied:
N    - sl_Malloc
N    - sl_Free
N
N    Using the dynamic mode will allocate the required resources on sl_Start and release these resource on sl_Stop.
N
N \subsection     porting_step6   Step 6 - OS adaptation
N
N The SimpleLink driver could run on two kind of platforms:
N     -# Non-Os / Single Threaded (default)
N     -# Multi-Threaded
N
N When building a multi-threaded application. the following pre-processor define must be set: \n
N #define SL_PLATFORM_MULTI_THREADED
N
N If you choose to work in multi-threaded environment under operating system you will have to
N provide some basic adaptation routines to allow the driver to protect access to resources
N for different threads (locking object) and to allow synchronization between threads (sync objects).
N In additional the driver support running without dedicated thread allocated solely to the
N SimpleLink driver. If you choose to work in this mode, you should also supply a spawn method that
N will enable to run function on a temporary context.
N
N
N \subsection     porting_step7   Step 7 - Set your asynchronous event handlers routines
N
N The SimpleLink device generate asynchronous events in several situations.
N These asynchronous events could be masked.
N In order to catch these events you have to provide handler routines.
N Please notice that if you not provide a handler routine and the event is received,
N the driver will drop this event without any indication of this drop.
N
N
N \subsection     porting_step8   Step 8 - Run diagnostic tools to validate the correctness of your porting
N
N The driver is delivered with some porting diagnostic tools to simplify the porting validation process
N and to reduce issues latter. It is very important to follow carefully this process.
N
N The diagnostic process include:
N     -# Validating interface communication driver
N     -# Validating basic work with the device
N
N
N    \section annex_step Annex Persistency
N            The SimpleLink(tm) device support few different persistency types for settings and configurations:\n
N            - <b>Temporary</b>             -    Effective immediately but returned to default after reset\n
N            - <b>System Persistent</b>     -    Effective immediately and kept after reset according\n
N                                           -    to system persistent mode\n
N            - <b>Persistent</b>            -    Effective immediately and kept after reset regardless the system persistent mode\n
N            - <b>Optionally Persistent</b> -    Effective immediately and kept after reset according to a parameter in the API call\n
N            - <b>Reset</b>                 -    Persistent but effective only after reset\n
N
N*/
N
N#ifndef __SIMPLELINK_H__
N#define __SIMPLELINK_H__
N
N/* define the default types
N * If user wants to overwrite it,
N * he need to undef and define again */
N#define _u8  unsigned char
N#define _i8  signed char
N#define _u16 unsigned short
N#define _i16 signed short
N#define _u32 unsigned long
N#define _i32 signed long
N
N#define _volatile volatile
N#define _const    const
N
N#include <ti/drivers/net/wifi/porting/user.h>
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/porting/user.h" 1
N/*
N * user.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N/******************************************************************************
N*	user.h - CC31xx/CC32xx Host Driver Implementation
N******************************************************************************/
N
N#ifndef __USER_H__
N#define __USER_H__
N
N#ifdef  __cplusplus
Sextern "C" {
N#endif
N
N  
N#include <string.h>
L 1 "/opt/ti/ccs-latest/ccsv7/tools/compiler/ti-cgt-arm_16.9.6.LTS/include/string.h" 1
N/*****************************************************************************/
N/* string.h   v16.9.6                                                        */
N/*                                                                           */
N/* Copyright (c) 1993-2017 Texas Instruments Incorporated                    */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _STRING
N#define _STRING
N
N
N#pragma diag_push
N#pragma CHECK_MISRA("-6.3") /* standard types required for standard headers */
N#pragma CHECK_MISRA("-19.1") /* #includes required for implementation */
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
N
N#ifdef __cplusplus
S/*---------------------------------------------------------------------------*/
S/* <cstring> IS RECOMMENDED OVER <string.h>.  <string.h> IS PROVIDED FOR     */
S/* COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++                  */
S/*---------------------------------------------------------------------------*/
Sextern "C" namespace std
S{
N#endif /* __cplusplus */
N 
N#ifndef NULL
N#define NULL 0
N#endif
N
N#ifndef _SIZE_T
N#define _SIZE_T
Ntypedef __SIZE_T_TYPE__ size_t;
Xtypedef unsigned size_t;
N#endif
N
N#include <linkage.h>
L 1 "/opt/ti/ccs-latest/ccsv7/tools/compiler/ti-cgt-arm_16.9.6.LTS/include/linkage.h" 1
N/*****************************************************************************/
N/* linkage.h   v16.9.6                                                       */
N/*                                                                           */
N/* Copyright (c) 1998-2017 Texas Instruments Incorporated                    */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _LINKAGE
N#define _LINKAGE
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.4") /* macros required for implementation */
N
N/* No modifiers are needed to access code or data */
N
N#define _CODE_ACCESS
N#define _DATA_ACCESS
N#define _DATA_ACCESS_NEAR
N
N/*--------------------------------------------------------------------------*/
N/* Define _IDECL ==> how inline functions are declared                      */
N/*--------------------------------------------------------------------------*/
N#ifdef _INLINE
S#define _IDECL static __inline
S#define _IDEFN static __inline
N#else
N#define _IDECL extern _CODE_ACCESS
N#define _IDEFN _CODE_ACCESS
N#endif
N
N#pragma diag_pop
N
N#endif /* ifndef _LINKAGE */
L 67 "/opt/ti/ccs-latest/ccsv7/tools/compiler/ti-cgt-arm_16.9.6.LTS/include/string.h" 2
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.4") /* macros required for implementation */
N
N#if defined(_OPTIMIZE_FOR_SPACE) && (defined(__TMS470__) || 		\
N				     defined(__TMS320C2000__)  ||       \
N                                     defined(__MSP430__))
X#if 1L && (1L || 						     0L  ||                                            0L)
N#define _OPT_IDECL
N#else
S#define _OPT_IDECL	_IDECL
N#endif
N
N#pragma diag_pop
N
N_OPT_IDECL size_t  strlen(const char *string);
X size_t  strlen(const char *string);
N
N_OPT_IDECL char *strcpy(char *dest, const char *src);
X char *strcpy(char *dest, const char *src);
N_OPT_IDECL char *strncpy(char *dest, const char *src, size_t n);
X char *strncpy(char *dest, const char *src, size_t n);
N_OPT_IDECL char *strcat(char *string1, const char *string2);
X char *strcat(char *string1, const char *string2);
N_OPT_IDECL char *strncat(char *dest, const char *src, size_t n);
X char *strncat(char *dest, const char *src, size_t n);
N_OPT_IDECL char *strchr(const char *string, int c);
X char *strchr(const char *string, int c);
N_OPT_IDECL char *strrchr(const char *string, int c);
X char *strrchr(const char *string, int c);
N
N_OPT_IDECL int  strcmp(const char *string1, const char *string2);
X int  strcmp(const char *string1, const char *string2);
N_OPT_IDECL int  strncmp(const char *string1, const char *string2, size_t n);
X int  strncmp(const char *string1, const char *string2, size_t n);
N
N_CODE_ACCESS int     strcoll(const char *string1, const char *_string2);
X int     strcoll(const char *string1, const char *_string2);
N_CODE_ACCESS size_t  strxfrm(char *to, const char *from, size_t n);
X size_t  strxfrm(char *to, const char *from, size_t n);
N_CODE_ACCESS char   *strpbrk(const char *string, const char *chs);
X char   *strpbrk(const char *string, const char *chs);
N_CODE_ACCESS size_t  strspn(const char *string, const char *chs);
X size_t  strspn(const char *string, const char *chs);
N_CODE_ACCESS size_t  strcspn(const char *string, const char *chs);
X size_t  strcspn(const char *string, const char *chs);
N_CODE_ACCESS char   *strstr(const char *string1, const char *string2);
X char   *strstr(const char *string1, const char *string2);
N_CODE_ACCESS char   *strtok(char *str1, const char *str2);
X char   *strtok(char *str1, const char *str2);
N_CODE_ACCESS char   *strerror(int _errno);
X char   *strerror(int _errno);
N_CODE_ACCESS char   *strdup(const char *string);
X char   *strdup(const char *string);
N
N
N_CODE_ACCESS void   *memmove(void *s1, const void *s2, size_t n);
X void   *memmove(void *s1, const void *s2, size_t n);
N#pragma diag_push
N#pragma CHECK_MISRA("-16.4") /* false positives due to builtin declarations */
N_CODE_ACCESS void   *memcpy(void *s1, const void *s2, size_t n);
X void   *memcpy(void *s1, const void *s2, size_t n);
N#pragma diag_pop
N
N_OPT_IDECL int     memcmp(const void *cs, const void *ct, size_t n);
X int     memcmp(const void *cs, const void *ct, size_t n);
N_OPT_IDECL void   *memchr(const void *cs, int c, size_t n);
X void   *memchr(const void *cs, int c, size_t n);
N
N_CODE_ACCESS void   *memset(void *mem, int ch, size_t length);
X void   *memset(void *mem, int ch, size_t length);
N
N
N#ifdef __cplusplus
S} /* extern "C" namespace std */
N#endif /* __cplusplus */
N
N#if defined(_INLINE) || defined(_STRING_IMPLEMENTATION)
X#if 0L || 0L
S
S#if (defined(_STRING_IMPLEMENTATION) ||					\
S     !(defined(_OPTIMIZE_FOR_SPACE) && (defined(__TMS470__) || 		\
S					defined(__TMS320C2000__)  ||    \
S                                        defined(__MSP430__))))
X#if (defined(_STRING_IMPLEMENTATION) ||					     !(defined(_OPTIMIZE_FOR_SPACE) && (defined(__TMS470__) || 							defined(__TMS320C2000__)  ||                                            defined(__MSP430__))))
S
S#ifdef __cplusplus
Snamespace std {
S#endif
S
S#pragma diag_push
S#pragma CHECK_MISRA("-19.4") /* macros required for implementation */
S
S#if (defined(_OPTIMIZE_FOR_SPACE) && (defined(__TMS470__) || 		\
S				      defined(__TMS320C2000__) ||       \
S                                      defined(__MSP430__)))
X#if (defined(_OPTIMIZE_FOR_SPACE) && (defined(__TMS470__) || 						      defined(__TMS320C2000__) ||                                             defined(__MSP430__)))
S#define _OPT_IDEFN
S#else
S#define _OPT_IDEFN	_IDEFN
S#endif
S
S#pragma diag_pop
S
S#pragma diag_push /* functions */
S
S/* MISRA exceptions to avoid changing inline versions of the functions that
S   would be linked in instead of included inline at different mf levels */
S/* these functions are very well-tested, stable, and efficient; it would
S   introduce a high risk to implement new, separate MISRA versions just for the
S   inline headers */
S
S#pragma CHECK_MISRA("-5.7") /* keep names intact */
S#pragma CHECK_MISRA("-6.1") /* false positive on use of char type */
S#pragma CHECK_MISRA("-8.5") /* need to define inline functions */
S#pragma CHECK_MISRA("-10.1") /* use implicit casts */
S#pragma CHECK_MISRA("-10.3") /* need casts */
S#pragma CHECK_MISRA("-11.5") /* casting away const required for standard impl */
S#pragma CHECK_MISRA("-12.1") /* avoid changing expressions */
S#pragma CHECK_MISRA("-12.2") /* avoid changing expressions */
S#pragma CHECK_MISRA("-12.4") /* avoid changing expressions */
S#pragma CHECK_MISRA("-12.5") /* avoid changing expressions */
S#pragma CHECK_MISRA("-12.6") /* avoid changing expressions */
S#pragma CHECK_MISRA("-12.13") /* ++/-- needed for reasonable implementation */
S#pragma CHECK_MISRA("-13.1") /* avoid changing expressions */
S#pragma CHECK_MISRA("-14.7") /* use multiple return points */
S#pragma CHECK_MISRA("-14.8") /* use non-compound statements */
S#pragma CHECK_MISRA("-14.9") /* use non-compound statements */
S#pragma CHECK_MISRA("-17.4") /* pointer arithmetic needed for reasonable impl */
S#pragma CHECK_MISRA("-17.6") /* false positive returning pointer-typed param */
S
S#if defined(_INLINE) || defined(_STRLEN)
S_OPT_IDEFN size_t strlen(const char *string)
S{
S   size_t      n = (size_t)-1;
S   const char *s = string;
S
S   do n++; while (*s++);
S   return n;
S}
S#endif /* _INLINE || _STRLEN */
S
S#if defined(_INLINE) || defined(_STRCPY)
S_OPT_IDEFN char *strcpy(register char *dest, register const char *src)
S{
S     register char       *d = dest;     
S     register const char *s = src;
S
S     while (*d++ = *s++);
S     return dest;
S}
S#endif /* _INLINE || _STRCPY */
S
S#if defined(_INLINE) || defined(_STRNCPY)
S_OPT_IDEFN char *strncpy(register char *dest,
S		     register const char *src,
S		     register size_t n)
S{
S     if (n) 
S     {
S	 register char       *d = dest;
S	 register const char *s = src;
S	 while ((*d++ = *s++) && --n);              /* COPY STRING         */
S	 if (n-- > 1) do *d++ = '\0'; while (--n);  /* TERMINATION PADDING */
S     }
S     return dest;
S}
S#endif /* _INLINE || _STRNCPY  */
S
S#if defined(_INLINE) || defined(_STRCAT)
S_OPT_IDEFN char *strcat(char *string1, const char *string2)
S{
S   char       *s1 = string1;
S   const char *s2 = string2;
S
S   while (*s1) s1++;		     /* FIND END OF STRING   */
S   while (*s1++ = *s2++);	     /* APPEND SECOND STRING */
S   return string1;
S}
S#endif /* _INLINE || _STRCAT */
S
S#if defined(_INLINE) || defined(_STRNCAT)
S_OPT_IDEFN char *strncat(char *dest, const char *src, register size_t n)
S{
S    if (n)
S    {
S	char       *d = dest;
S	const char *s = src;
S
S	while (*d) d++;                      /* FIND END OF STRING   */
S
S	while (n--)
S	  if (!(*d++ = *s++)) return dest; /* APPEND SECOND STRING */
S	*d = 0;
S    }
S    return dest;
S}
S#endif /* _INLINE || _STRNCAT */
S
S#if defined(_INLINE) || defined(_STRCHR)
S_OPT_IDEFN char *strchr(const char *string, int c)
S{
S   char        tch, ch  = c;
S   const char *s        = string;
S
S   for (;;)
S   {
S       if ((tch = *s) == ch) return (char *) s;
S       if (!tch)             return (char *) 0;
S       s++;
S   }
S}
S#endif /* _INLINE || _STRCHR */
S
S#if defined(_INLINE) || defined(_STRRCHR)
S_OPT_IDEFN char *strrchr(const char *string, int c)
S{
S   char        tch, ch = c;
S   char       *result  = 0;
S   const char *s       = string;
S
S   for (;;)
S   {
S      if ((tch = *s) == ch) result = (char *) s;
S      if (!tch) break;
S      s++;
S   }
S
S   return result;
S}
S#endif /* _INLINE || _STRRCHR */
S
S#if defined(_INLINE) || defined(_STRCMP)
S_OPT_IDEFN int strcmp(register const char *string1,
S		  register const char *string2)
S{
S   register int c1, res;
S
S   for (;;)
S   {
S       c1  = (unsigned char)*string1++;
S       res = c1 - (unsigned char)*string2++;
S
S       if (c1 == 0 || res != 0) break;
S   }
S
S   return res;
S}
S#endif /* _INLINE || _STRCMP */
S
S#if defined(_INLINE) || defined(_STRNCMP)
S_OPT_IDEFN int strncmp(const char *string1, const char *string2, size_t n)
S{
S     if (n) 
S     {
S	 const char *s1 = string1;
S	 const char *s2 = string2;
S	 unsigned char cp;
S	 int         result;
S
S	 do 
S	    if (result = (unsigned char)*s1++ - (cp = (unsigned char)*s2++))
S                return result;
S	 while (cp && --n);
S     }
S     return 0;
S}
S#endif /* _INLINE || _STRNCMP */
S
S#if defined(_INLINE) || defined(_MEMCMP)
S_OPT_IDEFN int memcmp(const void *cs, const void *ct, size_t n)
S{
S   if (n) 
S   {
S       const unsigned char *mem1 = (unsigned char *)cs;
S       const unsigned char *mem2 = (unsigned char *)ct;
S       int                 cp1, cp2;
S
S       while ((cp1 = *mem1++) == (cp2 = *mem2++) && --n);
S       return cp1 - cp2;
S   }
S   return 0;
S}
S#endif /* _INLINE || _MEMCMP */
S
S#if defined(_INLINE) || defined(_MEMCHR)
S_OPT_IDEFN void *memchr(const void *cs, int c, size_t n)
S{
S   if (n)
S   {
S      const unsigned char *mem = (unsigned char *)cs;   
S      unsigned char        ch  = c;
S
S      do 
S         if ( *mem == ch ) return (void *)mem;
S         else mem++;
S      while (--n);
S   }
S   return NULL;
S}
S#endif /* _INLINE || _MEMCHR */
S
S
S#ifdef __cplusplus
S} /* namespace std */
S#endif
S
S#endif /* (_STRING_IMPLEMENTATION || !(_OPTIMIZE_FOR_SPACE && __TMS470__)) */
S
N#endif /* (_INLINE || _STRING_IMPLEMENTATION) */
N
N#pragma diag_pop
N
N#endif /* ! _STRING */
N
N#pragma diag_push
N
N/* using declarations must occur outside header guard to support including both
N   C and C++-wrapped version of header; see _CPP_STYLE_HEADER check */
N/* this code is for C++ mode only and thus also not relevant for MISRA */
N#pragma CHECK_MISRA("-19.15")
N
N#if defined(__cplusplus) && !defined(_CPP_STYLE_HEADER)
X#if 0L && !0L
Susing std::size_t;
Susing std::strlen;
Susing std::strcpy;
Susing std::strncpy;
Susing std::strcat;
Susing std::strncat;
Susing std::strchr;
Susing std::strrchr;
Susing std::strcmp;
Susing std::strncmp;
Susing std::strcoll;
Susing std::strxfrm;
Susing std::strpbrk;
Susing std::strspn;
Susing std::strcspn;
Susing std::strstr;
Susing std::strtok;
Susing std::strerror;
Susing std::strdup;
Susing std::memmove;
Susing std::memcpy;
Susing std::memcmp;
Susing std::memchr;
Susing std::memset;
S
S
N#endif /* _CPP_STYLE_HEADER */
N
N#pragma diag_pop
L 50 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/porting/user.h" 2
N#include <ti/drivers/net/wifi/porting/cc_pal.h>
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/porting/cc_pal.h" 1
N/*
N * cc_pal.h - CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N/******************************************************************************
N*   cc_pal.h
N*
N*   SimpleLink Wi-Fi abstraction file for CC3220
N******************************************************************************/
N
N#ifndef __CC31xx_PAL_H__
N#define	__CC31xx_PAL_H__
N
N#ifdef	__cplusplus
Sextern "C" {
N#endif
N
N#include <ti/drivers/dpl/SemaphoreP.h>
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/dpl/SemaphoreP.h" 1
N/*
N * Copyright (c) 2015-2017, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N/** ============================================================================
N *  @file       SemaphoreP.h
N *
N *  @brief      Semaphore module for the RTOS Porting Interface
N *
N *  Semaphores can be counting semaphores or binary semaphores. Counting
N *  semaphores keep track of the number of times the semaphore has been posted
N *  with post functions. This is useful, for example, if you have a group of
N *  resources that are shared between tasks. Such tasks might call pend() to see
N *  if a resource is available before using one. A count of zero for a counting
N *  semaphore denotes that it is not available. A positive count denotes
N *  how many times a SemaphoreP_pend can be called before it is blocked (or
N *  returns SemaphoreP_TIMEOUT).
N *
N *  Binary semaphores can have only two states: available (count = 1) and
N *  unavailable (count = 0). They can be used to share a single resource
N *  between tasks. They can also be used for a basic signalling mechanism, where
N *  the semaphore can be posted multiple times. Binary semaphores do not keep
N *  track of the count; they simply track whether the semaphore has been posted
N *  or not.
N *
N *  ============================================================================
N */
N
N#ifndef ti_dpl_SemaphoreP__include
N#define ti_dpl_SemaphoreP__include
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <stddef.h>
L 1 "/opt/ti/ccs-latest/ccsv7/tools/compiler/ti-cgt-arm_16.9.6.LTS/include/stddef.h" 1
N/*****************************************************************************/
N/* stddef.h   v16.9.6                                                        */
N/*                                                                           */
N/* Copyright (c) 1993-2017 Texas Instruments Incorporated                    */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _STDDEF
N#define _STDDEF
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.7") /* macros required for implementation */
N#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
N#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
N
N#ifdef __cplusplus
Sextern "C" namespace std {
N#endif
N
N#ifndef NULL
S#define NULL 0
N#endif
N
Ntypedef __PTRDIFF_T_TYPE__ ptrdiff_t;
Xtypedef int ptrdiff_t;
N
N#ifndef _SIZE_T
S#define _SIZE_T
Stypedef __SIZE_T_TYPE__ size_t;
N#endif
N
N#ifndef __cplusplus
N#ifndef _WCHAR_T
N#define _WCHAR_T
N
Ntypedef __WCHAR_T_TYPE__ wchar_t;
Xtypedef unsigned short wchar_t;
N
N#endif /* _WCHAR_T */
N#endif /* ! __cplusplus */
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.10") /* need types as macro arguments */
N
N#ifdef __TI_LLVM__
S#  define offsetof(_type, _ident) __builtin_offsetof(_type, _ident)
N#else
N#    ifdef __cplusplus
S#      define offsetof(_type, _ident) \
S         ((std::size_t)__intaddr__(&(((_type *)0)->_ident)))
X#      define offsetof(_type, _ident)          ((std::size_t)__intaddr__(&(((_type *)0)->_ident)))
N#    else
N#      define offsetof(_type, _ident) \
N         ((size_t)__intaddr__(&(((_type *)0)->_ident)))
X#      define offsetof(_type, _ident)          ((size_t)__intaddr__(&(((_type *)0)->_ident)))
N#    endif
N#endif
N
N#ifdef __cplusplus
S} /* extern "C" namespace std */
N#endif  /* __cplusplus */
N
N#pragma diag_pop
N
N#endif  /* _STDDEF */
N
N#if defined(__cplusplus) && !defined(_CPP_STYLE_HEADER)
X#if 0L && !0L
Susing std::ptrdiff_t;
Susing std::size_t;
S/*using std::wchar_t;*/
N#endif /* _CPP_STYLE_HEADER */
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.15") /* code outside guard; see below comment */
N
N/*-----------------------------------------------------------------------*/
N/* Define _win_t, for compiling GCC libraries with the TI compiler.      */
N/* GCC's library (newlib) expects wint_t to be defined here, in stddef.h,*/
N/* which is arguably incorrect, but we go along for compatibility.       */
N/* This is outside the _STDDEF guard in case this file has already       */
N/* been included without __need_wint_t.                                  */
N/*-----------------------------------------------------------------------*/
N#if defined(__need_wint_t) && !defined(_WINT_T) 
X#if 0L && !0L 
S#if (__STDC_VERSION__ >= 199901L || !__TI_STRICT_ANSI_MODE__)
S
S#undef __need_wint_t
S#define _WINT_T
S#ifdef __cplusplus
S   extern "C" namespace std {
S#endif /* __cplusplus */
S
Stypedef unsigned int wint_t;
S
S#ifdef __cplusplus
S   } /* extern "C" namespace std { */
S#endif /* __cplusplus */
S
S#if defined(__cplusplus) && !defined(_CPP_STYLE_HEADER)
Susing std::wint_t;
S#endif /* _CPP_STYLE_HEADER */
S
S#endif /* __STDC_VERSION__ >= 199901L  */
N#endif
N
N#pragma diag_pop
L 66 "/vagrant/Q4_04/sdk_root/source/ti/drivers/dpl/SemaphoreP.h" 2
N
N/*!
N *  @brief    Number of bytes greater than or equal to the size of any RTOS
N *            SemaphoreP object.
N *
N *  nortos:   16
N *  SysBIOS:  28
N */
N#define SemaphoreP_STRUCT_SIZE   (28)
N
N/*!
N *  @brief    SemaphoreP structure.
N *
N *  Opaque structure that should be large enough to hold any of the
N *  RTOS specific SemaphoreP objects.
N */
Ntypedef union SemaphoreP_Struct {
N    uint32_t dummy;  /*!< Align object */
N    char     data[SemaphoreP_STRUCT_SIZE];
X    char     data[(28)];
N} SemaphoreP_Struct;
N
N/*!
N *  @brief    Wait forever define
N */
N#define SemaphoreP_WAIT_FOREVER ~(0)
N
N/*!
N *  @brief    No wait define
N */
N#define SemaphoreP_NO_WAIT       (0)
N
N/*!
N *  @brief    Status codes for SemaphoreP APIs (for backwards compatibility)
N */
Ntypedef enum SemaphoreP_Status {
N    /*! API completed successfully */
N    SemaphoreP_OK = 0,
N    /*! API failed because of a timeout */
N    SemaphoreP_TIMEOUT = -1
N} SemaphoreP_Status;
N
N/*!
N *  @brief    Opaque client reference to an instance of a SemaphoreP
N *
N *  A SemaphoreP_Handle returned from the ::SemaphoreP_create represents that
N *  instance and  is used in the other instance based functions (e.g.
N *  ::SemaphoreP_post or ::SemaphoreP_pend, etc.).
N */
Ntypedef  void *SemaphoreP_Handle;
N
N/*!
N *  @brief    Mode of the semaphore
N */
Ntypedef enum SemaphoreP_Mode {
N    SemaphoreP_Mode_COUNTING = 0x0,
N    SemaphoreP_Mode_BINARY   = 0x1
N} SemaphoreP_Mode;
N
N/*!
N *  @brief    Basic SemaphoreP Parameters
N *
N *  Structure that contains the parameters are passed into ::SemaphoreP_create
N *  when creating a SemaphoreP instance. The ::SemaphoreP_Params_init function
N *  should be used to initialize the fields to default values before the
N *  application sets the fields manually. The SemaphoreP default parameters are
N *  noted in SemaphoreP_Params_init.
N */
Ntypedef struct SemaphoreP_Params {
N    SemaphoreP_Mode mode;   /*!< Mode for the semaphore */
N    void (*callback)(void); /*!< Callback while pending for semaphore post */
N} SemaphoreP_Params;
N
N/*!
N *  @brief    Default SemaphoreP instance parameters
N *
N *  SemaphoreP_defaultParams represents the default parameters that are
N *  used when creating or constructing a SemaphoreP instance.
N *  SemaphoreP_Params_init() will use the contents of this structure for
N *  initializing the SemaphoreP_Params instance.
N *
N *  SemaphoreP_defaultParams is exposed to the application for the purpose
N *  of allowing the application to change the default parameters for all
N *  SemaphoreP instances created thereafter.  The main intent for allowing
N *  the default parameters to be changed is for setting a semaphore's
N *  callback function to Power_idleFunc(), so that the SOC can enter low
N *  power mode when pending on a semaphore.
N */
Nextern SemaphoreP_Params SemaphoreP_defaultParams;
N
N
N/*
N *  SemaphoreP construct APIs can only be used if one of the OS's
N *  is defined.  For FreeRTOS, configSUPPORT_STATIC_ALLOCATION also
N *  has to be set to 1 in FreeRTOSConfig.h.
N */
Nextern SemaphoreP_Handle SemaphoreP_construct(SemaphoreP_Struct *handle,
N        unsigned int count, SemaphoreP_Params *params);
N
Nextern SemaphoreP_Handle SemaphoreP_constructBinary(SemaphoreP_Struct *handle,
N        unsigned int count);
N
Nextern void SemaphoreP_destruct(SemaphoreP_Struct *semP);
N
N/*!
N *  @brief  Function to create a semaphore.
N *
N *  @param  count  Initial count of the semaphore. For binary semaphores,
N *                 only values of 0 or 1 are valid.
N *
N *  @param  params  Pointer to the instance configuration parameters. NULL
N *                  denotes to use the default parameters (SemaphoreP default
N *                  parameters as noted in ::SemaphoreP_Params_init.
N *
N *  @return A SemaphoreP_Handle on success or a NULL on an error
N */
Nextern SemaphoreP_Handle SemaphoreP_create(unsigned int count,
N        SemaphoreP_Params *params);
N
N/*!
N *  @brief  Function to create a binary semaphore.
N *
N *  This can be used instead of SemaphoreP_create() to create a binary
N *  semaphore.
N *
N *  @param  count  Initial count of the binary semaphore. Only values
N *                 of 0 or 1 are valid.
N *
N *  @return A SemaphoreP_Handle on success or a NULL on an error
N */
Nextern SemaphoreP_Handle SemaphoreP_createBinary(unsigned int count);
N
N/*!
N *  @brief  Function to create a binary semaphore.
N *
N *  This can be used instead of SemaphoreP_create() to create a binary
N *  semaphore.
N *
N *  @param  count  Initial count of the binary semaphore. Only values
N *                 of 0 or 1 are valid.
N *
N *  @return A SemaphoreP_Handle on success or a NULL on an error
N */
Nextern SemaphoreP_Handle SemaphoreP_createBinaryCallback(unsigned int count,
N        void (*callback)(void));
N
N/*!
N *  @brief  Function to delete a semaphore.
N *
N *  @param  handle  A SemaphoreP_Handle returned from ::SemaphoreP_create
N */
Nextern void SemaphoreP_delete(SemaphoreP_Handle handle);
N
N/*!
N *  @brief  Initialize params structure to default values.
N *
N *  The default parameters are:
N *   - mode: SemaphoreP_Mode_COUNTING
N *   - name: NULL
N *
N *  @param params  Pointer to the instance configuration parameters.
N */
Nextern void SemaphoreP_Params_init(SemaphoreP_Params *params);
N
N/*!
N *  @brief  Function to pend (wait) on a semaphore.
N *
N *  @param  handle  A SemaphoreP_Handle returned from ::SemaphoreP_create
N *
N *  @param  timeout Timeout (in ClockP ticks) to wait for the semaphore to
N *                  be posted (signalled).
N *
N *  @return Status of the functions
N *    - SemaphoreP_OK: Obtained the semaphore
N *    - SemaphoreP_TIMEOUT: Timed out. Semaphore was not obtained.
N */
Nextern SemaphoreP_Status SemaphoreP_pend(SemaphoreP_Handle handle,
N                                         uint32_t timeout);
N
N/*!
N *  @brief  Function to post (signal) a semaphore from task of ISR context.
N *
N *  @param  handle  A SemaphoreP_Handle returned from ::SemaphoreP_create
N */
Nextern void SemaphoreP_post(SemaphoreP_Handle handle);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* ti_dpl_SemaphoreP__include */
L 50 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/porting/cc_pal.h" 2
N#include <ti/drivers/dpl/MutexP.h>
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/dpl/MutexP.h" 1
N/*
N * Copyright (c) 2015-2017, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N/** ============================================================================
N *  @file       MutexP.h
N *
N *  @brief      Mutex module for the RTOS Porting Interface
N *
N *  The MutexP module allows task to maintain critical region segments. The
N *  MutexP module has two main functions: ::MutexP_lock and ::MutexP_unlock.
N *
N *  The MutexP module supports recursive calls to the MutexP_lock API by a
N *  single task. The same number of MutexP_unlock calls must be done for the
N *  mutex to be release. Note: the returned key must be provided in the LIFO
N *  order. For example:
N *  @code
N *  uintptr_t key1, key2;
N *  key1 = MutexP_lock();
N *  key2 = MutexP_lock();
N *  MutexP_lock(key2);
N *  MutexP_lock(key1);
N *  @endcode
N *
N *  ============================================================================
N */
N
N#ifndef ti_dpl_MutexP__include
N#define ti_dpl_MutexP__include
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <stddef.h>
L 1 "/opt/ti/ccs-latest/ccsv7/tools/compiler/ti-cgt-arm_16.9.6.LTS/include/stddef.h" 1
N/*****************************************************************************/
N/* stddef.h   v16.9.6                                                        */
N/*                                                                           */
N/* Copyright (c) 1993-2017 Texas Instruments Incorporated                    */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _STDDEF
S#define _STDDEF
S
S#pragma diag_push
S#pragma CHECK_MISRA("-19.7") /* macros required for implementation */
S#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
S#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
S
S#ifdef __cplusplus
Sextern "C" namespace std {
S#endif
S
S#ifndef NULL
S#define NULL 0
S#endif
S
Stypedef __PTRDIFF_T_TYPE__ ptrdiff_t;
S
S#ifndef _SIZE_T
S#define _SIZE_T
Stypedef __SIZE_T_TYPE__ size_t;
S#endif
S
S#ifndef __cplusplus
S#ifndef _WCHAR_T
S#define _WCHAR_T
S
Stypedef __WCHAR_T_TYPE__ wchar_t;
S
S#endif /* _WCHAR_T */
S#endif /* ! __cplusplus */
S
S#pragma diag_push
S#pragma CHECK_MISRA("-19.10") /* need types as macro arguments */
S
S#ifdef __TI_LLVM__
S#  define offsetof(_type, _ident) __builtin_offsetof(_type, _ident)
S#else
S#    ifdef __cplusplus
S#      define offsetof(_type, _ident) \
S         ((std::size_t)__intaddr__(&(((_type *)0)->_ident)))
X#      define offsetof(_type, _ident)          ((std::size_t)__intaddr__(&(((_type *)0)->_ident)))
S#    else
S#      define offsetof(_type, _ident) \
S         ((size_t)__intaddr__(&(((_type *)0)->_ident)))
X#      define offsetof(_type, _ident)          ((size_t)__intaddr__(&(((_type *)0)->_ident)))
S#    endif
S#endif
S
S#ifdef __cplusplus
S} /* extern "C" namespace std */
S#endif  /* __cplusplus */
S
S#pragma diag_pop
S
N#endif  /* _STDDEF */
N
N#if defined(__cplusplus) && !defined(_CPP_STYLE_HEADER)
X#if 0L && !0L
Susing std::ptrdiff_t;
Susing std::size_t;
S/*using std::wchar_t;*/
N#endif /* _CPP_STYLE_HEADER */
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.15") /* code outside guard; see below comment */
N
N/*-----------------------------------------------------------------------*/
N/* Define _win_t, for compiling GCC libraries with the TI compiler.      */
N/* GCC's library (newlib) expects wint_t to be defined here, in stddef.h,*/
N/* which is arguably incorrect, but we go along for compatibility.       */
N/* This is outside the _STDDEF guard in case this file has already       */
N/* been included without __need_wint_t.                                  */
N/*-----------------------------------------------------------------------*/
N#if defined(__need_wint_t) && !defined(_WINT_T) 
X#if 0L && !0L 
S#if (__STDC_VERSION__ >= 199901L || !__TI_STRICT_ANSI_MODE__)
S
S#undef __need_wint_t
S#define _WINT_T
S#ifdef __cplusplus
S   extern "C" namespace std {
S#endif /* __cplusplus */
S
Stypedef unsigned int wint_t;
S
S#ifdef __cplusplus
S   } /* extern "C" namespace std { */
S#endif /* __cplusplus */
S
S#if defined(__cplusplus) && !defined(_CPP_STYLE_HEADER)
Susing std::wint_t;
S#endif /* _CPP_STYLE_HEADER */
S
S#endif /* __STDC_VERSION__ >= 199901L  */
N#endif
N
N#pragma diag_pop
L 65 "/vagrant/Q4_04/sdk_root/source/ti/drivers/dpl/MutexP.h" 2
N
N/*!
N *  @brief    Number of bytes greater than or equal to the size of any RTOS
N *            MutexP object.
N *
N *  nortos:   12
N *  SysBIOS:  40
N */
N#define MutexP_STRUCT_SIZE   (40)
N
N/*!
N *  @brief    MutexP structure.
N *
N *  Opaque structure that should be large enough to hold any of the
N *  RTOS specific MutexP objects.
N */
Ntypedef union MutexP_Struct {
N    uint32_t dummy;  /*!< Align object */
N    char     data[MutexP_STRUCT_SIZE];
X    char     data[(40)];
N} MutexP_Struct;
N
N/*!
N *  @brief    Status codes for MutexP APIs
N */
Ntypedef enum MutexP_Status {
N    /*! API completed successfully */
N    MutexP_OK = 0,
N    /*! API failed */
N    MutexP_FAILURE = -1
N} MutexP_Status;
N
N/*!
N *  @brief    Opaque client reference to an instance of a MutexP
N *
N *  A MutexP_Handle returned from the ::MutexP_create represents that instance.
N *  and then is used in the other instance based functions (e.g. ::MutexP_lock,
N *  ::MutexP_unlock, etc.).
N */
Ntypedef void *MutexP_Handle;
N
N/*!
N *  @brief    Basic MutexP Parameters
N *
N *  Structure that contains the parameters are passed into ::MutexP_create
N *  when creating a MutexP instance. The ::MutexP_Params_init function should
N *  be used to initialize the fields to default values before the application
N *  sets the fields manually. The MutexP default parameters are noted in
N *  ::MutexP_Params_init.
N */
Ntypedef struct MutexP_Params {
N    void (*callback)(void); /*!< Callback while waiting for mutex unlock */
N} MutexP_Params;
N
N
N/*!
N *  @brief  Function to construct a mutex.
N *
N *  @param  handle Pointer to a MutexP_Struct object
N *
N *  @param  params  Pointer to the instance configuration parameters. NULL
N *                  denotes to use the default parameters (MutexP default
N *                  parameters as noted in ::MutexP_Params_init.
N *
N *  @return A MutexP_Handle on success or a NULL on an error
N */
Nextern MutexP_Handle MutexP_construct(MutexP_Struct *handle,
N        MutexP_Params *params);
N
N/*!
N *  @brief  Function to destruct a mutex object
N *
N *  @param  mutexP  Pointer to a MutexP_Struct object that was passed to
N *                  MutexP_construct().
N *
N *  @return
N */
Nextern void MutexP_destruct(MutexP_Struct *mutexP);
N
N/*!
N *  @brief  Function to create a mutex.
N *
N *  @param  params  Pointer to the instance configuration parameters. NULL
N *                  denotes to use the default parameters. The MutexP default
N *                  parameters are noted in ::MutexP_Params_init.
N *
N *  @return A MutexP_Handle on success or a NULL on an error
N */
Nextern MutexP_Handle MutexP_create(MutexP_Params *params);
N
N/*!
N *  @brief  Function to delete a mutex.
N *
N *  @param  handle  A MutexP_Handle returned from MutexP_create
N */
Nextern void MutexP_delete(MutexP_Handle handle);
N
N/*!
N *  @brief  Initialize params structure to default values.
N *
N *  The default parameters are:
N *      callback - NULL.
N *
N *  @param params  Pointer to the instance configuration parameters.
N */
Nextern void MutexP_Params_init(MutexP_Params *params);
N
N/*!
N *  @brief  Function to lock a mutex.
N *
N *  This function can only be called from a Task. It cannot be called from
N *  an interrupt. The lock will block until the mutex is available.
N *
N *  Users of a mutex should make every attempt to minimize the duration that
N *  that they have it locked. This is to minimize latency. It is recommended
N *  that the users of the mutex do not block while they have the mutex locked.
N *
N *  This function unlocks the mutex. If the mutex is locked multiple times
N *  by the caller, the same number of unlocks must be called.
N *
N *  @param  handle  A MutexP_Handle returned from ::MutexP_create
N *
N *  @return A key is returned. This key must be passed into ::MutexP_unlock.
N */
Nextern uintptr_t MutexP_lock(MutexP_Handle handle);
N
N/*!
N *  @brief  Function to unlock a mutex
N *
N *  This function unlocks the mutex. If the mutex is locked multiple times
N *  by the caller, the same number of unlocks must be called. The order of
N *  the keys must be reversed. For example
N *  @code
N *  uintptr_t key1, key2;
N *  key1 = MutexP_lock();
N *  key2 = MutexP_lock();
N *  MutexP_lock(key2);
N *  MutexP_lock(key1);
N *  @endcode
N *
N *  @param  handle  A MutexP_Handle returned from ::MutexP_create
N *
N *  @param  key  Return from ::MutexP_lock.
N */
Nextern void MutexP_unlock(MutexP_Handle handle, uintptr_t key);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* ti_dpl_MutexP__include */
L 51 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/porting/cc_pal.h" 2
N#include <ti/drivers/dpl/ClockP.h>
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/dpl/ClockP.h" 1
N/*
N * Copyright (c) 2016-2017, Texas Instruments Incorporated
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N *
N * *  Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N *
N * *  Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N *
N * *  Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
N * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
N * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
N * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
N * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
N * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
N * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
N * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N/** ============================================================================
N *  @file       ClockP.h
N *
N *  @brief      Clock interface for the RTOS Porting Interface
N *
N *  The ClockP module can be used to schedule functions that run at intervals
N *  specified in the underlying kernel's system ticks.  ClockP instances are
N *  one-shot.  The one-shot function will be run once
N *  after the specified period has elapsed since calling ClockP_start().
N *
N *  The ClockP module can also be used to obtain the period of the kernel's
N *  system tick in microseconds.  This is useful for determining the number of
N *  ticks needed for setting a Clock object's period.
N *
N *  When using the TI-RTOS kernel, ClockP functions are run at software
N *  interrupt level. With FreeRTOS, the ClockP functions are run by a timer
N *  service task with priority configured by the application.
N *
N *  A common use case is to post a semaphore in the clock function. There is a
N *  specific API for this: Semaphore_postFromClock(). This must be used in a
N *  clock function (instead of Semaphore_post).
N *
N *  ============================================================================
N */
N
N#ifndef ti_dpl_ClockP__include
N#define ti_dpl_ClockP__include
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <stddef.h>
L 1 "/opt/ti/ccs-latest/ccsv7/tools/compiler/ti-cgt-arm_16.9.6.LTS/include/stddef.h" 1
N/*****************************************************************************/
N/* stddef.h   v16.9.6                                                        */
N/*                                                                           */
N/* Copyright (c) 1993-2017 Texas Instruments Incorporated                    */
N/* http://www.ti.com/                                                        */
N/*                                                                           */
N/*  Redistribution and  use in source  and binary forms, with  or without    */
N/*  modification,  are permitted provided  that the  following conditions    */
N/*  are met:                                                                 */
N/*                                                                           */
N/*     Redistributions  of source  code must  retain the  above copyright    */
N/*     notice, this list of conditions and the following disclaimer.         */
N/*                                                                           */
N/*     Redistributions in binary form  must reproduce the above copyright    */
N/*     notice, this  list of conditions  and the following  disclaimer in    */
N/*     the  documentation  and/or   other  materials  provided  with  the    */
N/*     distribution.                                                         */
N/*                                                                           */
N/*     Neither the  name of Texas Instruments Incorporated  nor the names    */
N/*     of its  contributors may  be used to  endorse or  promote products    */
N/*     derived  from   this  software  without   specific  prior  written    */
N/*     permission.                                                           */
N/*                                                                           */
N/*  THIS SOFTWARE  IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS    */
N/*  "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT    */
N/*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    */
N/*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    */
N/*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    */
N/*  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL  DAMAGES  (INCLUDING, BUT  NOT    */
N/*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    */
N/*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    */
N/*  THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT    */
N/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    */
N/*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */
N/*                                                                           */
N/*****************************************************************************/
N
N#ifndef _STDDEF
S#define _STDDEF
S
S#pragma diag_push
S#pragma CHECK_MISRA("-19.7") /* macros required for implementation */
S#pragma CHECK_MISRA("-20.1") /* standard headers must define standard names */
S#pragma CHECK_MISRA("-20.2") /* standard headers must define standard names */
S
S#ifdef __cplusplus
Sextern "C" namespace std {
S#endif
S
S#ifndef NULL
S#define NULL 0
S#endif
S
Stypedef __PTRDIFF_T_TYPE__ ptrdiff_t;
S
S#ifndef _SIZE_T
S#define _SIZE_T
Stypedef __SIZE_T_TYPE__ size_t;
S#endif
S
S#ifndef __cplusplus
S#ifndef _WCHAR_T
S#define _WCHAR_T
S
Stypedef __WCHAR_T_TYPE__ wchar_t;
S
S#endif /* _WCHAR_T */
S#endif /* ! __cplusplus */
S
S#pragma diag_push
S#pragma CHECK_MISRA("-19.10") /* need types as macro arguments */
S
S#ifdef __TI_LLVM__
S#  define offsetof(_type, _ident) __builtin_offsetof(_type, _ident)
S#else
S#    ifdef __cplusplus
S#      define offsetof(_type, _ident) \
S         ((std::size_t)__intaddr__(&(((_type *)0)->_ident)))
X#      define offsetof(_type, _ident)          ((std::size_t)__intaddr__(&(((_type *)0)->_ident)))
S#    else
S#      define offsetof(_type, _ident) \
S         ((size_t)__intaddr__(&(((_type *)0)->_ident)))
X#      define offsetof(_type, _ident)          ((size_t)__intaddr__(&(((_type *)0)->_ident)))
S#    endif
S#endif
S
S#ifdef __cplusplus
S} /* extern "C" namespace std */
S#endif  /* __cplusplus */
S
S#pragma diag_pop
S
N#endif  /* _STDDEF */
N
N#if defined(__cplusplus) && !defined(_CPP_STYLE_HEADER)
X#if 0L && !0L
Susing std::ptrdiff_t;
Susing std::size_t;
S/*using std::wchar_t;*/
N#endif /* _CPP_STYLE_HEADER */
N
N#pragma diag_push
N#pragma CHECK_MISRA("-19.15") /* code outside guard; see below comment */
N
N/*-----------------------------------------------------------------------*/
N/* Define _win_t, for compiling GCC libraries with the TI compiler.      */
N/* GCC's library (newlib) expects wint_t to be defined here, in stddef.h,*/
N/* which is arguably incorrect, but we go along for compatibility.       */
N/* This is outside the _STDDEF guard in case this file has already       */
N/* been included without __need_wint_t.                                  */
N/*-----------------------------------------------------------------------*/
N#if defined(__need_wint_t) && !defined(_WINT_T) 
X#if 0L && !0L 
S#if (__STDC_VERSION__ >= 199901L || !__TI_STRICT_ANSI_MODE__)
S
S#undef __need_wint_t
S#define _WINT_T
S#ifdef __cplusplus
S   extern "C" namespace std {
S#endif /* __cplusplus */
S
Stypedef unsigned int wint_t;
S
S#ifdef __cplusplus
S   } /* extern "C" namespace std { */
S#endif /* __cplusplus */
S
S#if defined(__cplusplus) && !defined(_CPP_STYLE_HEADER)
Susing std::wint_t;
S#endif /* _CPP_STYLE_HEADER */
S
S#endif /* __STDC_VERSION__ >= 199901L  */
N#endif
N
N#pragma diag_pop
L 67 "/vagrant/Q4_04/sdk_root/source/ti/drivers/dpl/ClockP.h" 2
N
N/*!
N *  @brief    Number of bytes greater than or equal to the size of any RTOS
N *            ClockP object.
N *
N *  nortos:   32 (biggest of the HW-specific ClockP instance structs)
N *  SysBIOS:  36
N */
N#define ClockP_STRUCT_SIZE   (36)
N
N/*!
N *  @brief    ClockP structure.
N *
N *  Opaque structure that should be large enough to hold any of the
N *  RTOS specific ClockP objects.
N */
Ntypedef union ClockP_Struct {
N    uint32_t dummy;  /*!< Align object */
N    char     data[ClockP_STRUCT_SIZE];
X    char     data[(36)];
N} ClockP_Struct;
N
N/*!
N *  @brief  Frequency-in-hertz struct
N */
Ntypedef struct ClockP_FreqHz {
N    uint32_t hi;      /*! most significant 32-bits of frequency */
N    uint32_t lo;      /*! least significant 32-bits of frequency */
N} ClockP_FreqHz;
N
N/*!
N *  @brief    Status codes for ClockP APIs
N */
Ntypedef enum ClockP_Status {
N    ClockP_OK = 0,
N    ClockP_FAILURE = -1
N} ClockP_Status;
N
N/*!
N *  @brief    Opaque client reference to an instance of a ClockP
N *
N *  A ClockP_Handle returned from the ::ClockP_create represents that instance.
N *  and then is used in the other instance based functions (e.g. ::ClockP_start,
N *  ::ClockP_stop, etc.).
N */
Ntypedef  void *ClockP_Handle;
N
N#define ClockP_handle(x) ((ClockP_Handle)(x))
N
Nextern uint32_t ClockP_tickPeriod;
N
N/*!
N *  @brief  Prototype for a ClockP function.
N */
Ntypedef void (*ClockP_Fxn)(uintptr_t arg);
N
N/*!
N *  @brief    Basic ClockP Parameters
N *
N *  Structure that contains the parameters passed into ::ClockP_create
N *  when creating a ClockP instance. The ::ClockP_Params_init function should
N *  be used to initialize the fields to default values before the application
N *  sets the fields manually. The ClockP default parameters are noted in
N *  ClockP_Params_init.
N *  The default startFlag is false, meaning the user will have to call
N *  ClockP_start().  If startFlag is true, the clock instance will be
N *  started automatically when it is created.
N *
N *  The default value of period is 0, indicating a one-shot clock object.
N *  A non-zero period indicates the clock function will be called
N *  periodically at the period rate (in system clock ticks), after the
N *  clock is initially started and set to expire with the 'timeout'
N *  argument.
N */
Ntypedef struct ClockP_Params {
N    bool      startFlag; /*!< Start immediately after instance is created. */
X    _Bool      startFlag;  
N    uint32_t  period;    /*!< Period of clock object. */
N    uintptr_t arg;       /*!< Argument passed into the clock function. */
N} ClockP_Params;
N
N
N/*!
N *  @brief  Function to construct a clock object.
N *
N *  @param  clockP    Pointer to ClockP_Struct object.
N *  @param  timeout   The startup timeout, if supported by the RTOS.
N *  @param  clockFxn  Function called when timeout or period expires.
N *
N *  @param  params    Pointer to the instance configuration parameters. NULL
N *                    denotes to use the default parameters. The ClockP default
N *                    parameters are noted in ::SwiP_Params_init.
N *
N *  @return A ClockP_Handle on success or a NULL on an error
N */
Nextern ClockP_Handle ClockP_construct(ClockP_Struct *clockP,
N                                      ClockP_Fxn clockFxn,
N                                      uint32_t timeout,
N                                      ClockP_Params *params);
N
N/*!
N *  @brief  Function to destruct a clock object
N *
N *  @param  clockP  Pointer to a ClockP_Struct object that was passed to
N *                  ClockP_construct().
N *
N *  @return
N */
Nextern void ClockP_destruct(ClockP_Struct *clockP);
N
N/*!
N *  @brief  Function to create a clock object.
N *
N *  @param  clockFxn  Function called when timeout or period expires.
N *  @param  timeout   The startup timeout, if supported by the RTOS.
N *  @param  params    Pointer to the instance configuration parameters. NULL
N *                    denotes to use the default parameters. The ClockP default
N *                    parameters are noted in ::ClockP_Params_init.
N *
N *  @return A ClockP_Handle on success or a NULL on an error.  This handle can
N *          be passed to ClockP_start()
N */
Nextern ClockP_Handle ClockP_create(ClockP_Fxn clockFxn,
N                                   uint32_t timeout,
N                                   ClockP_Params *params);
N
N/*!
N *  @brief  Function to delete a clock.
N *
N *  @param  handle  A ClockP_Handle returned from ::ClockP_create
N */
Nextern void ClockP_delete(ClockP_Handle handle);
N
N/*!
N *  @brief  Get CPU frequency in Hz
N *
N *  @param  freq  Pointer to the FreqHz structure
N */
Nextern void ClockP_getCpuFreq(ClockP_FreqHz *freq);
N
N/*!
N *  @brief  Get the system tick period in microseconds.
N *
N *  @return The kernel's system tick period in microseconds.
N */
Nextern uint32_t ClockP_getSystemTickPeriod();
N
N/*!
N *  @brief  Get the current tick value
N *
N *  The value returned will wrap back to zero after it reaches the max
N *  value that can be stored in 32 bits.
N *
N *  @return Time in system clock ticks
N */
Nextern uint32_t ClockP_getSystemTicks();
N
N/*!
N *  @brief  Get number of ClockP tick periods expected to expire between
N *          now and the next interrupt from the timer peripheral
N *
N *  Returns the number of ClockP tick periods that are expected to expore
N *  between now and the next interrupt from the timer peripheral.
N *
N *  Used internally by PowerCC26XX module
N *
N *  @return count in ticks
N */
Nextern uint32_t ClockP_getTicksUntilInterrupt();
N
N/*!
N *  @brief  Get timeout of clock instance.
N *
N *  Returns the remaining time in clock ticks if the instance has
N *  been started.  If the clock is not active, the initial timeout value
N *  is returned.
N *
N *  @return  remaining timeout in clock ticks.
N *
N *  Cannot change the initial timeout if the clock has been started.
N */
Nextern uint32_t ClockP_getTimeout(ClockP_Handle handle);
N
N/*!
N *  @brief  Determine if a clock object is currently active (i.e., running)
N *
N *  Returns true if the clock object is currently active, otherwise
N *  returns false.
N *
N *  @return  active state
N */
Nextern bool ClockP_isActive(ClockP_Handle handle);
Xextern _Bool ClockP_isActive(ClockP_Handle handle);
N
N/*!
N *  @brief  Initialize params structure to default values.
N *
N *  The default parameters are:
N *   - name: NULL
N *   - arg: 0
N *
N *  @param params  Pointer to the instance configuration parameters.
N */
Nextern void ClockP_Params_init(ClockP_Params *params);
N
N/*!
N *  @brief  Set the initial timeout
N *
N *  @param timeout    Initial timeout in ClockP ticks
N *
N *  Cannot change the initial timeout if the clock has been started.
N */
Nextern void ClockP_setTimeout(ClockP_Handle handle, uint32_t timeout);
N
N/*!
N *  @brief  Function to start a clock.
N *
N *  @param  handle  A ClockP_Handle returned from ::ClockP_create
N */
Nextern void ClockP_start(ClockP_Handle handle);
N
N/*!
N *  @brief  Function to stop a clock.
N *
N *  @param  handle  A ClockP_Handle returned from ::ClockP_create
N *
N *  It is ok to call ClockP_stop() for a clock that has not been started.
N *
N *  @return Status of the functions
N *    - ClockP_OK: Stopped the clock function successfully
N *    - ClockP_FAILURE: The API failed.
N */
Nextern void ClockP_stop(ClockP_Handle handle);
N
Nextern void ClockP_timestamp(ClockP_Handle handle);
N
N/*!
N *  @brief  Set delay in microseconds
N *
N *  @param  usec  A duration in micro seconds
N *
N *  @return ClockP_OK
N */
Nextern void ClockP_usleep(uint32_t usec);
N
N/*!
N *  @brief  Set delay in seconds
N *
N *  @param  sec  A duration in seconds
N *
N *  @return ClockP_OK
N */
Nextern void ClockP_sleep(uint32_t sec);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* ti_dpl_ClockP__include */
L 52 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/porting/cc_pal.h" 2
N
N
N#define MAX_QUEUE_SIZE					(4)
N#define OS_WAIT_FOREVER   				(0xFFFFFFFF)
N#define OS_NO_WAIT        				(0)
N#define OS_OK 	 						(0)
N
N#define Semaphore_OK                    (0)
N#define Semaphore_FAILURE               (-1)
N
N#define Mutex_OK                        (0)
N#define Mutex_FAILURE                   (-1)
N
N
N/*!
N	\brief type definition for the SPI channel file descriptor
N
N	\note	On each porting or platform the type could be whatever is needed - integer, pointer to structure etc.
N*/
Ntypedef int Fd_t;
N
N
N/*!
N	\brief 	type definition for the host interrupt handler
N
N	\param 	pValue	-	pointer to any memory strcuture. The value of this pointer is given on
N						registration of a new interrupt handler
N
N	\note
N*/
N
Ntypedef void (*SL_P_EVENT_HANDLER)(void);
N
N#define P_EVENT_HANDLER SL_P_EVENT_HANDLER
N
N/*!
N	\brief 	type definition for the host spawn function
N
N	\param 	pValue	-	pointer to any memory strcuture. The value of this pointer is given on
N						invoking the spawn function.
N
N	\note
N*/
N
Ntypedef signed short (*P_OS_SPAWN_ENTRY)(void* pValue);
N
Ntypedef struct
N{
N	P_OS_SPAWN_ENTRY pEntry;
N    void* pValue;
N}tSimpleLinkSpawnMsg;
N
N/*!
N    \brief open spi communication port to be used for communicating with a SimpleLink device
N
N	Given an interface name and option flags, this function opens the spi communication port
N	and creates a file descriptor. This file descriptor can be used afterwards to read and
N	write data from and to this specific spi channel.
N	The SPI speed, clock polarity, clock phase, chip select and all other attributes are all
N	set to hardcoded values in this function.
N
N	\param	 		ifName		-	points to the interface name/path. The interface name is an
N									optional attributes that the SimpleLink driver receives
N									on opening the device. in systems that the spi channel is
N									not implemented as part of the os device drivers, this
N									parameter could be NULL.
N	\param			flags		-	option flags
N
N	\return			upon successful completion, the function shall open the spi channel and return
N					a non-negative integer representing the file descriptor.
N					Otherwise, -1 shall be returned
N
N    \sa             spi_Close , spi_Read , spi_Write
N	\note
N    \warning
N*/
NFd_t spi_Open(char *ifName, unsigned long flags);
N
N/*!
N    \brief closes an opened SPI communication port
N
N	\param	 		fd			-	file descriptor of an opened SPI channel
N
N	\return			upon successful completion, the function shall return 0.
N					Otherwise, -1 shall be returned
N
N    \sa             spi_Open
N	\note
N    \warning
N*/
Nint spi_Close(Fd_t fd);
N
N/*!
N    \brief attempts to read up to len bytes from SPI channel into a buffer starting at pBuff.
N
N	\param	 		fd			-	file descriptor of an opened SPI channel
N
N	\param			pBuff		- 	points to first location to start writing the data
N
N	\param			len			-	number of bytes to read from the SPI channel
N
N	\return			upon successful completion, the function shall return 0.
N					Otherwise, -1 shall be returned
N
N    \sa             spi_Open , spi_Write
N	\note
N    \warning
N*/
Nint spi_Read(Fd_t fd, unsigned char *pBuff, int len);
N
N/*!
N    \brief attempts to write up to len bytes to the SPI channel
N
N	\param	 		fd			-	file descriptor of an opened SPI channel
N
N	\param			pBuff		- 	points to first location to start getting the data from
N
N	\param			len			-	number of bytes to write to the SPI channel
N
N	\return			upon successful completion, the function shall return 0.
N					Otherwise, -1 shall be returned
N
N    \sa             spi_Open , spi_Read
N	\note			This function could be implemented as zero copy and return only upon successful completion
N					of writing the whole buffer, but in cases that memory allocation is not too tight, the
N					function could copy the data to internal buffer, return back and complete the write in
N					parallel to other activities as long as the other SPI activities would be blocked untill
N					the entire buffer write would be completed
N    \warning
N*/
Nint spi_Write(Fd_t fd, unsigned char *pBuff, int len);
N
N/*!
N    \brief register an interrupt handler for the host IRQ
N
N	\param	 		InterruptHdl	-	pointer to interrupt handler function
N
N	\param 			pValue			-	pointer to a memory strcuture that is passed to the interrupt handler.
N
N	\return			upon successful registration, the function shall return 0.
N					Otherwise, -1 shall be returned
N
N    \sa
N	\note			If there is already registered interrupt handler, the function should overwrite the old handler
N					with the new one
N    \warning
N*/
Nint NwpRegisterInterruptHandler(P_EVENT_HANDLER InterruptHdl , void* pValue);
Xint NwpRegisterInterruptHandler(SL_P_EVENT_HANDLER InterruptHdl , void* pValue);
N
N
N/*!
N    \brief 				Masks host IRQ
N
N
N    \sa             	NwpUnMaskInterrupt
N
N    \warning
N*/
Nvoid NwpMaskInterrupt();
N
N
N/*!
N    \brief 				Unmasks host IRQ
N
N
N    \sa             	NwpMaskInterrupt
N
N    \warning
N*/
Nvoid NwpUnMaskInterrupt();
N
N
N/*!
N    \brief Preamble to the enabling the Network Processor.
N           Placeholder to implement any pre-process operations
N           before enabling networking operations.
N
N    \sa			sl_DeviceEnable
N
N    \note       belongs to \ref ported_sec
N
N*/
N
Nvoid NwpPowerOnPreamble(void);
N
N
N
N/*!
N    \brief		Disable the Network Processor
N
N    \sa			sl_DeviceEnable
N
N    \note       belongs to \ref ported_sec
N*/
Nvoid NwpPowerOff(void);
N
N
N/*!
N    \brief		Enable the Network Processor
N
N    \sa			sl_DeviceDisable
N
N    \note       belongs to \ref ported_sec
N
N*/
Nvoid NwpPowerOn(void);
N
N
N/*!
N    \brief Creates a semaphore handle, using the driver porting layer of the core SDK. 
N
N	\param	 		pSemHandle      -	pointer to a memory structure that would contain the handle.
N
N	\return			upon successful creation, the function shall return 0.
N					Otherwise, -1 shall be returned
N
N	\note           belongs to \ref ported_sec		
N*/
Nint Semaphore_create_handle(SemaphoreP_Handle* pSemHandle);
N
N
N/*!
N    \brief Deletes a semaphore handle, using the driver porting layer of the core SDK.
N
N    \param          pSemHandle      -   pointer to a memory structure that would contain the handle.
N
N    \return         The function shall return 0.
N
N    \note           belongs to \ref ported_sec
N*/
Nint SemaphoreP_delete_handle(SemaphoreP_Handle* pSemHandle);
N
N
N/*!
N    \brief Post (signal) a semaphore handle, using the driver porting layer of the core SDK.
N
N    \param          pSemHandle      -   pointer to a memory structure that would contain the handle.
N
N    \return         The function shall return 0.
N
N    \note           belongs to \ref ported_sec
N*/
Nint SemaphoreP_post_handle(SemaphoreP_Handle* pSemHandle);
N
N
N/*!
N    \brief Creates a mutex object handle, using the driver porting layer of the core SDK. 
N
N	\param	 		pMutexHandle    -	pointer to a memory structure that would contain the handle.
N
N	\return			upon successful creation, the function shall return 0.
N					Otherwise, -1 shall be returned
N
N	\note           belongs to \ref ported_sec	
N*/
Nint Mutex_create_handle(MutexP_Handle* pMutexHandle);
N
N
N/*!
N    \brief Deletes a mutex object handle, using the driver porting layer of the core SDK.
N
N    \param          pMutexHandle    -   pointer to a memory structure that would contain the handle.
N
N    \return         the function shall return 0.
N
N    \note           belongs to \ref ported_sec
N*/
Nint  MutexP_delete_handle(MutexP_Handle* pMutexHandle);
N
N/*!
N    \brief Unlocks a mutex object.
N
N	\param	 		pMutexHandle    -	pointer to a memory structure that contains the object.
N
N	\return			upon successful unlocking, the function shall return 0.
N
N	\note           belongs to \ref ported_sec	
N*/
Nint Mutex_unlock(MutexP_Handle pMutexHandle);
N
N
N/*!
N    \brief Locks a mutex object.
N
N	\param	 		pMutexHandle    -	pointer to a memory structure that contains the object.
N
N	\return			upon successful locking, the function shall return 0.
N
N	\note           belongs to \ref ported_sec	
N	
N	\warning        The lock will block until the mutex is available.
N*/
Nint Mutex_lock(MutexP_Handle pMutexHandle);
N
N
N/*!
N    \brief Take a time stamp value.
N
N	\return			32-bit value of the systick counter.
N
N	\sa
N	
N	\warning
N*/
Nunsigned long TimerGetCurrentTimestamp();
N
N/*!
N    \brief
N
N	\return
N
N	\sa
N
N	\warning
N*/
Nvoid NwpWaitForShutDownInd();
N
N
N#ifdef  __cplusplus
S}
N#endif // __cplusplus
N
N#endif
N
L 51 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/porting/user.h" 2
N
Ntypedef signed int _SlFd_t;
N
N#define SL_TIMESTAMP_TICKS_IN_10_MILLISECONDS     (_u32)(10)
N#define SL_TIMESTAMP_MAX_VALUE                    (_u32)(0xFFFFFFFF)
N
N/*!
N	\def		MAX_CONCURRENT_ACTIONS
N
N    \brief      Defines the maximum number of concurrent action in the system
N				Min:1 , Max: 32
N
N                Actions which has async events as return, can be
N
N    \sa
N
N    \note       In case there are not enough resources for the actions needed in the system,
N	        	error is received: POOL_IS_EMPTY
N			    one option is to increase MAX_CONCURRENT_ACTIONS
N				(improves performance but results in memory consumption)
N		     	Other option is to call the API later (decrease performance)
N
N    \warning    In case of setting to one, recommend to use non-blocking recv\recvfrom to allow
N				multiple socket recv
N*/
N#ifndef SL_TINY_EXT
N#define MAX_CONCURRENT_ACTIONS 10
N#else
S#define MAX_CONCURRENT_ACTIONS 1
N#endif
N
N/*!
N	\def		CPU_FREQ_IN_MHZ
N    \brief      Defines CPU frequency for Host side, for better accuracy of busy loops, if any
N    \sa             
N    \note       
N
N    \warning    If not set the default CPU frequency is set to 200MHz
N                This option will be deprecated in future release
N*/
N
N/* #define CPU_FREQ_IN_MHZ        80 */
N
N
N/*!
N ******************************************************************************
N
N    \defgroup       configuration_capabilities        Configuration - Capabilities Set
N
N    This section IS NOT REQUIRED in case one of the following pre defined
N    capabilities set is in use:
N    - SL_TINY
N    - SL_SMALL
N    - SL_FULL
N
N    PORTING ACTION:
N        - Define one of the pre-defined capabilities set or uncomment the
N          relevant definitions below to select the required capabilities
N
N    @{
N
N *******************************************************************************
N*/
N/*!
N    \def        SL_RUNTIME_EVENT_REGISTERATION
N
N    \brief      Defines whether the SimpleLink driver uses dynamic event registration
N                or static precompiled event mechanism
N    \sa
N
N    \note       belongs to \ref configuration_sec
N
N*/
N#define SL_RUNTIME_EVENT_REGISTERATION
N
N
N/*!
N	\def		SL_INC_ARG_CHECK
N
N    \brief      Defines whether the SimpleLink driver perform argument check 
N                or not
N                    
N                When defined, the SimpleLink driver perform argument check on 
N                function call. Removing this define could reduce some code 
N                size and improve slightly the performances but may impact in 
N                unpredictable behavior in case of invalid arguments
N
N    \sa             
N
N    \note       belongs to \ref configuration_sec
N
N    \warning    Removing argument check may cause unpredictable behavior in 
N                case of invalid arguments. 
N                In this case the user is responsible to argument validity 
N                (for example all handlers must not be NULL)
N*/
N#define SL_INC_ARG_CHECK
N
N
N/*!
N    \def		SL_INC_INTERNAL_ERRNO
N
N    \brief      Defines whether SimpleLink driver should employ it's internal errno
N                setter and getter to comply with BSD.
N                (Usually, this kind of mechanism should be handled by the OS).
N
N                When defined, the SimpleLink driver would set and manage the errno variable
N                per thread, to the various returned errors by the standard BSD API.
N                The BSD API includes the following functions:
N                socket, close, accept, bind, listen, connect, select,
N                setsockopt, getsockopt, recv, recvfrom, send, sendto,
N                gethostbyname. Furthermore, the user's application can read errno's value.
N                When not defined, user must provide an errno setter, such that the SimpleLink driver
N                would use the users's external errno meachnism to set an error code.
N
N    \sa         slcb_SetErrno
N
N    \note       belongs to \ref configuration_sec
N
N    \warning    Query errno in the user's application is by simply invoking the macro 'errno'
N                which returns a dereferenced pointer to the allocated calling thread's errno value.
N                If the user choose to change, write to or modifiy the value of errno in any way,
N                It might overwrite the errno value allocated to any other thread at the point in time.
N                (Once errno has been read, the driver assumes it can be allocated to another thread).
N*/
N
N#define SL_INC_INTERNAL_ERRNO
N
N/*!
N    \brief      Defines whether to include extended API in SimpleLink driver
N                or not
N    
N                When defined, the SimpleLink driver will include also all 
N                exteded API of the included packages
N
N    \sa         ext_api
N
N    \note       belongs to \ref configuration_sec
N
N    \warning    
N*/
N#define SL_INC_EXT_API
N
N
N/*!
N    \brief      Defines whether to include WLAN package in SimpleLink driver 
N                or not
N    
N                When defined, the SimpleLink driver will include also 
N                the WLAN package
N
N    \sa         
N
N    \note       belongs to \ref configuration_sec
N
N    \warning        
N*/
N#define SL_INC_WLAN_PKG
N
N
N/*!
N    \brief      Defines whether to include SOCKET package in SimpleLink 
N                driver or not
N    
N                When defined, the SimpleLink driver will include also 
N                the SOCKET package
N
N    \sa         
N
N    \note       belongs to \ref configuration_sec
N
N    \warning        
N*/
N#define SL_INC_SOCKET_PKG
N
N
N/*!
N    \brief      Defines whether to include NET_APP package in SimpleLink 
N                driver or not
N    
N                When defined, the SimpleLink driver will include also the 
N                NET_APP package
N
N    \sa         
N
N    \note       belongs to \ref configuration_sec
N
N    \warning        
N*/
N#define SL_INC_NET_APP_PKG
N
N
N/*!
N    \brief      Defines whether to include NET_CFG package in SimpleLink 
N                driver or not
N    
N                When defined, the SimpleLink driver will include also 
N                the NET_CFG package
N
N    \sa         
N
N    \note       belongs to \ref configuration_sec
N
N    \warning        
N*/
N#define SL_INC_NET_CFG_PKG
N
N
N/*!
N    \brief      Defines whether to include NVMEM package in SimpleLink 
N                driver or not
N    
N                When defined, the SimpleLink driver will include also the 
N                NVMEM package
N
N    \sa         
N
N    \note       belongs to \ref configuration_sec
N
N    \warning        
N*/ 
N#define SL_INC_NVMEM_PKG
N
N
N/*!
N    \brief      Defines whether to include NVMEM extended package in SimpleLink
N                driver or not
N
N                When defined, the SimpleLink driver will include also the
N                NVMEM extended package
N
N    \sa
N
N    \note       belongs to \ref nvmem_ext
N
N    \warning
N*/
N#define SL_INC_NVMEM_EXT_PKG
N
N
N/*!
N    \brief      Defines whether to include socket server side APIs 
N                in SimpleLink driver or not
N    
N                When defined, the SimpleLink driver will include also socket 
N                server side APIs
N
N    \sa         server_side
N
N    \note       
N
N    \warning        
N*/
N#define SL_INC_SOCK_SERVER_SIDE_API
N
N
N/*!
N    \brief      Defines whether to include socket client side APIs in SimpleLink 
N                driver or not
N    
N                When defined, the SimpleLink driver will include also socket 
N                client side APIs
N
N    \sa         client_side
N
N    \note       belongs to \ref configuration_sec
N
N    \warning        
N*/
N#define SL_INC_SOCK_CLIENT_SIDE_API
N
N
N/*!
N    \brief      Defines whether to include socket receive APIs in SimpleLink 
N                driver or not
N    
N                When defined, the SimpleLink driver will include also socket 
N                receive side APIs
N
N    \sa         recv_api
N
N    \note       belongs to \ref configuration_sec
N
N    \warning        
N*/
N#define SL_INC_SOCK_RECV_API
N
N
N/*!
N    \brief      Defines whether to include socket send APIs in SimpleLink 
N                driver or not
N    
N                When defined, the SimpleLink driver will include also socket 
N                send side APIs
N
N    \sa         send_api
N
N    \note       belongs to \ref configuration_sec
N
N    \warning        
N*/
N#define SL_INC_SOCK_SEND_API
N
N
N/*!
N
N Close the Doxygen group.
N @}
N
N */
N
N
N/*!
N ******************************************************************************
N
N    \defgroup   configuration_enable_device       Configuration - Device Enable/Disable
N
N    The enable/disable API provide mechanism to enable/disable the network processor
N
N   
N    porting ACTION:
N        - None
N    @{
N
N ******************************************************************************
N */
N
N/*!
N    \brief		Preamble to the enabling the Network Processor.
N                        Placeholder to implement any pre-process operations
N                        before enabling networking operations.
N
N    \sa			sl_DeviceEnable
N
N    \note       belongs to \ref configuration_sec
N
N*/
N#define sl_DeviceEnablePreamble()
N
N
N
N/*!
N    \brief		Enable the Network Processor
N
N    \sa			sl_DeviceDisable
N
N    \note       belongs to \ref configuration_sec
N
N*/
N#define sl_DeviceEnable()			NwpPowerOn()
N
N
N/*!
N    \brief		Disable the Network Processor
N
N    \sa			sl_DeviceEnable
N
N    \note       belongs to \ref configuration_sec
N*/
N#define sl_DeviceDisable() 			NwpPowerOff()
N
N
N/*!
N
N Close the Doxygen group.
N @}
N
N */
N
N/*!
N ******************************************************************************
N
N    \defgroup   configuration_interface         Configuration - Communication Interface
N
N	The SimpleLink device supports several standard communication protocol among SPI and
N	UART. CC32XX Host Driver implements SPI Communication Interface
N
N
N    \note       	In CC32XX, SPI implementation uses DMA in order to increase the utilization
N 			of the communication channel. If user prefers to user UART, these interfaces 
N 			need to be redefined
N
N
N    porting ACTION:	
N        - None
N
N    @{
N
N ******************************************************************************
N*/
N
N#define _SlFd_t					Fd_t
N
N
N/*!
N    \brief      Opens an interface communication port to be used for communicating
N                with a SimpleLink device
N	
N	            Given an interface name and option flags, this function opens 
N                the communication port and creates a file descriptor. 
N                This file descriptor is used afterwards to read and write 
N                data from and to this specific communication channel.
N	            The speed, clock polarity, clock phase, chip select and all other 
N                specific attributes of the channel are all should be set to hardcoded
N                in this function.
N	
N	\param	 	ifName  -   points to the interface name/path. The interface name is an 
N                            optional attributes that the SimpleLink driver receives
N                            on opening the driver (sl_Start). 
N                            In systems that the spi channel is not implemented as 
N                            part of the os device drivers, this parameter could be NULL.
N
N	\param      flags   -   optional flags parameters for future use
N
N	\return     upon successful completion, the function shall open the channel 
N                and return a non-negative integer representing the file descriptor.
N                Otherwise, -1 shall be returned 
N					
N    \sa         sl_IfClose , sl_IfRead , sl_IfWrite
N
N	\note       The prototype of the function is as follow:
N                    Fd_t xxx_IfOpen(char* pIfName , unsigned long flags);
N
N    \note       belongs to \ref configuration_sec
N
N    \warning
N*/
N#define sl_IfOpen                           spi_Open
N
N
N/*!
N    \brief      Closes an opened interface communication port
N	
N	\param	 	fd  -   file descriptor of opened communication channel
N
N	\return		upon successful completion, the function shall return 0. 
N			    Otherwise, -1 shall be returned 
N					
N    \sa         sl_IfOpen , sl_IfRead , sl_IfWrite
N
N	\note       The prototype of the function is as follow:
N                    int xxx_IfClose(Fd_t Fd);
N
N    \note       belongs to \ref configuration_sec
N
N    \warning
N*/
N#define sl_IfClose                          spi_Close
N
N
N/*!
N    \brief      Attempts to read up to len bytes from an opened communication channel 
N                into a buffer starting at pBuff.
N	
N	\param	 	fd      -   file descriptor of an opened communication channel
N	
N	\param		pBuff   -   pointer to the first location of a buffer that contains enough 
N                            space for all expected data
N
N	\param      len     -   number of bytes to read from the communication channel
N
N	\return     upon successful completion, the function shall return the number of read bytes. 
N                Otherwise, 0 shall be returned 
N					
N    \sa         sl_IfClose , sl_IfOpen , sl_IfWrite
N
N
N	\note       The prototype of the function is as follow:
N                    int xxx_IfRead(Fd_t Fd , char* pBuff , int Len);
N
N    \note       belongs to \ref configuration_sec
N
N    \warning
N*/
N#define sl_IfRead                           spi_Read
N
N
N/*!
N    \brief attempts to write up to len bytes to the SPI channel
N	
N	\param	 	fd      -   file descriptor of an opened communication channel
N	
N	\param		pBuff   -   pointer to the first location of a buffer that contains 
N                            the data to send over the communication channel
N
N	\param      len     -   number of bytes to write to the communication channel
N
N	\return     upon successful completion, the function shall return the number of sent bytes. 
N				therwise, 0 shall be returned 
N					
N    \sa         sl_IfClose , sl_IfOpen , sl_IfRead
N
N	\note       This function could be implemented as zero copy and return only upon successful completion
N                of writing the whole buffer, but in cases that memory allocation is not too tight, the 
N                function could copy the data to internal buffer, return back and complete the write in 
N                parallel to other activities as long as the other SPI activities would be blocked until 
N                the entire buffer write would be completed 
N
N               The prototype of the function is as follow:
N                    int xxx_IfWrite(Fd_t Fd , char* pBuff , int Len);
N
N    \note       belongs to \ref configuration_sec
N
N    \warning
N*/
N#define sl_IfWrite                          spi_Write
N
N
N/*!
N    \brief 		register an interrupt handler routine for the host IRQ
N
N	\param	 	InterruptHdl	-	pointer to interrupt handler routine
N
N	\param 		pValue			-	pointer to a memory structure that is passed
N									to the interrupt handler.
N
N	\return		upon successful registration, the function shall return 0.
N				Otherwise, -1 shall be returned
N
N    \sa
N
N	\note		If there is already registered interrupt handler, the function
N				should overwrite the old handler with the new one
N
N	\note       If the handler is a null pointer, the function should un-register the
N	            interrupt handler, and the interrupts can be disabled.
N
N    \note       belongs to \ref configuration_sec
N
N    \warning
N*/
N#define sl_IfRegIntHdlr(InterruptHdl , pValue)          NwpRegisterInterruptHandler(InterruptHdl , pValue)   
N
N
N/*!
N    \brief 		Masks the Host IRQ
N
N    \sa		sl_IfUnMaskIntHdlr
N
N
N
N    \note       belongs to \ref configuration_sec
N
N    \warning
N*/
N#define sl_IfMaskIntHdlr()								NwpMaskInterrupt()
N
N
N/*!
N    \brief 		Unmasks the Host IRQ
N
N    \sa		sl_IfMaskIntHdlr
N
N
N
N    \note       belongs to \ref configuration_sec
N
N    \warning
N*/
N#define sl_IfUnMaskIntHdlr()							NwpUnMaskInterrupt()
N
N
N/*!
N    \brief 		Write Handers for statistics debug on write 
N
N	\param	 	interface handler	-	pointer to interrupt handler routine
N
N
N	\return		no return value
N
N    \sa
N
N	\note		An optional hooks for monitoring before and after write info
N
N    \note       belongs to \ref configuration_sec
N
N    \warning        
N*/
N/* #define SL_START_WRITE_STAT */
N
N#ifdef SL_START_WRITE_STAT
S#define sl_IfStartWriteSequence
S#define sl_IfEndWriteSequence
N#endif
N
N
N/*!
N    \brief 		Get the timer counter value (timestamp).
N				The timer must count from zero to its MAX value.
N
N	\param	 	None.
N
N
N	\return		Returns 32-bit timer counter value (ticks unit) 
N
N    \sa
N
N	\note		 
N
N    \note       belongs to \ref porting_sec
N
N    \warning        
N*/
N#ifndef SL_TINY_EXT
N#undef slcb_GetTimestamp
N/* A timer must be started before using this function */ 
N#define slcb_GetTimestamp           TimerGetCurrentTimestamp
N#endif
N
N
N/*!
N    \brief 		This macro wait for the NWP to raise a ready for shutdown indication.
N
N	\param	 	None.
N
N	\note       This function is unique for the CC32XX family
N
N    \warning
N*/
N
N#define WAIT_NWP_SHUTDOWN_READY          NwpWaitForShutDownInd()
N
N/*!
N    \brief      User's errno setter function. User must provide an errno setter
N                in order to let the SimpleLink Wi-Fi driver to support BSD API
N                alongside the user's errno mechanism.
N
N    \param      None.
N
N    \sa         SL_INC_INTERNAL_ERRNO
N
N    \note
N
N    \note       belongs to \ref porting_sec
N
N    \warning
N*/
N#ifndef SL_INC_INTERNAL_ERRNO
S#define slcb_SetErrno
N#endif
N
N/*!
N Close the Doxygen group.
N @}
N
N*/
N
N/*!
N ******************************************************************************
N
N    \defgroup   configuration_os          Configuration - Operating System
N
N	The SimpleLink driver could run on two kind of platforms:
N	   -# Non-Os / Single Threaded (default)
N	   -# Multi-Threaded
N	
N	CC32XX SimpleLink Host Driver is ported on both Non-Os and Multi Threaded OS enviroment. 
N	The Host driver is made OS independent by implementing an OS Abstraction layer. 
N	Reference implementation for OS Abstraction is available for FreeRTOS and TI-RTOS. 
N	
N	
N	If you choose to work in multi-threaded environment under different operating system you 
N	will have to provide some basic adaptation routines to allow the driver to protect access to 
N	resources for different threads (locking object) and to allow synchronization between threads 
N	(sync objects). In additional the driver support running without dedicated thread allocated solely
N	to the SimpleLink driver. If you choose to work in this mode, you should also supply a spawn
N	method that will enable to run function on a temporary context.
N
N	\note - This Macro is defined in the IDE to generate Driver for both OS and Non-OS 
N	
N	 porting ACTION: 
N		 - None
N	 
N	 @{
N
N ******************************************************************************
N*/
N
N/*
N#define SL_PLATFORM_MULTI_THREADED
N*/
N
N#ifdef SL_PLATFORM_MULTI_THREADED
N
N/*!
N    \brief
N    \sa
N    \note           belongs to \ref configuration_sec
N    \warning
N*/
N#define SL_OS_RET_CODE_OK                       ((int)OS_OK)
N
N/*!
N    \brief
N    \sa
N    \note           belongs to \ref configuration_sec
N    \warning
N*/
N#define SL_OS_WAIT_FOREVER                      ((uint32_t)OS_WAIT_FOREVER)
N
N/*!
N    \brief
N    \sa
N    \note           belongs to \ref configuration_sec
N    \warning
N*/
N#define SL_OS_NO_WAIT	                        ((uint32_t)OS_NO_WAIT)
N
N/*!
N	\brief type definition for a time value
N
N	\note	On each configuration or platform the type could be whatever is needed - integer, pointer to structure etc.
N
N    \note       belongs to \ref configuration_sec
N*/
N#define _SlTime_t				uint32_t
N
N
N#endif //SL_PLATFORM_MULTI_THREADED
N
N/*!
N	\brief 	type definition for a sync object container
N
N	Sync object is object used to synchronize between two threads or thread and interrupt handler.
N	One thread is waiting on the object and the other thread send a signal, which then
N	release the waiting thread.
N	The signal must be able to be sent from interrupt context.
N	This object is generally implemented by binary semaphore or events.
N
N	\note	On each configuration or platform the type could be whatever is needed - integer, structure etc.
N
N    \note       belongs to \ref configuration_sec
N*/
N#define _SlSyncObj_t			    SemaphoreP_Handle
N
N    
N/*!
N	\brief 	This function creates a sync object
N
N	The sync object is used for synchronization between diffrent thread or ISR and
N	a thread.
N
N	\param	pSyncObj	-	pointer to the sync object control block
N
N	\return upon successful creation the function should return 0
N			Otherwise, a negative value indicating the error code shall be returned
N
N    \note       belongs to \ref configuration_sec
N    \warning
N*/
N#define sl_SyncObjCreate(pSyncObj,pName)            Semaphore_create_handle(pSyncObj)
N
N
N/*!
N	\brief 	This function deletes a sync object
N
N	\param	pSyncObj	-	pointer to the sync object control block
N
N	\return upon successful deletion the function should return 0
N			Otherwise, a negative value indicating the error code shall be returned
N    \note       belongs to \ref configuration_sec
N    \warning
N*/
N#define sl_SyncObjDelete(pSyncObj)                  SemaphoreP_delete_handle(pSyncObj)
N
N
N/*!
N	\brief 		This function generates a sync signal for the object.
N
N	All suspended threads waiting on this sync object are resumed
N
N	\param		pSyncObj	-	pointer to the sync object control block
N
N	\return 	upon successful signaling the function should return 0
N				Otherwise, a negative value indicating the error code shall be returned
N	\note		the function could be called from ISR context
N    \warning
N*/
N#define sl_SyncObjSignal(pSyncObj)                SemaphoreP_post_handle(pSyncObj)
N
N
N/*!
N	\brief 		This function generates a sync signal for the object from Interrupt
N
N	This is for RTOS that should signal from IRQ using a dedicated API
N
N	\param		pSyncObj	-	pointer to the sync object control block
N
N	\return 	upon successful signaling the function should return 0
N				Otherwise, a negative value indicating the error code shall be returned
N	\note		the function could be called from ISR context
N	\warning
N*/
N#define sl_SyncObjSignalFromIRQ(pSyncObj)           SemaphoreP_post_handle(pSyncObj)
N
N
N/*!
N	\brief 	This function waits for a sync signal of the specific sync object
N
N	\param	pSyncObj	-	pointer to the sync object control block
N	\param	Timeout		-	numeric value specifies the maximum number of mSec to
N							stay suspended while waiting for the sync signal
N							Currently, the SimpleLink driver uses only two values:
N								- OSI_WAIT_FOREVER
N								- OSI_NO_WAIT
N
N	\return upon successful reception of the signal within the timeout window return 0
N			Otherwise, a negative value indicating the error code shall be returned
N    \note       belongs to \ref configuration_sec
N    \warning
N*/
N#define sl_SyncObjWait(pSyncObj,Timeout)            SemaphoreP_pend((*(pSyncObj)),Timeout)
N
N
N/*!
N	\brief 	type definition for a locking object container
N
N	Locking object are used to protect a resource from mutual accesses of two or more threads.
N	The locking object should suppurt reentrant locks by a signal thread.
N	This object is generally implemented by mutex semaphore
N
N	\note	On each configuration or platform the type could be whatever is needed - integer, structure etc.
N    \note       belongs to \ref configuration_sec
N*/
N#define _SlLockObj_t 			             MutexP_Handle
N
N/*!
N	\brief 	This function creates a locking object.
N
N	The locking object is used for protecting a shared resources between different
N	threads.
N
N	\param	pLockObj	-	pointer to the locking object control block
N
N	\return upon successful creation the function should return 0
N			Otherwise, a negative value indicating the error code shall be returned
N    \note       belongs to \ref configuration_sec
N    \warning
N*/
N#define sl_LockObjCreate(pLockObj, pName)     Mutex_create_handle(pLockObj)
N
N
N/*!
N	\brief 	This function deletes a locking object.
N
N	\param	pLockObj	-	pointer to the locking object control block
N
N	\return upon successful deletion the function should return 0
N			Otherwise, a negative value indicating the error code shall be returned
N    \note       belongs to \ref configuration_sec
N    \warning
N*/
N#define sl_LockObjDelete(pLockObj)                  MutexP_delete_handle(pLockObj)
N
N
N/*!
N	\brief 	This function locks a locking object.
N
N	All other threads that call this function before this thread calls
N	the osi_LockObjUnlock would be suspended
N
N	\param	pLockObj	-	pointer to the locking object control block
N	\param	Timeout		-	numeric value specifies the maximum number of mSec to
N							stay suspended while waiting for the locking object
N							Currently, the SimpleLink driver uses only two values:
N								- OSI_WAIT_FOREVER
N								- OSI_NO_WAIT
N
N
N	\return upon successful reception of the locking object the function should return 0
N			Otherwise, a negative value indicating the error code shall be returned
N    \note       belongs to \ref configuration_sec
N    \warning
N*/
N#define sl_LockObjLock(pLockObj,Timeout)          Mutex_lock(*(pLockObj))
N
N
N/*!
N	\brief 	This function unlock a locking object.
N
N	\param	pLockObj	-	pointer to the locking object control block
N
N	\return upon successful unlocking the function should return 0
N			Otherwise, a negative value indicating the error code shall be returned
N    \note       belongs to \ref configuration_sec
N    \warning
N*/
N#define sl_LockObjUnlock(pLockObj)                   Mutex_unlock(*(pLockObj))
N
N
N/*!
N	\brief 	This function call the pEntry callback from a different context
N
N	\param	pEntry		-	pointer to the entry callback function
N
N	\param	pValue		- 	pointer to any type of memory structure that would be
N							passed to pEntry callback from the execution thread.
N
N	\param	flags		- 	execution flags - reserved for future usage
N
N	\return upon successful registration of the spawn the function should return 0
N			(the function is not blocked till the end of the execution of the function
N			and could be returned before the execution is actually completed)
N			Otherwise, a negative value indicating the error code shall be returned
N    \note       belongs to \ref configuration_sec
N    
N    \warning                User must implement it's own 'os_Spawn' function.
N*/
N//#define SL_PLATFORM_EXTERNAL_SPAWN
N
N#ifdef SL_PLATFORM_EXTERNAL_SPAWN
S#define sl_Spawn(pEntry,pValue,flags)       os_Spawn(pEntry,pValue,flags)        
N#endif
N
N/*!
N *
N Close the Doxygen group.
N @}
N
N */
N/*!
N ******************************************************************************
N
N    \defgroup   configuration_mem_mgm             Configuration - Memory Management
N
N    This section declare in which memory management model the SimpleLink driver
N    will run:
N        -# Static
N        -# Dynamic
N
N    This section IS NOT REQUIRED in case Static model is selected.
N
N    The default memory model is Static
N
N
N    @{
N
N *****************************************************************************
N*/
N
N/*!
N    \brief      Defines whether the SimpleLink driver is working in dynamic
N                memory model or not
N
N                When defined, the SimpleLink driver use dynamic allocations
N                if dynamic allocation is selected malloc and free functions
N                must be retrieved
N
N    \sa
N
N    \note       belongs to \ref configuration_sec
N
N    \warning
N*/
N/*
N#define SL_MEMORY_MGMT_DYNAMIC 	1
N#define SL_MEMORY_MGMT_STATIC  0
N
N#define SL_MEMORY_MGMT  SL_MEMORY_MGMT_DYNAMIC
N*/
N#ifdef SL_MEMORY_MGMT_DYNAMIC
S
S#ifdef SL_PLATFORM_MULTI_THREADED
S
S/*!
S    \brief
S    \sa
S    \note           belongs to \ref configuration_sec
S    \warning
S*/
S#define sl_Malloc(Size)                                 mem_Malloc(Size)
S
S/*!
S    \brief
S    \sa
S    \note           belongs to \ref configuration_sec
S    \warning
S*/
S#define sl_Free(pMem)                                   mem_Free(pMem)
S
S#else
S#include <stdlib.h>
S/*!
S    \brief
S    \sa
S    \note           belongs to \ref configuration_sec
S    \warning        
S*/
S#define sl_Malloc(Size)                                 malloc(Size)
S
S/*!
S    \brief
S    \sa
S    \note           belongs to \ref configuration_sec
S    \warning        
S*/
S#define sl_Free(pMem)                                   free(pMem)
S#endif
S                        
N#endif
N
N/*!
N
N Close the Doxygen group.
N @}
N
N*/
N
N/*!
N ******************************************************************************
N
N    \defgroup       configuration_events      Configuration - Event Handlers
N
N    This section includes the asynchronous event handlers routines
N
N    porting ACTION:
N        -define your routine as the value of this handler
N
N    @{
N
N ******************************************************************************
N */
N
N
N
N/*!
N    \brief      Fatal Error async event for inspecting fatal error events.
N				This event handles events/errors reported from the device/host driver
N	
N	\param[out]	pSlFatalErrorEvent
N	
N	\par
N             Parameters:
N			 
N			 - <b> slFatalErrorEvent->Id = SL_DEVICE_EVENT_FATAL_DEVICE_ABORT </b>,
N			 
N			 - <b> slFatalErrorEvent->Id = SL_DEVICE_EVENT_FATAL_DRIVER_ABORT </b>,
N			 
N			 - <b> slFatalErrorEvent->Id = SL_DEVICE_EVENT_FATAL_NO_CMD_ACK </b>,
N			
N			 - <b> slFatalErrorEvent->Id = SL_DEVICE_EVENT_FATAL_SYNC_LOSS </b>,
N			
N			 - <b> slFatalErrorEvent->Id = SL_DEVICE_EVENT_FATAL_CMD_TIMEOUT </b>,
N			
N
N    \note       belongs to \ref configuration_sec
N
N    \warning
N*/
N
N#define slcb_DeviceFatalErrorEvtHdlr      SimpleLinkFatalErrorEventHandler
N
N/*!
N    \brief      General async event for inspecting general events.
N				This event handles events/errors reported from the device/host driver
N    \sa
N
N    \note       belongs to \ref configuration_sec
N
N    \warning
N*/
N
N#define slcb_DeviceGeneralEvtHdlr		  SimpleLinkGeneralEventHandler
N
N/*!
N    \brief WLAN Async event handler
N    
N    \param[out]      pSlWlanEvent   pointer to SlWlanEvent_t data 
N    
N    \par
N             Parameters:
N             
N             - <b>pSlWlanEvent->Event = SL_WLAN_CONNECT_EVENT </b>, STA or P2P client connection indication event
N                 - pSlWlanEvent->EventData.STAandP2PModeWlanConnected main fields:
N                      - ssid_name
N                      - ssid_len
N                      - bssid
N                      - go_peer_device_name
N                      - go_peer_device_name_len
N                       
N             - <b>pSlWlanEvent->Event = SL_WLAN_DISCONNECT_EVENT </b>, STA or P2P client disconnection event                          
N                 - pSlWlanEvent->EventData.STAandP2PModeDisconnected main fields:
N                      - ssid_name
N                      - ssid_len
N                      - reason_code
N
N             - <b>pSlWlanEvent->Event = SL_WLAN_STA_CONNECTED_EVENT </b>, AP/P2P(Go) connected STA/P2P(Client)                  
N                  - pSlWlanEvent->EventData.APModeStaConnected fields:
N                      - go_peer_device_name
N                      - mac
N                      - go_peer_device_name_len
N                      - wps_dev_password_id
N                      - own_ssid:  relevant for event sta-connected only
N                      - own_ssid_len:  relevant for event sta-connected only
N                      
N             - <b>pSlWlanEvent->Event = SL_WLAN_STA_DISCONNECTED_EVENT </b>, AP/P2P(Go) disconnected STA/P2P(Client)                        
N                  - pSlWlanEvent->EventData.APModestaDisconnected fields:
N                      - go_peer_device_name
N                      - mac
N                      - go_peer_device_name_len
N                      - wps_dev_password_id
N                      - own_ssid:  relevant for event sta-connected only
N                      - own_ssid_len:  relevant for event sta-connected only
N
N             - <b>pSlWlanEvent->Event = SL_WLAN_SMART_CONFIG_COMPLETE_EVENT </b>                             
N                  - pSlWlanEvent->EventData.smartConfigStartResponse fields:
N                     - status
N                     - ssid_len
N                     - ssid
N                     - private_token_len
N                     - private_token
N                     
N             - <b>pSlWlanEvent->Event = SL_WLAN_SMART_CONFIG_STOP_EVENT </b>                 
N                     - pSlWlanEvent->EventData.smartConfigStopResponse fields:       
N                         - status
N                         
N             - <b>pSlWlanEvent->Event = SL_WLAN_P2P_DEV_FOUND_EVENT </b>         
N                     - pSlWlanEvent->EventData.P2PModeDevFound fields:
N                         - go_peer_device_name
N                         - mac
N                         - go_peer_device_name_len
N                         - wps_dev_password_id
N                         - own_ssid:  relevant for event sta-connected only
N                         - own_ssid_len:  relevant for event sta-connected only
N                         
N             - <b>pSlWlanEvent->Event = SL_WLAN_P2P_NEG_REQ_RECEIVED_EVENT </b>                             
N                      - pSlWlanEvent->EventData.P2PModeNegReqReceived fields
N                          - go_peer_device_name
N                          - mac
N                          - go_peer_device_name_len
N                          - wps_dev_password_id
N                          - own_ssid:  relevant for event sta-connected only
N                           
N             - <b>pSlWlanEvent->Event = SL_WLAN_CONNECTION_FAILED_EVENT </b>, P2P only
N                       - pSlWlanEvent->EventData.P2PModewlanConnectionFailure fields:
N                           - status   
N
N    \sa
N
N    \note           belongs to \ref configuration_sec
N
N    \warning
N*/
N
N#define slcb_WlanEvtHdlr                     SimpleLinkWlanEventHandler         
N
N
N/*!
N    \brief NETAPP Async event handler
N    
N    \param[out]      pSlNetApp   pointer to SlNetAppEvent_t data    
N    
N    \par
N             Parameters:
N              - <b>pSlWlanEvent->Event = SL_NETAPP_IPV4_IPACQUIRED_EVENT</b>, IPV4 acquired event
N                  - pSlWlanEvent->EventData.ipAcquiredV4 fields:
N                       - ip
N                       - gateway
N                       - dns
N                           
N              - <b>pSlWlanEvent->Event = SL_NETAPP_IP_LEASED_EVENT</b>, AP or P2P go dhcp lease event
N                  - pSlWlanEvent->EventData.ipLeased  fields:
N                       - ip_address
N                       - lease_time
N                       - mac
N
N              - <b>pSlWlanEvent->Event = SL_NETAPP_IP_RELEASED_EVENT</b>, AP or P2P go dhcp ip release event
N                   - pSlWlanEvent->EventData.ipReleased fields
N                       - ip_address
N                       - mac
N                       - reason
N
N
N    \sa
N
N    \note           belongs to \ref configuration_sec
N
N    \warning
N*/
N
N#define slcb_NetAppEvtHdlr              		SimpleLinkNetAppEventHandler              
N
N/*!
N    \brief HTTP server async event
N
N    \param[out] pSlHttpServerEvent   pointer to SlHttpServerEvent_t
N    \param[in] pSlHttpServerResponse pointer to SlHttpServerResponse_t
N
N    \par
N          Parameters: \n
N
N          - <b>pSlHttpServerEvent->Event = SL_NETAPP_HTTPGETTOKENVALUE_EVENT</b>
N             - pSlHttpServerEvent->EventData fields:
N                 - httpTokenName
N                     - data
N                     - len
N             - pSlHttpServerResponse->ResponseData fields:
N                     - data
N                     - len
N             
N          - <b>pSlHttpServerEvent->Event = SL_NETAPP_HTTPPOSTTOKENVALUE_EVENT</b>
N              - pSlHttpServerEvent->EventData.httpPostData fields:
N                     - action
N                     - token_name
N                     - token_value                     
N              - pSlHttpServerResponse->ResponseData fields:
N                     - data
N                     - len  
N
N
N    \sa
N
N    \note           belongs to \ref configuration_sec
N
N    \warning
N*/
N
N#define slcb_NetAppHttpServerHdlr   SimpleLinkHttpServerEventHandler
N
N
N
N/*!
N    \brief          A handler for handling Netapp requests.
N                    Netapp request types:
N                    For HTTP server: GET / POST (future: PUT / DELETE)
N
N	\param
N
N	\param
N
N    \sa
N
N    \note           belongs to \ref porting_sec
N
N    \warning
N*/
N
N#define slcb_NetAppRequestHdlr  SimpleLinkNetAppRequestEventHandler
N
N
N
N/*!
N    \brief          A handler for freeing the memory of the NetApp response.
N
N	\param
N
N	\param
N
N    \sa
N
N    \note           belongs to \ref porting_sec
N
N    \warning
N*/
N
N#define slcb_NetAppRequestMemFree  SimpleLinkNetAppRequestMemFreeEventHandler
N
N
N
N/*!
N    \brief Socket Async event handler
N    
N    \param[out]      pSlSockEvent   pointer to SlSockEvent_t data 
N    
N    \par
N             Parameters:\n
N             - <b>pSlSockEvent->Event = SL_SOCKET_TX_FAILED_EVENT</b>
N                 - pSlSockEvent->EventData fields:
N                     - sd
N                     - status
N             - <b>pSlSockEvent->Event = SL_SOCKET_ASYNC_EVENT</b>
N                - pSlSockEvent->EventData fields:
N                     - sd
N                     - type: SSL_ACCEPT  or RX_FRAGMENTATION_TOO_BIG or OTHER_SIDE_CLOSE_SSL_DATA_NOT_ENCRYPTED 
N                     - val
N
N    \sa
N
N    \note           belongs to \ref configuration_sec
N
N    \warning
N*/
N
N#define slcb_SockEvtHdlr         SimpleLinkSockEventHandler
N
N
N/*!
N    \brief Trigger Async event handler. If define, sl_Select operates only in trigger mode.
N                           To disable trigger mode, handler should not be defined.
N
N    \param[out]      pSlTriggerEvent   pointer to SlSockTriggerEvent_t data
N
N    \par
N             Parameters:\n
N             - <b>pSlTriggerEvent->Event = SL_SOCKET_TRIGGER_EVENT_SELECT</b>
N             - pSlTriggerEvent->EventData: Not in use
N
N
N    \sa
N
N    \note           belongs to \ref configuration_sec
N
N    \warning
N*/
N#ifndef SL_PLATFORM_MULTI_THREADED
S#define slcb_SocketTriggerEventHandler SimpleLinkSocketTriggerEventHandler
N#endif
N/*!
N
N Close the Doxygen group.
N @}
N
N */
N
N
N#ifdef  __cplusplus
S}
N#endif // __cplusplus
N
N#endif // __USER_H__
L 259 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N
N#ifdef    __cplusplus
Sextern "C"
S{
N#endif
N
N/*!
N    \defgroup UserEvents
N    \short Function prototypes for event callback handlers
N
N*/
N
N/*! \attention  Async event activation notes\n
N    Function prototypes for event callback handlers\n
N    Event handler function names should be defined in the user.h file\n
N    e.g.\n
N    "#define slcb_WlanEvtHdlr   SLWlanEventHandler"\n
N    Indicates all WLAN events are handled by User func "SLWlanEventHandler"\n
N    Important notes:\n
N    1. Event handlers cannot activate another SimpleLink API from the event's context
N    2. Event's data is valid during event's context. Any application data
N       which is required for the user application should be copied or marked
N       into user's variables
N    3. It is not recommended to delay the execution of the event callback handler
N
N*/
N
N/*!
N
N    \addtogroup UserEvents
N    @{
N
N*/
N
N
N/*****************************************************************************/
N/* Macro declarations for Host Driver version                                */
N/*****************************************************************************/
N#define SL_DRIVER_VERSION       "2.0.1.26"
N#define SL_MAJOR_VERSION_NUM    2L
N#define SL_MINOR_VERSION_NUM    0L
N#define SL_VERSION_NUM          1L
N#define SL_SUB_VERSION_NUM      26L
N
N/*****************************************************************************/
N/* Macro declarations for predefined configurations                          */
N/*****************************************************************************/
N
N#ifdef SL_TINY
S#undef SL_INC_ARG_CHECK
S#undef SL_INC_EXT_API
S#undef SL_INC_SOCK_SERVER_SIDE_API
S#undef SL_INC_WLAN_PKG
S#undef SL_INC_NET_CFG_PKG
S#undef SL_INC_FS_PKG
S#undef SL_INC_SET_UART_MODE
S#undef SL_INC_NVMEM_PKG
S#define SL_INC_SOCK_CLIENT_SIDE_API
S#define SL_INC_SOCK_RECV_API
S#define SL_INC_SOCK_SEND_API
S#define SL_INC_SOCKET_PKG
S#define SL_INC_NET_APP_PKG
N#endif
N
N#ifdef SL_SMALL
S#undef SL_INC_EXT_API
S#undef SL_INC_NET_APP_PKG
S#undef SL_INC_NET_CFG_PKG
S#undef SL_INC_FS_PKG
S#define SL_INC_ARG_CHECK
S#define SL_INC_WLAN_PKG
S#define SL_INC_SOCKET_PKG
S#define SL_INC_SOCK_CLIENT_SIDE_API
S#define SL_INC_SOCK_SERVER_SIDE_API
S#define SL_INC_SOCK_RECV_API
S#define SL_INC_SOCK_SEND_API
S#define SL_INC_SET_UART_MODE
N#endif
N
N#ifdef SL_FULL
S#define SL_INC_EXT_API
S#define SL_INC_NET_APP_PKG
S#define SL_INC_NET_CFG_PKG
S#define SL_INC_FS_PKG
S#define SL_INC_ARG_CHECK
S#define SL_INC_WLAN_PKG
S#define SL_INC_SOCKET_PKG
S#define SL_INC_SOCK_CLIENT_SIDE_API
S#define SL_INC_SOCK_SERVER_SIDE_API
S#define SL_INC_SOCK_RECV_API
S#define SL_INC_SOCK_SEND_API
S#define SL_INC_SET_UART_MODE
N#endif
N
N/* #define sl_Memcpy       memcpy */
N#define sl_Memset(addr, val, len)      memset(addr, val, (size_t)len)
N#define sl_Memcpy(dest, src, len)      memcpy(dest, src, (size_t)len)
N#define sl_Memmove(dest, src, len)     memmove(dest, src, (size_t)len)
N
N#ifndef SL_TINY
N#define SL_MAX_SOCKETS      (_u8)(16)
N#else
S#define SL_MAX_SOCKETS      (_u8)(2)
N#endif
N
N/*****************************************************************************/
N/* Types definitions                                                         */
N/*****************************************************************************/
N
N#ifndef NULL
S#define NULL        (0)
N#endif
N
N#ifndef FALSE
N#define FALSE       (0)
N#endif
N
N#ifndef TRUE
N#define TRUE        (!FALSE)
N#endif
N
Ntypedef _u16  _SlOpcode_t;
Xtypedef unsigned short  _SlOpcode_t;
Ntypedef _u8   _SlArgSize_t;
Xtypedef unsigned char   _SlArgSize_t;
Ntypedef _i16   _SlDataSize_t;
Xtypedef signed short   _SlDataSize_t;
Ntypedef _i16   _SlReturnVal_t;
Xtypedef signed short   _SlReturnVal_t;
N
N/*
N * This event status used to  block or continue the event propagation
N * through all the registered external libs/user application
N *
N */
N
N typedef enum {
N    EVENT_PROPAGATION_BLOCK = 0,
N    EVENT_PROPAGATION_CONTINUE
N } _SlEventPropogationStatus_e;
N
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N
N
N/*
N   objInclusion.h and user.h must be included before all api header files
N   objInclusion.h must be the last arrangement just before including the API header files
N   since it based on the other configurations to decide which object should be included
N*/
N#include "source/objInclusion.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/source/objInclusion.h" 1
N/*
N * objInclusion.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N
N#include <ti/drivers/net/wifi/simplelink.h>
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 1
N/*
N * simplelink.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/
N *
N *
N *  Redistribution and use in source and binary forms, with or without
N *  modification, are permitted provided that the following conditions
N *  are met:
N *
N *  Redistributions of source code must retain the above copyright
N *  notice, this list of conditions and the following disclaimer.
N *
N *  Redistributions in binary form must reproduce the above copyright
N *  notice, this list of conditions and the following disclaimer in the
N *  documentation and/or other materials provided with the
N *  distribution.
N *
N *  Neither the name of Texas Instruments Incorporated nor the names of
N *  its contributors may be used to endorse or promote products derived
N *  from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N
N/*!
N    \mainpage SimpleLink Driver
N
N    \section intro_sec Introduction
N
N The SimpleLink(tm) CC31xx/CC32xx family allows to add Wi-Fi and networking capabilities
N to low-cost embedded products without having prior Wi-Fi, RF or networking expertise.\n
N The CC31xx/CC32xx is an ideal solution for microcontroller-based sensor and control
N applications such as home appliances, home automation and smart metering.\n
N The CC31xx/CC32xx has integrated a comprehensive TCP/IP network stack, Wi-Fi driver and
N security supplicant leading to easier portability to microcontrollers, to an
N ultra-low memory footprint, all without compromising the capabilities and robustness
N of the final application.
N
N
N
N \section modules_sec Module Names
N To make it simple, TI's SimpleLink CC31xx/CC32xx platform capabilities were divided into modules by topic (Silo).\n
N These capabilities range from basic device management through wireless
N network configuration, standard BSD socket and much more.\n
N Listed below are the various modules in the SimpleLink CC31xx/CC32xx driver:
N     -# \ref Device     - Controls the behaviour of the CC31xx/CC32xx device (start/stop, events masking and obtaining specific device status)
N     -# \ref FileSystem - Provides file system capabilities to TI's CC31XX that can be used by both the CC31XX device and the user.
N     -# \ref NetApp     - Activates networking applications, such as: HTTP Server, DHCP Server, Ping, DNS and mDNS.
N     -# \ref NetCfg     - Controls the configuration of the device addresses (i.e. IP and MAC addresses)
N     -# \ref NetUtil    - Networking related commands and configuration
N     -# \ref Socket     - Controls standard client/server sockets programming options and capabilities
N     -# \ref Wlan       - Controls the use of the WiFi WLAN module including:
N                            - Connection features, such as: profiles, policies, SmartConfig(tm)
N                            - Advanced WLAN features, such as: scans, rx filters and rx statistics collection
N     -# \ref UserEvents - Function prototypes for event callback handlers
N
N    \section persistency_sec Persistency
N            The SimpleLink(tm) device support few different persistency types for settings and configurations:\n
N            - <b>Temporary</b>             -    Effective immediately but returned to default after reset\n
N            - <b>System Persistent</b>     -    Effective immediately and kept after reset according\n
N                                                to system persistent mode\n
N            - <b>Persistent</b>            -    Effective immediately and kept after reset regardless the system persistent mode\n
N            - <b>Optionally Persistent</b> -    Effective immediately and kept after reset according to a parameter in the API call\n
N            - <b>Reset</b>                 -    Persistent but effective only after reset\n
N            \n
N            For all Set/Get function in this guide, the type of persistency per relevant parameters will be
N            described as part of the function description\n
N
N    \section    proting_sec     Porting Guide
N
N The porting of the SimpleLink host driver to any new platform is based on few simple steps.\n
N This guide takes you through this process step by step. Please follow the instructions
N carefully to avoid any problems during this process and to enable efficient and proper
N work with the device.\n
N Please notice that all modifications and porting adjustments of the driver should be
N made in the user.h header file only. Keeping this method ensure smoothly
Ntransaction to new versions of the driver in the future!\n
N
NThe porting process consists of few simple steps:
N-# Create user.h for the target platform
N-# Select the capabilities set
N-# Bind the device enable/disable line
N-# Writing your interface communication driver
N-# Choose your memory management model
N-# OS adaptation
N-# Set your asynchronous event handlers
N-# Testing
N
NFor host interface details please refer to:
Nhttp://processors.wiki.ti.com/index.php/CC31xx_Host_Interface
N
NPlease see the rest of the page for more details about the different steps.
N
N \subsection     porting_step1   Step 1 - Create your own user.h file
N
N The first step is to create a <b><i>user.h</i></b> file that will include your configurations and
N adjustments. \n
N The file should be located in the porting directory (the porting directory is in the same level as the source directory)\n
N It is recommended to use the empty template provided as part of this driver or
N file of other platform such as MSP432 or CC3220, from one of the wide range
N of example applications provided by Texas Instruments.
N
N \subsection    porting_step2   Step 2 - Select the capabilities set required for your application
N
N Texas Instruments built 3 different predefined sets of capabilities that would fit most of
N the target applications.\n
N It is recommended to try and choose one of this predefined capabilities set before going to
N build your own customized set. If you find compatible set you can skip the rest of this step.
N
N The available sets are:
N     -# SL_TINY     -   Compatible to be used on platforms with very limited resources. Provides
N                        the best in class low foot print in terms of Code and Data consumption.
N     -# SL_SMALL    -   Compatible to most common networking applications. Provide the most
N                        common APIs with decent balance between code size, data size, functionality
N                        and performances
N     -# SL_FULL     -   Provide access to all SimpleLink functionalities
N
N \subsection    porting_step3   Step 3 - Bind the device enable/disable output line
N
N The CC3120 has two external hardware lines that can be used to enable/disable the device.
N - <b>nReset</b>
N - <b>nHib</b> - provides mechanism to enter the device into the least current consumption mode. In
N this mode the RTC value is kept.
N
N The driver manipulates the enable/disable line automatically during sl_Start / sl_Stop.\n
N Not connecting one these lines means that the driver could start only once (sl_Stop will not
N work correctly and might lead to failure latter on) and the internal provisioning mechanism
N could not be used.\n
N
N To bind these lines the following defines should be defined correctly:
N - <b>sl_DeviceEnable</b>
N - <b>sl_DeviceDisable</b>
N
N If some initializations required before the enable/disable macros are called the user can use also the following <i>optional</i> define
N - <b>sl_DeviceEnablePreamble</b>
N
N \subsection    porting_step4   Step 4 - Writing your interface communication driver
N
N The SimpleLink CC3120 has two standard communication interfaces
N    - SPI
N    - UART
N
N The device detects automatically the active interface during initialization. After the detection, the second interface could not be used.\n
N
N To wrap the driver for the communication channel the following functions should be implemented:
N -# sl_IfOpen
N -# sl_IfClose
N -# sl_IfRead
N -# sl_IfWrite
N -# sl_IfRegIntHdlr
N
N The way these functions are implemented has direct effect on the performances of the SimpleLink
N device on this target platform. DMA and Jitter Buffer should be considered.\n
N
N In some platforms the user need to mask the IRQ line when this interrupt could be masked. \n
N The driver can call the mask/unmask whenever is needed. To allow this functionality the
N user should implement also the following defines:
N    - sl_IfMaskIntHdlr
N    - sl_IfUnMaskIntHdlr
N
N By default the driver is writing the command in few transactions to allow zero-copy mechanism. \n
N To enable a Jitter buffer for improving the communication line utilization, the can implement
N also the following defines:
N    - sl_IfStartWriteSequence
N    - sl_IfEndWriteSequence
N
N \subsection     porting_step5   Step 5 - Choose your memory management model
N
N The SimpleLink driver support two memory models:
N     - Static (default)
N     - Dynamic
N
N To enable the dynamic memory, the following pre-processor define should be set: \n
N #define SL_MEMORY_MGMT_DYNAMIC
N
N And the following macros should be defined and supplied:
N    - sl_Malloc
N    - sl_Free
N
N    Using the dynamic mode will allocate the required resources on sl_Start and release these resource on sl_Stop.
N
N \subsection     porting_step6   Step 6 - OS adaptation
N
N The SimpleLink driver could run on two kind of platforms:
N     -# Non-Os / Single Threaded (default)
N     -# Multi-Threaded
N
N When building a multi-threaded application. the following pre-processor define must be set: \n
N #define SL_PLATFORM_MULTI_THREADED
N
N If you choose to work in multi-threaded environment under operating system you will have to
N provide some basic adaptation routines to allow the driver to protect access to resources
N for different threads (locking object) and to allow synchronization between threads (sync objects).
N In additional the driver support running without dedicated thread allocated solely to the
N SimpleLink driver. If you choose to work in this mode, you should also supply a spawn method that
N will enable to run function on a temporary context.
N
N
N \subsection     porting_step7   Step 7 - Set your asynchronous event handlers routines
N
N The SimpleLink device generate asynchronous events in several situations.
N These asynchronous events could be masked.
N In order to catch these events you have to provide handler routines.
N Please notice that if you not provide a handler routine and the event is received,
N the driver will drop this event without any indication of this drop.
N
N
N \subsection     porting_step8   Step 8 - Run diagnostic tools to validate the correctness of your porting
N
N The driver is delivered with some porting diagnostic tools to simplify the porting validation process
N and to reduce issues latter. It is very important to follow carefully this process.
N
N The diagnostic process include:
N     -# Validating interface communication driver
N     -# Validating basic work with the device
N
N
N    \section annex_step Annex Persistency
N            The SimpleLink(tm) device support few different persistency types for settings and configurations:\n
N            - <b>Temporary</b>             -    Effective immediately but returned to default after reset\n
N            - <b>System Persistent</b>     -    Effective immediately and kept after reset according\n
N                                           -    to system persistent mode\n
N            - <b>Persistent</b>            -    Effective immediately and kept after reset regardless the system persistent mode\n
N            - <b>Optionally Persistent</b> -    Effective immediately and kept after reset according to a parameter in the API call\n
N            - <b>Reset</b>                 -    Persistent but effective only after reset\n
N
N*/
N
N#ifndef __SIMPLELINK_H__
S#define __SIMPLELINK_H__
S
S/* define the default types
S * If user wants to overwrite it,
S * he need to undef and define again */
S#define _u8  unsigned char
S#define _i8  signed char
S#define _u16 unsigned short
S#define _i16 signed short
S#define _u32 unsigned long
S#define _i32 signed long
S
S#define _volatile volatile
S#define _const    const
S
S#include <ti/drivers/net/wifi/porting/user.h>
S
S#ifdef    __cplusplus
Sextern "C"
S{
S#endif
S
S/*!
S    \defgroup UserEvents
S    \short Function prototypes for event callback handlers
S
S*/
S
S/*! \attention  Async event activation notes\n
S    Function prototypes for event callback handlers\n
S    Event handler function names should be defined in the user.h file\n
S    e.g.\n
S    "#define slcb_WlanEvtHdlr   SLWlanEventHandler"\n
S    Indicates all WLAN events are handled by User func "SLWlanEventHandler"\n
S    Important notes:\n
S    1. Event handlers cannot activate another SimpleLink API from the event's context
S    2. Event's data is valid during event's context. Any application data
S       which is required for the user application should be copied or marked
S       into user's variables
S    3. It is not recommended to delay the execution of the event callback handler
S
S*/
S
S/*!
S
S    \addtogroup UserEvents
S    @{
S
S*/
S
S
S/*****************************************************************************/
S/* Macro declarations for Host Driver version                                */
S/*****************************************************************************/
S#define SL_DRIVER_VERSION       "2.0.1.26"
S#define SL_MAJOR_VERSION_NUM    2L
S#define SL_MINOR_VERSION_NUM    0L
S#define SL_VERSION_NUM          1L
S#define SL_SUB_VERSION_NUM      26L
S
S/*****************************************************************************/
S/* Macro declarations for predefined configurations                          */
S/*****************************************************************************/
S
S#ifdef SL_TINY
S#undef SL_INC_ARG_CHECK
S#undef SL_INC_EXT_API
S#undef SL_INC_SOCK_SERVER_SIDE_API
S#undef SL_INC_WLAN_PKG
S#undef SL_INC_NET_CFG_PKG
S#undef SL_INC_FS_PKG
S#undef SL_INC_SET_UART_MODE
S#undef SL_INC_NVMEM_PKG
S#define SL_INC_SOCK_CLIENT_SIDE_API
S#define SL_INC_SOCK_RECV_API
S#define SL_INC_SOCK_SEND_API
S#define SL_INC_SOCKET_PKG
S#define SL_INC_NET_APP_PKG
S#endif
S
S#ifdef SL_SMALL
S#undef SL_INC_EXT_API
S#undef SL_INC_NET_APP_PKG
S#undef SL_INC_NET_CFG_PKG
S#undef SL_INC_FS_PKG
S#define SL_INC_ARG_CHECK
S#define SL_INC_WLAN_PKG
S#define SL_INC_SOCKET_PKG
S#define SL_INC_SOCK_CLIENT_SIDE_API
S#define SL_INC_SOCK_SERVER_SIDE_API
S#define SL_INC_SOCK_RECV_API
S#define SL_INC_SOCK_SEND_API
S#define SL_INC_SET_UART_MODE
S#endif
S
S#ifdef SL_FULL
S#define SL_INC_EXT_API
S#define SL_INC_NET_APP_PKG
S#define SL_INC_NET_CFG_PKG
S#define SL_INC_FS_PKG
S#define SL_INC_ARG_CHECK
S#define SL_INC_WLAN_PKG
S#define SL_INC_SOCKET_PKG
S#define SL_INC_SOCK_CLIENT_SIDE_API
S#define SL_INC_SOCK_SERVER_SIDE_API
S#define SL_INC_SOCK_RECV_API
S#define SL_INC_SOCK_SEND_API
S#define SL_INC_SET_UART_MODE
S#endif
S
S/* #define sl_Memcpy       memcpy */
S#define sl_Memset(addr, val, len)      memset(addr, val, (size_t)len)
S#define sl_Memcpy(dest, src, len)      memcpy(dest, src, (size_t)len)
S#define sl_Memmove(dest, src, len)     memmove(dest, src, (size_t)len)
S
S#ifndef SL_TINY
S#define SL_MAX_SOCKETS      (_u8)(16)
S#else
S#define SL_MAX_SOCKETS      (_u8)(2)
S#endif
S
S/*****************************************************************************/
S/* Types definitions                                                         */
S/*****************************************************************************/
S
S#ifndef NULL
S#define NULL        (0)
S#endif
S
S#ifndef FALSE
S#define FALSE       (0)
S#endif
S
S#ifndef TRUE
S#define TRUE        (!FALSE)
S#endif
S
Stypedef _u16  _SlOpcode_t;
Stypedef _u8   _SlArgSize_t;
Stypedef _i16   _SlDataSize_t;
Stypedef _i16   _SlReturnVal_t;
S
S/*
S * This event status used to  block or continue the event propagation
S * through all the registered external libs/user application
S *
S */
S
S typedef enum {
S    EVENT_PROPAGATION_BLOCK = 0,
S    EVENT_PROPAGATION_CONTINUE
S } _SlEventPropogationStatus_e;
S
S
S/*****************************************************************************/
S/* Include files                                                             */
S/*****************************************************************************/
S
S
S/*
S   objInclusion.h and user.h must be included before all api header files
S   objInclusion.h must be the last arrangement just before including the API header files
S   since it based on the other configurations to decide which object should be included
S*/
S#include "source/objInclusion.h"
S#include "trace.h"
S#include "fs.h"
S#include "sl_socket.h"
S#include "netapp.h"
S#include "wlan.h"
S#include "device.h"
S#include "netcfg.h"
S#include "netutil.h"
S#include "errors.h"
S#include "eventreg.h"
S
S/*!
S    \cond DOXYGEN_IGNORE
S*/
S /* In case of use dynamic event registration
S  * redirect the event to the internal mechanism */
S#if (defined(SL_RUNTIME_EVENT_REGISTERATION))
S
S#define _SlDrvHandleFatalErrorEvents            _SlDeviceFatalErrorEvtHdlr
S#define _SlDrvHandleGeneralEvents               _SlDeviceGeneralEvtHdlr
S#define _SlDrvHandleWlanEvents                  _SlWlanEvtHdlr
S#define _SlDrvHandleNetAppEvents                _SlNetAppEvtHdlr
S#define _SlDrvHandleSockEvents                  _SlSockEvtHdlr
S#define _SlDrvHandleHttpServerEvents            _SlNetAppHttpServerHdlr
S#define _SlDrvHandleNetAppRequestEvents         _SlNetAppRequestHdlr
S#define _SlDrvHandleNetAppRequestMemFreeEvents  _SlNetAppRequestMemFree
S#define _SlDrvHandleSocketTriggerEvents         _SlSocketTriggerEventHandler
S
S#else
S
S /* The fatal error events dispatcher which is
S  * initialized to the user handler */
S#ifdef slcb_DeviceFatalErrorEvtHdlr
S#define _SlDrvHandleFatalErrorEvents slcb_DeviceFatalErrorEvtHdlr
S#endif
S
S /* The general events dispatcher which is
S  * initialized to the user handler */
S#ifdef slcb_DeviceGeneralEvtHdlr
S#define _SlDrvHandleGeneralEvents slcb_DeviceGeneralEvtHdlr
S#endif
S
S /* The wlan events dispatcher which is
S  * initialized to the user handler */
S#ifdef slcb_WlanEvtHdlr
S#define _SlDrvHandleWlanEvents slcb_WlanEvtHdlr
S#endif
S
S /* The NetApp events dispatcher which is
S  * initialized to the user handler */
S#ifdef slcb_NetAppEvtHdlr
S#define _SlDrvHandleNetAppEvents slcb_NetAppEvtHdlr
S#endif
S
S /* The http server events dispatcher which is
S  * initialized to the user handler if exists */
S#ifdef slcb_NetAppHttpServerHdlr
S#define _SlDrvHandleHttpServerEvents slcb_NetAppHttpServerHdlr
S#endif
S
S /* The socket events dispatcher which is
S  * initialized to the user handler */
S#ifdef slcb_SockEvtHdlr
S#define _SlDrvHandleSockEvents slcb_SockEvtHdlr
S#endif
S
S
S/* The netapp requests dispatcher which is
S  * initialized to the user handler if exists */
S#ifdef slcb_NetAppRequestHdlr
S#define _SlDrvHandleNetAppRequestEvents slcb_NetAppRequestHdlr
S#endif
S
S/* The netapp request mem free requests dispatcher which is
S* initialized to the user handler if exists */
S#ifdef slcb_NetAppRequestMemFree
S#define _SlDrvHandleNetAppRequestMemFreeEvents slcb_NetAppRequestMemFree
S#endif
S
S/* The netapp requests dispatcher which is
S* initialized to the user handler if exists */
S#ifdef slcb_SocketTriggerEventHandler
S#define _SlDrvHandleSocketTriggerEvents slcb_SocketTriggerEventHandler
S#endif
S
S
S#endif
S
S#define SL_CONCAT(x,y)  x ## y
S#define SL_CONCAT2(x,y) SL_CONCAT(x,y)
S
S
S#if (!defined(SL_RUNTIME_EVENT_REGISTERATION))
S
S/*
S * The section below handles the external lib event registration
S * according to the desired events it specified in its API header file.
S * The external lib should be first installed by the user (see user.h)
S */
S#ifdef SL_EXT_LIB_1
S
S/* General Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_GENERAL_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _GeneralEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib1GeneralEventHandler   SL_CONCAT2(SL_EXT_LIB_1, _GeneralEventHdl)
S    
S    #undef EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #define EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #endif
S    
S    /* Wlan Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_WLAN_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _WlanEventHdl) (SlWlanEvent_t *);
S    #define SlExtLib1WlanEventHandler   SL_CONCAT2(SL_EXT_LIB_1, _WlanEventHdl)
S    
S    #undef EXT_LIB_REGISTERED_WLAN_EVENTS
S    #define EXT_LIB_REGISTERED_WLAN_EVENTS
S    #endif
S    
S    /* NetApp Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_NETAPP_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _NetAppEventHdl) (SlNetAppEvent_t *);
S    #define SlExtLib1NetAppEventHandler SL_CONCAT2(SL_EXT_LIB_1, _NetAppEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #endif
S
S    /* Http Server Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_HTTP_SERVER_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _HttpServerEventHdl) (SlNetAppHttpServerEvent_t* , SlNetAppHttpServerResponse_t*);
S    #define SlExtLib1HttpServerEventHandler SL_CONCAT2(SL_EXT_LIB_1, _HttpServerEventHdl)
S
S    #undef EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #define EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #endif
S
S    /* Socket Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_SOCK_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _SockEventHdl) (SlSockEvent_t *);
S    #define SlExtLib1SockEventHandler SL_CONCAT2(SL_EXT_LIB_1, _SockEventHdl)
S
S    #undef EXT_LIB_REGISTERED_SOCK_EVENTS
S    #define EXT_LIB_REGISTERED_SOCK_EVENTS
S    #endif
S
S    /* Fatal Error Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_FATAL_ERROR_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _FatalErrorEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib1FatalErrorEventHandler   SL_CONCAT2(SL_EXT_LIB_1, _FatalErrorEventHdl)
S    
S    #undef EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #define EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #endif
S
S    /* NetApp requests events registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_NETAPP_REQUEST_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _NetAppRequestEventHdl) (SlNetAppRequest_t*, SlNetAppResponse_t *);
S    #define SlExtLib1NetAppRequestEventHandler   SL_CONCAT2(SL_EXT_LIB_1, _NetAppRequestEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #endif
S
S#endif
S
S
S#ifdef SL_EXT_LIB_2
S
S    /* General Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_GENERAL_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _GeneralEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib2GeneralEventHandler   SL_CONCAT2(SL_EXT_LIB_2, _GeneralEventHdl)
S
S    #undef EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #define EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #endif
S
S    /* Wlan Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_WLAN_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _WlanEventHdl) (SlWlanEvent_t *);
S    #define SlExtLib2WlanEventHandler   SL_CONCAT2(SL_EXT_LIB_2, _WlanEventHdl)
S
S    #undef EXT_LIB_REGISTERED_WLAN_EVENTS
S    #define EXT_LIB_REGISTERED_WLAN_EVENTS
S    #endif
S
S    /* NetApp Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_NETAPP_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _NetAppEventHdl) (SlNetAppEvent_t *);
S    #define SlExtLib2NetAppEventHandler SL_CONCAT2(SL_EXT_LIB_2, _NetAppEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #endif
S
S    /* Http Server Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_HTTP_SERVER_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _HttpServerEventHdl) (SlNetAppHttpServerEvent_t* , SlNetAppHttpServerResponse_t*);
S    #define SlExtLib2HttpServerEventHandler SL_CONCAT2(SL_EXT_LIB_2, _HttpServerEventHdl)
S
S    #undef EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #define EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #endif
S
S    /* Socket Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_SOCK_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _SockEventHdl) (SlSockEvent_t *);
S    #define SlExtLib2SockEventHandler SL_CONCAT2(SL_EXT_LIB_2, _SockEventHdl)
S
S    #undef EXT_LIB_REGISTERED_SOCK_EVENTS
S    #define EXT_LIB_REGISTERED_SOCK_EVENTS
S    #endif
S
S    /* Fatal Error Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_FATAL_ERROR_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _FatalErrorEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib2FatalErrorEventHandler   SL_CONCAT2(SL_EXT_LIB_2, _FatalErrorEventHdl)
S
S    #undef EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #define EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #endif
S
S    /* NetApp requests events registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_NETAPP_REQUEST_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _NetAppRequestEventHdl) (SlNetAppRequest_t*, SlNetAppResponse_t *);
S    #define SlExtLib1NetAppRequestEventHandler   SL_CONCAT2(SL_EXT_LIB_2, _NetAppRequestEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #endif
S
S#endif
S
S#ifdef SL_EXT_LIB_3
S
S  /* General Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_GENERAL_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _GeneralEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib3GeneralEventHandler   SL_CONCAT2(SL_EXT_LIB_3, _GeneralEventHdl)
S
S    #undef EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #define EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #endif
S
S    /* Wlan Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_WLAN_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _WlanEventHdl) (SlWlanEvent_t *);
S    #define SlExtLib3WlanEventHandler   SL_CONCAT2(SL_EXT_LIB_3, _WlanEventHdl)
S
S    #undef EXT_LIB_REGISTERED_WLAN_EVENTS
S    #define EXT_LIB_REGISTERED_WLAN_EVENTS
S    #endif
S
S    /* NetApp Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_NETAPP_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _NetAppEventHdl) (SlNetAppEvent_t *);
S    #define SlExtLib3NetAppEventHandler SL_CONCAT2(SL_EXT_LIB_3, _NetAppEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #endif
S
S    /* Http Server Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_HTTP_SERVER_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _HttpServerEventHdl) (SlNetAppHttpServerEvent_t* , SlNetAppHttpServerResponse_t*);
S    #define SlExtLib3HttpServerEventHandler SL_CONCAT2(SL_EXT_LIB_3, _HttpServerEventHdl)
S
S    #undef EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #define EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #endif
S
S    /* Socket Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_SOCK_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _SockEventHdl) (SlSockEvent_t *);
S    #define SlExtLib3SockEventHandler SL_CONCAT2(SL_EXT_LIB_3, _SockEventHdl)
S
S    #undef EXT_LIB_REGISTERED_SOCK_EVENTS
S    #define EXT_LIB_REGISTERED_SOCK_EVENTS
S    #endif
S
S
S    /* Fatal Error Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_FATAL_ERROR_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _FatalErrorEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib3FatalErrorEventHandler   SL_CONCAT2(SL_EXT_LIB_3, _FatalErrorEventHdl)
S
S    #undef EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #define EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #endif
S
S    /* NetApp requests events registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_NETAPP_REQUEST_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _NetAppRequestEventHdl) (SlNetAppRequest_t*, SlNetAppResponse_t *);
S    #define SlExtLib1NetAppRequestEventHandler   SL_CONCAT2(SL_EXT_LIB_3, _NetAppRequestEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #endif
S
S#endif
S
S#ifdef SL_EXT_LIB_4
S
S    /* General Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_GENERAL_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _GeneralEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib4GeneralEventHandler   SL_CONCAT2(SL_EXT_LIB_4, _GeneralEventHdl)
S
S    #undef EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #define EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #endif
S
S    /* Wlan Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_WLAN_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _WlanEventHdl) (SlWlanEvent_t *);
S    #define SlExtLib4WlanEventHandler   SL_CONCAT2(SL_EXT_LIB_4, _WlanEventHdl)
S
S    #undef EXT_LIB_REGISTERED_WLAN_EVENTS
S    #define EXT_LIB_REGISTERED_WLAN_EVENTS
S    #endif
S
S    /* NetApp Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_NETAPP_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _NetAppEventHdl) (SlNetAppEvent_t *);
S    #define SlExtLib4NetAppEventHandler SL_CONCAT2(SL_EXT_LIB_4, _NetAppEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #endif
S
S    /* Http Server Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_HTTP_SERVER_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _HttpServerEventHdl) (SlNetAppHttpServerEvent_t* , SlNetAppHttpServerResponse_t*);
S    #define SlExtLib4HttpServerEventHandler SL_CONCAT2(SL_EXT_LIB_4, _HttpServerEventHdl)
S
S    #undef EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #define EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #endif
S
S    /* Socket Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_SOCK_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _SockEventHdl) (SlSockEvent_t *);
S    #define SlExtLib4SockEventHandler SL_CONCAT2(SL_EXT_LIB_4, _SockEventHdl)
S
S    #undef EXT_LIB_REGISTERED_SOCK_EVENTS
S    #define EXT_LIB_REGISTERED_SOCK_EVENTS
S    #endif
S
S    /* Fatal Error Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_FATAL_ERROR_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _FatalErrorEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib4FatalErrorEventHandler   SL_CONCAT2(SL_EXT_LIB_4, _FatalErrorEventHdl)
S
S    #undef EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #define EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #endif
S
S    /* NetApp requests events registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_NETAPP_REQUEST_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _NetAppRequestEventHdl) (SlNetAppRequest_t*, SlNetAppResponse_t *);
S    #define SlExtLib1NetAppRequestEventHandler   SL_CONCAT2(SL_EXT_LIB_4, _NetAppRequestEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #endif
S
S#endif
S
S#ifdef SL_EXT_LIB_5
S
S    /* General Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_GENERAL_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _GeneralEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib5GeneralEventHandler   SL_CONCAT2(SL_EXT_LIB_5, _GeneralEventHdl)
S
S    #undef EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #define EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #endif
S
S    /* Wlan Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_WLAN_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _WlanEventHdl) (SlWlanEvent_t *);
S    #define SlExtLib5WlanEventHandler   SL_CONCAT2(SL_EXT_LIB_5, _WlanEventHdl)
S
S    #undef EXT_LIB_REGISTERED_WLAN_EVENTS
S    #define EXT_LIB_REGISTERED_WLAN_EVENTS
S    #endif
S
S    /* NetApp Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_NETAPP_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _NetAppEventHdl) (SlNetAppEvent_t *);
S    #define SlExtLib5NetAppEventHandler SL_CONCAT2(SL_EXT_LIB_5, _NetAppEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #endif
S
S    /* Http Server Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_HTTP_SERVER_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _HttpServerEventHdl) (SlNetAppHttpServerEvent_t* , SlNetAppHttpServerResponse_t*);
S    #define SlExtLib5HttpServerEventHandler SL_CONCAT2(SL_EXT_LIB_5, _HttpServerEventHdl)
S
S    #undef EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #define EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #endif
S
S    /* Socket Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_SOCK_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _SockEventHdl) (SlSockEvent_t *);
S    #define SlExtLib5SockEventHandler SL_CONCAT2(SL_EXT_LIB_5, _SockEventHdl)
S
S    #undef EXT_LIB_REGISTERED_SOCK_EVENTS
S    #define EXT_LIB_REGISTERED_SOCK_EVENTS
S    #endif
S
S    /* Fatal Error Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_FATAL_ERROR_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _FatalErrorEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib5FatalErrorEventHandler   SL_CONCAT2(SL_EXT_LIB_5, _FatalErrorEventHdl)
S
S    #undef EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #define EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #endif
S
S    /* NetApp requests events registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_NETAPP_REQUEST_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _NetAppRequestEventHdl) (SlNetAppRequest_t*, SlNetAppResponse_t *);
S    #define SlExtLib1NetAppRequestEventHandler   SL_CONCAT2(SL_EXT_LIB_5, _NetAppRequestEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #endif
S
S#endif
S
S#if defined(EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS)
Sextern void _SlDrvHandleFatalErrorEvents(SlDeviceEvent_t *slFatalErrorEvent);
S#endif
S
S#if defined(EXT_LIB_REGISTERED_GENERAL_EVENTS)
Sextern void _SlDrvHandleGeneralEvents(SlDeviceEvent_t *slGeneralEvent);
S#endif
S
S#if defined(EXT_LIB_REGISTERED_WLAN_EVENTS)
Sextern void _SlDrvHandleWlanEvents(SlWlanEvent_t *slWlanEvent);
S#endif
S
S#if defined (EXT_LIB_REGISTERED_NETAPP_EVENTS)
Sextern void _SlDrvHandleNetAppEvents(SlNetAppEvent_t *slNetAppEvent);
S#endif
S
S#if defined(EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS)
Sextern void _SlDrvHandleHttpServerEvents(SlNetAppHttpServerEvent_t *slHttpServerEvent, SlNetAppHttpServerResponse_t *slHttpServerResponse);
S#endif
S
S#if defined(EXT_LIB_REGISTERED_SOCK_EVENTS)
Sextern void _SlDrvHandleSockEvents(SlSockEvent_t *slSockEvent);
S#endif
S
S#if defined(EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS)
Sextern void _SlDrvHandleNetAppRequestEvents(SlNetAppRequest_t *pNetAppRequest, SlNetAppResponse_t *pNetAppResponse);
S#endif
S
S#endif //#if (defined(SL_RUNTIME_EVENT_REGISTERATION))
S
Stypedef _SlReturnVal_t (*_SlSpawnEntryFunc_t)(void* pValue);
S
S#define SL_SPAWN_FLAG_FROM_SL_IRQ_HANDLER    (0X1)
S
S#ifdef SL_PLATFORM_MULTI_THREADED
S    #include "source/spawn.h"
S#else
S    #include "source/nonos.h"
S#endif
S
S/*!
S    \endcond
S*/
S
S
S/* Async functions description*/
S
S
S/*!
S    \brief Fatal Error event for inspecting fatal error
S
S    \param[out]      pSlFatalErrorEvent   pointer to SlDeviceFatal_t
S    \return None
S    \sa
S    \note
S    \warning
S    \par    Example
S    \code
S        For pSlDeviceFatal->Id = SL_DEVICE_EVENT_FATAL_DEVICE_ABORT
S                Indicates a severe error occured and the device stopped
S        Use pSlDeviceFatal->Data.DeviceAssert fields
S                    - Code: An idication of the abort type
S                    - Value: The abort data
S
S
S        For pSlDeviceFatal->Id = SL_DEVICE_EVENT_FATAL_NO_CMD_ACK
S                Indicates that the command sent to the device had no ack
S        Use pSlDeviceFatal->Data.NoCmdAck fields
S                    - Code: An idication of the cmd opcode
S
S        For pSlDeviceFatal->Id = SL_DEVICE_EVENT_FATAL_CMD_TIMEOUT
S                Indicates that the command got a timeout while waiting for its async response
S        Use pSlDeviceFatal->Data.CmdTimeout fields
S                    - Code: An idication of the asyncevent opcode
S
S
S        For pSlDeviceFatal->Id = SL_DEVICE_EVENT_FATAL_DRIVER_ABORT
S                Indicates a severe error occured in the driver
S        Use pSlDeviceFatal->Data.DeviceAssert fields
S                    - None.
S
S        For pSlDeviceFatal->Id = SL_DEVICE_EVENT_FATAL_SYNC_LOSS
S                Indicates a sync loss with the device
S        Use pSlDeviceFatal->Data.DeviceAssert fields
S                    - None.
S    \endcode
S    \code
S        Example for fatal error
S             printf(Abort type =%d Abort Data=0x%x\n\n",
S                   pSlDeviceFatal->Data.deviceReport.AbortType,
S                   pSlDeviceFatal->Data.deviceReport.AbortData);
S    \endcode
S*/
S#if (defined(slcb_DeviceFatalErrorEvtHdlr))
Sextern void slcb_DeviceFatalErrorEvtHdlr(SlDeviceFatal_t *pSlFatalErrorEvent);
S#endif
S
S
S/*!
S    \brief General async event for inspecting general events
S
S    \param[out]      pSlDeviceEvent   pointer to SlDeviceEvent_t
S    \return None
S    \sa
S    \note
S    \warning
S    \par    Example
S    \code
S          For pSlDeviceEvent->Id = SL_DEVICE_EVENT_RESET_REQUEST
S          Use pSlDeviceEvent->Data.ResetRequest fields
S                  - Status: An error code indication from the device
S                  - Source: The sender originator which is based on SlDeviceSource_e enum
S
S          For pSlDeviceEvent->Id = SL_DEVICE_EVENT_ERROR
S          Use pSlDeviceEvent->Data.Error fields
S                  - Code: An error code indication from the device
S                  - Source: The sender originator which is based on SlErrorSender_e enum
S    \endcode
S    \code
S        Example for error event:
S            printf(General Event Handler - ID=%d Sender=%d\n\n",
S                   pSlDeviceEvent->Data.Error.Code,  // the error code
S                   pSlDeviceEvent->Data.Error.Source); // the error source
S    \endcode
S
S*/
S#if (defined(slcb_DeviceGeneralEvtHdlr))
Sextern void slcb_DeviceGeneralEvtHdlr(SlDeviceEvent_t *pSlDeviceEvent);
S#endif
S
S/*!
S    \brief WLAN Async event handler
S
S    \param[out]      pSlWlanEvent   pointer to SlWlanEvent_t data
S    \return None
S    \sa
S    \note
S    \warning
S    \par             Example
S    \code
S         For pSlWlanEvent->Id = SL_WLAN_EVENT_CONNECT, STA connection indication event
S         Use pSlWlanEvent->Data.Connect main fields
S                 - SsidLen
S                 - SsidName
S                 - Bssid
S
S         For pSlWlanEvent->Id = SL_WLAN_EVENT_P2P_CONNECT, P2P client connection indication event
S         Use pSlWlanEvent->Data.P2PConnect main fields
S                 - SsidLen
S                 - SsidName
S                 - Bssid
S                 - GoDeviceNameLen
S                 - GoDeviceName
S
S         For pSlWlanEvent->Id = SL_WLAN_EVENT_DISCONNECT, STA client disconnection event
S         Use pSlWlanEvent->Data.Disconnect main fields:
S                 - SsidLen
S                 - SsidName
S                 - Bssid
S                 - ReasonCode
S
S         For pSlWlanEvent->Id = SL_WLAN_EVENT_P2P_DISCONNECT, P2P client disconnection event
S         Use pSlWlanEvent->Data.P2PDisconnect main fields:
S                 - SsidLen
S                 - SsidName
S                 - Bssid
S                 - ReasonCode
S                 - GoDeviceNameLen
S                 - GoDeviceName
S
S         For pSlWlanEvent->Id = SL_WLAN_EVENT_STA_ADDED, AP connected STA
S         Use pSlWlanEvent->Data.STAAdded fields:
S                 - Mac
S
S         For pSlWlanEvent->Id = SL_WLAN_EVENT_STA_REMOVED, AP disconnected STA
S         Use pSlWlanEvent->Data.STARemoved fields:
S                 - Mac
S
S         For pSlWlanEvent->Id = SL_WLAN_EVENT_P2P_CLIENT_ADDED, P2P(Go) connected P2P(Client)
S         Use pSlWlanEvent->Data.P2PClientAdded fields:
S                 - Mac
S                 - GoDeviceNameLen
S                 - GoDeviceName
S                 - OwnSsidLen
S                 - OwnSsid
S
S         For pSlWlanEvent->Id = SL_WLAN_EVENT_P2P_CLIENT_REMOVED, P2P(Go) disconnected P2P(Client)
S         Use pSlWlanEvent->Data.P2PClientRemoved fields:
S                 - Mac
S                 - GoDeviceNameLen
S                 - GoDeviceName
S                 - OwnSsidLen
S                 - OwnSsid
S
S         For pSlWlanEvent->Id = SL_WLAN_P2P_DEV_FOUND_EVENT
S         Use pSlWlanEvent->Data.P2PDevFound fields:
S                - GoDeviceNameLen
S                - GoDeviceName
S                - Mac
S                - WpsMethod
S
S         For pSlWlanEvent->Id = SL_WLAN_EVENT_P2P_REQUEST
S         Use pSlWlanEvent->Data.P2PRequest fields
S                - GoDeviceNameLen
S                - GoDeviceName
S                - Mac
S                - WpsMethod
S
S         For pSlWlanEvent->Id = SL_WLAN_EVENT_P2P_CONNECTFAIL, P2P only
S         Use pSlWlanEvent->Data.P2PConnectFail fields:
S                    - Status
S
S         For pSlWlanEvent->Id = SL_WLAN_EVENT_PROVISIONING_STATUS
S         Use pSlWlanEvent->Data.ProvisioningStatus fields
S                  - Status
S
S         For pSlWlanEvent->Id = SL_WLAN_EVENT_PROVISIONING_PROFILE_ADDED
S         Use pSlWlanEvent->Data.ProvisioningProfileAdded fields:
S                 - Status
S                 - SsidLen
S                 - Ssid
S                 - Reserved
S    \endcode
S*/
S#if (defined(slcb_WlanEvtHdlr))
Sextern void slcb_WlanEvtHdlr(SlWlanEvent_t* pSlWlanEvent);
S#endif
S
S
S/*!
S    \brief NETAPP Async event handler
S
S    \param[out]      pSlNetAppEvent   pointer to SlNetAppEvent_t data
S    \return None
S    \sa
S    \note
S    \warning
S    \par    Example
S    \code
S        For pSlNetAppEvent->Id = SL_NETAPP_EVENT_IPV4_ACQUIRED/SL_NETAPP_EVENT_IPV6_ACQUIRED
S        Use pSlNetAppEvent->Data.ipAcquiredV4 (V6) fields
S           - ip
S           - gateway
S           - dns
S
S        For pSlNetAppEvent->Id = SL_NETAPP_IP_LEASED_EVENT, AP or P2P go dhcp lease event
S        Use pSlNetAppEvent->Data.ipLeased  fields
S           - ip_address
S           - lease_time
S           - mac
S
S        For pSlNetApp->Id = SL_NETAPP_IP_RELEASED_EVENT, AP or P2P go dhcp ip release event
S        Use pSlNetAppEvent->Data.ipReleased fields
S            - ip_address
S            - mac
S            - reason
S    \endcode
S*/
S#if (defined(slcb_NetAppEvtHdlr))
Sextern void slcb_NetAppEvtHdlr(SlNetAppEvent_t* pSlNetAppEvent);
S#endif
S
S/*!
S    \brief Socket Async event handler
S
S    \param[out]      pSlSockEvent   pointer to SlSockEvent_t data
S    \return None
S    \sa
S    \note
S    \warning
S    \par             Example
S    \code
S             For pSlSockEvent->Event = SL_SOCKET_TX_FAILED_EVENT
S             Use pSlSockEvent->SockTxFailData fields
S                    - sd
S                    - status
S             For pSlSockEvent->Event = SL_SOCKET_ASYNC_EVENT
S             Use pSlSockEvent->SockAsyncData fields
S                    - sd
S                    - type
S                        - SL_SSL_ACCEPT
S                        - SL_WLAN_RX_FRAGMENTATION_TOO_BIG
S                        - SL_OTHER_SIDE_CLOSE_SSL_DATA_NOT_ENCRYPTED
S                    - val
S    \endcode
S
S*/
S#if (defined(slcb_SockEvtHdlr))
Sextern void slcb_SockEvtHdlr(SlSockEvent_t* pSlSockEvent);
S#endif
S
S/*!
S    \brief HTTP server async event
S
S    \param[out] pSlHttpServerEvent   Pointer to SlNetAppHttpServerEvent_t
S    \param[in]  pSlHttpServerResponse Pointer to SlNetAppHttpServerResponse_t
S
S    \return     None
S    \sa         slcb_NetAppRequestHdlr
S    \note
S    \warning
S    \par        Example
S    \code
S          For pSlHttpServerResponse->Event = SL_NETAPP_HTTPGETTOKENVALUE_EVENT
S          Use pSlHttpServerEvent->EventData fields
S                - httpTokenName
S                - data
S                - len
S          And pSlHttpServerResponse->ResponseData fields
S                - data
S                - len
S
S          For pSlHttpServerEvent->Event = SL_NETAPP_HTTPPOSTTOKENVALUE_EVENT
S          Use pSlHttpServerEvent->EventData.httpPostData fields
S                - action
S                - token_name
S                - token_value
S          And pSlHttpServerResponse->ResponseData fields:
S                - data
S                - len
S    \endcode
S*/
S#if (defined(slcb_NetAppHttpServerHdlr))
Sextern void slcb_NetAppHttpServerHdlr(SlNetAppHttpServerEvent_t *pSlHttpServerEvent, SlNetAppHttpServerResponse_t *pSlHttpServerResponse);
S#endif
S
S/*!
S    \brief General netapp async event
S
S    \param[out] pNetAppRequest   Pointer to SlNetAppRequest_t
S    \param[in]  pNetAppResponse Pointer to SlNetAppResponse_t
S
S    \return     None
S    \sa         slcb_NetAppHttpServerHdlr
S    \note
S    \warning
S    \par        Example
S    \code
S        TBD
S    \endcode
S*/
S#if (defined(slcb_NetAppRequestHdlr))
Sextern void slcb_NetAppRequestHdlr(SlNetAppRequest_t *pNetAppRequest, SlNetAppResponse_t *pNetAppResponse);
S#endif
S
S/*!
S    \brief A handler for freeing the memory of the NetApp response.
S
S    \param[in,out] buffer        Pointer to the buffer to free
S
S    \return        None
S    \sa
S    \note
S    \warning
S    \par           Example
S    \code
S        TBD
S    \endcode
S*/
S#if (defined(slcb_NetAppRequestMemFree))
Sextern void slcb_NetAppRequestMemFree (_u8 *buffer);
S#endif
S
S/*!
S    \brief      Get the timer counter value (timestamp).\n
S                The timer must count from zero to its MAX value.
S                For non-os application, this routine must be implemented.
S    \param      None
S    \return     Returns 32-bit timer counter value (ticks unit)
S    \sa
S    \note
S    \note       belongs to \ref porting_sec
S    \warning
S*/
S#if defined (slcb_GetTimestamp)
Sextern _u32 slcb_GetTimestamp(void);
S#endif
S
S
S/*!
S    \brief      Socket trigger routine.
S                This routine will notify the application that a netwrok activity has 
S                been completed on the required socket/s.
S    
S    \param[out] pSlSockTriggerEvent   pointer to SlSockTriggerEvent_t data
S    \return     None.
S    \sa
S    \note
S    \note       belongs to \ref porting_sec
S    \warning
S*/
S#if (defined(slcb_SocketTriggerEventHandler))
Sextern void slcb_SocketTriggerEventHandler(SlSockTriggerEvent_t* pSlSockTriggerEvent);
S#endif
S
S
S/*!
S Close the Doxygen group.
S @}
S
S */
S
S#ifdef  __cplusplus
S}
S#endif /* __cplusplus */
S
N#endif    /*  __SIMPLELINK_H__ */
N
L 39 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/source/objInclusion.h" 2
N
N
N#ifndef OBJINCLUSION_H_
N#define OBJINCLUSION_H_
N
N#ifdef    __cplusplus
Sextern "C" {
N#endif
N
N/******************************************************************************
N 
N For future use
N    
N*******************************************************************************/
N
N#define __inln            /* if inline functions requiered: #define __inln inline */
N
N#define SL_DEVICE         /* Device silo is currently always mandatory */
N
N
N/******************************************************************************
N
N Qualifiers for package customizations 
N    
N*******************************************************************************/
N
N#if defined (SL_DEVICE)
X#if 1L
N#define __dev   1
N#else
S#define __dev   0
N#endif
N
N#if defined (SL_DEVICE) && defined (SL_INC_EXT_API)
X#if 1L && 1L
N#define __dev__ext    1
N#else
S#define __dev__ext    0
N#endif
N
N
N#if (!defined (SL_PLATFORM_MULTI_THREADED)) || (!defined (SL_PLATFORM_EXTERNAL_SPAWN))
X#if (!1L) || (!0L)
N#define __int__spwn    1
N#else
S#define __int__spwn    0
N#endif
N
N#if defined (SL_INC_NET_APP_PKG)
X#if 1L
N#define __nap    1
N#else
S#define __nap    0
N#endif
N
N#if defined  (SL_INC_NET_APP_PKG) && defined (SL_INC_SOCK_CLIENT_SIDE_API)
X#if 1L && 1L
N#define __nap__clt    1
N#else
S#define __nap__clt    0
N#endif
N
N#if defined  (SL_INC_NET_APP_PKG) && defined (SL_INC_EXT_API)
X#if 1L && 1L
N#define __nap__ext    1
N#else
S#define __nap__ext    0
N#endif
N  
N#if defined (SL_INC_NET_CFG_PKG)
X#if 1L
N#define __ncg    1
N#else
S#define __ncg    0
N#endif
N
N#if defined (SL_INC_NET_CFG_PKG) && defined (SL_INC_EXT_API)
X#if 1L && 1L
N#define __ncg__ext    1
N#else
S#define __ncg__ext    0
N#endif
N
N#if defined (SL_INC_NVMEM_PKG)
X#if 1L
N#define __nvm    1
N#else
S#define __nvm    0
N#endif
N
N#if defined (SL_INC_NVMEM_EXT_PKG) && defined (SL_INC_EXT_API)
X#if 1L && 1L
N#define __nvm__ext    1
N#else
S#define __nvm__ext    0
N#endif
N
N#if defined (SL_INC_SOCKET_PKG)
X#if 1L
N#define __sck    1
N#else
S#define __sck    0
N#endif
N
N#if defined  (SL_INC_SOCKET_PKG) && defined (SL_INC_EXT_API)
X#if 1L && 1L
N#define __sck__ext    1
N#else
S#define __sck__ext    0
N#endif
N
N#if defined  (SL_INC_SOCKET_PKG) && defined (SL_INC_SOCK_SERVER_SIDE_API)
X#if 1L && 1L
N#define __sck__srv    1
N#else
S#define __sck__srv    0
N#endif
N
N#if defined  (SL_INC_SOCKET_PKG) && defined (SL_INC_SOCK_CLIENT_SIDE_API)
X#if 1L && 1L
N#define __sck__clt    1
N#else
S#define __sck__clt    0
N#endif
N
N#if defined  (SL_INC_SOCKET_PKG) && defined (SL_INC_SOCK_RECV_API)
X#if 1L && 1L
N#define __sck__rcv    1
N#else
S#define __sck__rcv    0
N#endif
N
N#if defined  (SL_INC_SOCKET_PKG) && defined (SL_INC_SOCK_SEND_API)
X#if 1L && 1L
N#define __sck__snd    1
N#else
S#define __sck__snd    0
N#endif
N
N#if defined (SL_INC_WLAN_PKG)
X#if 1L
N#define __wln    1
N#else
S#define __wln    0
N#endif
N
N#if defined  (SL_INC_WLAN_PKG) && defined (SL_INC_EXT_API)
X#if 1L && 1L
N#define __wln__ext    1
N#else
S#define __wln__ext    0
N#endif
N
N/* The return 1 is the function need to be included in the output */
N#define _SL_INCLUDE_FUNC(Name)    (_SL_INC_##Name)
N
N/* Driver */
N#define _SL_INC_sl_NetAppStart    __nap__ext
N#define _SL_INC_sl_NetAppStop     __nap__ext
N
N#define _SL_INC_sl_NetAppDnsGetHostByName    __nap__clt
N
N
N#define _SL_INC_sl_NetAppDnsGetHostByService      __nap__ext
N#define _SL_INC_sl_NetAppMDNSRegisterService      __nap__ext
N#define _SL_INC_sl_NetAppMDNSUnRegisterService    __nap__ext
N#define _SL_INC_sl_NetAppGetServiceList           __nap__ext
N    
N
N#define _SL_INC_sl_DnsGetHostByAddr    __nap__ext
N#define _SL_INC_sl_NetAppPing          __nap__ext
N#define _SL_INC_sl_NetAppSet           __nap__ext
N#define _SL_INC_sl_NetAppGet           __nap__ext
N#define _SL_INC_sl_NetAppRecv          __nap__ext
N
N#define _SL_INC_sl_NetAppSend          __nap__ext
N
N/* FS */
N#define _SL_INC_sl_FsOpen           __nvm
N
N#define _SL_INC_sl_FsClose          __nvm
N
N#define _SL_INC_sl_FsRead           __nvm
N
N#define _SL_INC_sl_FsWrite          __nvm
N
N#define _SL_INC_sl_FsGetInfo        __nvm
N
N#define _SL_INC_sl_FsDel            __nvm
N
N#define _SL_INC_sl_FsCtl            __nvm__ext
N
N#define _SL_INC_sl_FsProgram        __nvm__ext
N
N#define _SL_INC_sl_FsGetFileList    __nvm__ext
N
N/* netcfg */
N#define _SL_INC_sl_MacAdrrSet       __ncg
N
N#define _SL_INC_sl_MacAdrrGet       __ncg
N
N#define _SL_INC_sl_NetCfgGet        __ncg
N
N#define _SL_INC_sl_NetCfgSet        __ncg
N
N/* socket */
N#define _SL_INC_sl_Socket        __sck
N
N#define _SL_INC_sl_Close         __sck
N
N#define _SL_INC_sl_Accept        __sck__srv
N
N#define _SL_INC_sl_Bind          __sck
N
N#define _SL_INC_sl_Listen        __sck__srv
N
N#define _SL_INC_sl_Connect       __sck__clt
N
N#define _SL_INC_sl_Select        __sck
N
N#define _SL_INC_sl_SetSockOpt    __sck
N
N#define _SL_INC_sl_GetSockOpt    __sck__ext
N
N#define _SL_INC_sl_Recv          __sck__rcv
N
N#define _SL_INC_sl_RecvFrom      __sck__rcv
N
N#define _SL_INC_sl_Write         __sck__snd
N
N#define _SL_INC_sl_Send          __sck__snd
N
N#define _SL_INC_sl_SendTo        __sck__snd
N
N#define _SL_INC_sl_StartTLS      __sck
N
N#define _SL_INC_sl_Htonl         __sck
N
N#define _SL_INC_sl_Htons         __sck
N  
N/* wlan */
N#define _SL_INC_sl_WlanConnect          __wln__ext
N
N#define _SL_INC_sl_WlanDisconnect       __wln__ext
N
N#define _SL_INC_sl_WlanProfileAdd       __wln__ext
N
N#define _SL_INC_sl_WlanProfileGet       __wln__ext
N
N#define _SL_INC_sl_WlanProfileDel       __wln__ext
N
N#define _SL_INC_sl_WlanPolicySet        __wln__ext
N
N#define _SL_INC_sl_WlanPolicyGet        __wln__ext
N
N#define _SL_INC_sl_WlanGetNetworkList   __wln__ext
N
N#define _SL_INC_sl_WlanRxFilterAdd      __wln__ext
N
N#define _SL_INC_sl_WlanRxFilterSet      __wln__ext
N
N#define _SL_INC_sl_WlanRxFilterGet      __wln__ext
N
N#define _SL_INC_sl_SmartConfigStart     __wln
N
N#define _SL_INC_sl_SmartConfigOptSet    __wln__ext
N
N#define _SL_INC_sl_WlanProvisioning     __wln
N
N#define _SL_INC_sl_WlanSetMode          __wln
N
N#define _SL_INC_sl_WlanSet              __wln
N
N#define _SL_INC_sl_WlanGet              __wln
N
N#define _SL_INC_sl_SmartConfigOptSet    __wln__ext
N
N#define _SL_INC_sl_SmartConfigOptGet    __wln__ext
N
N#define  _SL_INC_sl_WlanRxStatStart     __wln__ext
N
N#define _SL_INC_sl_WlanRxStatStop       __wln__ext
N
N#define _SL_INC_sl_WlanRxStatGet        __wln__ext
N
N
N/* device */
N#define _SL_INC_sl_Task                  __int__spwn
N
N#define _SL_INC_sl_Start                 __dev
N
N#define _SL_INC_sl_Stop                  __dev
N
N#define _SL_INC_sl_StatusGet             __dev
N
N#ifdef SL_IF_TYPE_UART  
S#define _SL_INC_sl_DeviceUartSetMode     __dev__ext
N#endif
N
N#define _SL_INC_sl_DeviceEventMaskGet    __dev__ext
N
N#define _SL_INC_sl_DeviceEventMaskSet    __dev__ext
N
N#define _SL_INC_sl_DeviceGet             __dev__ext
N
N#define _SL_INC_sl_DeviceSet             __dev__ext
N
N/* netutil */
N#define _SL_INC_sl_NetUtilGet    __dev__ext
N 
N#define _SL_INC_sl_NetUtilSet    __dev__ext
N
N#define _SL_INC_sl_NetUtilCmd    __dev__ext
N
N#ifdef  __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /*OBJINCLUSION_H_  */
L 408 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N#include "trace.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/trace.h" 1
N/*
N * trace.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N
N
N#include <ti/drivers/net/wifi/simplelink.h>
N
N#ifndef __SIMPLELINK_TRACE_H__
N#define __SIMPLELINK_TRACE_H__
N
N
N#ifdef  __cplusplus
Sextern "C" {
N#endif
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N
N#define SL_SYNC_SCAN_THRESHOLD  (( _u32 )2000)
N
N#ifdef SL_TINY
S#define _SlDrvAssert(line )  { while(1); }
N#else
N#define _SlDrvAssert() _SlDrvHandleFatalError(SL_DEVICE_EVENT_FATAL_DRIVER_ABORT, 0, 0)
N#endif
N
N#define _SL_ASSERT(expr)              {if(!(expr)){ _SlDrvAssert();}}
N#define _SL_ERROR(expr, error)        {if(!(expr)){return (error);}}
N
N#define _SL_ASSERT_ERROR(expr, error) {if(!(expr)){_SlDrvAssert(); return (error);}}
N
N#define SL_HANDLING_ASSERT          2
N#define SL_HANDLING_ERROR           1
N#define SL_HANDLING_NONE            0
N
N#ifndef SL_TINY
N#define SL_SELF_COND_HANDLING       SL_HANDLING_ASSERT
N#define SL_PROTOCOL_HANDLING        SL_HANDLING_ASSERT
N#define SL_DRV_RET_CODE_HANDLING    SL_HANDLING_ERROR
N#define SL_NWP_IF_HANDLING          SL_HANDLING_ASSERT
N#define SL_OSI_RET_OK_HANDLING      SL_HANDLING_ERROR
N#define SL_MALLOC_OK_HANDLING       SL_HANDLING_ASSERT
N#define SL_USER_ARGS_HANDLING       SL_HANDLING_ASSERT
N#define SL_ERR_IN_PROGRESS_HANDLING SL_HANDLING_ERROR
N#define SL_ERR_IN_API_ALLOWED       SL_HANDLING_ERROR
N#else
S#define SL_SELF_COND_HANDLING       SL_HANDLING_NONE
S#define SL_PROTOCOL_HANDLING        SL_HANDLING_NONE
S#define SL_DRV_RET_CODE_HANDLING    SL_HANDLING_NONE
S#define SL_NWP_IF_HANDLING          SL_HANDLING_NONE
S#define SL_OSI_RET_OK_HANDLING      SL_HANDLING_NONE
S#define SL_MALLOC_OK_HANDLING       SL_HANDLING_NONE
S#define SL_USER_ARGS_HANDLING       SL_HANDLING_NONE
S#define SL_ERR_IN_PROGRESS_HANDLING SL_HANDLING_NONE
S#define SL_ERR_IN_API_ALLOWED       SL_HANDLING_NONE
N#endif
N
N
N#if (SL_ERR_IN_PROGRESS_HANDLING == SL_HANDLING_ERROR)
X#if (1 == 1)
N#define VERIFY_NO_ERROR_HANDLING_IN_PROGRESS() { \
N        if (SL_IS_RESTART_REQUIRED) return SL_API_ABORTED; }
X#define VERIFY_NO_ERROR_HANDLING_IN_PROGRESS() {         if (SL_IS_RESTART_REQUIRED) return SL_API_ABORTED; }
N#else
S#define VERIFY_NO_ERROR_HANDLING_IN_PROGRESS()
N#endif
N
N#if (SL_ERR_IN_API_ALLOWED == SL_HANDLING_ERROR)
X#if (1 == 1)
N#define VERIFY_API_ALLOWED(Silo) { \
N        _SlReturnVal_t status = _SlDrvDriverIsApiAllowed(Silo); \
N        if ( status ) return status; }
X#define VERIFY_API_ALLOWED(Silo) {         _SlReturnVal_t status = _SlDrvDriverIsApiAllowed(Silo);         if ( status ) return status; }
N#else
S#define VERIFY_API_ALLOWED(Silo)
N#endif
N
N#if (SL_DRV_RET_CODE_HANDLING == SL_HANDLING_ASSERT)
X#if (1 == 2)
S#define VERIFY_RET_OK(Func)                     {_SlReturnVal_t _RetVal = (Func); _SL_ASSERT((_SlReturnVal_t)SL_OS_RET_CODE_OK == _RetVal)}
N#elif (SL_DRV_RET_CODE_HANDLING == SL_HANDLING_ERROR)
X#elif (1 == 1)
N#define VERIFY_RET_OK(Func)                     {_SlReturnVal_t _RetVal = (Func); if (SL_OS_RET_CODE_OK != _RetVal) return (_SlReturnVal_t)_RetVal;}
N#else
S#define VERIFY_RET_OK(Func)                     (Func);
N#endif
N
N#if (SL_PROTOCOL_HANDLING == SL_HANDLING_ASSERT)
X#if (2 == 2)
N#define VERIFY_PROTOCOL(expr)                   _SL_ASSERT(expr)
N#elif (SL_PROTOCOL_HANDLING == SL_HANDLING_ERROR)
S#define VERIFY_PROTOCOL(expr)                   _SL_ERROR(expr, SL_RET_CODE_PROTOCOL_ERROR)
S#else
S#define VERIFY_PROTOCOL(expr)
N#endif
N
N#if (defined(PROTECT_SOCKET_ASYNC_RESP) && (SL_SELF_COND_HANDLING == SL_HANDLING_ASSERT))
X#if (0L && (2 == 2))
S#define VERIFY_SOCKET_CB(expr)                  _SL_ASSERT(expr)
S#elif (defined(PROTECT_SOCKET_ASYNC_RESP) && (SL_SELF_COND_HANDLING == SL_HANDLING_ERROR))
X#elif (0L && (2 == 1))
S#define VERIFY_SOCKET_CB(expr)                  _SL_ERROR(expr, SL_RET_CODE_SELF_ERROR)
N#else
N#define VERIFY_SOCKET_CB(expr)
N#endif
N
N#if (SL_NWP_IF_HANDLING == SL_HANDLING_ASSERT)
X#if (2 == 2)
N#define NWP_IF_WRITE_CHECK(fd,pBuff,len)       { _i16 RetSize, ExpSize = (_i16)(len); RetSize = sl_IfWrite((fd),(pBuff),ExpSize); _SL_ASSERT(ExpSize == RetSize)}
N#define NWP_IF_READ_CHECK(fd,pBuff,len)        { _i16 RetSize, ExpSize = (_i16)(len); RetSize = sl_IfRead((fd),(pBuff),ExpSize);  _SL_ASSERT(ExpSize == RetSize)}
N#elif (SL_NWP_IF_HANDLING == SL_HANDLING_ERROR)
S#define NWP_IF_WRITE_CHECK(fd,pBuff,len)       { _SL_ERROR((len == sl_IfWrite((fd),(pBuff),(len))), SL_RET_CODE_NWP_IF_ERROR);}
S#define NWP_IF_READ_CHECK(fd,pBuff,len)        { _SL_ERROR((len == sl_IfRead((fd),(pBuff),(len))),  SL_RET_CODE_NWP_IF_ERROR);}
S#else
S#define NWP_IF_WRITE_CHECK(fd,pBuff,len)       { sl_IfWrite((fd),(pBuff),(len));}
S#define NWP_IF_READ_CHECK(fd,pBuff,len)        { sl_IfRead((fd),(pBuff),(len));}
N#endif
N
N#if (SL_OSI_RET_OK_HANDLING == SL_HANDLING_ASSERT)
X#if (1 == 2)
S#define OSI_RET_OK_CHECK(Func)                  {_SlReturnVal_t _RetVal = (Func); _SL_ASSERT((_SlReturnVal_t)SL_OS_RET_CODE_OK == _RetVal)}
N#elif (SL_OSI_RET_OK_HANDLING == SL_HANDLING_ERROR)
X#elif (1 == 1)
N#define OSI_RET_OK_CHECK(Func)                  {_SlReturnVal_t _RetVal = (Func); if (SL_OS_RET_CODE_OK != _RetVal) return  _RetVal;}
N#else
S#define OSI_RET_OK_CHECK(Func)                  (Func);
N#endif
N
N#if (SL_MALLOC_OK_HANDLING == SL_HANDLING_ASSERT)
X#if (2 == 2)
N#define MALLOC_OK_CHECK(Ptr)                    _SL_ASSERT(NULL != Ptr)
N#elif (SL_MALLOC_OK_HANDLING == SL_HANDLING_ERROR)
S#define MALLOC_OK_CHECK(Ptr)                    _SL_ERROR((NULL != Ptr), SL_RET_CODE_MALLOC_ERROR)
S#else
S#define MALLOC_OK_CHECK(Ptr)
N#endif
N
N#ifdef SL_INC_ARG_CHECK
N
N#if (SL_USER_ARGS_HANDLING == SL_HANDLING_ASSERT)
X#if (2 == 2)
N#define ARG_CHECK_PTR(Ptr)                      _SL_ASSERT(NULL != Ptr)
N#elif (SL_USER_ARGS_HANDLING == SL_HANDLING_ERROR)
S#define ARG_CHECK_PTR(Ptr)                      _SL_ERROR((NULL != Ptr), SL_RET_CODE_INVALID_INPUT)
S#else
S#define ARG_CHECK_PTR(Ptr)
N#endif
N
N#else
S#define ARG_CHECK_PTR(Ptr)
N#endif
N
N/*#define SL_DBG_TRACE_ENABLE*/
N#ifdef SL_DBG_TRACE_ENABLE
S#define SL_TRACE0(level,msg_id,str)                     printf(str)
S#define SL_TRACE1(level,msg_id,str,p1)                  printf(str,(p1))
S#define SL_TRACE2(level,msg_id,str,p1,p2)               printf(str,(p1),(p2))
S#define SL_TRACE3(level,msg_id,str,p1,p2,p3)            printf(str,(p1),(p2),(p3))
S#define SL_TRACE4(level,msg_id,str,p1,p2,p3,p4)         printf(str,(p1),(p2),(p3),(p4))
S#define SL_ERROR_TRACE(msg_id,str)                      printf(str)
S#define SL_ERROR_TRACE1(msg_id,str,p1)                  printf(str,(p1))
S#define SL_ERROR_TRACE2(msg_id,str,p1,p2)               printf(str,(p1),(p2))
S#define SL_ERROR_TRACE3(msg_id,str,p1,p2,p3)            printf(str,(p1),(p2),(p3))
S#define SL_ERROR_TRACE4(msg_id,str,p1,p2,p3,p4)         printf(str,(p1),(p2),(p3),(p4))
S#define SL_TRACE_FLUSH()
N#else
N#define SL_TRACE0(level,msg_id,str)
N#define SL_TRACE1(level,msg_id,str,p1)
N#define SL_TRACE2(level,msg_id,str,p1,p2)
N#define SL_TRACE3(level,msg_id,str,p1,p2,p3)
N#define SL_TRACE4(level,msg_id,str,p1,p2,p3,p4)
N#define SL_ERROR_TRACE(msg_id,str)
N#define SL_ERROR_TRACE1(msg_id,str,p1)
N#define SL_ERROR_TRACE2(msg_id,str,p1,p2)
N#define SL_ERROR_TRACE3(msg_id,str,p1,p2,p3)
N#define SL_ERROR_TRACE4(msg_id,str,p1,p2,p3,p4)
N#define SL_TRACE_FLUSH()
N#endif
N
N/* #define SL_DBG_CNT_ENABLE */
N#ifdef SL_DBG_CNT_ENABLE
S#define _SL_DBG_CNT_INC(Cnt)            g_DbgCnt. ## Cnt++
S#define _SL_DBG_SYNC_LOG(index,value)   {if(index < SL_DBG_SYNC_LOG_SIZE){*(_u32 *)&g_DbgCnt.SyncLog[index] = *(_u32 *)(value);}}
S
N#else
N#define _SL_DBG_CNT_INC(Cnt)
N#define _SL_DBG_SYNC_LOG(index,value)
N#endif
N
N#define SL_DBG_LEVEL_1                  1
N#define SL_DBG_LEVEL_2                  2
N#define SL_DBG_LEVEL_3                  4
N#define SL_DBG_LEVEL_MASK               (SL_DBG_LEVEL_2|SL_DBG_LEVEL_3)
N
N#define SL_INCLUDE_DBG_FUNC(Name)       ((Name ## _DBG_LEVEL) & SL_DBG_LEVEL_MASK)
N
N#define _SlDrvPrintStat_DBG_LEVEL       SL_DBG_LEVEL_3
N#define _SlDrvOtherFunc_DBG_LEVEL       SL_DBG_LEVEL_1
N
N#ifdef  __cplusplus
S}
N#endif
N
N
N#endif /*__SIMPLELINK_TRACE_H__*/
N
L 409 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N#include "fs.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/fs.h" 1
N/*
N * fs.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N#include <ti/drivers/net/wifi/simplelink.h>
N
N#ifndef __FS_H__
N#define __FS_H__
N
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*!
N    \defgroup FileSystem 
N    \short Provides file system capabilities to TI's CC31XX that can be used by both the CC31XX device and the user
N
N*/
N
N/*!
N
N    \addtogroup FileSystem
N    @{
N
N*/
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N
N/* Create file max size mode  */
N#define SL_FS_OPEN_MODE_BIT_MASK    (0xF8000000)
N#define SL_NUM_OF_MODE_BIT          (5)
N
N#define SL_FS_OPEN_FLAGS_BIT_MASK   (0x07FE0000)
N#define SL_NUM_OF_FLAGS_BIT         (10)
N
N#define SL_FS_OPEN_MAXSIZE_BIT_MASK (0x1FFFF)
N#define SL_NUM_OF_MAXSIZE_BIT       (17)
N
N
N/*
N  sl_FsGetInfo and sl_FsGetFileList flags
N  ------------------
N*/
N
N#define SL_FS_INFO_OPEN_WRITE                    0x1000   /* File is opened for write */
N#define SL_FS_INFO_OPEN_READ                     0x800    /* File is opened for read */
N
N#define SL_FS_INFO_MUST_COMMIT                   0x1      /* File is currently open with SL_FS_FILE_OPEN_FLAG_COMMIT_MODE */
N#define SL_FS_INFO_BUNDLE_FILE                   0x2      /* File is currently open with SL_FS_FILE_OPEN_FLAG_BUNDLE_COMMIT_MODE */
N
N#define SL_FS_INFO_PENDING_COMMIT                0x4      /* File is currently closed with SL_FS_FILE_OPEN_FLAG_COMMIT_MODE */
N#define SL_FS_INFO_PENDING_BUNDLE_COMMIT         0x8      /* File is currently closed with SL_FS_FILE_OPEN_FLAG_BUNDLE_COMMIT_MODE */
N
N#define SL_FS_INFO_NOT_FAILSAFE                  0x20     /* File was created with SL_FS_FILE_OPEN_FLAG_FAILSAFE */
N#define SL_FS_INFO_NOT_VALID                     0x100    /* No valid image exists for the file */
N#define SL_FS_INFO_SYS_FILE                      0x40     /* File is system file */
N#define SL_FS_INFO_SECURE                        0x10     /* File is secured */
N#define SL_FS_INFO_NOSIGNATURE                   0x2000   /* File is unsigned, the flag is returns only for sl_FsGetInfo function and not for sl_FsGetFileList */
N#define SL_FS_INFO_PUBLIC_WRITE                  0x200    /* File is open for public write */
N#define SL_FS_INFO_PUBLIC_READ                   0x400    /* File is open for public read */
N
N
N/*
N  fs_Open flags
N  --------------
N*/
N
N/* mode */
N#define     SL_FS_CREATE                         ((_u32)0x1<<(SL_NUM_OF_MAXSIZE_BIT+SL_NUM_OF_FLAGS_BIT))
N#define     SL_FS_WRITE                          ((_u32)0x2<<(SL_NUM_OF_MAXSIZE_BIT+SL_NUM_OF_FLAGS_BIT))
N#define     SL_FS_OVERWRITE                      ((_u32)0x4<<(SL_NUM_OF_MAXSIZE_BIT+SL_NUM_OF_FLAGS_BIT))
N#define     SL_FS_READ                           ((_u32)0x8<<(SL_NUM_OF_MAXSIZE_BIT+SL_NUM_OF_FLAGS_BIT))
N/* creation flags */
N#define     SL_FS_CREATE_FAILSAFE                ((_u32)0x1<<SL_NUM_OF_MAXSIZE_BIT)         /* Fail safe */
N#define     SL_FS_CREATE_SECURE                  ((_u32)0x2<<SL_NUM_OF_MAXSIZE_BIT)         /* SECURE */
N#define     SL_FS_CREATE_NOSIGNATURE             ((_u32)0x4<<SL_NUM_OF_MAXSIZE_BIT)         /* Relevant to secure file only  */
N#define     SL_FS_CREATE_STATIC_TOKEN            ((_u32)0x8<<SL_NUM_OF_MAXSIZE_BIT)         /* Relevant to secure file only */
N#define     SL_FS_CREATE_VENDOR_TOKEN            ((_u32)0x10<<SL_NUM_OF_MAXSIZE_BIT)        /* Relevant to secure file only */
N#define     SL_FS_CREATE_PUBLIC_WRITE            ((_u32)0x20<<SL_NUM_OF_MAXSIZE_BIT)        /* Relevant to secure file only, the file can be opened for write without Token */
N#define     SL_FS_CREATE_PUBLIC_READ             ((_u32)0x40<<SL_NUM_OF_MAXSIZE_BIT)        /* Relevant to secure file only, the file can be opened for read without Token  */
N
N#define     SL_FS_CREATE_MAX_SIZE( MaxFileSize ) ((((_u32)MaxFileSize + 255) / 256 ) & SL_FS_OPEN_MAXSIZE_BIT_MASK )
N
N/* write flags */
N#define    SL_FS_WRITE_MUST_COMMIT               ((_u32)0x80<<SL_NUM_OF_MAXSIZE_BIT)        /* The file is locked for changes */
N#define    SL_FS_WRITE_BUNDLE_FILE               ((_u32)0x100<<SL_NUM_OF_MAXSIZE_BIT)       /* The file is locked for changes as part of Bundle */
N#define    SL_FS_WRITE_ENCRYPTED                 ((_u32)0x200<<SL_NUM_OF_MAXSIZE_BIT)       /* This indicates the start of a secured content write session */
N
N/*****************************************************************************/
N/* Structure/Enum declarations                                               */
N/*****************************************************************************/
N
Ntypedef enum
N{
N    SL_FS_TOKEN_MASTER               = 0,
N    SL_FS_TOKEN_WRITE_READ           = 1,
N    SL_FS_TOKEN_WRITE_ONLY           = 2,
N    SL_FS_TOKEN_READ_ONLY            = 3
N}SlFsTokenId_e;
N
Ntypedef struct
N{
N    _u16  Flags;                    /* see Flags options */
X    unsigned short  Flags;                     
N    _u32  Len;                      /* In bytes, The actual size of the copy which is used for read*/
X    unsigned long  Len;                       
N    _u32  MaxSize;                  /* In bytes, The max file size  */
X    unsigned long  MaxSize;                   
N    _u32  Token[4];                 /* see SlFsTokenId_e */
X    unsigned long  Token[4];                  
N    _u32  StorageSize;              /* In bytes, The total size that the file required on the storage including the mirror */
X    unsigned long  StorageSize;               
N    _u32  WriteCounter;             /* Number of times in which the file have been written successfully */
X    unsigned long  WriteCounter;              
N}SlFsFileInfo_t;
N
N
N/*
N  sl_FsCtl
N  --------
N*/
Ntypedef enum
N{
N  SL_FS_CTL_RESTORE = 0,   /* restores the factory default */
N  SL_FS_CTL_ROLLBACK = 1,
N  SL_FS_CTL_COMMIT = 2,
N  SL_FS_CTL_RENAME = 3,
N  SL_FS_CTL_GET_STORAGE_INFO = 5,
N  SL_FS_CTL_BUNDLE_ROLLBACK = 6,
N  SL_FS_CTL_BUNDLE_COMMIT = 7
N}SlFsCtl_e;
N
Ntypedef enum
N{
N  SL_FS_BUNDLE_STATE_STOPPED = 0,
N  SL_FS_BUNDLE_STATE_STARTED = 1,
N  SL_FS_BUNDLE_STATE_PENDING_COMMIT = 3
N}SlFsBundleState_e;
N
Ntypedef struct
N{
N    _u32  Key[4];/*16 bytes*/
X    unsigned long  Key[4]; 
N}SlFsKey_t;
N
Ntypedef struct
N{
N  _u8   Index;
X  unsigned char   Index;
N}SlFsFileNameIndex_t;
N
Ntypedef union
N{
N  SlFsFileNameIndex_t  Index;
N  _i32                 ErrorNumber;
X  signed long                 ErrorNumber;
N}SlFsFileNameIndexOrError_t;
N
N/* File control helper structures */
N
N/*SL_FS_CTL_RESTORE*/
Ntypedef enum
N{
N  SL_FS_FACTORY_RET_TO_IMAGE =  0,/*The system will be back to the production image.*/
N  SL_FS_FACTORY_RET_TO_DEFAULT = 2 /*return to factory default*/
N}SlFsRetToFactoryOper_e;
N
Ntypedef struct
N{
N  _u32 Operation;/*see _SlFsRetToFactoryOper_e*/
X  unsigned long Operation; 
N}SlFsRetToFactoryCommand_t;
N
N/******************* Input flags end *****************************************/
N
Ntypedef struct
N{
N  _u32           IncludeFilters;
X  unsigned long           IncludeFilters;
N
N}SlFsControl_t;
N
Ntypedef struct
N{
N  _u16 DeviceBlockSize;
X  unsigned short DeviceBlockSize;
N  _u16 DeviceBlocksCapacity;
X  unsigned short DeviceBlocksCapacity;
N  _u16 NumOfAllocatedBlocks;
X  unsigned short NumOfAllocatedBlocks;
N  _u16 NumOfReservedBlocks;
X  unsigned short NumOfReservedBlocks;
N  _u16 NumOfReservedBlocksForSystemfiles;
X  unsigned short NumOfReservedBlocksForSystemfiles;
N  _u16 LargestAllocatedGapInBlocks;
X  unsigned short LargestAllocatedGapInBlocks;
N  _u16 NumOfAvailableBlocksForUserFiles;
X  unsigned short NumOfAvailableBlocksForUserFiles;
N  _u8  Padding[2];
X  unsigned char  Padding[2];
N} SlFsControlDeviceUsage_t;
N
Ntypedef struct
N{
N  _u8  MaxFsFiles;
X  unsigned char  MaxFsFiles;
N  _u8  IsDevlopmentFormatType;
X  unsigned char  IsDevlopmentFormatType;
N  _u8  Bundlestate; /*see SlFsBundleState_e*/
X  unsigned char  Bundlestate;  
N  _u8  Reserved;
X  unsigned char  Reserved;
N  _u8  MaxFsFilesReservedForSysFiles;
X  unsigned char  MaxFsFilesReservedForSysFiles;
N  _u8  ActualNumOfUserFiles;
X  unsigned char  ActualNumOfUserFiles;
N  _u8  ActualNumOfSysFiles;
X  unsigned char  ActualNumOfSysFiles;
N  _u8  Padding;
X  unsigned char  Padding;
N  _u32 NumOfAlerts;
X  unsigned long NumOfAlerts;
N  _u32 NumOfAlertsThreshold;
X  unsigned long NumOfAlertsThreshold;
N  _u16 FATWriteCounter;/*Though it is increased during the programming, the programming and ret to factory takes only 1- write to the FAT, independ of the number of the programming files */
X  unsigned short FATWriteCounter; 
N  _u16 Padding2;
X  unsigned short Padding2;
N}SlFsControlFilesUsage_t;
N
N/*SL_FS_CTL_GET_STORAGE_INFO*/
Ntypedef struct
N{
N    SlFsControlDeviceUsage_t DeviceUsage;
N    SlFsControlFilesUsage_t  FilesUsage;
N} SlFsControlGetStorageInfoResponse_t;
N
Ntypedef struct
N{
N   _u32   IncludeFilters; /* see SlFsControlFilterCounterFlags_e*/
X   unsigned long   IncludeFilters;  
N   _u8    OpenedForWriteCnt;
X   unsigned char    OpenedForWriteCnt;
N   _u8    OpeneForReadCnt;
X   unsigned char    OpeneForReadCnt;
N   _u8    ClosedFilesCnt;
X   unsigned char    ClosedFilesCnt;
N   _u8    OpenedForWriteCntWithValidFailSafeImage;
X   unsigned char    OpenedForWriteCntWithValidFailSafeImage;
N   _u8    OpeneForReadCntWithValidFailSafeImage;
X   unsigned char    OpeneForReadCntWithValidFailSafeImage;
N   _u8    ClosedFilesCntWithValidFailSafeImage;
X   unsigned char    ClosedFilesCntWithValidFailSafeImage;
N   _u8    padding[2];
X   unsigned char    padding[2];
N} SlFsControlGetCountersResponse_t;
N
N/* GetFileList */
N#define SL_FS_MAX_FILE_NAME_LENGTH                       180
N
Ntypedef enum
N{
N    SL_FS_GET_FILE_ATTRIBUTES = 0x1
N}SlFileListFlags_t;
N
N
N
N
Ntypedef struct
N{
N   _u32  FileMaxSize;
X   unsigned long  FileMaxSize;
N   _u32  Properties; /* see SL_FS_INFO_  flags */
X   unsigned long  Properties;  
N   _u32  FileAllocatedBlocks;/*1 block = 4096 bytes*/
X   unsigned long  FileAllocatedBlocks; 
N}SlFileAttributes_t;
N/*!
N    \cond DOXYGEN_REMOVE
N*/
N/*****************************************************************************/
N/* external Function prototypes                                              */
N/*****************************************************************************/
N
N/*****************************************************************************/
N/* Function prototypes                                                       */
N/*****************************************************************************/
N/*!
N    \endcond
N*/
N/*!
N    \brief open file for read or write from/to storage device
N
N    \param[in]      pFileName                  File Name buffer pointer
N    \param[in]      AccessModeAndMaxSize       Options: As described below
N    \param[in]      pToken                     input Token for read, output Token for write
N
N     AccessModeAndMaxSize possible input                                                                        \n
N     SL_FS_READ                                        - Read a file                                                                  \n
N     SL_FS_WRITE                                       - Open for write for an existing file (whole file content needs to be rewritten)\n
N     SL_FS_CREATE|maxSizeInBytes,accessModeFlags
N     SL_FS_CREATE|SL_FS_OVERWRITE|maxSizeInBytes,accessModeFlags  - Open for creating a new file. Max file size is defined in bytes.             \n
N                                                                    For optimal FS size, use max size in 4K-512 bytes steps (e.g. 3584,7680,117760)  \n
N                                                                    Several access modes bits can be combined together from SlFileOpenFlags_e enum
N
N    \return         File handle on success. Negative error code on fail
N
N    \sa             sl_FsRead sl_FsWrite sl_FsClose
N    \note           belongs to \ref basic_api
N    \warning
N    \par            Example
N
N    - Creating file and writing data to it
N    \code
N        char*           DeviceFileName = "MyFile.txt";
N        unsigned long   MaxSize = 63 * 1024; //62.5K is max file size
N        long            DeviceFileHandle = -1;
N        _i32            RetVal;        //negative retval is an error
N        unsigned long   Offset = 0;
N        unsigned char   InputBuffer[100];
N        _u32            MasterToken = 0;
N 
N        // Create a file and write data. The file in this example is secured, without signature and with a fail safe commit
N 
N        //create a secure file if not exists and open it for write.
N        DeviceFileHandle =  sl_FsOpen(unsigned char *)DeviceFileName,
N                                      SL_FS_CREATE|SL_FS_OVERWRITE | SL_FS_CREATE_SECURE | SL_FS_CREATE_NOSIGNATURE | SL_FS_CREATE_MAX_SIZE( MaxSize ),
N                                      &MasterToken);
N 
N        Offset = 0;
N        //Preferred in secure file that the Offset and the length will be aligned to 16 bytes.
N        RetVal = sl_FsWrite( DeviceFileHandle, Offset, (unsigned char *)"HelloWorld", strlen("HelloWorld"));
N 
N        RetVal = sl_FsClose(DeviceFileHandle, NULL, NULL , 0);
N 
N        // open the same file for read, using the Token we got from the creation procedure above
N        DeviceFileHandle =  sl_FsOpen(unsigned char *)DeviceFileName,
N                                      SL_FS_READ,
N                                      &MasterToken);
N 
N        Offset = 0;
N        RetVal = sl_FsRead( DeviceFileHandle, Offset, (unsigned char *)InputBuffer, strlen("HelloWorld"));
N 
N        RetVal = sl_FsClose(DeviceFileHandle, NULL, NULL , 0);
N    \endcode
N    <br>
N
N    - Create a non secure file if not already exists and open it for write
N    \code
N        DeviceFileHandle = sl_FsOpen((unsigned char *)DeviceFileName,
N                                      SL_FS_CREATE|SL_FS_OVERWRITE| SL_FS_CREATE_MAX_SIZE( MaxSize ),
N                                      NULL);
N    \endcode
N    
N    \note             Some of the flags are creation flags and can only be set when the file is created. When opening the file for write the creation flags are ignored. For more information, refer to chapter 8 in the user manual.
N              
N*/
N
N#if _SL_INCLUDE_FUNC(sl_FsOpen)
X#if (1)
N_i32 sl_FsOpen(const _u8 *pFileName,const _u32 AccessModeAndMaxSize,_u32 *pToken);
Xsigned long sl_FsOpen(const unsigned char *pFileName,const unsigned long AccessModeAndMaxSize,unsigned long *pToken);
N#endif
N
N/*!
N    \brief Close file in storage device
N
N    \param[in]      FileHdl               Pointer to the file (assigned from sl_FsOpen)
N    \param[in]      pCeritificateFileName Certificate file, or NULL if irrelevant.
N    \param[in]      pSignature            The signature is SHA-1, the certificate chain may include SHA-256
N    \param[in]      SignatureLen          The signature actual length
N
N    \return         Zero on success, or a negative value if an error occurred
N    \sa             sl_FsRead sl_FsWrite sl_FsOpen
N    \note           Call the fs_Close  with signature = 'A' signature len = 1 for activating an abort action\n
N                    Creating signature : OpenSSL> dgst -binary -sha1 -sign <file-location>\<private_key>.pem -out <file-location>\<output>.sig <file-location>\<input>.txt
N    \warning
N    \par            Examples
N    
N    - Closing file: 
N    \code
N        _i16 RetVal;
N        RetVal = sl_FsClose(FileHandle,0,0,0);
N    \endcode
N    <br>
N
N    - Aborting file:
N    \code
N        _u8  Signature;
N        Signature = 'A';
N        sl_FsClose(FileHandle,0,&Signature, 1);
N    \endcode
N    
N    \note            In case the file was opened as not secure file or as secure-not signed, any certificate or signature provided are ignored, those fields should be set to NULL.
N*/
N#if _SL_INCLUDE_FUNC(sl_FsClose)
X#if (1)
N_i16 sl_FsClose(const _i32 FileHdl,const _u8* pCeritificateFileName,const _u8* pSignature,const _u32 SignatureLen);
Xsigned short sl_FsClose(const signed long FileHdl,const unsigned char* pCeritificateFileName,const unsigned char* pSignature,const unsigned long SignatureLen);
N#endif
N
N/*!
N    \brief Read block of data from a file in storage device
N
N    \param[in]      FileHdl Pointer to the file (assigned from sl_FsOpen)
N    \param[in]      Offset  Offset to specific read block
N    \param[out]     pData   Pointer for the received data
N    \param[in]      Len     Length of the received data
N
N    \return         Number of read bytes on success, negative error code on failure
N
N    \sa             sl_FsClose sl_FsWrite sl_FsOpen
N    \note           belongs to \ref basic_api
N    \warning
N    \par            Example
N    
N    - Reading File:
N    \code
N    Status = sl_FsRead(FileHandle, 0, &readBuff[0], readSize);
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_FsRead)
X#if (1)
N_i32 sl_FsRead(const _i32 FileHdl,_u32 Offset ,_u8*  pData,_u32 Len);
Xsigned long sl_FsRead(const signed long FileHdl,unsigned long Offset ,unsigned char*  pData,unsigned long Len);
N#endif
N
N/*!
N    \brief Write block of data to a file in storage device
N
N    \param[in]      FileHdl  Pointer to the file (assigned from sl_FsOpen)
N    \param[in]      Offset   Offset to specific block to be written
N    \param[in]      pData    Pointer the transmitted data to the storage device
N    \param[in]      Len      Length of the transmitted data
N
N    \return         Number of wireted bytes on success, negative error code on failure
N
N    \sa
N    \note           belongs to \ref basic_api
N    \warning
N    \par            Example
N    
N    - Writing file:
N    \code
N    Status = sl_FsWrite(FileHandle, 0, &buff[0], readSize);
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_FsWrite)
X#if (1)
N_i32 sl_FsWrite(const _i32 FileHdl,_u32 Offset,_u8*  pData,_u32 Len);
Xsigned long sl_FsWrite(const signed long FileHdl,unsigned long Offset,unsigned char*  pData,unsigned long Len);
N#endif
N
N/*!
N    \brief Get information of a file
N
N    \param[in]      pFileName    File name
N    \param[in]      Token        File token. if irrelevant set to 0.
N    \param[out]     pFsFileInfo Returns the File's Information (SlFsFileInfo_t)
N                                - Flags
N                                - File size 
N                                - Allocated size 
N                                - Tokens
N
N    \return         Zero on success, negative error code on failure \n
N                    When file not exists : SL_ERROR_FS_FILE_NOT_EXISTS
N    \note           
N                    - If the return value is SL_ERROR_FS_FILE_HAS_NOT_BEEN_CLOSE_CORRECTLY or  SL_ERROR_FS_FILE_IS_ALREADY_OPENED information about the file is valid.
N                    - Belongs to \ref basic_api
N
N    \sa             sl_FsOpen
N    \warning
N    \par            Example
N
N    - Getting file info:
N    \code
N    Status = sl_FsGetInfo("FileName.html",Token,&FsFileInfo);
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_FsGetInfo)
X#if (1)
N_i16 sl_FsGetInfo(const _u8 *pFileName,const _u32 Token,SlFsFileInfo_t* pFsFileInfo);
Xsigned short sl_FsGetInfo(const unsigned char *pFileName,const unsigned long Token,SlFsFileInfo_t* pFsFileInfo);
N#endif
N
N/*!
N    \brief Delete specific file from a storage or all files from a storage (format)
N
N    \param[in]      pFileName    File Name
N    \param[in]      Token        File token. if irrelevant set to 0
N    \return         Zero on success, or a negative value if an error occurred
N
N    \sa
N    \note           belongs to \ref basic_api
N    \warning
N    \par            Example
N
N    - Deleting file:
N    \code
N        Status = sl_FsDel("FileName.html",Token);
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_FsDel)
X#if (1)
N_i16 sl_FsDel(const _u8 *pFileName,const _u32 Token);
Xsigned short sl_FsDel(const unsigned char *pFileName,const unsigned long Token);
N#endif
N
N
N
N/*!
N    \brief Controls various file system operations
N
N   \param[in]  Command , the command to execute, \see SlFsCtl_e
N    SL_FS_CTL_RESTORE , Return to factory default, return to factory image , see fs programming
N    SL_FS_CTL_ROLLBACK , Roll-back file which was created with 'SL_FS_WRITE_MUST_COMMIT'
N    SL_FS_CTL_COMMIT,Commit file which was created with 'SL_FS_WRITE_MUST_COMMIT'
N    SL_FS_CTL_RENAME, Rename file
N    SL_FS_CTL_GET_STORAGE_INFO, Total size of storage , available size of storage
N    SL_FS_CTL_BUNDLE_ROLLBACK, Rollback bundle files
N    SL_FS_CTL_BUNDLE_COMMIT, Commit Bundle files
N    \param[in]      Token         Set to NULL if not relevant to the command
N    \param[in]      pFileName     Set to NULL if not relevant to the command
N    \param[in]      pData         The data according the command.
N    \param[in]      DataLen       Length of data buffer
N    \param[out]     pOutputData   Buffer for the output data
N    \param[out]     OutputDataLen Length of the output data buffer
N    \param[out]     pNewToken     The new valid file token, if irrelevant can be set to NULL.
N    \return         
N                    - Zero on success, or a negative value if an error occurred
N                    - For SL_FS_CTL_BUNDLE_ROLLBACK, On success bundle the new bundle state is returned (see SlFsBundleState_e) else negative error number
N                    - For SL_FS_CTL_BUNDLE_COMMIT, On success the new bundle state is returned (see SlFsBundleState_e) else negative error number
N    
N    \sa
N    \note           belongs to \ref ext_api
N    \warning
N    \par            Examples
N
N    - SL_FS_CTL_ROLLBACK:
N    \code
N            FsControl.IncludeFilters = 0;
N            slRetVal = sl_FsCtl( (SlFsCtl_e)SL_FS_CTL_FILE_ROLLBACK, Token, NWPfileName ,(_u8 *)&FsControl, sizeof(SlFsControl_t), NULL, 0 , pNewToken);
N    \endcode
N    <br>
N
N    - SL_FS_CTL_COMMIT:
N    \code
N            FsControl.IncludeFilters = 0;
N            slRetVal = sl_FsCtl(SL_FS_CTL_COMMIT, Token, NWPfileName ,(_u8 *)&FsControl, sizeof(SlFsControl_t), NULL, 0, pNewToken );
N    \endcode
N    <br>
N
N    - SL_FS_CTL_RENAME:
N    \code
N            slRetVal = sl_FsCtl(SL_FS_CTL_RENAME, Token, NWPfileName, NewFileName, 0, NULL, 0, NULL );
N    \endcode
N    <br>
N
N    - SL_FS_CTL_GET_STORAGE_INFO:
N    \code
N        _i32  GetStorageInfo( SlFsControlGetStorageInfoResponse_t* pSlFsControlGetStorageInfoResponse )
N        {
N            _i32 slRetVal;
N
N            slRetVal = sl_FsCtl( ( SlFsCtl_e)SL_FS_CTL_GET_STORAGE_INFO, 0, NULL , NULL , 0, (_u8 *)pSlFsControlGetStorageInfoResponse, sizeof(SlFsControlGetStorageInfoResponse_t), NULL );
N            return slRetVal;
N        }
N    \endcode
N    <br>
N
N    - SL_FS_CTL_RESTORE:
N    \code
N        //Return 0 for OK, else Error
N        _i32 ProgramRetToImage( )
N        {
N            _i32 slRetVal;
N            SlFsRetToFactoryCommand_t RetToFactoryCommand;
N            _i32 RetVal, ExtendedError;
N
N            RetToFactoryCommand.Operation = SL_FS_FACTORY_RET_TO_IMAGE;
N            slRetVal = sl_FsCtl( (SlFsCtl_e)SL_FS_CTL_RESTORE, 0, NULL , (_u8 *)&RetToFactoryCommand , sizeof(SlFsRetToFactoryCommand_t), NULL, 0 , NULL );
N            if ((_i32)slRetVal < 0)
N                {
N                    //Pay attention, for this function the slRetVal is composed from Signed RetVal & extended error
N                    RetVal = (_i16)slRetVal>> 16;
N                    ExtendedError = (_u16)slRetVal& 0xFFFF;
N                    printf("\tError SL_FS_FACTORY_RET_TO_IMAGE, 5d, %d\n", RetVal, ExtendedError);
N                    return slRetVal;
N            }
N            //Reset
N            sl_Stop(0);
N            Sleep(1000);
N            sl_Start(NULL, NULL, NULL);
N
N            return slRetVal;
N        }
N    \endcode
N    <br>
N    
N    - SL_FS_CTL_BUNDLE_ROLLBACK:
N    \code    
N        //return 0 for O.K else negative
N        _i32 BundleRollback()
N        {
N            _i32 slRetVal = 0;
N            SlFsControl_t FsControl;
N            FsControl.IncludeFilters = 0; //Use default behaviour
N            slRetVal = sl_FsCtl( (SlFsCtl_e)SL_FS_CTL_BUNDLE_ROLLBACK, 0, NULL ,(_u8 *)&FsControl, sizeof(SlFsControl_t), NULL, 0 , NULL);
N            return slRetVal;
N        }
N    \endcode
N    <br>
N
N    - SL_FS_CTL_BUNDLE_COMMIT:
N    \code
N        //return 0 for O.K else negative
N        _i32 BundleCommit()
N        {
N            _i32 slRetVal = 0;
N            SlFsControl_t FsControl;
N            FsControl.IncludeFilters = 0; //Use default behaviour
N            slRetVal = sl_FsCtl( (SlFsCtl_e)SL_FS_CTL_BUNDLE_COMMIT, 0, NULL ,(_u8 *)&FsControl, sizeof(SlFsControl_t), NULL, 0 , NULL);
N            return slRetVal;
N        }
N    \endcode
N */
N#if _SL_INCLUDE_FUNC(sl_FsCtl)
X#if (1)
N_i32   sl_FsCtl(  SlFsCtl_e Command,  _u32 Token,  _u8 *pFileName, const _u8 *pData, _u16 DataLen, _u8 *pOutputData, _u16 OutputDataLen,_u32 *pNewToken );
Xsigned long   sl_FsCtl(  SlFsCtl_e Command,  unsigned long Token,  unsigned char *pFileName, const unsigned char *pData, unsigned short DataLen, unsigned char *pOutputData, unsigned short OutputDataLen,unsigned long *pNewToken );
N#endif
N/*!
N    \brief Enables to format and configure the device with pre-prepared configuration
N
N    \param[in]      Flags          For future use
N    \param[in]      pKey        In case the ucf is encrypted the encryption key, otherwise NULL
N    \param[in]      pData       The file is download in data chunks, the chunk size should be aligned to 16 bytes, if no data Set to NULL
N    \param[in]      Len         The length of pData in bytes
N    \return         The return value is:
N                    - On error < 0 , contains the error number and extended error number
N                    - On success > 0, represent the number of bytes received
N                    - On successful end == 0 , when all file chunks are download
N    \sa
N    \note           belongs to \ref ext_api
N    \warning
N    \par            Example 
N    
N    - FS programming:
N    \code
N
N        //Return 0 for OK, else Error
N        _i32 ProgramImage( char* UcfFileName, char * KeyFileName )
N        {
N            #define PROGRAMMING_CHUNK_SIZE 4096
N            _i32 slRetVal = 0;
N            SlFsKey_t Key;
N            FILE *hostFileHandle = NULL;
N            _u16 bytesRead;
N            _u8 DataBuf[PROGRAMMING_CHUNK_SIZE];
N            FILE *KeyFileHandle = NULL;
N            short ErrorNum;
N            unsigned short ExtendedErrorNum;
N            time_t start,end;
N            double dif;
N            _u8* pKey = NULL;
N            errno_t err;
N
N            if (KeyFileName != "")
N            {
N                //Read key
N                err   = fopen_s( &KeyFileHandle, KeyFileName, "rb");
N                if (err != 0)
N                {
N                    return __LINE__;//error
N                }
N                fread((_u8*)&Key, 1, sizeof(SlFsKey_t), KeyFileHandle);
N                fclose(KeyFileHandle);
N                pKey = (_u8*)&Key;
N            }
N
N            // Downlaoding the Data with the key, the key can be set only in the first chunk,no need to download it with each chunk
N            if (UcfFileName != "")
N            {
N                //Read data
N                 err   = fopen_s( &hostFileHandle, UcfFileName, "rb");
N                if (err != 0)
N                {
N                    return __LINE__;//error
N                }
N
N                time (&start);
N
N                bytesRead = fread(DataBuf, 1, PROGRAMMING_CHUNK_SIZE, hostFileHandle);
N
N                while ( bytesRead  )
N                {
N                    slRetVal =  sl_FsProgram( DataBuf , bytesRead , (_u8*)pKey,  0 );
N                    if(slRetVal ==  SL_API_ABORTED)//timeout
N                    {
N                        return( slRetVal );
N                    }
N                    else if (slRetVal < 0 )//error
N                    {
N                        ErrorNum = (long)slRetVal >> 16;
N                        ExtendedErrorNum = (_u16)(slRetVal & 0xFFFF);
N                        printf("\tError sl_FsProgram = %d , %d \n", ErrorNum, ExtendedErrorNum);
N                        fclose(hostFileHandle);
N                        return( ErrorNum );
N                    }
N                    if(slRetVal == 0)//finished succesfully
N                        break;
N                    pKey = NULL;//no need to download the key with each chunk;
N                    bytesRead = fread(DataBuf, 1, PROGRAMMING_CHUNK_SIZE, hostFileHandle);
N                }
N
N
N                time (&end);
N                dif = difftime (end,start);
N            #ifdef PRINT
N                printf ("\tProgramming took %.2lf seconds to run.\n", dif );
N            #endif
N                //The file was downloaded but it was not detected by the programming as the EOF.
N                if((bytesRead == 0 ) && (slRetVal > 0 ))
N                {
N                    return __LINE__;//error
N                }
N
N
N                fclose(hostFileHandle);
N            }//if (UcfFileName != "")
N
N            //this scenario is in case the image was already "burned" to the SFLASH by external tool and only the key is downloaded
N            else if (KeyFileName != "")
N            {
N                slRetVal =  sl_FsProgram(NULL , 0 , (_u8*)pKey,  0 );
N                if (slRetVal < 0)//error
N                {
N                    ErrorNum = (long)slRetVal >> 16;
N                    ExtendedErrorNum = (_u16)slRetVal && 0xFF;;
N                    printf("\tError sl_FsProgram = %d , %d \n", ErrorNum, ExtendedErrorNum);
N                    fclose(hostFileHandle);
N                    return( ErrorNum );
N                }
N            }
N
N            if( slRetVal == 0 )
N            {
N                //Reset the nWP
N                sl_Stop(100);
N                Sleep(1000);
N                sl_Start(NULL, NULL, NULL);
N                Sleep(2000);
N             }
N
N            return slRetVal;
N
N        }
N
N    \endcode
N*/
N
N#if _SL_INCLUDE_FUNC(sl_FsProgram)
X#if (1)
N_i32   sl_FsProgram(const _u8*  pData , _u16 Len , const _u8 * pKey ,  _u32 Flags );
Xsigned long   sl_FsProgram(const unsigned char*  pData , unsigned short Len , const unsigned char * pKey ,  unsigned long Flags );
N#endif
N/*!
N    \brief The list of file names, the files are retrieve in chunks
N
N    \param[in, out] pIndex      The first chunk should start with value of  -1, afterwards the Index from the previous call should be set as input\n
N                                Returns current chunk intex, start the next chunk from that number
N    \param[in]      Count       Number of entries to retrieve
N    \param[in]      MaxEntryLen The total size of the buffer is Count * MaxEntryLen
N    \param[out]     pBuff       The buffer contains list of SlFileAttributes_t + file name
N    \param[in]      Flags       Is to retrieve file attributes see SlFileAttributes_t.
N    \return         The actual number of entries which are contained in the buffer. On error negative number which contains the error number.
N    \sa
N    \note           belongs to \ref ext_api
N    \warning
N    \par            Example
N
N    - Getting file list
N    \code
N        typedef struct
N        {
N            SlFileAttributes_t attribute;
N            char fileName[SL_FS_MAX_FILE_NAME_LENGTH];
N        }slGetfileList_t;
N    
N        #define COUNT 5
N    
N        void PrintFileListProperty(_u16 prop);
N    
N        INT32 GetFileList()
N        {
N            _i32 NumOfEntriesOrError = 1;
N            _i32 Index = -1;
N            slGetfileList_t File[COUNT];
N            _i32  i;
N            _i32 RetVal = 0;
N    
N            printf("%\n");
N            while( NumOfEntriesOrError > 0 )
N            {
N                NumOfEntriesOrError = sl_FsGetFileList( &Index, COUNT, (_u8)(SL_FS_MAX_FILE_NAME_LENGTH + sizeof(SlFileAttributes_t)), (unsigned char*)File, SL_FS_GET_FILE_ATTRIBUTES);
N                if (NumOfEntriesOrError < 0)
N                {
N                    RetVal = NumOfEntriesOrError;//error
N                    break;
N                }
N                for (i = 0; i < NumOfEntriesOrError; i++)
N                {
N                   printf("Name: %s\n", File[i].fileName);
N                   printf("AllocatedBlocks: %5d ",File[i].attribute.FileAllocatedBlocks);
N                   printf("MaxSize(byte): %5d \n", File[i].attribute.FileMaxSize);
N                   PrintFileListProperty((_u16)File[i].attribute.Properties);
N                   printf("%\n\n");
N               }
N           }
N           printf("%\n");
N           return RetVal;//0 means O.K
N       }
N   
N       void PrintFileListProperty(_u16 prop)
N       {
N           printf("Flags : ");
N           if (prop & SL_FS_INFO_MUST_COMMIT)
N               printf("Open file commit,");
N           if (prop & SL_FS_INFO_BUNDLE_FILE)
N               printf("Open bundle commit,");
N           if (prop & SL_FS_INFO_PENDING_COMMIT)
N               printf("Pending file commit,");
N           if (prop & SL_FS_INFO_PENDING_BUNDLE_COMMIT)
N                printf("Pending bundle commit,");
N            if (prop & SL_FS_INFO_SECURE)
N                printf("Secure,");
N            if (prop & SL_FS_INFO_NOT_FAILSAFE)
N                printf("File safe,");
N            if (prop & SL_FS_INFO_SYS_FILE)
N                printf("System,");
N            if (prop & SL_FS_INFO_NOT_VALID)
N                printf("No valid copy,");
N            if (prop & SL_FS_INFO_PUBLIC_WRITE)
N                printf("Public write,");
N            if (prop & SL_FS_INFO_PUBLIC_READ)
N                printf("Public read,");
N        }
N
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_FsGetFileList)
X#if (1)
N_i32  sl_FsGetFileList(_i32* pIndex, _u8 Count, _u8 MaxEntryLen , _u8* pBuff, SlFileListFlags_t Flags );
Xsigned long  sl_FsGetFileList(signed long* pIndex, unsigned char Count, unsigned char MaxEntryLen , unsigned char* pBuff, SlFileListFlags_t Flags );
N#endif
N
N/*!
N
N Close the Doxygen group.
N @}
N
N */
N
N#ifdef  __cplusplus
S}
N#endif /*  __cplusplus */
N
N#endif /*  __FS_H__ */
N
L 410 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N#include "sl_socket.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/sl_socket.h" 1
N/*
N * sl_socket.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N 
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N#include <ti/drivers/net/wifi/simplelink.h>
N
N#ifndef __SL_SOCKET_H__
N#define __SL_SOCKET_H__
N
N
N#ifdef    __cplusplus
Sextern "C" {
N#endif
N
N/*!
N    \defgroup Socket 
N    \short Controls standard client/server sockets programming options and capabilities
N
N*/
N/*!
N
N    \addtogroup Socket
N    @{
N
N*/
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N#undef SL_FD_SETSIZE
N#define SL_FD_SETSIZE                                         SL_MAX_SOCKETS  /* Number of sockets to select on - same is max sockets! */
N#define SL_BSD_SOCKET_ID_MASK                                 (0x1F)          /* Index using the LBS 4 bits for socket id 0-7 */
N
N/* Define some BSD protocol constants.  */
N#define SL_SOCK_STREAM                                        (1)   /* TCP Socket */
N#define SL_SOCK_DGRAM                                         (2)   /* UDP Socket */
N#define SL_SOCK_RAW                                           (3)   /* Raw socket */
N#define SL_IPPROTO_TCP                                        (6)   /* TCP Raw Socket */
N#define SL_IPPROTO_UDP                                        (17)  /* UDP Raw Socket */
N#define SL_IPPROTO_RAW                                        (255) /* Raw Socket */
N#define SL_SEC_SOCKET                                         (100) /* Secured Socket Layer (SSL,TLS) */
N
N/* Address families.  */
N#define     SL_AF_INET                                        (2)   /* IPv4 socket (UDP, TCP, etc) */
N#define     SL_AF_INET6                                       (3)   /* IPv6 socket (UDP, TCP, etc) */
N#define     SL_AF_RF                                          (6)   /* data include RF parameter, All layer by user (Wifi could be disconnected) */ 
N#define     SL_AF_PACKET                                      (17)
N/* Protocol families, same as address families.  */
N#define     SL_PF_INET                                        AF_INET
N#define     SL_PF_INET6                                       AF_INET6
N#define     SL_INADDR_ANY                                     (0)   /* bind any address */
N#define     SL_IN6ADDR_ANY                                    (0)
N
N
N/* Max payload size by protocol */
N#define SL_SOCKET_PAYLOAD_TYPE_MASK                           (0xF0)  /*4 bits type, 4 bits sockets id */
N#define SL_SOCKET_PAYLOAD_TYPE_RAW_TRANCEIVER                 (0x80)  /* 1536 bytes */
N
N/* SL_SOCKET_EVENT_CLASS_BSD user events */
N#define    SL_SOCKET_TX_FAILED_EVENT                          (1)
N#define    SL_SOCKET_ASYNC_EVENT                              (2)
N
N
N/* SL_SOCKET_EVENT_CLASS_BSD user trigger events */
N#define    SL_SOCKET_TRIGGER_EVENT_SELECT                     (1) 
N
N#define SL_SOL_SOCKET                                         (1)  /* Define the socket option category. */
N#define SL_IPPROTO_IP                                         (2)  /* Define the IP option category.     */
N#define SL_SOL_PHY_OPT                                        (3)  /* Define the PHY option category.    */
N
N#define SL_SO_RCVBUF                                          (8)  /* Setting TCP receive buffer size */
N#define SL_SO_KEEPALIVE                                       (9)  /* Connections are kept alive with periodic messages */
N#define SL_SO_LINGER                                          (13) /* Socket lingers on close pending remaining send/receive packets. */
N#define SL_SO_RCVTIMEO                                        (20) /* Enable receive timeout */
N#define SL_SO_NONBLOCKING                                     (24) /* Enable . disable nonblocking mode  */
N#define SL_SO_SECMETHOD                                       (25) /* security metohd */
N#define SL_SO_SECURE_MASK                                     (26) /* security mask */
N#define SL_SO_SECURE_FILES                                    (27) /* security files */
N#define SL_SO_CHANGE_CHANNEL                                  (28) /* This option is available only when transceiver started */
N#define SL_SO_SECURE_FILES_PRIVATE_KEY_FILE_NAME              (30) /* This option used to configue secure file */
N#define SL_SO_SECURE_FILES_CERTIFICATE_FILE_NAME              (31) /* This option used to configue secure file */
N#define SL_SO_SECURE_FILES_CA_FILE_NAME                       (32) /* This option used to configue secure file */
N#define SL_SO_SECURE_FILES_PEER_CERT_OR_DH_KEY_FILE_NAME      (33) /* This option used to configue secure file - in server mode DH params file, and in client mode peer cert for domain verification */
N#define SL_SO_STARTTLS                                        (35) /* initiate STARTTLS on non secure socket */
N#define SL_SO_SSL_CONNECTION_PARAMS                           (36) /* retrieve by getsockopt the connection params of the current SSL connection in to SlSockSSLConnectionParams_t*/
N#define SL_SO_KEEPALIVETIME                                   (37) /* keepalive time out  */
N#define SL_SO_SECURE_DISABLE_CERTIFICATE_STORE                (38) /* disable certificate store */
N#define SL_SO_RX_NO_IP_BOUNDARY                               (39) /* connectionless socket disable rx boundary */
N#define SL_SO_SECURE_ALPN                                     (40) /* set the ALPN bitmap list */
N#define SL_SO_SECURE_EXT_CLIENT_CHLNG_RESP                    (41) /*set external challange for client certificate */
N#define SL_SO_SECURE_DOMAIN_NAME_VERIFICATION                 (42) /* set a domain name for verification */
N
N#define SL_IP_MULTICAST_IF                                    (60) /* Specify outgoing multicast interface */
N#define SL_IP_MULTICAST_TTL                                   (61) /* Specify the TTL value to use for outgoing multicast packet. */
N#define SL_IP_ADD_MEMBERSHIP                                  (65) /* Join IPv4 multicast membership */
N#define SL_IP_DROP_MEMBERSHIP                                 (66) /* Leave IPv4 multicast membership */
N#define SL_IP_HDRINCL                                         (67) /* Raw socket IPv4 header included. */
N#define SL_IP_RAW_RX_NO_HEADER                                (68) /* Proprietary socket option that does not includeIPv4/IPv6 header (and extension headers) on received raw sockets*/
N#define SL_IP_RAW_IPV6_HDRINCL                                (69) /* Transmitted buffer over IPv6 socket contains IPv6 header. */
N#define SL_IPV6_ADD_MEMBERSHIP                                (70) /* Join IPv6 multicast membership */
N#define SL_IPV6_DROP_MEMBERSHIP                               (71) /* Leave IPv6 multicast membership */
N#define SL_IPV6_MULTICAST_HOPS                                (72) /* Specify the hops value to use for outgoing multicast packet. */
N
N#define SL_SO_PHY_RATE                                        (100) /* WLAN Transmit rate */
N#define SL_SO_PHY_TX_POWER                                    (101) /* TX Power level */  
N#define SL_SO_PHY_NUM_FRAMES_TO_TX                            (102) /* Number of frames to transmit */
N#define SL_SO_PHY_PREAMBLE                                    (103) /* Preamble for transmission */
N#define SL_SO_PHY_TX_INHIBIT_THRESHOLD                        (104) /* TX Inhibit Threshold (CCA) */
N#define SL_SO_PHY_TX_TIMEOUT                                  (105) /* TX timeout for Transceiver frames (lifetime) in miliseconds (max value is 100ms) */
N#define SL_SO_PHY_ALLOW_ACKS                                  (106) /* Enable sending ACKs in transceiver mode */
N
Ntypedef enum
N{
N    SL_TX_INHIBIT_THRESHOLD_MIN = 1,
N    SL_TX_INHIBIT_THRESHOLD_LOW = 2,
N    SL_TX_INHIBIT_THRESHOLD_DEFAULT = 3,
N    SL_TX_INHIBIT_THRESHOLD_MED = 4,
N    SL_TX_INHIBIT_THRESHOLD_HIGH = 5,
N    SL_TX_INHIBIT_THRESHOLD_MAX = 6
N} SlTxInhibitThreshold_e;
N
N#define SL_SO_SEC_METHOD_SSLV3                                       (0)  /* security metohd SSL v3*/
N#define SL_SO_SEC_METHOD_TLSV1                                       (1)  /* security metohd TLS v1*/
N#define SL_SO_SEC_METHOD_TLSV1_1                                     (2)  /* security metohd TLS v1_1*/
N#define SL_SO_SEC_METHOD_TLSV1_2                                     (3)  /* security metohd TLS v1_2*/
N#define SL_SO_SEC_METHOD_SSLv3_TLSV1_2                               (4)  /* use highest possible version from SSLv3 - TLS 1.2*/
N#define SL_SO_SEC_METHOD_DLSV1                                       (5)  /* security metohd DTL v1  */
N
N#define SL_SEC_MASK_SSL_RSA_WITH_RC4_128_SHA                         (1 << 0)
N#define SL_SEC_MASK_SSL_RSA_WITH_RC4_128_MD5                         (1 << 1)
N#define SL_SEC_MASK_TLS_RSA_WITH_AES_256_CBC_SHA                     (1 << 2)
N#define SL_SEC_MASK_TLS_DHE_RSA_WITH_AES_256_CBC_SHA                 (1 << 3)
N#define SL_SEC_MASK_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA               (1 << 4)
N#define SL_SEC_MASK_TLS_ECDHE_RSA_WITH_RC4_128_SHA                   (1 << 5)
N#define SL_SEC_MASK_TLS_RSA_WITH_AES_128_CBC_SHA256                  (1 << 6)
N#define SL_SEC_MASK_TLS_RSA_WITH_AES_256_CBC_SHA256                  (1 << 7)
N#define SL_SEC_MASK_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256            (1 << 8)
N#define SL_SEC_MASK_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256          (1 << 9)
N#define SL_SEC_MASK_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA             (1 << 10)
N#define SL_SEC_MASK_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA             (1 << 11)
N#define SL_SEC_MASK_TLS_RSA_WITH_AES_128_GCM_SHA256                  (1 << 12)
N#define SL_SEC_MASK_TLS_RSA_WITH_AES_256_GCM_SHA384                  (1 << 13)
N#define SL_SEC_MASK_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256              (1 << 14)
N#define SL_SEC_MASK_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384              (1 << 15)
N#define SL_SEC_MASK_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256            (1 << 16)
N#define SL_SEC_MASK_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384            (1 << 17)
N#define SL_SEC_MASK_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256          (1 << 18)
N#define SL_SEC_MASK_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384          (1 << 19)
N#define SL_SEC_MASK_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256    (1 << 20)
N#define SL_SEC_MASK_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256      (1 << 21)
N#define SL_SEC_MASK_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256        (1 << 22)
N
N#define SL_SEC_MASK_SECURE_DEFAULT                                   ((SL_SEC_MASK_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256  <<  1)  -  1)
N
N#define SL_SECURE_ALPN_H1                                            (1 << 0)
N#define SL_SECURE_ALPN_H2                                            (1 << 1)
N#define SL_SECURE_ALPN_H2C                                           (1 << 2)
N#define SL_SECURE_ALPN_H2_14                                         (1 << 3)
N#define SL_SECURE_ALPN_H2_16                                         (1 << 4)
N#define SL_SECURE_ALPN_FULL_LIST                                     ((SL_SECURE_ALPN_H2_16 << 1 ) - 1)
N
N#define SL_MSG_DONTWAIT                                              (0x00000008)  /* Nonblocking IO */
N
N/* AP DHCP Server - IP Release reason code */
N#define SL_IP_LEASE_PEER_RELEASE     (0)
N#define SL_IP_LEASE_PEER_DECLINE     (1)
N#define SL_IP_LEASE_EXPIRED          (2)
N
N/* possible types when receiving SL_SOCKET_ASYNC_EVENT*/
N#define SL_SSL_ACCEPT                                        (0) /* accept failed due to ssl issue ( tcp pass) */
N#define SL_RX_FRAGMENTATION_TOO_BIG                          (1) /* connection less mode, rx packet fragmentation > 16K, packet is being released */
N#define SL_OTHER_SIDE_CLOSE_SSL_DATA_NOT_ENCRYPTED           (2) /* remote side down from secure to unsecure */
N#define SL_SSL_NOTIFICATION_CONNECTED_SECURED                (3) /* STARTTLS success */
N#define SL_SSL_NOTIFICATION_HANDSHAKE_FAILED                 (4) /* STARTTLS handshake faild */
N#define SL_SSL_NOTIFICATION_WRONG_ROOT_CA                    (5) /* Root CA configured is wrong, the name is in SocketAsyncEvent.EventData.extraInfo */
N#define SL_SOCKET_ASYNC_EVENT_SSL_NOTIFICATION_WRONG_ROOT_CA (5)
N#define SL_MAX_ISSUER_AND_SUBJECT_NAME_LEN                   (16)
N
N/*****************************************************************************/
N/* Structure/Enum declarations                                               */
N/*****************************************************************************/
N
N/* Internet address   */
Ntypedef struct SlInAddr_t
N{
N#ifndef s_addr
N    _u32           s_addr;             /* Internet address 32 bits */
X    unsigned long           s_addr;              
N#else
S    union S_un {
S       struct { _u8 s_b1,s_b2,s_b3,s_b4; } S_un_b;
S       struct { _u16 s_w1,s_w2; } S_un_w;
S        _u32 S_addr;
S    } S_un;
N#endif
N}SlInAddr_t;
N
N/* IpV6 or Ipv6 EUI64 */
Ntypedef struct SlIn6Addr_t
N{
N    union 
N    {
N        _u8   _S6_u8[16];
X        unsigned char   _S6_u8[16];
N        _u32  _S6_u32[4];
X        unsigned long  _S6_u32[4];
N    } _S6_un;
N}SlIn6Addr_t;
N
N
N/* sockopt */
Ntypedef struct 
N{
N    _u32 KeepaliveEnabled; /* 0 = disabled;1 = enabled; default = 1*/
X    unsigned long KeepaliveEnabled;  
N}SlSockKeepalive_t;
N
Ntypedef struct 
N{
N    _u32 ReuseaddrEnabled; /* 0 = disabled; 1 = enabled; default = 1*/
X    unsigned long ReuseaddrEnabled;  
N}SlSockReuseaddr_t;
N
Ntypedef struct 
N{
N    _i32 RxIpNoBoundaryEnabled;  /* 0 = keep IP boundary; 1 = don`t keep ip boundary; default = 0; */
X    signed long RxIpNoBoundaryEnabled;   
N} SlSockRxNoIpBoundary_t;
N
Ntypedef struct 
N{
N    _u32 WinSize;          /* receive window size for tcp sockets  */
X    unsigned long WinSize;           
N}SlSockWinsize_t;
N
Ntypedef struct 
N{
N    _u32 NonBlockingEnabled;/* 0 = disabled;1 = enabled;default = 1*/
X    unsigned long NonBlockingEnabled; 
N}SlSockNonblocking_t;
N
Ntypedef struct
N{
N    _u8   Sd;
X    unsigned char   Sd;
N    _u8   Type;
X    unsigned char   Type;
N    _i16  Val;
X    signed short  Val;
N    _i8   pExtraInfo[128];
X    signed char   pExtraInfo[128];
N} SlSocketAsyncEvent_t;
N
Ntypedef struct
N{
N   _i16        Status;
X   signed short        Status;
N    _u8        Sd;
X    unsigned char        Sd;
N    _u8        Padding;
X    unsigned char        Padding;
N} SlSockTxFailEventData_t;
N
N
Ntypedef union
N{
N    SlSockTxFailEventData_t   SockTxFailData;
N    SlSocketAsyncEvent_t      SockAsyncData;
N} SlSockEventData_u;
N
N
Ntypedef struct
N{
N   _u32                    Event;
X   unsigned long                    Event;
N    SlSockEventData_u      SocketAsyncEvent;
N} SlSockEvent_t;
N
Ntypedef struct
N{
N   _u32         Event;
X   unsigned long         Event;
N   _u32         EventData;
X   unsigned long         EventData;
N} SlSockTriggerEvent_t;
N
N
Ntypedef struct
N{
N    _u32    SecureALPN;
X    unsigned long    SecureALPN;
N} SlSockSecureALPN_t;
N
Ntypedef struct
N{
N    _u32    SecureMask;
X    unsigned long    SecureMask;
N} SlSockSecureMask_t;
N
Ntypedef struct
N{
N    _u8     SecureMethod;
X    unsigned char     SecureMethod;
N} SlSockSecureMethod_t;
N
Ntypedef struct
N{
N    _u16 SubjectNameXoredSha1;
X    unsigned short SubjectNameXoredSha1;
N    _u16 IssuerNameXoredSha1;
X    unsigned short IssuerNameXoredSha1;
N    _i8  FromDate[8];
X    signed char  FromDate[8];
N    _i8  ToDate[8];
X    signed char  ToDate[8];
N    _i8  SubjectName[SL_MAX_ISSUER_AND_SUBJECT_NAME_LEN];
X    signed char  SubjectName[(16)];
N    _i8  IssuerName[SL_MAX_ISSUER_AND_SUBJECT_NAME_LEN];
X    signed char  IssuerName[(16)];
N    _i8  SubjectNameLen;
X    signed char  SubjectNameLen;
N    _i8  IssuerNameLen; 
X    signed char  IssuerNameLen; 
N    _i8  Padding[2];
X    signed char  Padding[2];
N} SlSockSSLCertInfo_t;
N
N
Ntypedef struct
N{
N    _u32     SecureVersion;              /* what version of SSL decided in the handshake    */
X    unsigned long     SecureVersion;               
N    _u32     SecureCipherSuit;           /* what Cipher Index was decided in the handshake  */
X    unsigned long     SecureCipherSuit;            
N    _u32     SecureIsPeerValidated;      /* was the other peer verified         */
X    unsigned long     SecureIsPeerValidated;       
N    _u32     SecureALPNChosenProtocol;    /* bit indicate one of the protocol defined above
X    unsigned long     SecureALPNChosenProtocol;    
N                                         SL_SECURE_ALPN_H1   
N                                         SL_SECURE_ALPN_H2   
N                                         SL_SECURE_ALPN_H2C  
N                                         SL_SECURE_ALPN_H2_14
N                                         SL_SECURE_ALPN_H2_16
N                                         */
N    SlSockSSLCertInfo_t SecurePeerCertinfo;
N} SlSockSSLConnectionParams_t;
N
Ntypedef enum
N{
N  SL_BSD_SECURED_PRIVATE_KEY_IDX = 0,
N  SL_BSD_SECURED_CERTIFICATE_IDX,
N  SL_BSD_SECURED_CA_IDX,
N  SL_BSD_SECURED_DH_IDX
N}SlSockSecureSocketFilesIndex_e;
N
Ntypedef struct 
N{
N    SlInAddr_t   imr_multiaddr;   /* The IPv4 multicast address to join */
N    SlInAddr_t   imr_interface;   /* The interface to use for this group */
N}SlSockIpMreq_t;
N
Ntypedef struct{
N    SlIn6Addr_t ipv6mr_multiaddr; /* IPv6 multicast address of group */
N    _u32        ipv6mr_interface; /*should be 0 to choose the default multicast interface*/
X    unsigned long        ipv6mr_interface;  
N}SlSockIpV6Mreq_t;
N
Ntypedef struct 
N{
N    _u32 l_onoff;                 /* 0 = disabled; 1 = enabled; default = 0;*/
X    unsigned long l_onoff;                  
N    _u32 l_linger;                /* linger time in seconds; default = 0;*/
X    unsigned long l_linger;                 
N}SlSocklinger_t;
N
N/* sockopt */
Ntypedef _i32   SlTime_t;
Xtypedef signed long   SlTime_t;
Ntypedef _i32   SlSuseconds_t;
Xtypedef signed long   SlSuseconds_t;
N
Ntypedef struct SlTimeval_t
N{
N    SlTime_t          tv_sec;     /* Seconds */
N    SlSuseconds_t     tv_usec;    /* Microseconds */
N}SlTimeval_t;
N
Ntypedef _u16 SlSocklen_t;
Xtypedef unsigned short SlSocklen_t;
N
N/* IpV4 socket address */
Ntypedef struct SlSockAddr_t
N{
N    _u16          sa_family;     /* Address family (e.g. , AF_INET)     */
X    unsigned short          sa_family;      
N    _u8           sa_data[14];  /* Protocol- specific address information*/
X    unsigned char           sa_data[14];   
N}SlSockAddr_t;
N
Ntypedef struct SlSockAddrIn6_t
N{
N    _u16           sin6_family;                 /* AF_INET6 || AF_INET6_EUI_48*/
X    unsigned short           sin6_family;                  
N    _u16           sin6_port;                   /* Transport layer port.  */
X    unsigned short           sin6_port;                    
N    _u32           sin6_flowinfo;               /* IPv6 flow information. */
X    unsigned long           sin6_flowinfo;                
N    SlIn6Addr_t    sin6_addr;                   /* IPv6 address. */
N    _u32           sin6_scope_id;               /* set of interfaces for a scope. */
X    unsigned long           sin6_scope_id;                
N}SlSockAddrIn6_t;
N
N/* Socket address, Internet style. */
N
Ntypedef struct SlSockAddrIn_t
N{
N    _u16              sin_family;         /* Internet Protocol (AF_INET). */
X    unsigned short              sin_family;          
N    _u16              sin_port;           /* Address port (16 bits). */
X    unsigned short              sin_port;            
N    SlInAddr_t        sin_addr;           /* Internet address (32 bits). */
N    _i8               sin_zero[8];        /* Not used. */
X    signed char               sin_zero[8];         
N}SlSockAddrIn_t;
N
Ntypedef struct
N{
N    _u8  SecureFiles[4];
X    unsigned char  SecureFiles[4];
N}SlSockSecureFiles_t;
N
Ntypedef struct SlFdSet_t  /* The select socket array manager */
N{ 
N   _u32        fd_array[(SL_FD_SETSIZE + (_u8)31)/(_u8)32]; /* Bit map of SOCKET Descriptors */
X   unsigned long        fd_array[((unsigned char)(16) + (unsigned char)31)/(unsigned char)32];  
N} SlFdSet_t;
N
Ntypedef struct
N{
N    _u8   Rate;               /* Recevied Rate  */
X    unsigned char   Rate;                
N    _u8   Channel;            /* The received channel*/
X    unsigned char   Channel;             
N    _i8   Rssi;               /* The computed RSSI value in db of current frame */
X    signed char   Rssi;                
N    _u8   Padding;            /* pad to align to 32 bits */
X    unsigned char   Padding;             
N    _u32  Timestamp;          /* Timestamp in microseconds */
X    unsigned long  Timestamp;           
N}SlTransceiverRxOverHead_t;
N
N
N
N/*****************************************************************************/
N/* Function prototypes                                                       */
N/*****************************************************************************/
N
N/*!
N
N    \brief Create an endpoint for communication
N 
N    The socket function creates a new socket of a certain socket type, identified 
N    by an integer number, and allocates system resources to it.\n
N    This function is called by the application layer to obtain a socket handle.
N 
N    \param[in] Domain           Specifies the protocol family of the created socket.
N                                For example:
N                                   - SL_AF_INET for network protocol IPv4
N                                   - SL_AF_INET6 for network protocol IPv6
N                                   - SL_AF_RF for starting transceiver mode. Notes: 
N                                        - sending and receiving any packet overriding 802.11 header
N                                        - for optimized power consumption the socket will be started in TX 
N                                          only mode until receive command is activated
N
N    \param[in] Type              specifies the communication semantic, one of:
N                                   - SL_SOCK_STREAM (reliable stream-oriented service or Stream Sockets)
N                                   - SL_SOCK_DGRAM (datagram service or Datagram Sockets)
N                                   - SL_SOCK_RAW (raw protocols atop the network layer)
N                                   - when used with AF_RF:
N                                      - SL_SOCK_DGRAM - L2 socket
N                                      - SL_SOCK_RAW - L1 socket - bypass WLAN CCA (Clear Channel Assessment)
N
N    \param[in] Protocol         specifies a particular transport to be used with 
N                                the socket. \n
N                                The most common are 
N                                    - SL_IPPROTO_TCP
N                                    - SL_IPPROTO_UDP 
N                                The value 0 may be used to select a default 
N                                protocol from the selected domain and type
N 
N    \return                     On success, socket handle that is used for consequent socket operations. \n
N                                A successful return code should be a positive number (int16)\n
N                                On error, a negative (int16) value will be returned specifying the error code.
N                                   - SL_EAFNOSUPPORT  - illegal domain parameter
N                                   - SL_EPROTOTYPE  - illegal type parameter
N                                   - SL_EACCES   - permission denied
N                                   - SL_ENSOCK  - exceeded maximal number of socket 
N                                   - SL_ENOMEM  - memory allocation error
N                                   - SL_EINVAL  - error in socket configuration
N                                   - SL_EPROTONOSUPPORT  - illegal protocol parameter
N                                   - SL_EOPNOTSUPP  - illegal combination of protocol and type parameters
N 
N    \sa                         sl_Close
N    \note                       belongs to \ref basic_api
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_Socket)
X#if (1)
N_i16 sl_Socket(_i16 Domain, _i16 Type, _i16 Protocol);
Xsigned short sl_Socket(signed short Domain, signed short Type, signed short Protocol);
N#endif
N
N/*!
N    \brief Gracefully close socket
N
N    This function causes the system to release resources allocated to a socket.  \n
N    In case of TCP, the connection is terminated.
N
N    \param[in] sd               Socket handle (received in sl_Socket)
N
N    \return                     Zero on success, or negative error code on failure
N
N    \sa                         sl_Socket
N    \note                       belongs to \ref ext_api
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_Close)
X#if (1)
N_i16 sl_Close(_i16 sd);
Xsigned short sl_Close(signed short sd);
N#endif
N
N/*!
N    \brief Accept a connection on a socket
N    
N    This function is used with connection-based socket types (SOCK_STREAM).\n
N    It extracts the first connection request on the queue of pending 
N    connections, creates a new connected socket, and returns a new file 
N    descriptor referring to that socket.\n
N    The newly created socket is not in the listening state. The 
N    original socket sd is unaffected by this call. \n
N    The argument sd is a socket that has been created with 
N    sl_Socket(), bound to a local address with sl_Bind(), and is 
N    listening for connections after a sl_Listen(). The argument \b 
N    \e addr is a pointer to a sockaddr structure. This structure 
N    is filled in with the address of the peer socket, as known to 
N    the communications layer. The exact format of the address 
N    returned addr is determined by the socket's address family. \n
N    The \b \e addrlen argument is a value-result argument: it 
N    should initially contain the size of the structure pointed to 
N    by addr, on return it will contain the actual length (in 
N    bytes) of the address returned.
N    
N    \param[in] sd               Socket descriptor (handle)
N    \param[out] addr            The argument addr is a pointer 
N                                to a sockaddr structure. This
N                                structure is filled in with the
N                                address of the peer socket, as
N                                known to the communications
N                                layer. The exact format of the
N                                address returned addr is
N                                determined by the socket's
N                                address\n
N                                sockaddr:\n - code for the
N                                address format. On this version
N                                only AF_INET is supported.\n -
N                                socket address, the length
N                                depends on the code format
N    \param[out] addrlen         The addrlen argument is a value-result 
N                                argument: it should initially contain the
N                                size of the structure pointed to by addr
N    
N    \return                     On success, a socket handle.\n
N                                On a non-blocking accept a possible negative value is SL_EAGAIN.\n
N                                On failure, negative error code.\n
N                                SL_POOL_IS_EMPTY may be return in case there are no resources in the system
N                                 In this case try again later or increase MAX_CONCURRENT_ACTIONS
N    
N    \sa                         sl_Socket  sl_Bind  sl_Listen
N    \note                       Belongs to \ref server_side
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_Accept)
X#if (1)
N_i16 sl_Accept(_i16 sd, SlSockAddr_t *addr, SlSocklen_t *addrlen);
Xsigned short sl_Accept(signed short sd, SlSockAddr_t *addr, SlSocklen_t *addrlen);
N#endif
N
N/*!
N    \brief Assign a name to a socket
N 
N    This function gives the socket the local address addr.
N    addr is addrlen bytes long. Traditionally, this is called
N    When a socket is created with socket, it exists in a name
N    space (address family) but has no name assigned.
N    It is necessary to assign a local address before a SOCK_STREAM
N    socket may receive connections.
N 
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] addr             Specifies the destination 
N                                addrs\n sockaddr:\n - code for
N                                the address format. On this
N                                version only SL_AF_INET is
N                                supported.\n - socket address,
N                                the length depends on the code
N                                format
N    \param[in] addrlen          Contains the size of the structure pointed to by addr
N 
N    \return                     Zero on success, or negative error code on failure    
N 
N    \sa                         sl_Socket  sl_Accept sl_Listen
N    \note                       belongs to \ref basic_api
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_Bind)
X#if (1)
N_i16 sl_Bind(_i16 sd, const SlSockAddr_t *addr, _i16 addrlen);
Xsigned short sl_Bind(signed short sd, const SlSockAddr_t *addr, signed short addrlen);
N#endif
N
N/*!
N    \brief Listen for connections on a socket
N 
N    The willingness to accept incoming connections and a queue
N    limit for incoming connections are specified with listen(),
N    and then the connections are accepted with accept.
N    The listen() call applies only to sockets of type SOCK_STREAM
N    The backlog parameter defines the maximum length the queue of
N    pending connections may grow to. 
N 
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] backlog          Specifies the listen queue depth. 
N
N    \return                     Zero on success, or negative error code on failure 
N 
N    \sa                         sl_Socket  sl_Accept  sl_Bind
N    \note                       Belongs to \ref server_side
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_Listen)
X#if (1)
N_i16 sl_Listen(_i16 sd, _i16 backlog);
Xsigned short sl_Listen(signed short sd, signed short backlog);
N#endif
N
N/*!
N    \brief Initiate a connection on a socket 
N   
N    Function connects the socket referred to by the socket 
N    descriptor sd, to the address specified by addr. The addrlen 
N    argument specifies the size of addr. The format of the 
N    address in addr is determined by the address space of the 
N    socket. If it is of type SOCK_DGRAM, this call specifies the 
N    peer with which the socket is to be associated; this address 
N    is that to which datagrams are to be sent, and the only 
N    address from which datagrams are to be received.  If the 
N    socket is of type SOCK_STREAM, this call attempts to make a 
N    connection to another socket. The other socket is specified 
N    by address, which is an address in the communications space 
N    of the socket. 
N   
N   
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] addr             Specifies the destination addr\n
N                                sockaddr:\n - code for the
N                                address format. On this version
N                                only AF_INET is supported.\n -
N                                socket address, the length
N                                depends on the code format
N   
N    \param[in] addrlen          Contains the size of the structure pointed 
N                                to by addr
N 
N    \return                     On success, a socket handle.\n
N                                On a non-blocking connect a possible negative value is SL_EALREADY.
N                                On failure, negative value.\n
N                                SL_POOL_IS_EMPTY may be return in case there are no resources in the system
N                                  In this case try again later or increase MAX_CONCURRENT_ACTIONS
N 
N    \sa                         sl_Socket
N    \note                       belongs to \ref client_side
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_Connect)
X#if (1)
N_i16 sl_Connect(_i16 sd, const SlSockAddr_t *addr, _i16 addrlen);
Xsigned short sl_Connect(signed short sd, const SlSockAddr_t *addr, signed short addrlen);
N#endif
N
N/*!
N    \brief Monitor socket activity
N   
N    Select allow a program to monitor multiple file descriptors,
N    waiting until one or more of the file descriptors become 
N    "ready" for some class of I/O operation.
N    If trigger mode is enabled the active fdset is the one that was retrieved in the first triggered call.
N    To enable the trigger mode, an handler must be statically registered as slcb_SocketTriggerEventHandler in user.h
N   
N   
N    \param[in]  nfds        The highest-numbered file descriptor in any of the
N                            three sets, plus 1.
N    \param[out] readsds     Socket descriptors list for read monitoring and accept monitoring
N    \param[out] writesds    Socket descriptors list for connect monitoring only, write monitoring is not supported
N    \param[out] exceptsds   Socket descriptors list for exception monitoring, not supported.
N    \param[in]  timeout     Is an upper bound on the amount of time elapsed
N                            before select() returns. Null or above 0xffff seconds means 
N                            infinity timeout. The minimum timeout is 10 milliseconds,
N                            less than 10 milliseconds will be set automatically to 10 milliseconds. 
N                            Max microseconds supported is 0xfffc00.
N                            In trigger mode the timout fields must be set to zero.
N   
N    \return                 On success, select()  returns the number of
N                            file descriptors contained in the three returned
N                            descriptor sets (that is, the total number of bits that
N                            are set in readfds, writefds, exceptfds) which may be
N                            zero if the timeout expires before anything interesting
N                            happens.\n On error, a negative value is returned.
N                            readsds - return the sockets on which read request will
N                            return without delay with valid data.\n
N                            writesds - return the sockets on which write request 
N                            will return without delay.\n
N                            exceptsds - return the sockets closed recently. \n
N                            SL_POOL_IS_EMPTY may be return in case there are no resources in the system
N                            In this case try again later or increase MAX_CONCURRENT_ACTIONS
N 
N    \sa     sl_Socket
N    \note   If the timeout value set to less than 10ms it will automatically set 
N            to 10ms to prevent overload of the system\n
N            Belongs to \ref basic_api
N            
N            Several threads can call sl_Select at the same time.\b
N            Calling this API while the same command is called from another thread, may result
N                in one of the following scenarios:
N            1. The command will be executed alongside other select callers (success).
N            2. The command will wait (internal) until the previous sl_select finish, and then be executed.
N            3. There are not enough resources and SL_POOL_IS_EMPTY error will return. 
N            In this case, MAX_CONCURRENT_ACTIONS can be increased (result in memory increase) or try
N            again later to issue the command.
N
N            In case all the user sockets are open, sl_Select will exhibit the behaviour mentioned in (2)
N            This is due to the fact sl_select supports multiple callers by utilizing one user socket internally.
N            User who wish to ensure multiple select calls at any given time, must reserve one socket out of the 16 given.
N   
N    \warning
N            multiple select calls aren't supported when trigger mode is active. The two are mutually exclusive.
N*/
N#if _SL_INCLUDE_FUNC(sl_Select)
X#if (1)
N_i16 sl_Select(_i16 nfds, SlFdSet_t *readsds, SlFdSet_t *writesds, SlFdSet_t *exceptsds, struct SlTimeval_t *timeout);
Xsigned short sl_Select(signed short nfds, SlFdSet_t *readsds, SlFdSet_t *writesds, SlFdSet_t *exceptsds, struct SlTimeval_t *timeout);
N#endif
N
N/*!
N    \cond DOXYGEN_IGNORE
N*/
N
N/*!
N    \brief Select's SlFdSet_t SET function
N   
N    Sets current socket descriptor on SlFdSet_t container
N*/
Nvoid SL_SOCKET_FD_SET(_i16 fd, SlFdSet_t *fdset);
Xvoid SL_SOCKET_FD_SET(signed short fd, SlFdSet_t *fdset);
N
N/*!
N    \brief Select's SlFdSet_t CLR function
N   
N    Clears current socket descriptor on SlFdSet_t container
N*/
Nvoid SL_SOCKET_FD_CLR(_i16 fd, SlFdSet_t *fdset);
Xvoid SL_SOCKET_FD_CLR(signed short fd, SlFdSet_t *fdset);
N
N
N/*!
N    \brief Select's SlFdSet_t ISSET function
N   
N    Checks if current socket descriptor is set (TRUE/FALSE)
N
N    \return            Returns TRUE if set, FALSE if unset
N
N*/
N_i16  SL_SOCKET_FD_ISSET(_i16 fd, SlFdSet_t *fdset);
Xsigned short  SL_SOCKET_FD_ISSET(signed short fd, SlFdSet_t *fdset);
N
N/*!
N    \brief Select's SlFdSet_t ZERO function
N   
N    Clears all socket descriptors from SlFdSet_t
N*/
Nvoid SL_SOCKET_FD_ZERO(SlFdSet_t *fdset);
N
N/*!
N    \endcond
N*/
N
N
N/*!
N    \brief Set socket options-
N 
N    This function manipulate the options associated with a socket.\n
N    Options may exist at multiple protocol levels; they are always
N    present at the uppermost socket level.\n
N 
N    When manipulating socket options the level at which the option resides
N    and the name of the option must be specified.  To manipulate options at
N    the socket level, level is specified as SOL_SOCKET.  To manipulate
N    options at any other level the protocol number of the appropriate proto-
N    col controlling the option is supplied.  For example, to indicate that an
N    option is to be interpreted by the TCP protocol, level should be set to
N    the protocol number of TCP; \n
N 
N    The parameters optval and optlen are used to access optval - 
N    ues for setsockopt().  For getsockopt() they identify a 
N    buffer in which the value for the requested option(s) are to 
N    be returned.  For getsockopt(), optlen is a value-result 
N    parameter, initially containing the size of the buffer 
N    pointed to by option_value, and modified on return to 
N    indicate the actual size of the value returned.  If no option 
N    value is to be supplied or returned, option_value may be 
N    NULL.
N   
N    \param[in] sd               Socket handle
N    \param[in] level            Defines the protocol level for this option
N                                - <b>SL_SOL_SOCKET</b>   Socket level configurations (L4, transport layer)
N                                - <b>SL_IPPROTO_IP</b>   IP level configurations (L3, network layer)
N                                - <b>SL_SOL_PHY_OPT</b>  Link level configurations (L2, link layer)
N    \param[in] optname          Defines the option name to interrogate
N                                - <b>SL_SOL_SOCKET</b>
N                                - <b>SL_SO_KEEPALIVE</b>  \n
N                                                Enable/Disable periodic keep alive.
N                                                Keeps TCP connections active by enabling the periodic transmission of messages \n
N                                                Timeout is 5 minutes.\n
N                                                Default: Enabled \n
N                                                This options takes SlSockKeepalive_t struct as parameter
N                                - <b>SL_SO_KEEPALIVETIME</b>  \n
N                                                Set keep alive timeout.
N                                                Value is in seconds \n
N                                                Default: 5 minutes \n
N                                - <b>SL_SO_RX_NO_IP_BOUNDARY</b>  \n
N                                                Enable/Disable rx ip boundary.
N                                                In connectionless socket (udp/raw), unread data is dropped (when recvfrom len parameter < data size), Enable this option in order to read the left data on the next recvfrom iteration 
N                                                Default: Disabled, IP boundary kept,  \n
N                                                This options takes SlSockRxNoIpBoundary_t struct as parameter                                               
N                                - <b>SL_SO_RCVTIMEO</b>  \n
N                                                Sets the timeout value that specifies the maximum amount of time an input function waits until it completes. \n
N                                                Default: No timeout \n
N                                                This options takes SlTimeval_t struct as parameter
N                                - <b>SL_SO_RCVBUF</b>  \n
N                                                Sets tcp max recv window size. \n
N                                                This options takes SlSockWinsize_t struct as parameter
N                                - <b>SL_SO_NONBLOCKING</b> \n
N                                                Sets socket to non-blocking operation Impacts: connect, accept, send, sendto, recv and recvfrom. \n
N                                                Default: Blocking.
N                                                This options takes SlSockNonblocking_t struct as parameter
N                                - <b>SL_SO_SECMETHOD</b> \n
N                                                Sets method to tcp secured socket (SL_SEC_SOCKET) \n
N                                                Default: SL_SO_SEC_METHOD_SSLv3_TLSV1_2 \n
N                                                This options takes SlSockSecureMethod_t struct as parameter
N                                - <b>SL_SO_SECURE_MASK</b> \n
N                                                Sets specific cipher to tcp secured socket (SL_SEC_SOCKET) \n
N                                                Default: "Best" cipher suitable to method \n
N                                                This options takes SlSockSecureMask_t struct as parameter
N                                - <b>SL_SO_SECURE_FILES_CA_FILE_NAME</b> \n
N                                                Map secured socket to CA file by name \n
N                                                This options takes <b>_u8</b> buffer as parameter 
N                                - <b>SL_SO_SECURE_FILES_PRIVATE_KEY_FILE_NAME</b> \n
N                                                Map secured socket to private key by name \n
N                                                This options takes <b>_u8</b> buffer as parameter 
N                                - <b>SL_SO_SECURE_FILES_CERTIFICATE_FILE_NAME</b> \n
N                                                Map secured socket to certificate file by name \n
N                                                This options takes <b>_u8</b> buffer as parameter 
N                                - <b>SL_SO_SECURE_FILES_DH_KEY_FILE_NAME</b> \n
N                                                Map secured socket to Diffie Hellman file by name \n
N                                                This options takes <b>_u8</b> buffer as parameter 
N                                - <b>SL_SO_CHANGE_CHANNEL</b> \n
N                                                Sets channel in transceiver mode.
N                                                This options takes <b>_u32</b> as channel number parameter
N                                - <b>SL_SO_SECURE_ALPN</b> \n
N                                                Sets the ALPN list. the parameter is a bit map consist of or of the following values -
N                                                SL_SECURE_ALPN_H1       
N                                                SL_SECURE_ALPN_H2       
N                                                SL_SECURE_ALPN_H2C      
N                                                SL_SECURE_ALPN_H2_14    
N                                                SL_SECURE_ALPN_H2_16    
N                                                SL_SECURE_ALPN_FULL_LIST
N                                - <b>SL_IPPROTO_IP</b> 
N                                - <b>SL_IP_MULTICAST_TTL</b> \n
N                                                Set the time-to-live value of outgoing multicast packets for this socket. \n
N                                                This options takes <b>_u8</b> as parameter 
N                                - <b>SL_IP_ADD_MEMBERSHIP</b> \n
N                                                UDP socket, Join a multicast group. \n
N                                                This options takes SlSockIpMreq_t struct as parameter
N                                - <b>SL_IP_DROP_MEMBERSHIP</b> \n
N                                                UDP socket, Leave a multicast group \n
N                                                This options takes SlSockIpMreq_t struct as parameter
N                                - <b>SL_IP_RAW_RX_NO_HEADER</b> \n                 
N                                                Raw socket remove IP header from received data. \n
N                                                Default: data includes ip header \n
N                                                This options takes <b>_u32</b> as parameter
N                                - <b>SL_IP_HDRINCL</b> \n
N                                                RAW socket only, the IPv4 layer generates an IP header when sending a packet unless \n
N                                                the IP_HDRINCL socket option is enabled on the socket.    \n
N                                                When it is enabled, the packet must contain an IP header. \n
N                                                Default: disabled, IPv4 header generated by Network Stack \n
N                                                This options takes <b>_u32</b> as parameter
N                                - <b>SL_IP_RAW_IPV6_HDRINCL</b> (inactive) \n
N                                                RAW socket only, the IPv6 layer generates an IP header when sending a packet unless \n
N                                                the IP_HDRINCL socket option is enabled on the socket. When it is enabled, the packet must contain an IP header \n
N                                                Default: disabled, IPv4 header generated by Network Stack \n
N                                                This options takes <b>_u32</b> as parameter
N                                - <b>SL_SOL_PHY_OPT</b>
N                                - <b>SL_SO_PHY_RATE</b> \n
N                                                RAW socket, set WLAN PHY transmit rate \n
N                                                The values are based on SlWlanRateIndex_e    \n
N                                                This options takes <b>_u32</b> as parameter
N                                - <b>SL_SO_PHY_TX_POWER</b> \n
N                                                RAW socket, set WLAN PHY TX power \n
N                                                Valid rage is 1-15 \n
N                                                This options takes <b>_u32</b> as parameter
N                                - <b>SL_SO_PHY_NUM_FRAMES_TO_TX</b> \n
N                                                RAW socket, set number of frames to transmit in transceiver mode.
N                                                Default: 1 packet
N                                                This options takes <b>_u32</b> as parameter
N                                - <b>SL_SO_PHY_PREAMBLE</b> \n  
N                                                RAW socket, set WLAN PHY preamble for Long/Short\n
N                                                This options takes <b>_u32</b> as parameter      
N                                - <b>SL_SO_PHY_TX_INHIBIT_THRESHOLD</b> \n  
N                                                RAW socket, set WLAN Tx  Set CCA threshold. \n
N                                                The values are based on SlTxInhibitThreshold_e    \n
N                                                This options takes <b>_u32</b> as parameter 
N                                - <b>SL_SO_PHY_TX_TIMEOUT</b> \n  
N                                                RAW socket, set WLAN Tx  changes the TX timeout (lifetime) of transceiver frames. \n   
N                                                Value in Ms, maximum value is 10ms    \n
N                                                This options takes <b>_u32</b> as parameter 
N                                - <b>SL_SO_PHY_ALLOW_ACKS </b> \n  
N                                                RAW socket, set WLAN Tx  Enable\Disable sending ACKs in transceiver mode \n  
N                                                0 = disabled / 1 = enabled    \n
N                                                This options takes <b>_u32</b> as parameter 
N                                - <b>SL_SO_LINGER</b> \n
N                                                Socket lingers on close pending remaining send/receive packetst\n
N                                - <b>SL_SO_SECURE_EXT_CLIENT_CHLNG_RESP</b> \n
N                                                Set with no parameter to indicate that the client uses external signature using netapp requesrt.\n
N                                                needs netapp request handler\n
N                                - <b>SL_SO_SECURE_DOMAIN_NAME_VERIFICATION </b>\n
N                                                Set a domain name, to check in ssl client connection.
N
N    \param[in] optval           Specifies a value for the option
N    \param[in] optlen           Specifies the length of the 
N        option value
N 
N    \return                     Zero on success, or negative error code on failure
N    
N    \par Persistent                 
N                All params are <b>Non- Persistent</b> 
N    \sa     sl_getsockopt
N    \note   Belongs to \ref basic_api  
N    \warning
N    \par   Examples
N
N    - SL_SO_KEEPALIVE (disable Keepalive):
N    \code
N        SlSockKeepalive_t enableOption;
N        enableOption.KeepaliveEnabled = 0;
N        sl_SetSockOpt(SockID,SL_SOL_SOCKET,SL_SO_KEEPALIVE, (_u8 *)&enableOption,sizeof(enableOption));  
N    \endcode
N    <br>
N
N    - SL_SO_KEEPALIVETIME (Set Keepalive timeout):
N    \code   
N        _i16 Status;
N        _u32 TimeOut = 120;
N        sl_SetSockOpt(Sd, SL_SOL_SOCKET, SL_SO_KEEPALIVETIME,( _u8*) &TimeOut, sizeof(TimeOut));
N    \endcode
N    <br>
N
N    - SL_SO_RX_NO_IP_BOUNDARY (disable boundary):
N    \code
N        SlSockRxNoIpBoundary_t enableOption;
N        enableOption.RxIpNoBoundaryEnabled = 1;
N        sl_SetSockOpt(SockID,SL_SOL_SOCKET,SL_SO_RX_NO_IP_BOUNDARY, (_u8 *)&enableOption,sizeof(enableOption));  
N    \endcode
N    <br>
N
N    - SL_SO_RCVTIMEO:
N    \code
N        struct SlTimeval_t timeVal;
N        timeVal.tv_sec =  1;             // Seconds
N        timeVal.tv_usec = 0;             // Microseconds. 10000 microseconds resolution
N        sl_SetSockOpt(SockID,SL_SOL_SOCKET,SL_SO_RCVTIMEO, (_u8 *)&timeVal, sizeof(timeVal));    // Enable receive timeout 
N    \endcode
N    <br>
N
N    - SL_SO_RCVBUF:
N    \code
N           SlSockWinsize_t size;
N           size.Winsize = 3000;  // bytes
N           sl_SetSockOpt(SockID,SL_SOL_SOCKET,SL_SO_RCVBUF, (_u8 *)&size, sizeof(size));
N    \endcode
N    <br>
N
N    - SL_SO_NONBLOCKING:
N    \code
N    
N           SlSockNonblocking_t enableOption;
N           enableOption.NonblockingEnabled = 1;
N           sl_SetSockOpt(SockID,SL_SOL_SOCKET,SL_SO_NONBLOCKING, (_u8 *)&enableOption,sizeof(enableOption)); // Enable/disable nonblocking mode
N    \endcode
N    <br>
N
N    - SL_SO_SECMETHOD:
N    \code
N           SlSockSecureMethod_t method;
N           method.SecureMethod = SL_SO_SEC_METHOD_SSLV3;                                 // security method we want to use
N           SockID = sl_Socket(SL_AF_INET,SL_SOCK_STREAM, SL_SEC_SOCKET);
N           sl_SetSockOpt(SockID, SL_SOL_SOCKET, SL_SO_SECMETHOD, (_u8 *)&method, sizeof(method));
N    \endcode
N    <br>
N
N    - SL_SO_SECURE_MASK:
N    \code 
N           SlSockSecureMask_t cipher;
N           cipher.SecureMask = SL_SEC_MASK_SSL_RSA_WITH_RC4_128_SHA;                   // cipher type
N           SockID = sl_Socket(SL_AF_INET,SL_SOCK_STREAM, SL_SEC_SOCKET);
N           sl_SetSockOpt(SockID, SL_SOL_SOCKET, SL_SO_SECURE_MASK,(_u8 *)&cipher, sizeof(cipher));
N    \endcode
N    <br>
N
N    - SL_SO_SECURE_FILES_CA_FILE_NAME:
N    \code               
N        sl_SetSockOpt(SockID,SL_SOL_SOCKET,SL_SO_SECURE_FILES_CA_FILE_NAME,"exuifaxCaCert.der",strlen("exuifaxCaCert.der"));
N    \endcode
N    <br>
N
N    - SL_SO_SECURE_FILES_PRIVATE_KEY_FILE_NAME;
N    \code           
N        sl_SetSockOpt(SockID,SL_SOL_SOCKET,SL_SO_SECURE_FILES_PRIVATE_KEY_FILE_NAME,"myPrivateKey.der",strlen("myPrivateKey.der"));
N    \endcode
N    <br>
N
N    - SL_SO_SECURE_FILES_CERTIFICATE_FILE_NAME:
N     \code
N        sl_SetSockOpt(SockID,SL_SOL_SOCKET,SL_SO_SECURE_FILES_CERTIFICATE_FILE_NAME,"myCertificate.der",strlen("myCertificate.der"));
N     \endcode
N     <br>
N
N    - SL_SO_SECURE_FILES_DH_KEY_FILE_NAME:
N     \code
N        sl_SetSockOpt(SockID,SL_SOL_SOCKET,SL_SO_SECURE_FILES_DH_KEY_FILE_NAME,"myDHinServerMode.der",strlen("myDHinServerMode.der"));
N     \endcode
N     <br>
N
N    - SL_IP_MULTICAST_TTL:
N     \code
N        _u8 ttl = 20;
N        sl_SetSockOpt(SockID, SL_IPPROTO_IP, SL_IP_MULTICAST_TTL, &ttl, sizeof(ttl));
N     \endcode
N     <br>
N
N    - SL_IP_ADD_MEMBERSHIP:
N     \code
N        SlSockIpMreq_t mreq;
N        sl_SetSockOpt(SockID, SL_IPPROTO_IP, SL_IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
N    \endcode
N    <br>
N
N    - SL_IP_DROP_MEMBERSHIP:
N    \code
N        SlSockIpMreq_t mreq;
N        sl_SetSockOpt(SockID, SL_IPPROTO_IP, SL_IP_DROP_MEMBERSHIP, &mreq, sizeof(mreq));
N    \endcode
N    <br>
N
N    - SL_SO_CHANGE_CHANNEL:
N    \code
N        _u32 newChannel = 6; // range is 1-13
N        sl_SetSockOpt(SockID, SL_SOL_SOCKET, SL_SO_CHANGE_CHANNEL, &newChannel, sizeof(newChannel));  
N    \endcode
N    <br>
N
N    - SL_SO_SECURE_ALPN:
N    \code
N        SlSockSecureALPN_t alpn;
N        alpn.SecureALPN = SL_SECURE_ALPN_H2 | SL_SECURE_ALPN_H2_14;
N        sl_SetSockOpt(SockID, SL_SOL_SOCKET, SL_SO_SECURE_ALPN, &alpn, sizeof(SlSockSecureALPN_t));  
N    \endcode
N    <br>
N
N    -   SL_IP_RAW_RX_NO_HEADER:
N    \code
N        _u32 header = 1;  // remove ip header
N        sl_SetSockOpt(SockID, SL_IPPROTO_IP, SL_IP_RAW_RX_NO_HEADER, &header, sizeof(header));
N    \endcode
N    <br>
N
N    - SL_IP_HDRINCL:
N    \code
N        _u32 header = 1;
N        sl_SetSockOpt(SockID, SL_IPPROTO_IP, SL_IP_HDRINCL, &header, sizeof(header));
N    \endcode
N    <br>
N
N    - SL_IP_RAW_IPV6_HDRINCL:
N    \code
N        _u32 header = 1;
N        sl_SetSockOpt(SockID, SL_IPPROTO_IP, SL_IP_RAW_IPV6_HDRINCL, &header, sizeof(header));
N    \endcode
N    <br>
N
N    -   SL_SO_PHY_RATE:
N    \code
N        _u32 rate = 6; // see wlan.h SlWlanRateIndex_e for values
N        sl_SetSockOpt(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_RATE, &rate, sizeof(rate));  
N    \endcode
N    <br>
N
N    - SL_SO_PHY_TX_POWER:
N    \code
N        _u32 txpower = 1; // valid range is 1-15
N        sl_SetSockOpt(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_TX_POWER, &txpower, sizeof(txpower));
N    \endcode
N    <br>
N
N    - SL_SO_PHY_NUM_FRAMES_TO_TX:
N    \code
N        _u32 numframes = 1;
N        sl_SetSockOpt(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_NUM_FRAMES_TO_TX, &numframes, sizeof(numframes));
N    \endcode
N    <br>
N
N    - SL_SO_PHY_PREAMBLE:
N    \code
N        _u32 preamble = 1;
N        sl_SetSockOpt(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_PREAMBLE, &preamble, sizeof(preamble));
N    \endcode
N    <br>
N
N    - SL_SO_PHY_TX_INHIBIT_THRESHOLD:
N    \code
N        _u32 thrshld = SL_TX_INHIBIT_THRESHOLD_MED;
N        sl_SetSockOpt(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_TX_INHIBIT_THRESHOLD , &thrshld, sizeof(thrshld));
N    \endcode
N    <br>
N
N    - SL_SO_PHY_TX_TIMEOUT:
N    \code
N        _u32 timeout = 50;
N        sl_SetSockOpt(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_TX_TIMEOUT  , &timeout, sizeof(timeout));
N    \endcode
N    <br>
N    
N    - SL_SO_PHY_ALLOW_ACKS:
N    \code
N        _u32 acks = 1; // 0 = disabled / 1 = enabled
N        sl_SetSockOpt(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_ALLOW_ACKS, &acks, sizeof(acks));
N    \endcode
N    <br>
N    
N    - SL_SO_LINGER:
N    \code
N        SlSocklinger_t linger;
N        linger.l_onoff = 1;
N        linger.l_linger = 10;
N        sl_SetSockOpt(SockID, SL_SOL_SOCKET, SL_SO_LINGER, &linger, sizeof(linger));
N    \endcode
N    <br>
N
N    - SL_SO_SECURE_EXT_CLIENT_CHLNG_RESP:
N    \code
N        int dummy;
N        sl_SetSockOpt(SockID, SL_SOL_SOCKET, SL_SO_SECURE_EXT_CLIENT_CHLNG_RESP, &dummy, sizeof(dummy));
N    \endcode
N    <br>
N
N    - SL_SO_SECURE_DOMAIN_NAME_VERIFICATION:
N    \code
N        sl_SetSockOpt(SockID,SL_SOL_SOCKET,SL_SO_SECURE_DOMAIN_NAME_VERIFICATION,"www.google.co.il",strlen("www.google.co.il"));
N    \endcode
N              
N*/
N#if _SL_INCLUDE_FUNC(sl_SetSockOpt)
X#if (1)
N_i16 sl_SetSockOpt(_i16 sd, _i16 level, _i16 optname, const void *optval, SlSocklen_t optlen);
Xsigned short sl_SetSockOpt(signed short sd, signed short level, signed short optname, const void *optval, SlSocklen_t optlen);
N#endif
N
N/*!
N    \brief Get socket options
N    
N    This function manipulate the options associated with a socket.
N    Options may exist at multiple protocol levels; they are always
N    present at the uppermost socket level.\n
N    
N    When manipulating socket options the level at which the option resides
N    and the name of the option must be specified.  To manipulate options at
N    the socket level, level is specified as SOL_SOCKET.  To manipulate
N    options at any other level the protocol number of the appropriate
N    protocol controlling the option is supplied.  For example, to indicate
N    that an option is to be interpreted by the TCP protocol, level should
N    be set to the protocol number of TCP; \n
N    
N    The parameters optval and optlen are used to access optvalues
N    for setsockopt().  For getsockopt() they identify a 
N    buffer in which the value for the requested option(s) are to 
N    be returned.  For getsockopt(), optlen is a value-result 
N    parameter, initially containing the size of the buffer 
N    pointed to by option_value, and modified on return to 
N    indicate the actual size of the value returned.  If no option 
N    value is to be supplied or returned, option_value may be 
N    NULL. 
N    
N    
N    \param[in]  sd              Socket handle
N    \param[in]  level           Defines the protocol level for this option
N    \param[in]  optname         defines the option name to interrogate
N    \param[out] optval          Specifies a value for the option
N    \param[out] optlen          Specifies the length of the 
N                                option value
N    
N    \return                     Zero on success, or negative error code on failure
N    \sa     sl_SetSockOpt
N    \note   See sl_SetSockOpt
N            Belongs to \ref ext_api
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_GetSockOpt)
X#if (1)
N_i16 sl_GetSockOpt(_i16 sd, _i16 level, _i16 optname, void *optval, SlSocklen_t *optlen);
Xsigned short sl_GetSockOpt(signed short sd, signed short level, signed short optname, void *optval, SlSocklen_t *optlen);
N#endif
N
N/*!
N    \brief Read data from TCP socket
N     
N    Function receives a message from a connection-mode socket
N     
N    \param[in]  sd              Socket handle
N    \param[out] buf             Points to the buffer where the 
N                                message should be stored.
N    \param[in]  len             Specifies the length in bytes of 
N                                the buffer pointed to by the buffer argument. 
N                                Range: 1-16000 bytes
N    \param[in]  flags           Specifies the type of message 
N                                reception. On this version, this parameter is not
N                                supported.
N    
N    \return                     Return the number of bytes received, 
N                                or a negative value if an error occurred.\n
N                                Using a non-blocking recv a possible negative value is SL_EAGAIN.\n
N                                SL_POOL_IS_EMPTY may be return in case there are no resources in the system
N                                 In this case try again later or increase MAX_CONCURRENT_ACTIONS
N    
N    \sa     sl_RecvFrom
N    \note                       Belongs to \ref recv_api
N    \warning
N    \par        Examples
N
N    - Receiving data using TCP socket:
N    \code    
N        SlSockAddrIn_t  Addr;
N        SlSockAddrIn_t  LocalAddr;
N        _i16 AddrSize = sizeof(SlSockAddrIn_t);
N        _i16 SockID, newSockID;
N        _i16 Status;
N        _i8 Buf[RECV_BUF_LEN];
N
N        LocalAddr.sin_family = SL_AF_INET;
N        LocalAddr.sin_port = sl_Htons(5001);
N        LocalAddr.sin_addr.s_addr = 0;
N
N        Addr.sin_family = SL_AF_INET;
N        Addr.sin_port = sl_Htons(5001);
N        Addr.sin_addr.s_addr = sl_Htonl(SL_IPV4_VAL(10,1,1,200));
N
N        SockID = sl_Socket(SL_AF_INET,SL_SOCK_STREAM, 0);
N        Status = sl_Bind(SockID, (SlSockAddr_t *)&LocalAddr, AddrSize);
N        Status = sl_Listen(SockID, 0);
N        newSockID = sl_Accept(SockID, (SlSockAddr_t*)&Addr, (SlSocklen_t*) &AddrSize);
N        Status = sl_Recv(newSockID, Buf, 1460, 0);
N    \endcode
N    <br>
N
N    - Rx transceiver mode using a raw socket:
N    \code      
N        _i8 buffer[1536];
N        _i16 sd;
N        _u16 size;
N        SlTransceiverRxOverHead_t *transHeader;
N        sd = sl_Socket(SL_AF_RF,SL_SOCK_RAW,11); // channel 11
N        while(1)
N        {
N            size = sl_Recv(sd,buffer,1536,0);
N            transHeader = (SlTransceiverRxOverHead_t *)buffer;
N            printf("RSSI is %d frame type is 0x%x size %d\n",transHeader->rssi,buffer[sizeof(SlTransceiverRxOverHead_t)],size);
N        }
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_Recv)
X#if (1)
N_i16 sl_Recv(_i16 sd, void *buf, _i16 len, _i16 flags);
Xsigned short sl_Recv(signed short sd, void *buf, signed short len, signed short flags);
N#endif
N
N/*!
N    \brief Read data from socket
N    
N    Function receives a message from a connection-mode or
N    connectionless-mode socket
N    
N    \param[in]  sd              Socket handle 
N    \param[out] buf             Points to the buffer where the message should be stored.
N    \param[in]  len             Specifies the length in bytes of the buffer pointed to by the buffer argument.
N                                Range: 1-16000 bytes
N    \param[in]  flags           Specifies the type of message
N                                reception. On this version, this parameter is not
N                                supported.
N    \param[in]  from            Pointer to an address structure 
N                                indicating the source
N                                address.\n sockaddr:\n - code
N                                for the address format. On this
N                                version only AF_INET is
N                                supported.\n - socket address,
N                                the length depends on the code
N                                format
N    \param[in]  fromlen         Source address structure
N                                size. This parameter MUST be set to the size of the structure pointed to by addr.
N    
N    
N    \return                     Return the number of bytes received, 
N                                or a negative value if an error occurred.\n
N                                Using a non-blocking recv a possible negative value is SL_EAGAIN.
N                                SL_RET_CODE_INVALID_INPUT (-2) will be returned if fromlen has incorrect length. \n
N                                SL_POOL_IS_EMPTY may be return in case there are no resources in the system
N                                 In this case try again later or increase MAX_CONCURRENT_ACTIONS
N    
N    \sa     sl_Recv
N    \note                       Belongs to \ref recv_api
N    \warning
N    \par        Example
N
N    - Receiving data:
N    \code
N        SlSockAddrIn_t  Addr;
N        SlSockAddrIn_t  LocalAddr;
N        _i16 AddrSize = sizeof(SlSockAddrIn_t);
N        _i16 SockID;
N        _i16 Status;
N        _i8 Buf[RECV_BUF_LEN];
N
N        LocalAddr.sin_family = SL_AF_INET;
N        LocalAddr.sin_port = sl_Htons(5001);
N        LocalAddr.sin_addr.s_addr = 0;
N
N        SockID = sl_Socket(SL_AF_INET,SL_SOCK_DGRAM, 0);
N        Status = sl_Bind(SockID, (SlSockAddr_t *)&LocalAddr, AddrSize);
N        Status = sl_RecvFrom(SockID, Buf, 1472, 0, (SlSockAddr_t *)&Addr, (SlSocklen_t*)&AddrSize);
N
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_RecvFrom)
X#if (1)
N_i16 sl_RecvFrom(_i16 sd, void *buf, _i16 len, _i16 flags, SlSockAddr_t *from, SlSocklen_t *fromlen);
Xsigned short sl_RecvFrom(signed short sd, void *buf, signed short len, signed short flags, SlSockAddr_t *from, SlSocklen_t *fromlen);
N#endif
N
N/*!
N    \brief Write data to TCP socket
N    
N    This function is used to transmit a message to another socket.
N    Returns immediately after sending data to device.
N    In case of TCP failure an async event SL_SOCKET_TX_FAILED_EVENT is going to
N    be received.\n
N    In case of a RAW socket (transceiver mode), extra 4 bytes should be reserved at the end of the 
N    frame data buffer for WLAN FCS 
N     
N    \param[in] sd               Socket handle
N    \param[in] buf              Points to a buffer containing 
N                                the message to be sent
N    \param[in] len              Message size in bytes. Range: 1-1460 bytes
N    \param[in] flags            Specifies the type of message 
N                                transmission. On this version, this parameter is not
N                                supported for TCP.
N                                For transceiver mode, the SL_WLAN_RAW_RF_TX_PARAMS macro can be used to determine
N                                transmission parameters (channel,rate,tx_power,preamble)
N    
N    
N    \return                     Zero on success, or negative error code on failure
N    
N    \sa     sl_SendTo 
N    \note                       Belongs to \ref send_api
N    \warning   
N    \par        Example
N
N    - Sending data:
N    \code
N        SlSockAddrIn_t  Addr;
N        _i16 AddrSize = sizeof(SlSockAddrIn_t);
N        _i16 SockID;
N        _i16 Status;
N        _i8 Buf[SEND_BUF_LEN];
N
N        Addr.sin_family = SL_AF_INET;
N        Addr.sin_port = sl_Htons(5001);
N        Addr.sin_addr.s_addr = sl_Htonl(SL_IPV4_VAL(10,1,1,200));
N
N        SockID = sl_Socket(SL_AF_INET,SL_SOCK_STREAM, 0);
N        Status = sl_Connect(SockID, (SlSockAddr_t *)&Addr, AddrSize);
N        Status = sl_Send(SockID, Buf, 1460, 0 );
N    \endcode
N */ 
N#if _SL_INCLUDE_FUNC(sl_Send )
X#if (1)
N_i16 sl_Send(_i16 sd, const void *buf, _i16 len, _i16 flags);
Xsigned short sl_Send(signed short sd, const void *buf, signed short len, signed short flags);
N#endif
N
N/*!
N    \brief Write data to socket
N    
N    This function is used to transmit a message to another socket
N    (connection less socket SOCK_DGRAM,  SOCK_RAW).\n
N    Returns immediately after sending data to device.\n
N    In case of transmission failure an async event SL_SOCKET_TX_FAILED_EVENT is going to
N    be received.
N    
N    \param[in] sd               Socket handle
N    \param[in] buf              Points to a buffer containing 
N                                the message to be sent
N    \param[in] len              message size in bytes. Range: 1-1460 bytes
N    \param[in] flags            Specifies the type of message 
N                                transmission. On this version, this parameter is not
N                                supported 
N    \param[in] to               Pointer to an address structure 
N                                indicating the destination
N                                address.\n sockaddr:\n - code
N                                for the address format. On this
N                                version only AF_INET is
N                                supported.\n - socket address,
N                                the length depends on the code
N                                format
N    \param[in] tolen            Destination address structure size 
N    
N    \return                     Zero on success, or negative error code on failure
N    
N    \sa     sl_Send
N    \note                       Belongs to \ref send_api
N    \warning
N    \par        Example
N
N    - Sending data:
N    \code
N        SlSockAddrIn_t  Addr;
N        _i16 AddrSize = sizeof(SlSockAddrIn_t);
N        _i16 SockID;
N        _i16 Status;
N        _i8 Buf[SEND_BUF_LEN];
N
N        Addr.sin_family = SL_AF_INET;
N        Addr.sin_port = sl_Htons(5001);
N        Addr.sin_addr.s_addr = sl_Htonl(SL_IPV4_VAL(10,1,1,200));
N
N        SockID = sl_Socket(SL_AF_INET,SL_SOCK_DGRAM, 0);
N        Status = sl_SendTo(SockID, Buf, 1472, 0, (SlSockAddr_t *)&Addr, AddrSize);
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_SendTo)
X#if (1)
N_i16 sl_SendTo(_i16 sd, const void *buf, _i16 len, _i16 flags, const SlSockAddr_t *to, SlSocklen_t tolen);
Xsigned short sl_SendTo(signed short sd, const void *buf, signed short len, signed short flags, const SlSockAddr_t *to, SlSocklen_t tolen);
N#endif
N
N/*!
N    \brief Initiate TLS connection on a socket
N
N    Function Initiate TLS connection on the socket referred to by
N    the socket descriptor sd. This function will works on blocking
N    mode until the TLS handshake success or fails.
N
N    \param[in] sd               Socket descriptor (handle)
N
N    \return                     Zero on success, or negative error code on failure
N
N    \sa                         sl_Socket
N    \note                       belongs to \ref client_side
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_StartTLS)
X#if (1)
N_i16 sl_StartTLS(_i16 sd);
Xsigned short sl_StartTLS(signed short sd);
N#endif
N
N/*!
N    \brief Reorder the bytes of a 32-bit unsigned value
N    
N    This function is used to Reorder the bytes of a 32-bit unsigned value from processor order to network order.
N     
N    \param[in] val              Variable to reorder 
N    
N    \return                     Return the reorder variable, 
N    
N    \sa     sl_SendTo  sl_Bind  sl_Connect  sl_RecvFrom  sl_Accept
N    \note                       Belongs to \ref send_api
N    \warning   
N*/
N#if _SL_INCLUDE_FUNC(sl_Htonl )
X#if (1)
N_u32 sl_Htonl( _u32 val );
Xunsigned long sl_Htonl( unsigned long val );
N
N#define sl_Ntohl sl_Htonl  /* Reorder the bytes of a 16-bit unsigned value from network order to processor orde. */
N#endif
N
N/*!
N    \brief Reorder the bytes of a 16-bit unsigned value
N    
N    This function is used to Reorder the bytes of a 16-bit unsigned value from processor order to network order.
N     
N    \param[in] val              Variable to reorder 
N    
N    \return                     Return the reorder variable, 
N    
N    \sa     sl_SendTo  sl_Bind    sl_Connect  sl_RecvFrom  sl_Accept
N    \note                       Belongs to \ref send_api
N    \warning   
N*/
N#if _SL_INCLUDE_FUNC(sl_Htons )
X#if (1)
N_u16 sl_Htons( _u16 val );
Xunsigned short sl_Htons( unsigned short val );
N
N#define sl_Ntohs sl_Htons   /* Reorder the bytes of a 16-bit unsigned value from network order to processor orde. */
N#endif
N
N
N/*!
N
N Close the Doxygen group.
N @}
N
N */
N
N
N#ifdef  __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __SOCKET_H__ */
N
N
L 411 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N#include "netapp.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/netapp.h" 1
N/*
N * netapp.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N#include <ti/drivers/net/wifi/simplelink.h>
N
N#ifndef __NETAPP_H__
N#define __NETAPP_H__
N
N
N
N
N#ifdef    __cplusplus
Sextern "C" {
N#endif
N
N/*!
N    \defgroup NetApp 
N    \short Activates networking applications, such as: HTTP Server, DHCP Server, Ping, DNS and mDNS
N
N*/
N
N/*!
N
N    \addtogroup NetApp
N    @{
N
N*/
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N
N/* NetApp user events */   
Ntypedef enum
N{
N    SL_NETAPP_EVENT_IPV4_ACQUIRED = 1,
N    SL_NETAPP_EVENT_IPV6_ACQUIRED,
N    SL_NETAPP_EVENT_IP_COLLISION,
N    SL_NETAPP_EVENT_DHCPV4_LEASED,
N    SL_NETAPP_EVENT_DHCPV4_RELEASED,
N    SL_NETAPP_EVENT_HTTP_TOKEN_GET,
N    SL_NETAPP_EVENT_HTTP_TOKEN_POST,
N    SL_NETAPP_EVENT_IPV4_LOST,
N    SL_NETAPP_EVENT_DHCP_IPV4_ACQUIRE_TIMEOUT,
N    SL_NETAPP_EVENT_IPV6_LOST,
N    SL_NETAPP_EVENT_MAX
N} SlNetAppEventId_e;
N
N  
N#define SL_NETAPP_MDNS_OPTIONS_IS_UNIQUE_BIT                0x1
N#define SL_NETAPP_MDNS_OPTIONS_ADD_SERVICE_BIT              ((_u32)0x1 << 31)
N#define SL_NETAPP_MDNS_OPTIONS_IS_NOT_PERSISTENT            ((_u32)0x1 << 30)
N#define SL_NETAPP_MDNS_OPTION_UPDATE_TEXT                   ((_u32)0x1 << 29)
N#define SL_NETAPP_MDNS_IPV4_ONLY_SERVICE                    (_u32)(0) /* default mode:zero bits 27,28*/
N#define SL_NETAPP_MDNS_IPV6_ONLY_SERVICE                    ((_u32)0x1 << 28)
N#define SL_NETAPP_MDNS_IPV6_IPV4_SERVICE                    ((_u32)0x1 << 27)
N
N
N/*ERROR code*/
N#define SL_NETAPP_RX_BUFFER_LENGTH_ERROR                    (-230)
N
N/*  Http Server interface */
N#define SL_NETAPP_MAX_INPUT_STRING                          (64) /*  because of WPA */
N
N#define SL_NETAPP_MAX_AUTH_NAME_LEN                         (20)
N#define SL_NETAPP_MAX_AUTH_PASSWORD_LEN                     (20)
N#define SL_NETAPP_MAX_AUTH_REALM_LEN                        (20)
N
N#define SL_NETAPP_MAX_DEVICE_URN_LEN                        (32+1)
N#define SL_NETAPP_MAX_DOMAIN_NAME_LEN                       (24+1)
N
N#define SL_NETAPP_MAX_ACTION_LEN                            (30)
N#define SL_NETAPP_MAX_TOKEN_NAME_LEN                        (20)
N
N
N#define SL_NETAPP_MAX_TOKEN_VALUE_LEN                       SL_NETAPP_MAX_INPUT_STRING
N
N#define SL_NETAPP_MAX_SERVICE_TEXT_SIZE                     (256)
N#define SL_NETAPP_MAX_SERVICE_NAME_SIZE                     (60)
N#define SL_NETAPP_MAX_SERVICE_HOST_NAME_SIZE                (64)
N
N
N/* Server Responses */
N#define SL_NETAPP_HTTPRESPONSE_NONE                         (0)
N#define SL_NETAPP_HTTPSETTOKENVALUE                         (1)
N
N#define SL_NETAPP_FAMILY_MASK                               (0x80)
N
N/* mDNS types */
N#define SL_NETAPP_MASK_IPP_TYPE_OF_SERVICE                  (0x00000001)
N#define SL_NETAPP_MASK_DEVICE_INFO_TYPE_OF_SERVICE          (0x00000002)
N#define SL_NETAPP_MASK_HTTP_TYPE_OF_SERVICE                 (0x00000004)
N#define SL_NETAPP_MASK_HTTPS_TYPE_OF_SERVICE                (0x00000008)
N#define SL_NETAPP_MASK_WORKSATION_TYPE_OF_SERVICE           (0x00000010)
N#define SL_NETAPP_MASK_GUID_TYPE_OF_SERVICE                 (0x00000020)
N#define SL_NETAPP_MASK_H323_TYPE_OF_SERVICE                 (0x00000040)
N#define SL_NETAPP_MASK_NTP_TYPE_OF_SERVICE                  (0x00000080)
N#define SL_NETAPP_MASK_OBJECITVE_TYPE_OF_SERVICE            (0x00000100)
N#define SL_NETAPP_MASK_RDP_TYPE_OF_SERVICE                  (0x00000200)
N#define SL_NETAPP_MASK_REMOTE_TYPE_OF_SERVICE               (0x00000400)
N#define SL_NETAPP_MASK_RTSP_TYPE_OF_SERVICE                 (0x00000800)
N#define SL_NETAPP_MASK_SIP_TYPE_OF_SERVICE                  (0x00001000)
N#define SL_NETAPP_MASK_SMB_TYPE_OF_SERVICE                  (0x00002000)
N#define SL_NETAPP_MASK_SOAP_TYPE_OF_SERVICE                 (0x00004000)
N#define SL_NETAPP_MASK_SSH_TYPE_OF_SERVICE                  (0x00008000)
N#define SL_NETAPP_MASK_TELNET_TYPE_OF_SERVICE               (0x00010000)
N#define SL_NETAPP_MASK_TFTP_TYPE_OF_SERVICE                 (0x00020000)
N#define SL_NETAPP_MASK_XMPP_CLIENT_TYPE_OF_SERVICE          (0x00040000)
N#define SL_NETAPP_MASK_RAOP_TYPE_OF_SERVICE                 (0x00080000)
N#define SL_NETAPP_MASK_ALL_TYPE_OF_SERVICE                  (0xFFFFFFFF)
N
N/********************************************************************************************************/
N
N/* NetApp application IDs */
N#define SL_NETAPP_HTTP_SERVER_ID                            (0x01)
N#define SL_NETAPP_DHCP_SERVER_ID                            (0x02)
N#define SL_NETAPP_MDNS_ID                                   (0x04)
N#define SL_NETAPP_DNS_SERVER_ID                             (0x08)
N
N#define SL_NETAPP_DEVICE_ID                                 (0x10)
N#define SL_NETAPP_DNS_CLIENT_ID                             (0x20)
N#define SL_NETAPP_STATUS                                    (0x40)
N
N/* NetApp application set/get options */             
N#define SL_NETAPP_DHCP_SRV_BASIC_OPT                        (0)             
N
N/* HTTP server set/get options */                    
N#define SL_NETAPP_HTTP_PRIMARY_PORT_NUMBER                  (0)
N#define SL_NETAPP_HTTP_AUTH_CHECK                           (1)
N#define SL_NETAPP_HTTP_AUTH_NAME                            (2)
N#define SL_NETAPP_HTTP_AUTH_PASSWORD                        (3)
N#define SL_NETAPP_HTTP_AUTH_REALM                           (4)
N#define SL_NETAPP_HTTP_ROM_PAGES_ACCESS                     (5)
N#define SL_NETAPP_HTTP_SECONDARY_PORT_NUMBER                (6)
N#define SL_NETAPP_HTTP_SECONDARY_PORT_ENABLE                (7) /*Enable / disable of secondary port */
N#define SL_NETAPP_HTTP_PRIMARY_PORT_SECURITY_MODE           (8)
N#define SL_NETAPP_HTTP_PRIVATE_KEY_FILENAME                 (9)
N#define SL_NETAPP_HTTP_DEVICE_CERTIFICATE_FILENAME          (10)
N#define SL_NETAPP_HTTP_CA_CERTIFICATE_FILE_NAME             (11)
N#define SL_NETAPP_HTTP_TEMP_REGISTER_MDNS_SERVICE_NAME      (12)
N#define SL_NETAPP_HTTP_TEMP_UNREGISTER_MDNS_SERVICE_NAME    (13)
N                                                     
N#define SL_NETAPP_MDNS_CONT_QUERY_OPT                       (1)
N#define SL_NETAPP_MDNS_QEVETN_MASK_OPT                      (2)
N#define SL_NETAPP_MDNS_TIMING_PARAMS_OPT                    (3)
N
N/* DNS server set/get options */
N#define SL_NETAPP_DNS_OPT_DOMAIN_NAME                       (0)
N
N/* Device Config set/get options */
N#define SL_NETAPP_DEVICE_URN                                (0)
N#define SL_NETAPP_DEVICE_DOMAIN                             (1)
N
N/* DNS client set/get options */
N#define SL_NETAPP_DNS_CLIENT_TIME                           (0)
N
N/* Get active application bimap */
N#define SL_NETAPP_STATUS_ACTIVE_APP                         (0)
N
N#ifdef SL_TINY
S#define SL_NETAPP_MDNS_MAX_SERVICE_NAME_AND_TEXT_LENGTH     (63)
N#else
N#define SL_NETAPP_MDNS_MAX_SERVICE_NAME_AND_TEXT_LENGTH     (255)
N#endif
N
N/*****************************************************************************/
N/* Structure/Enum declarations                                               */
N/*****************************************************************************/
N
Ntypedef struct
N{
N    _u32 Ip;
X    unsigned long Ip;
N    _u32 Gateway;
X    unsigned long Gateway;
N    _u32 Dns;
X    unsigned long Dns;
N}SlIpV4AcquiredAsync_t;
N
Ntypedef enum
N{
N    SL_BSD_IPV6_ACQUIRED_TYPE_LOCAL = 1,
N    SL_BSD_IPV6_ACQUIRED_TYPE_GLOBAL = 2
N}SlIpV6AcquiredAsyncType_e;
N
Ntypedef struct  
N{
N    _u32 Ip[4];
X    unsigned long Ip[4];
N    _u32 Dns[4];
X    unsigned long Dns[4];
N}SlIpV6AcquiredAsync_t;
N
Ntypedef struct
N{
N    _u32    IpAddress;
X    unsigned long    IpAddress;
N    _u32    LeaseTime;
X    unsigned long    LeaseTime;
N    _u8     Mac[6];
X    unsigned char     Mac[6];
N    _u16    Padding;
X    unsigned short    Padding;
N}SlIpLeasedAsync_t;
N
Ntypedef struct
N{
N    _u32    IpAddress;
X    unsigned long    IpAddress;
N    _u8     Mac[6];
X    unsigned char     Mac[6];
N    _u16    Reason;
X    unsigned short    Reason;
N}SlIpReleasedAsync_t;
N
Ntypedef struct
N{
N    _u32    IpAddress;
X    unsigned long    IpAddress;
N    _u8     DhcpMac[6];
X    unsigned char     DhcpMac[6];
N    _u8     ConflictMac[6];
X    unsigned char     ConflictMac[6];
N}SlIpCollisionAsync_t;
N
Ntypedef struct
N{
N    _i16  Status;
X    signed short  Status;
N    _u16  Padding;
X    unsigned short  Padding;
N}SlIpV4Lost_t;
N
Ntypedef struct
N{
N    _u32 IpLost[4];
X    unsigned long IpLost[4];
N}SlIpV6Lost_t;
N
Ntypedef struct
N{
N    _i16  Status;
X    signed short  Status;
N    _u16  Padding;
X    unsigned short  Padding;
N}SlDhcpIpAcquireTimeout_t;
N
Ntypedef union
N{
N    SlIpV4AcquiredAsync_t        IpAcquiredV4;           /* SL_NETAPP_EVENT_IPV4_ACQUIRED */
N    SlIpV6AcquiredAsync_t        IpAcquiredV6;           /* SL_NETAPP_EVENT_IPV6_ACQUIRED */
N    _u32                         Sd;                     /* SL_SOCKET_TX_FAILED_EVENT */ 
X    unsigned long                         Sd;                       
N    SlIpLeasedAsync_t            IpLeased;               /* SL_NETAPP_EVENT_DHCPV4_LEASED */
N    SlIpReleasedAsync_t          IpReleased;             /* SL_NETAPP_EVENT_DHCPV4_RELEASED */
N    SlIpV4Lost_t                 IpV4Lost;               /* SL_NETAPP_EVENT_IPV4_LOST */
N    SlDhcpIpAcquireTimeout_t     DhcpIpAcquireTimeout;   /* SL_NETAPP_DHCP_ACQUIRE_IPV4_TIMEOUT_EVENT */
N    SlIpCollisionAsync_t         IpCollision;            /* SL_NETAPP_EVENT_IP_COLLISION */
N    SlIpV6Lost_t                 IpV6Lost;               /* SL_NETAPP_EVENT_IPV6_LOST */
N} SlNetAppEventData_u;
N
Ntypedef struct
N{
N    _u32                     Id;
X    unsigned long                     Id;
N    SlNetAppEventData_u      Data;
N}SlNetAppEvent_t;
N
Ntypedef struct
N{
N    _u32    PacketsSent;
X    unsigned long    PacketsSent;
N    _u32    PacketsReceived;
X    unsigned long    PacketsReceived;
N    _u16    MinRoundTime;
X    unsigned short    MinRoundTime;
N    _u16    MaxRoundTime;
X    unsigned short    MaxRoundTime;
N    _u16    AvgRoundTime;
X    unsigned short    AvgRoundTime;
N    _u32    TestTime;
X    unsigned long    TestTime;
N}SlNetAppPingReport_t;
N
Ntypedef struct
N{
N    _u32    PingIntervalTime;       /* delay between pings, in milliseconds */
X    unsigned long    PingIntervalTime;        
N    _u16    PingSize;               /* ping packet size in bytes           */
X    unsigned short    PingSize;                
N    _u16    PingRequestTimeout;     /* timeout time for every ping in milliseconds  */
X    unsigned short    PingRequestTimeout;      
N    _u32    TotalNumberOfAttempts;  /* max number of ping requests. 0 - forever    */
X    unsigned long    TotalNumberOfAttempts;   
N    _u32    Flags;                  /* flag - 0 report only when finished, 1 - return response for every ping, 2 - stop after 1 successful ping.  4 - ipv4 header flag - don`t fragment packet */
X    unsigned long    Flags;                   
N    _u32    Ip;                     /* IPv4 address or IPv6 first 4 bytes  */
X    unsigned long    Ip;                      
N    _u32    Ip1OrPadding;
X    unsigned long    Ip1OrPadding;
N    _u32    Ip2OrPadding;
X    unsigned long    Ip2OrPadding;
N    _u32    Ip3OrPadding;
X    unsigned long    Ip3OrPadding;
N}SlNetAppPingCommand_t;
N
Ntypedef struct
N{
N    _u8     Len;
X    unsigned char     Len;
N    _u8     *pData;
X    unsigned char     *pData;
N} SlNetAppHttpServerString_t;
N
Ntypedef struct
N{
N    _u8     ValueLen;
X    unsigned char     ValueLen;
N    _u8     NameLen;
X    unsigned char     NameLen;
N    _u8     *pTokenValue;
X    unsigned char     *pTokenValue;
N    _u8     *pTokenName;
X    unsigned char     *pTokenName;
N} SlNetAppHttpServerData_t;
N
Ntypedef struct
N{
N    SlNetAppHttpServerString_t Action;
N    SlNetAppHttpServerString_t TokenName;
N    SlNetAppHttpServerString_t TokenValue;
N}SlNetAppHttpServerPostData_t;
N
Ntypedef union
N{
N    SlNetAppHttpServerString_t        HttpTokenName; /* SL_NETAPP_HTTPGETTOKENVALUE */
N    SlNetAppHttpServerPostData_t      HttpPostData;  /* SL_NETAPP_HTTPPOSTTOKENVALUE */
N} SlNetAppHttpServerEventData_u;
N
Ntypedef union
N{
N    SlNetAppHttpServerString_t TokenValue;
N} SlNetAppHttpServerResponsedata_u;
N
Ntypedef struct
N{
N    _u32                          Event;
X    unsigned long                          Event;
N    SlNetAppHttpServerEventData_u EventData;
N}SlNetAppHttpServerEvent_t;
N
Ntypedef struct
N{
N    _u32                             Response;
X    unsigned long                             Response;
N    SlNetAppHttpServerResponsedata_u ResponseData;
N}SlNetAppHttpServerResponse_t;
N
N/*****************************************************************************************
N*   NETAPP Request/Response/Send/Receive
N******************************************************************************************/
N/*  TODO: check what definitions are eventually needed */
N/* NETAPP http request types */
N#define SL_NETAPP_REQUEST_HTTP_GET    1
N#define SL_NETAPP_REQUEST_HTTP_POST   2
N#define SL_NETAPP_REQUEST_HTTP_PUT    3
N#define SL_NETAPP_REQUEST_HTTP_DELETE 4
N
N#define SL_NETAPP_REQUEST_MAX_METADATA_LEN 1024
N#define SL_NETAPP_REQUEST_MAX_DATA_LEN     1364   /* Metadata + Payload */
N
N
Ntypedef enum
N{
N    SL_NETAPP_REQUEST_METADATA_TYPE_STATUS = 0,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_VERSION,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_REQUEST_URI,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_QUERY_STRING,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_CONTENT_LEN,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_CONTENT_TYPE,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_LOCATION,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_SERVER,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_USER_AGENT,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_COOKIE,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_SET_COOKIE,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_UPGRADE,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_REFERER,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_ACCEPT,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_CONTENT_ENCODING,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_CONTENT_DISPOSITION,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_CONNECTION,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_ETAG,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_DATE,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HEADER_HOST,
N    SL_NETAPP_REQUEST_METADATA_TYPE_ACCEPT_ENCODING,
N    SL_NETAPP_REQUEST_METADATA_TYPE_ACCEPT_LANGUAGE,
N    SL_NETAPP_REQUEST_METADATA_TYPE_CONTENT_LANGUAGE,
N    SL_NETAPP_REQUEST_METADATA_TYPE_ORIGIN,          
N    SL_NETAPP_REQUEST_METADATA_TYPE_ORIGIN_CONTROL_ACCESS,
N    SL_NETAPP_REQUEST_METADATA_TYPE_HTTP_NONE
N} SlNetAppMetadataHTTPTypes_e;
N
Ntypedef enum
N{
N    SL_NETAPP_RESPONSE_NONE = 0,                             /* No response */
N    SL_NETAPP_RESPONSE_PENDING = 1,                          /* status will arrive in future NetApp Send call (in metadata) */
N
N    SL_NETAPP_HTTP_RESPONSE_101_SWITCHING_PROTOCOLS = 101,   /* 101 Switching Protocol*/
N    SL_NETAPP_HTTP_RESPONSE_200_OK = 200,                    /* 200 OK */
N    SL_NETAPP_HTTP_RESPONSE_201_CREATED = 201,               /* "HTTP/1.0 201 Created" */
N    SL_NETAPP_HTTP_RESPONSE_202_ACCEPTED = 202,              /* "HTTP/1.0 202 Accepted" */
N    SL_NETAPP_HTTP_RESPONSE_204_OK_NO_CONTENT = 204,         /* 204 No Content */
N    SL_NETAPP_HTTP_RESPONSE_301_MOVED_PERMANENTLY = 301,     /* "HTTP/1.0 301 Moved Permanently" */
N    SL_NETAPP_HTTP_RESPONSE_302_MOVED_TEMPORARILY = 302,     /* 302 Moved Temporarily (http 1.0) */
N    SL_NETAPP_HTTP_RESPONSE_303_SEE_OTHER = 303,             /* "HTTP/1.1 303 See Other" */
N    SL_NETAPP_HTTP_RESPONSE_304_NOT_MODIFIED = 304,          /* "HTTP/1.0 304 Not Modified" */
N    SL_NETAPP_HTTP_RESPONSE_400_BAD_REQUEST = 400,           /* "HTTP/1.0 400 Bad Request" */
N    SL_NETAPP_HTTP_RESPONSE_403_FORBIDDEN = 403,             /* "HTTP/1.0 403 Forbidden" */
N    SL_NETAPP_HTTP_RESPONSE_404_NOT_FOUND = 404,             /* 404 Not Found */
N    SL_NETAPP_HTTP_RESPONSE_405_METHOD_NOT_ALLOWED = 405,    /* "HTTP/1.0 405 Method Not Allowed" */
N    SL_NETAPP_HTTP_RESPONSE_500_INTERNAL_SERVER_ERROR = 500, /* 500 Internal Server Error */
N    SL_NETAPP_HTTP_RESPONSE_503_SERVICE_UNAVAILABLE = 503,   /* "HTTP/1.0 503 Service Unavailable" */
N    SL_NETAPP_HTTP_RESPONSE_504_GATEWAY_TIMEOUT = 504        /* "HTTP/1.0 504 Gateway Timeout" */
N} SlNetAppResponseCode_e;
N
N
N#define SL_NETAPP_REQUEST_RESPONSE_FLAGS_CONTINUATION    0x00000001
N#define SL_NETAPP_REQUEST_RESPONSE_FLAGS_METADATA        0x00000002  /* 0 - data is payload, 1 - data is metadata */
N#define SL_NETAPP_REQUEST_RESPONSE_FLAGS_ACCUMULATION    0x00000004
N#define SL_NETAPP_REQUEST_RESPONSE_FLAGS_ERROR           0x80000000  /* in that case the last two bytes represents the error code */
N
Ntypedef struct
N{
N    _u16 MetadataLen;
X    unsigned short MetadataLen;
N    _u8 *pMetadata;
X    unsigned char *pMetadata;
N    _u16 PayloadLen;
X    unsigned short PayloadLen;
N    _u8 *pPayload;
X    unsigned char *pPayload;
N    _u32 Flags;
X    unsigned long Flags;
N} SlNetAppData_t;
N
Ntypedef struct
N{
N    _u8     AppId;
X    unsigned char     AppId;
N    _u8     Type;
X    unsigned char     Type;
N    _u16    Handle;
X    unsigned short    Handle;
N    SlNetAppData_t  requestData;
N} SlNetAppRequest_t;
N
Ntypedef struct
N{
N    _u16            Status;
X    unsigned short            Status;
N    SlNetAppData_t  ResponseData;
N} SlNetAppResponse_t;
N
Ntypedef struct
N{
N    _u32   lease_time;
X    unsigned long   lease_time;
N    _u32   ipv4_addr_start;
X    unsigned long   ipv4_addr_start;
N    _u32   ipv4_addr_last;
X    unsigned long   ipv4_addr_last;
N}SlNetAppDhcpServerBasicOpt_t; 
N
N/* mDNS parameters */
Ntypedef enum
N{
N    SL_NETAPP_FULL_SERVICE_WITH_TEXT_IPV4_TYPE = 1,
N    SL_NETAPP_FULL_SERVICE_IPV4_TYPE,
N    SL_NETAPP_SHORT_SERVICE_IPV4_TYPE,
N    SL_NETAPP_FULL_SERVICE_WITH_TEXT_IPV6_TYPE ,
N    SL_NETAPP_FULL_SERVICE_IPV6_TYPE,
N    SL_NETAPP_SHORT_SERVICE_IPV6_TYPE
N} SlNetAppGetServiceListType_e;
N
Ntypedef struct
N{
N    _u32   service_ipv4;
X    unsigned long   service_ipv4;
N    _u16   service_port;
X    unsigned short   service_port;
N    _u16   Reserved;
X    unsigned short   Reserved;
N}SlNetAppGetShortServiceIpv4List_t;
N
Ntypedef struct
N{
N    _u32   service_ipv4;
X    unsigned long   service_ipv4;
N    _u16   service_port;
X    unsigned short   service_port;
N    _u16   Reserved;
X    unsigned short   Reserved;
N    _u8    service_name[SL_NETAPP_MAX_SERVICE_NAME_SIZE];
X    unsigned char    service_name[(60)];
N    _u8    service_host[SL_NETAPP_MAX_SERVICE_HOST_NAME_SIZE];
X    unsigned char    service_host[(64)];
N}SlNetAppGetFullServiceIpv4List_t;
N
Ntypedef struct
N{
N    _u32    service_ipv4;
X    unsigned long    service_ipv4;
N    _u16    service_port;
X    unsigned short    service_port;
N    _u16    Reserved;
X    unsigned short    Reserved;
N    _u8     service_name[SL_NETAPP_MAX_SERVICE_NAME_SIZE];
X    unsigned char     service_name[(60)];
N    _u8     service_host[SL_NETAPP_MAX_SERVICE_HOST_NAME_SIZE];
X    unsigned char     service_host[(64)];
N    _u8     service_text[SL_NETAPP_MAX_SERVICE_TEXT_SIZE];
X    unsigned char     service_text[(256)];
N}SlNetAppGetFullServiceWithTextIpv4List_t;
N
N/* IPv6 entries */
Ntypedef struct
N{
N    _u32   service_ipv6[4];
X    unsigned long   service_ipv6[4];
N    _u16   service_port;
X    unsigned short   service_port;
N    _u16   Reserved;
X    unsigned short   Reserved;
N}SlNetAppGetShortServiceIpv6List_t;
N
Ntypedef struct
N{
N    _u32   service_ipv6[4];
X    unsigned long   service_ipv6[4];
N    _u16   service_port;
X    unsigned short   service_port;
N    _u16   Reserved;
X    unsigned short   Reserved;
N    _u8    service_name[SL_NETAPP_MAX_SERVICE_NAME_SIZE];
X    unsigned char    service_name[(60)];
N    _u8    service_host[SL_NETAPP_MAX_SERVICE_HOST_NAME_SIZE];
X    unsigned char    service_host[(64)];
N}SlNetAppGetFullServiceIpv6List_t;
N
Ntypedef struct
N{
N    _u32    service_ipv6[4];
X    unsigned long    service_ipv6[4];
N    _u16    service_port;
X    unsigned short    service_port;
N    _u16    Reserved;
X    unsigned short    Reserved;
N    _u8     service_name[SL_NETAPP_MAX_SERVICE_NAME_SIZE];
X    unsigned char     service_name[(60)];
N    _u8     service_host[SL_NETAPP_MAX_SERVICE_HOST_NAME_SIZE];
X    unsigned char     service_host[(64)];
N    _u8     service_text[SL_NETAPP_MAX_SERVICE_TEXT_SIZE];
X    unsigned char     service_text[(256)];
N}SlNetAppGetFullServiceWithTextIpv6List_t;
N
Ntypedef struct
N{
N    /*The below parameters are used to configure the advertise times and interval
N    For example:
N        If:
N        Period is set to T
N        Repetitions are set to P
N        Telescopic factor is K=2
N        The transmission shall be:
N        advertise P times
N        wait T
N        advertise P times
N        wait 4 * T
N        advertise P time
N        wait 16 * T  ... (till max time reached / configuration changed / query issued)
N    */
N    _u32    t;               /* Number of ticks for the initial period. Default is 100 ticks for 1 second. */
X    unsigned long    t;                
N    _u32    p;               /* Number of repetitions. Default value is 1                                  */
X    unsigned long    p;                
N    _u32    k;               /* Telescopic factor. Default value is 2.                                     */
X    unsigned long    k;                
N    _u32    RetransInterval; /* Announcing retransmission interval                                         */
X    unsigned long    RetransInterval;  
N    _u32    Maxinterval;     /* Announcing max period interval                                             */
X    unsigned long    Maxinterval;      
N    _u32    max_time;        /* Announcing max time                                                        */
X    unsigned long    max_time;         
N}SlNetAppServiceAdvertiseTimingParameters_t;
N
Ntypedef struct
N{
N    _u16   MaxResponseTime;
X    unsigned short   MaxResponseTime;
N    _u16   NumOfRetries;
X    unsigned short   NumOfRetries;
N}SlNetAppDnsClientTime_t; 
N
N/*****************************************************************************/
N/* Types declarations                                               */
N/*****************************************************************************/
Ntypedef void (*P_SL_DEV_PING_CALLBACK)(SlNetAppPingReport_t*);
N
N/*****************************************************************************/
N/* Function prototypes                                                       */
N/*****************************************************************************/
N
N
N/*!
N    \brief Starts a network application
N
N    Gets and starts network application for the current WLAN mode
N
N    \param[in] AppBitMap Application bitmap, could be one or combination of the following:
N                         - SL_NETAPP_HTTP_SERVER_ID   
N                         - SL_NETAPP_DHCP_SERVER_ID   
N                         - SL_NETAPP_MDNS_ID       
N                         - SL_NETAPP_DNS_SERVER_ID
N
N    \par    Persistent   - <b>System Persistent</b>
N    \return              Zero on success, or negative error code on failure
N
N    \sa                  sl_NetAppStop
N    \note                This command activates the application for the current WLAN mode (AP or STA)
N    \warning
N    \par                 Example  
N    
N    - Starting internal HTTP server + DHCP server:
N    \code
N        sl_NetAppStart(SL_NETAPP_HTTP_SERVER_ID | SL_NETAPP_DHCP_SERVER_ID)
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_NetAppStart)
X#if (1)
N_i16 sl_NetAppStart(const _u32 AppBitMap);
Xsigned short sl_NetAppStart(const unsigned long AppBitMap);
N#endif
N/*!
N    \brief Stops a network application
N
N    Gets and stops network application for the current WLAN mode
N
N    \param[in] AppBitMap   Application id, could be one of the following: \n
N                           - SL_NETAPP_HTTP_SERVER_ID 
N                           - SL_NETAPP_DHCP_SERVER_ID 
N                           - SL_NETAPP_MDNS_ID 
N                           - SL_NETAPP_DNS_SERVER_ID 
N
N    \par    Persistent     - <b>System Persistent</b>
N
N    \return                Zero on success, or nagative error code on failure
N
N    \sa                    sl_NetAppStart
N    \note                  This command disables the application for the current active WLAN mode (AP or STA)
N    \warning
N    \par                   Example
N
N    - Stopping internal HTTP server:
N    \code                
N        sl_NetAppStop(SL_NETAPP_HTTP_SERVER_ID); 
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_NetAppStop)
X#if (1)
N_i16 sl_NetAppStop(const _u32 AppBitMap);
Xsigned short sl_NetAppStop(const unsigned long AppBitMap);
N#endif
N
N/*!
N    \brief Get host IP by name\n
N    Obtain the IP Address of machine on network, by machine name.
N
N    \param[in]  pHostName       Host name
N    \param[in]  NameLen         Name length
N    \param[out] OutIpAddr       This parameter is filled in with
N                                host IP address. In case that host name is not
N                                resolved, out_ip_addr is zero.
N    \param[in]  Family          Protocol family
N
N    \return                     Zero on success, or negative on failure.\n
N                                SL_POOL_IS_EMPTY may be return in case there are no resources in the system\n
N                                    In this case try again later or increase MAX_CONCURRENT_ACTIONS
N                                Possible DNS error codes:
N                                - SL_NETAPP_DNS_QUERY_NO_RESPONSE       
N                                - SL_NETAPP_DNS_NO_SERVER               
N                                - SL_NETAPP_DNS_QUERY_FAILED            
N                                - SL_NETAPP_DNS_MALFORMED_PACKET        
N                                - SL_NETAPP_DNS_MISMATCHED_RESPONSE     
N
N    \sa
N    \note   Only one sl_NetAppDnsGetHostByName can be handled at a time.\n
N            Calling this API while the same command is called from another thread, may result
N            in one of the two scenarios:
N            1. The command will wait (internal) until the previous command finish, and then be executed.
N            2. There are not enough resources and POOL_IS_EMPTY error will return.\n
N            In this case, MAX_CONCURRENT_ACTIONS can be increased (result in memory increase) or try
N            again later to issue the command.
N    \warning
N            In case an IP address in a string format is set as input, without any prefix (e.g. "1.2.3.4") the device will not 
N            try to access the DNS and it will return the input address on the 'out_ip_addr' field 
N    \par    Example
N    
N    - Getting host by name:
N    \code
N        _u32 DestinationIP;
N        _u32 AddrSize;
N        _i16 SockId;
N        SlSockAddrIn_t Addr;
N    
N        sl_NetAppDnsGetHostByName("www.google.com", strlen("www.google.com"), &DestinationIP,SL_AF_INET);
N    
N        Addr.sin_family = SL_AF_INET;
N        Addr.sin_port = sl_Htons(80);
N        Addr.sin_addr.s_addr = sl_Htonl(DestinationIP);
N        AddrSize = sizeof(SlSockAddrIn_t);
N        SockId = sl_Socket(SL_AF_INET,SL_SOCK_STREAM, 0);
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_NetAppDnsGetHostByName)
X#if (1)
N_i16 sl_NetAppDnsGetHostByName(_i8 * pHostName,const  _u16 NameLen, _u32*  OutIpAddr,const _u8 Family );
Xsigned short sl_NetAppDnsGetHostByName(signed char * pHostName,const  unsigned short NameLen, unsigned long*  OutIpAddr,const unsigned char Family );
N#endif
N
N/*!
N        \brief Return service attributes like IP address, port and text according to service name\n
N            The user sets a service name Full/Part (see example below), and should get:
N            - IP of service
N            - The port of service
N            - The text of service
N        Hence it can make a connection to the specific service and use it.
N        It is similar to sl_NetAppDnsGetHostByName method.\n
N        It is done by a single shot ipv4 & ipv6 (if enabled) query with PTR type on the service name.
N                  The command that is sent is from constant parameters and variables parameters.
N
N        \param[in]    pServiceName                Service name can be full or partial. \n
N                                                  Example for full service name:
N                                                  1. PC1._ipp._tcp.local
N                                                  2. PC2_server._ftp._tcp.local \n
N                                                  .
N                                                  Example for partial service name:
N                                                  1. _ipp._tcp.local
N                                                  2. _ftp._tcp.local
N
N        \param[in]    ServiceLen                  The length of the service name (in_pService).
N        \param[in]    Family                      IPv4 or IPv6 (SL_AF_INET , SL_AF_INET6).
N        \param[out]   pAddr                       Contains the IP address of the service.
N        \param[out]   pPort                       Contains the port of the service.
N        \param[out]   pTextLen                    Has 2 options. One as Input field and the other one as output:
N                                                  - Input: \n
N                                                  Contains the max length of the text that the user wants to get.\n
N                                                  It means that if the text len of service is bigger that its value than
N                                                  the text is cut to inout_TextLen value.
N                                                  - Output: \n
N                                                  Contain the length of the text that is returned. Can be full text or part of the text (see above).
N
N        \param[out]   pText     Contains the text of the service full or partial
N
N        \return       Zero on success,\n
N                      SL_POOL_IS_EMPTY may be return in case there are no resources in the system, 
N                      In this case try again later or increase MAX_CONCURRENT_ACTIONS\n
N                      In case No service is found error SL_NETAPP_DNS_NO_ANSWER will be returned
N        \sa              sl_NetAppDnsGetHostByName
N        \note         The returns attributes belongs to the first service found.
N                      There may be other services with the same service name that will response to the query.
N                      The results of these responses are saved in the peer cache of the Device and should be read by another API.\n
N                          
N                      Only one sl_NetAppDnsGetHostByService can be handled at a time.\n
N                      Calling this API while the same command is called from another thread, may result
N                      in one of the two scenarios:
N                      1. The command will wait (internal) until the previous command finish, and then be executed.
N                      2. There are not enough resources and SL_POOL_IS_EMPTY error will return. 
N                      In this case, MAX_CONCURRENT_ACTIONS can be increased (result in memory increase) or try
N                      again later to issue the command.
N
N        \warning      Text length can be 120 bytes only
N*/
N#if _SL_INCLUDE_FUNC(sl_NetAppDnsGetHostByService)
X#if (1)
N_i16 sl_NetAppDnsGetHostByService(_i8  *pServiceName, /* string containing all (or only part): name + subtype + service */
Xsigned short sl_NetAppDnsGetHostByService(signed char  *pServiceName,  
N                                  const _u8  ServiceLen,
X                                  const unsigned char  ServiceLen,
N                                  const _u8  Family, /* 4-IPv4 , 16-IPv6 */
X                                  const unsigned char  Family,  
N                                  _u32 pAddr[], 
X                                  unsigned long pAddr[], 
N                                  _u32 *pPort,
X                                  unsigned long *pPort,
N                                  _u16 *pTextLen, /* in: max len , out: actual len */
X                                  unsigned short *pTextLen,  
N                                  _i8  *pText
X                                  signed char  *pText
N                                 );
N
N#endif
N
N/*!
N        \brief Get service list\n
N        Insert into out pBuffer a list of peer's services that are in the NWP without issuing any queries (relying on pervious collected data).\n
N        The list is in a form of service struct. The user should chose the type
N        of the service struct like:
N            - Full service parameters with text.
N            - Full service parameters.
N            - Short service parameters (port and IP only) especially for tiny hosts.
N
N        The different types of struct are made to give the 
N        possibility to save memory in the host.\n
N
N        The user can also chose how many max services to get and start point index
N        NWP peer cache.\n
N        For example:
N            1.    Get max of 3 full services from index 0. 
N                - Up to 3 full services from index 0 are inserted into pBuffer (services that are in indexes 0,1,2).
N            2.    Get max of 4 full services from index 3.
N                - Up to 4 full services from index 3 are inserted into pBuffer (services that are in indexes 3,4,5,6).
N            3.    Get max of 2 int services from index 6.
N                - Up to 2 int services from index 6 are inserted into pBuffer (services that are in indexes 6,7).
N        See below - command parameters.
N                    
N        \param[in]  IndexOffset - The start index in the peer cache that from it the first service is returned.
N        \param[in]  MaxServiceCount - The Max services that can be returned if existed or if not exceed the max index 
N                                      in the peer cache
N        \param[in]  Flags - an ENUM number that means which service struct to use (means which types of service to fill)                                            
N                          - use SL_NETAPP_FULL_SERVICE_WITH_TEXT_IPV4_TYPE  for SlNetAppGetFullServiceWithTextIpv4List_t
N                          - use SL_NETAPP_FULL_SERVICE_IPV4_TYPE for SlNetAppGetFullServiceIpv4List_t
N                          - use SL_NETAPP_SHORT_SERVICE_IPV4_TYP SlNetAppGetShortServiceIpv4List_t
N                          - use SL_NETAPP_FULL_SERVICE_IPV6_TYPE, SlNetAppGetFullServiceIpv6List_t
N                          - use SL_NETAPP_SHORT_SERVICE_IPV6_TYPE SlNetAppGetShortServiceIpv6List_t
N                          - use SL_NETAPP_FULL_SERVICE_WITH_TEXT_IPV6_TYPE  SlNetAppGetFullServiceWithTextIpv6List_t
N
N       \param[out]  pBuffer - The Services are inserted into this buffer. In the struct form according to the bit that is set in the Flags 
N                    input parameter.
N
N        \param[in]  BufferLength - The allocated buffer length (pointed by pBuffer).
N 
N        \return     ServiceFoundCount - The number of the services that were inserted into the buffer.\n 
N                    Zero means no service is found negative number means an error
N        \sa         sl_NetAppMDNSRegisterService
N        \note        
N        \warning 
N                    If the out pBuffer size is bigger than an RX packet(1480), than
N                    an error is returned because there is no place in the RX packet.\n
N                    The size is a multiply of MaxServiceCount and size of service struct(that is set 
N                    according to flag value).
N*/
N
N#if _SL_INCLUDE_FUNC(sl_NetAppGetServiceList)
X#if (1)
N_i16 sl_NetAppGetServiceList(const _u8   IndexOffset,
Xsigned short sl_NetAppGetServiceList(const unsigned char   IndexOffset,
N                             const _u8   MaxServiceCount,
X                             const unsigned char   MaxServiceCount,
N                             const  _u8  Flags,
X                             const  unsigned char  Flags,
N                                   _i8   *pBuffer,
X                                   signed char   *pBuffer,
N                             const _u32  BufferLength
X                             const unsigned long  BufferLength
N                            );
N
N#endif
N
N/*!
N        \brief Unregister mDNS service\n
N        This function deletes the mDNS service from the mDNS package and the database.
N
N        The mDNS service that is to be unregistered is a service that the application no longer wishes to provide. \n
N        The service name should be the full service name according to RFC
N        of the DNS-SD - meaning the value in name field in the SRV answer.
N                    
N        Examples for service names:
N        1. PC1._ipp._tcp.local
N        2. PC2_server._ftp._tcp.local
N
N        \param[in]    pServiceName      Full service name. \n
N        \param[in]    ServiceNameLen    The length of the service. 
N        \param[in]    Options           bitwise parameters: \n
N                                        - SL_NETAPP_MDNS_OPTIONS_IS_UNIQUE_BIT     bit 0   - service is unique per interface (means that the service needs to be unique)
N                                        - SL_NETAPP_MDNS_IPV6_IPV4_SERVICE         bit 27  - add this service to IPv6 interface, if exist (default is IPv4 service only)
N                                        - SL_NETAPP_MDNS_IPV6_ONLY_SERVICE         bit 28  - add this service to IPv6 interface, but remove it from IPv4 (only IPv6 is available)
N                                        - SL_NETAPP_MDNS_OPTION_UPDATE_TEXT        bit 29  - for update text fields (without reregister the service)
N                                        - SL_NETAPP_MDNS_OPTIONS_IS_NOT_PERSISTENT bit 30  - for setting a non persistent service
N                                        - SL_NETAPP_MDNS_OPTIONS_ADD_SERVICE_BIT   bit 31  - for internal use if the service should be added or deleted (set means ADD).
N
N        \return    Zero on success, or negative error code on failure 
N        \sa          sl_NetAppMDNSRegisterService
N        \note        
N        \warning 
N        The size of the service length should be smaller than 255.
N*/
N#if _SL_INCLUDE_FUNC(sl_NetAppMDNSUnRegisterService)
X#if (1)
N_i16 sl_NetAppMDNSUnRegisterService(const _i8 *pServiceName,const _u8 ServiceNameLen,_u32 Options);
Xsigned short sl_NetAppMDNSUnRegisterService(const signed char *pServiceName,const unsigned char ServiceNameLen,unsigned long Options);
N#endif
N
N/*!
N        \brief Register a new mDNS service\n
N        This function registers a new mDNS service to the mDNS package and the DB. \n
N        This registered service is a service offered by the application.
N        The service name should be full service name according to RFC
N        of the DNS-SD - meaning the value in name field in the SRV answer.\n
N        Example for service name:
N        1. PC1._ipp._tcp.local
N        2. PC2_server._ftp._tcp.local
N
N        If the option is_unique is set, mDNS probes the service name to make sure
N        it is unique before starting to announce the service on the network.
N        Instance is the instance portion of the service name.
N
N        \param[in]  ServiceNameLen  The length of the service.
N        \param[in]  TextLen         The length of the service should be smaller than 64.
N        \param[in]  Port            The port on this target host port.
N        \param[in]  TTL             The TTL of the service
N        \param[in]  Options         bitwise parameters: \n
N                                    - SL_NETAPP_MDNS_OPTIONS_IS_UNIQUE_BIT     bit 0   - service is unique per interface (means that the service needs to be unique)
N                                    - SL_NETAPP_MDNS_IPV6_IPV4_SERVICE         bit 27  - add this service to IPv6 interface, if exist (default is IPv4 service only)
N                                    - SL_NETAPP_MDNS_IPV6_ONLY_SERVICE         bit 28  - add this service to IPv6 interface, but remove it from IPv4 (only IPv6 is available)
N                                    - SL_NETAPP_MDNS_OPTION_UPDATE_TEXT        bit 29  - for update text fields (without reregister the service)
N                                    - SL_NETAPP_MDNS_OPTIONS_IS_NOT_PERSISTENT bit 30  - for setting a non persistent service
N                                    - SL_NETAPP_MDNS_OPTIONS_ADD_SERVICE_BIT   bit 31  - for internal use if the service should be added or deleted (set means ADD).
N
N        \param[in] pServiceName     The service name.
N        \param[in] pText            The description of the service.
N                                    should be as mentioned in the RFC
N                                    (according to type of the service IPP,FTP...)
N
N        \return    Zero on success, or negative error code on failure
N
N        \sa        sl_NetAppMDNSUnRegisterService
N
N        \warning   1) Temporary -  there is an allocation on stack of internal buffer.
N                   Its size is SL_NETAPP_MDNS_MAX_SERVICE_NAME_AND_TEXT_LENGTH. \n
N                   It means that the sum of the text length and service name length cannot be bigger than
N                   SL_NETAPP_MDNS_MAX_SERVICE_NAME_AND_TEXT_LENGTH.\n
N                   If it is - An error is returned. \n
N                   2) According to now from certain constraints the variables parameters are set in the
N                   attribute part (contain constant parameters)
N
N        \par   Examples:
N
N    - Register a new service:
N    \code
N        const signed char AddService[40]            = "PC1._ipp._tcp.local";
N        _u32  Options;
N
N        Options = SL_NETAPP_MDNS_OPTIONS_IS_UNIQUE_BIT | SL_NETAPP_MDNS_OPTIONS_IS_NOT_PERSISTENT;
N        sl_NetAppMDNSRegisterService(AddService,sizeof(AddService),"Service 1;payper=A3;size=5",strlen("Service 1;payper=A3;size=5"),1000,120,Options);
N    \endcode
N    <br>
N
N    - Update text for existing service:
N    \code
N        Please Note! Update is for text only! Importent to apply the same persistent flag options as original service registration.\n
N
N        Options = SL_NETAPP_MDNS_OPTION_UPDATE_TEXT | SL_NETAPP_MDNS_OPTIONS_IS_NOT_PERSISTENT;
N        sl_NetAppMDNSRegisterService(AddService,sizeof(AddService),"Service 5;payper=A4;size=10",strlen("Service 5;payper=A4;size=10"),1000,120,Options);
N    \endcode 
N*/
N#if _SL_INCLUDE_FUNC(sl_NetAppMDNSRegisterService)
X#if (1)
N_i16 sl_NetAppMDNSRegisterService( const _i8*  pServiceName, 
Xsigned short sl_NetAppMDNSRegisterService( const signed char*  pServiceName, 
N                                   const _u8   ServiceNameLen,
X                                   const unsigned char   ServiceNameLen,
N                                   const _i8*  pText,
X                                   const signed char*  pText,
N                                   const _u8   TextLen,
X                                   const unsigned char   TextLen,
N                                   const _u16  Port,
X                                   const unsigned short  Port,
N                                   const _u32  TTL,
X                                   const unsigned long  TTL,
N                                         _u32  Options);
X                                         unsigned long  Options);
N#endif
N
N/*!
N    \brief send ICMP ECHO_REQUEST to network hosts
N
N    Ping uses the ICMP protocol's mandatory ECHO_REQUEST
N
N    \param[in]   pPingParams     Pointer to the ping request structure: 
N                                 - If flags parameter is set to 0, ping will report back once all requested pings are done (as defined by TotalNumberOfAttempts). 
N                                 - If flags parameter is set to 1, ping will report back after every ping, for TotalNumberOfAttempts.
N                                 - If flags parameter is set to 2, ping will stop after the first successful ping, and report back for the successful ping, as well as any preceding failed ones. \n
N                                 - If flags parameter is set to 4, for ipv4 -  don`t fragment the ping packet. This flag can be set with other flags.
N                                 For stopping an ongoing ping activity, set parameters IP address to 0
N    \param[in]   Family          SL_AF_INET or  SL_AF_INET6
N    \param[out]  pReport         Ping pReport
N    \param[out]  pPingCallback   Callback function upon completion.\n
N                                 If callback is NULL, the API is blocked until data arrives
N
N    \return    Zero on success, or negative error code on failure.\n
N               SL_POOL_IS_EMPTY may be return in case there are no resources in the system
N               In this case try again later or increase MAX_CONCURRENT_ACTIONS
N
N    \sa       
N    \note     Only one sl_NetAppPing can be handled at a time.
N              Calling this API while the same command is called from another thread, may result
N              in one of the two scenarios:
N              1. The command will wait (internal) until the previous command finish, and then be executed.
N              2. There are not enough resources and SL_POOL_IS_EMPTY error will return. 
N              In this case, MAX_CONCURRENT_ACTIONS can be increased (result in memory increase) or try
N              again later to issue the command.
N    \warning  
N    \par      Example:
N    
N    - Sending 20 ping requests and reporting results to a callback routine when 
N      all requests are sent:
N    \code     
N        // callback routine
N        void pingRes(SlNetAppPingReport_t* pReport)
N        {
N        // handle ping results 
N        }
N              
N        // ping activation
N        void PingTest()
N        {
N            SlNetAppPingReport_t report;
N            SlNetAppPingCommand_t pingCommand;
N                 
N            pingCommand.Ip = SL_IPV4_VAL(10,1,1,200);     // destination IP address is 10.1.1.200
N            pingCommand.PingSize = 150;                   // size of ping, in bytes 
N            pingCommand.PingIntervalTime = 100;           // delay between pings, in milliseconds
N            pingCommand.PingRequestTimeout = 1000;        // timeout for every ping in milliseconds
N            pingCommand.TotalNumberOfAttempts = 20;       // max number of ping requests. 0 - forever 
N            pingCommand.Flags = 0;                        // report only when finished
N  
N            sl_NetAppPing( &pingCommand, SL_AF_INET, &report, pingRes );
N        }
N    \endcode
N    <br>
N
N    - Stopping Ping command:
N    \code
N        Status = sl_NetAppPing(0, 0, 0, 0 );
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_NetAppPing)
X#if (1)
N_i16 sl_NetAppPing(const SlNetAppPingCommand_t* pPingParams,const _u8 Family, SlNetAppPingReport_t *pReport, const P_SL_DEV_PING_CALLBACK pPingCallback);
Xsigned short sl_NetAppPing(const SlNetAppPingCommand_t* pPingParams,const unsigned char Family, SlNetAppPingReport_t *pReport, const P_SL_DEV_PING_CALLBACK pPingCallback);
N#endif
N
N/*!
N    \brief     Setting network application configurations
N
N    \param[in] AppId          Application id, could be one of the following: 
N                              - SL_NETAPP_HTTP_SERVER_ID
N                              - SL_NETAPP_DHCP_SERVER_ID (AP Role only)
N                              - SL_NETAPP_MDNS_ID
N                              - SL_NETAPP_DNS_SERVER_ID
N                              - SL_NETAPP_DEVICE_ID
N                              - SL_NETAPP_DNS_CLIENT_ID
N
N    \param[in] Option           Set option, could be one of the following:
N                                - For SL_NETAPP_HTTP_SERVER_ID
N                                    - SL_NETAPP_HTTP_PRIMARY_PORT_NUMBER
N                                    - SL_NETAPP_HTTP_AUTH_CHECK
N                                    - SL_NETAPP_HTTP_AUTH_NAME
N                                    - SL_NETAPP_HTTP_AUTH_PASSWORD
N                                    - SL_NETAPP_HTTP_AUTH_REALM
N                                    - SL_NETAPP_HTTP_ROM_PAGES_ACCESS
N                                    - SL_NETAPP_HTTP_SECONDARY_PORT_NUMBER
N                                    - SL_NETAPP_HTTP_SECONDARY_PORT_ENABLE
N                                    - SL_NETAPP_HTTP_PRIMARY_PORT_SECURITY_MODE
N                                    - SL_NETAPP_HTTP_PRIVATE_KEY_FILENAME
N                                    - SL_NETAPP_HTTP_DEVICE_CERTIFICATE_FILENAME
N                                    - SL_NETAPP_HTTP_CA_CERTIFICATE_FILE_NAME
N                                    - SL_NETAPP_HTTP_TEMP_REGISTER_MDNS_SERVICE_NAME
N                                    - SL_NETAPP_HTTP_TEMP_UNREGISTER_MDNS_SERVICE_NAME
N                                - For SL_NETAPP_DHCP_SERVER_ID:
N                                    - SL_NETAPP_DHCP_SERVER_BASIC_OPT
N                                - For SL_NETAPP_MDNS_ID:
N                                    - SL_NETAPP_MDNS_CONT_QUERY_OPT
N                                    - SL_NETAPP_MDNS_QEVETN_MASK_OPT
N                                    - SL_NETAPP_MDNS_TIMING_PARAMS_OPT 
N                                - For SL_NETAPP_DEVICE_ID:
N                                    - SL_NETAPP_DEVICE_URN
N                                    - SL_NETAPP_DEVICE_DOMAIN
N                                - For SL_NETAPP_DNS_CLIENT_ID:
N                                    - SL_NETAPP_DNS_CLIENT_TIME
N    \param[in] OptionLen        Option structure length
N
N    \param[in] pOptionValue     Pointer to the option structure
N
N    \par Persistent                 
N    \par
N                                <b>Reset</b>:                
N                                    - SL_NETAPP_DHCP_SERVER_BASIC_OPT \n
N    \par
N                                <b>Non- Persistent</b>:                    
N                                    - SL_NETAPP_HTTP_TEMP_REGISTER_MDNS_SERVICE_NAME
N                                    - SL_NETAPP_HTTP_TEMP_UNREGISTER_MDNS_SERVICE_NAME \n
N    \par
N                                <b>System Persistent</b>: 
N                                    - SL_NETAPP_HTTP_PRIMARY_PORT_NUMBER
N                                    - SL_NETAPP_HTTP_AUTH_CHECK
N                                    - SL_NETAPP_HTTP_AUTH_NAME
N                                    - SL_NETAPP_HTTP_AUTH_PASSWORD
N                                    - SL_NETAPP_HTTP_AUTH_REALM
N                                    - SL_NETAPP_HTTP_ROM_PAGES_ACCESS
N                                    - SL_NETAPP_HTTP_SECONDARY_PORT_NUMBER
N                                    - SL_NETAPP_HTTP_SECONDARY_PORT_ENABLE
N                                    - SL_NETAPP_HTTP_PRIMARY_PORT_SECURITY_MODE
N                                    - SL_NETAPP_HTTP_PRIVATE_KEY_FILENAME
N                                    - SL_NETAPP_HTTP_DEVICE_CERTIFICATE_FILE_NAME
N                                    - SL_NETAPP_HTTP_CA_CERTIFICATE_FILENAME
N                                    - SL_NETAPP_MDNS_CONT_QUERY_OPT
N                                    - SL_NETAPP_MDNS_QEVETN_MASK_OPT
N                                    - SL_NETAPP_MDNS_TIMING_PARAMS_OPT 
N                                    - SL_NETAPP_DEV_CONF_OPT_DEVICE_URN
N                                    - SL_NETAPP_DEV_CONF_OPT_DOMAIN_NAME
N
N    \return    Zero on success, or negative value if an error occurred.
N    \sa        sl_NetAppGet
N    \note
N    \warning
N    \par       Example
N    
N    - Setting DHCP Server (AP mode) parameters example:
N    \code             
N        SlNetAppDhcpServerBasicOpt_t dhcpParams; 
N        _u8 outLen = sizeof(SlNetAppDhcpServerBasicOpt_t); 
N        dhcpParams.lease_time      = 4096;                         // lease time (in seconds) of the IP Address
N        dhcpParams.ipv4_addr_start =  SL_IPV4_VAL(192,168,1,10);   // first IP Address for allocation. IP Address should be set as Hex number - i.e. 0A0B0C01 for (10.11.12.1)
N        dhcpParams.ipv4_addr_last  =  SL_IPV4_VAL(192,168,1,16);   // last IP Address for allocation. IP Address should be set as Hex number - i.e. 0A0B0C01 for (10.11.12.1)
N        sl_NetAppStop(SL_NETAPP_DHCP_SERVER_ID);                   // Stop DHCP server before settings
N        sl_NetAppSet(SL_NETAPP_DHCP_SERVER_ID, SL_NETAPP_DHCP_SRV_BASIC_OPT, outLen, (_u8* )&dhcpParams);  // set parameters
N        sl_NetAppStart(SL_NETAPP_DHCP_SERVER_ID);                  // Start DHCP server with new settings
N    \endcode
N    <br>
N
N    - Setting Device URN name: <br>
N    Device name, maximum length of 32 characters 
N    Device name affects URN name, and WPS file "device name" in WPS I.E (STA-WPS / P2P)
N    In case no device URN name set, the default name is "mysimplelink" 
N    In case of setting the device name with length 0, device will return to default name "mysimplelink"
N    Allowed characters in device name are: 'a - z' , 'A - Z' , '0-9' and '-'
N    \code
N        _u8 *my_device = "MY-SIMPLELINK-DEV";
N        sl_NetAppSet (SL_NETAPP_DEVICE_ID, SL_NETAPP_DEVICE_URN, strlen(my_device), (_u8 *) my_device);
N    \endcode
N    <br>
N    
N    - Register new temporary HTTP service name for MDNS (not persistent):  
N    \code
N        _u8 *my_http_temp_name = "New - Bonjour Service Name";
N        sl_NetAppSet (SL_NETAPP_HTTP_SERVER_ID, SL_NETAPP_HTTP_TEMP_REGISTER_MDNS_SERVICE_NAME, strlen(my_http_temp_name), (_u8 *) my_http_temp_name); 
N    \endcode
N    <br>
N
N    - Remove registration of current HTTP internal MDNS service (not persistent) :
N    \code
N        _u8 *old_http_name  = "0800285A7891@mysimplelink-022";
N        sl_NetAppSet (SL_NETAPP_HTTP_SERVER_ID, SL_NETAPP_HTTP_TEMP_UNREGISTER_MDNS_SERVICE_NAME, strlen(old_http_name), (_u8 *) old_http_name); 
N    \endcode
N    <br>
N
N    -   Set DNS client time example: <br>
N        Set DNS client (sl_NetAppDnsGetHostByName) timeout, two parameters max_response_time and number_retries. 
N        number_retries: Max number of DNS request before sl_NetAppDnsGetHostByName failed, (up to 100 retries).
N        max_response_time: DNS request timeout changed every retry, it`s start with 100 millisecond and increased every retry up to max_response_time milliseconds, (up to 2 seconds)
N    \code
N        SlNetAppDnsClientTime_t time;
N         time.MaxResponseTime = 2000;
N        time.NumOfRetries = 30;
N        sl_NetAppSet (SL_NETAPP_DNS_CLIENT_ID, SL_NETAPP_DNS_CLIENT_TIME, sizeof(time), (_u8 *)&time);
N    \endcode
N    <br>
N
N    - Start MDNS continuous querys: <br>
N    In a continuous mDNS query mode, the device keeps sending queries to the network according to a specific service name. 
N    The query will be sent in IPv4 and IPv6 (if enabled) format. To see the completed list of responding services sl_NetAppGetServiceList() need to be called
N    \code
N        const signed char AddService[40]            = "Printer._ipp._tcp.local";
N        _i16 Status;
N
N        Status = sl_NetAppSet(SL_NETAPP_MDNS_ID, SL_NETAPP_MDNS_CONT_QUERY_OPT,strlen(AddService) , &AddService);
N    \endcode
N    <br>
N
N    - Stop MDNS:
N    \code
N        Status = sl_NetAppSet(SL_NETAPP_MDNS_ID, SL_NETAPP_MDNS_CONT_QUERY_OPT,0 , 0);
N    \endcode
N    <br>
N
N    - Set MDNS timing parameters for service advertisement: <br>
N    This option allows to control and reconfigures the timing parameters for service advertisement
N    \code
N        SlNetAppServiceAdvertiseTimingParameters_t Timing;
N        _i16 Status;
N        
N        Timing.t = 200; // 2 seconds
N        Timing.p = 2; // 2 repetitions
N        Timing.k = 2; // Telescopic factor 2
N        Timing.RetransInterval = 0; 
N        Timing.Maxinterval = 0xFFFFFFFF;
N        Timing.max_time = 5;
N
N        Status = sl_NetAppSet(SL_NETAPP_MDNS_ID, SL_NETAPP_MDNS_TIMING_PARAMS_OPT,sizeof(Timing),&Timing);
N
N    \endcode
N    <br>
N
N    - User-defined service types to monitor: <br>
N      In cases that the user decides not to get responses from certain 
N      types of services it should set the adapt bit in the event mask that is related to:
N    \code
N        // bit 0:  _ipp  
N        // bit 1:  _device-info 
N        // bit 2:  _http
N        // bit 3:  _https
N        // bit 4:  _workstation
N        // bit 5:  _guid
N        // bit 6:  _h323
N        // bit 7:  _ntp
N        // bit 8:  _objective
N        // bit 9:  _rdp
N        // bit 10: _remote
N        // bit 11: _rtsp
N        // bit 12: _sip
N        // bit 13: _smb
N        // bit 14: _soap
N        // bit 15: _ssh
N        // bit 16: _telnet
N        // bit 17: _tftp
N        // bit 18: _xmpp-client
N        // bit 19: _raop
N
N        _u32 EventMask;
N        _i16 Status;
N
N        EventMask = BIT0 | BIT1 | BIT18;
N        Status = sl_NetAppSet(SL_NETAPP_MDNS_ID, SL_NETAPP_MDNS_QEVETN_MASK_OPT,sizeof(EventMask),&EventMask);
N    \endcode
N    <br>
N*/
N#if _SL_INCLUDE_FUNC(sl_NetAppSet)
X#if (1)
N_i16 sl_NetAppSet(const _u8 AppId ,const _u8 Option,const _u8 OptionLen,const _u8 *pOptionValue);
Xsigned short sl_NetAppSet(const unsigned char AppId ,const unsigned char Option,const unsigned char OptionLen,const unsigned char *pOptionValue);
N#endif
N
N/*!
N    \brief     Getting network applications configurations
N
N    \param[in] AppId         Application id, could be one of the following: \n
N                              - SL_NETAPP_HTTP_SERVER_ID
N                              - SL_NETAPP_DHCP_SERVER_ID
N                              - SL_NETAPP_DNS_SERVER_ID
N                              - SL_NETAPP_DEVICE_ID
N                              - SL_NETAPP_DNS_CLIENT_ID
N
N    \param[in] Option         Get option, could be one of the following: \n
N                              - SL_NETAPP_DHCP_SERVER_ID:
N                              - SL_NETAPP_DHCP_SRV_BASIC_OPT
N                              - SL_NETAPP_HTTP_SERVER_ID:
N                              - SL_NETAPP_HTTP_PRIMARY_PORT_NUMBER
N                              - SL_NETAPP_HTTP_AUTH_CHECK
N                              - SL_NETAPP_HTTP_AUTH_NAME
N                              - SL_NETAPP_HTTP_AUTH_PASSWORD
N                              - SL_NETAPP_HTTP_AUTH_REALM
N                              - SL_NETAPP_HTTP_ROM_PAGES_ACCESS
N                              - SL_NETAPP_HTTP_SECONDARY_PORT_NUMBER
N                              - SL_NETAPP_HTTP_SECONDARY_PORT_ENABLE
N                              - SL_NETAPP_HTTP_PRIMARY_PORT_SECURITY_MODE
N                              - SL_NETAPP_MDNS_ID:
N                              - SL_NETAPP_MDNS_CONT_QUERY_OPT
N                              - SL_NETAPP_MDNS_QEVETN_MASK_OPT
N                              - SL_NETAPP_MDNS_TIMING_PARAMS_OPT
N                              - SL_NETAPP_DEVICE_ID:
N                              - SL_NETAPP_DEVICE_URN
N                              - SL_NETAPP_DEVICE_DOMAIN
N                              - SL_NETAPP_DNS_CLIENT_ID:
N                              - SL_NETAPP_DNS_CLIENT_TIME
N
N    \param[in] pOptionLen     The length of the allocated memory as input, when the
N                              function complete, the value of this parameter would be
N                              the len that actually read from the device.\n
N                              If the device return length that is longer from the input
N                              value, the function will cut the end of the returned structure
N                              and will return ESMALLBUF
N
N    \param[out] pOptionValue  pointer to the option structure which will be filled with the response from the device
N
N    \return     Zero on success, or negative value if an error occurred.
N
N    \sa         sl_NetAppSet
N    \note
N    \warning
N    \par Example
N
N    - Getting DHCP Server parameters example:
N    \code
N         SlNetAppDhcpServerBasicOpt_t dhcpParams;
N         _u8 outLen = sizeof(SlNetAppDhcpServerBasicOpt_t);
N         sl_NetAppGet(SL_NETAPP_DHCP_SERVER_ID, SL_NETAPP_SET_DHCP_SRV_BASIC_OPT, &outLen, (_u8* )&dhcpParams);
N 
N         printf("DHCP Start IP %d.%d.%d.%d End IP %d.%d.%d.%d Lease time seconds %d\n",                                                           
N            SL_IPV4_BYTE(dhcpParams.ipv4_addr_start,3),SL_IPV4_BYTE(dhcpParams.ipv4_addr_start,2),
N            SL_IPV4_BYTE(dhcpParams.ipv4_addr_start,1),SL_IPV4_BYTE(dhcpParams.ipv4_addr_start,0), 
N            SL_IPV4_BYTE(dhcpParams.ipv4_addr_last,3),SL_IPV4_BYTE(dhcpParams.ipv4_addr_last,2),
N            SL_IPV4_BYTE(dhcpParams.ipv4_addr_last,1),SL_IPV4_BYTE(dhcpParams.ipv4_addr_last,0),         
N            dhcpParams.lease_time);    
N    \endcode
N    <br>
N
N    - Getting device URN name: <br>
N    Maximum length of 32 characters of device name. 
N    Device name affects URN name, own SSID name in AP mode, and WPS file "device name" in WPS I.E (STA-WPS / P2P)
N    in case no device URN name set, the default name is "mysimplelink" 
N    \code
N        _u8 my_device_name[SL_NETAPP_MAX_DEVICE_URN_LEN];
N        sl_NetAppGet (SL_NETAPP_DEVICE_ID, SL_NETAPP_DEVICE_URN, strlen(my_device_name), (_u8 *)my_device_name); 
N    \endcode
N    <br>
N    
N    - Getting DNS client time: <br>
N      Get DNS client (sl_NetAppDnsGetHostByName) timeout, two parameters max_response_time and number_retries. 
N      number_retries: Max number of DNS request before sl_NetAppDnsGetHostByName failed.
N      max_response_time: DNS request timeout changed every retry, it`s start with 100 millisecond and increased every retry up to max_response_time milliseconds
N    \code
N        SlNetAppDnsClientTime_t time;
N        _u8 pOptionLen  = sizeof(time);
N        sl_NetAppGet (SL_NETAPP_DNS_CLIENT_ID, SL_NETAPP_DNS_CLIENT_TIME, &pOptionLen, (_u8 *)&time); 
N    \endcode
N    <br>
N
N    - Getting active applications: <br>
N      Get active applications for active role. return value is mask of the active application (similar defines as sl_NetAppStart\sl_NetAppStop):
N    \code
N        _u32 AppBitMap;
N        _u8 pOptionLen  = sizeof(AppBitMap);
N        sl_NetAppGet (SL_NETAPP_STATUS, SL_NETAPP_STATUS_ACTIVE_APP, &pOptionLen, (_u8 *)&AppBitMap); 
N
N    \endcode
N
N*/
N#if _SL_INCLUDE_FUNC(sl_NetAppGet)
X#if (1)
N_i16 sl_NetAppGet(const _u8 AppId, const _u8 Option,_u8 *pOptionLen, _u8 *pOptionValue);
Xsigned short sl_NetAppGet(const unsigned char AppId, const unsigned char Option,unsigned char *pOptionLen, unsigned char *pOptionValue);
N#endif
N
N/*!
N    \brief     Function for sending Netapp response or data following a Netapp request event (i.e. HTTP GET request)
N
N
N    \param[in]  Handle   Handle to send the data to. Should match the handle received in the Netapp request event
N    \param[in]  DataLen  Data Length
N    \param[in]  pData    Data to send. Can be just data payload or metadata (depends on flags)
N    \param[out] Flags   Can have the following values:
N                        - SL_NETAPP_REQUEST_RESPONSE_FLAGS_CONTINUATION - More data will arrive in subsequent calls to NetAppSend
N                        - SL_NETAPP_REQUEST_RESPONSE_FLAGS_METADATA      - 0 - data is payload, 1 - data is metadata
N                        - SL_NETAPP_REQUEST_RESPONSE_FLAGS_ACCUMULATION - The network processor should accumulate the data chunks and will process it when it is completelly received
N
N    \return     Zero on success, or negative error code on failure
N
N    \sa         sl_NetAppRecv 
N    \note
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_NetAppSend)
X#if (1)
N_u16 sl_NetAppSend( _u16 Handle, _u16 DataLen, _u8 *pData, _u32 Flags);
Xunsigned short sl_NetAppSend( unsigned short Handle, unsigned short DataLen, unsigned char *pData, unsigned long Flags);
N#endif
N
N/*!
N    \brief     Function for retrieving data from the network processor following a Netapp request event (i.e. HTTP POST request)
N
N    \param[in]      Handle     Handle to receive data from. Should match the handle received in the Netapp request event
N    \param[in,out]  *DataLen   Max buffer size (in) / Actual data received (out)
N    \param[out]     *pData     Data received
N    \param[in,out]  *Flags     Can have the following values:
N                               - SL_NETAPP_REQUEST_RESPONSE_FLAGS_CONTINUATION (out) 
N                               - More data is pending in the network procesor. Application should continue reading the data by calling sl_NetAppRecv again
N
N    \return         Zero on success, or negative error code on failure
N
N    \sa             sl_NetAppSend 
N    \note    
N    \warning        handle is received in the sl_NetAppRequestHandler callback. Handle is valid untill all data is receive from the network processor.
N*/
N#if _SL_INCLUDE_FUNC(sl_NetAppRecv)
X#if (1)
N_SlReturnVal_t sl_NetAppRecv( _u16 Handle, _u16 *DataLen, _u8 *pData, _u32 *Flags);
X_SlReturnVal_t sl_NetAppRecv( unsigned short Handle, unsigned short *DataLen, unsigned char *pData, unsigned long *Flags);
N#endif
N
N/*!
N
N Close the Doxygen group.
N @}
N
N */
N
N
N#ifdef  __cplusplus
S}
N#endif /*  __cplusplus */
N
N#endif    /*  __NETAPP_H__ */
N
L 412 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N#include "wlan.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/wlan.h" 1
N/*
N * wlan.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N#include <ti/drivers/net/wifi/simplelink.h>
N
N#ifndef __WLAN_H__
N#define __WLAN_H__
N
N
N#ifdef    __cplusplus
Sextern "C" {
N#endif
N
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N/*!
N    \defgroup Wlan 
N    \short Controls the use of the WiFi WLAN module
N
N*/
N/*!
N
N    \addtogroup Wlan
N    - Connection features, such as: profiles, policies, SmartConfig(tm)
N    - Advanced WLAN features, such as: scans, rx filters and rx statistics collection
N
N    @{
N
N*/
N
N#define SL_WLAN_BSSID_LENGTH                    (6)
N#define SL_WLAN_SSID_MAX_LENGTH                 (32)
N
N#define SL_WLAN_NUM_OF_RATE_INDEXES             (20)
N#define SL_WLAN_SIZE_OF_RSSI_HISTOGRAM          (6)
N#define SL_WLAN_SMART_CONFIG_KEY_LENGTH         (16)
N#define SL_WLAN_SMART_CONFIG_DEFAULT_CIPHER     (1)
N#define SL_WLAN_SMART_CONFIG_DEFAULT_GROUP      (0)
N
N#define SL_WLAN_MAX_PROFILES                    (7)
N#define SL_WLAN_DEL_ALL_PROFILES                (255)
N
Ntypedef enum
N{
N    SL_WLAN_P2P_WPS_METHOD_DEFAULT,
N    SL_WLAN_P2P_WPS_METHOD_PIN_USER,
N    SL_WLAN_P2P_WPS_METHOD_PIN_MACHINE,
N    SL_WLAN_P2P_WPS_METHOD_REKEY,
N    SL_WLAN_P2P_WPS_METHOD_PBC,
N    SL_WLAN_P2P_WPS_METHOD_REGISTRAR
N} SlWlanP2PWpsMethod_e;
N
N/* WLAN user events */
Ntypedef enum
N{
N    SL_WLAN_EVENT_CONNECT = 1,
N    SL_WLAN_EVENT_DISCONNECT,
N    SL_WLAN_EVENT_STA_ADDED,
N    SL_WLAN_EVENT_STA_REMOVED,
N
N    SL_WLAN_EVENT_P2P_CONNECT,
N    SL_WLAN_EVENT_P2P_DISCONNECT,
N    SL_WLAN_EVENT_P2P_CLIENT_ADDED,
N    SL_WLAN_EVENT_P2P_CLIENT_REMOVED,
N    SL_WLAN_EVENT_P2P_DEVFOUND,
N    SL_WLAN_EVENT_P2P_REQUEST,
N    SL_WLAN_EVENT_P2P_CONNECTFAIL,
N
N    SL_WLAN_EVENT_RXFILTER,
N    SL_WLAN_EVENT_PROVISIONING_STATUS,
N    SL_WLAN_EVENT_PROVISIONING_PROFILE_ADDED,
N    SL_WLAN_EVENT_MAX
N
N} SlWlanEventId_e;
N
N
N/* WLAN Disconnect Reason Codes */
N#define  SL_WLAN_DISCONNECT_UNSPECIFIED                                              (1)
N     #define  SL_WLAN_DISCONNECT_AUTH_NO_LONGER_VALID                                (2)
N     #define  SL_WLAN_DISCONNECT_DEAUTH_SENDING_STA_LEAVING                          (3)
N     #define  SL_WLAN_DISCONNECT_INACTIVITY                                          (4)
N     #define  SL_WLAN_DISCONNECT_TOO_MANY_STA                                        (5)
N     #define  SL_WLAN_DISCONNECT_FRAME_FROM_NONAUTH_STA                              (6)
N     #define  SL_WLAN_DISCONNECT_FRAME_FROM_NONASSOC_STA                             (7)
N     #define  SL_WLAN_DISCONNECT_DISS_SENDING_STA_LEAVING                            (8)
N     #define  SL_WLAN_DISCONNECT_STA_NOT_AUTH                                        (9)
N     #define  SL_WLAN_DISCONNECT_POWER_CAPABILITY_INVALID                            (10)
N     #define  SL_WLAN_DISCONNECT_SUPPORTED_CHANNELS_INVALID                          (11)
N     #define  SL_WLAN_DISCONNECT_INVALID_IE                                          (13)
N     #define  SL_WLAN_DISCONNECT_MIC_FAILURE                                         (14)
N     #define  SL_WLAN_DISCONNECT_FOURWAY_HANDSHAKE_TIMEOUT                           (15)
N     #define  SL_WLAN_DISCONNECT_GROUPKEY_HANDSHAKE_TIMEOUT                          (16)
N     #define  SL_WLAN_DISCONNECT_REASSOC_INVALID_IE                                  (17)
N     #define  SL_WLAN_DISCONNECT_INVALID_GROUP_CIPHER                                (18)
N     #define  SL_WLAN_DISCONNECT_INVALID_PAIRWISE_CIPHER                             (19)
N     #define  SL_WLAN_DISCONNECT_INVALID_AKMP                                        (20)
N     #define  SL_WLAN_DISCONNECT_UNSUPPORTED_RSN_VERSION                             (21)
N     #define  SL_WLAN_DISCONNECT_INVALID_RSN_CAPABILITIES                            (22)
N     #define  SL_WLAN_DISCONNECT_IEEE_802_1X_AUTHENTICATION_FAILED                   (23)
N     #define  SL_WLAN_DISCONNECT_CIPHER_SUITE_REJECTED                               (24)
N     #define  SL_WLAN_DISCONNECT_DISASSOC_QOS                                        (32)
N     #define  SL_WLAN_DISCONNECT_DISASSOC_QOS_BANDWIDTH                              (33)
N     #define  SL_WLAN_DISCONNECT_DISASSOC_EXCESSIVE_ACK_PENDING                      (34)
N     #define  SL_WLAN_DISCONNECT_DISASSOC_TXOP_LIMIT                                 (35)
N     #define  SL_WLAN_DISCONNECT_STA_LEAVING                                         (36)
N     #define  SL_WLAN_DISCONNECT_STA_DECLINED                                        (37)
N     #define  SL_WLAN_DISCONNECT_STA_UNKNOWN_BA                                      (38)
N     #define  SL_WLAN_DISCONNECT_STA_TIMEOUT                                         (39)
N     #define  SL_WLAN_DISCONNECT_STA_UNSUPPORTED_CIPHER_SUITE                        (40)
N     #define  SL_WLAN_DISCONNECT_USER_INITIATED                                      (200)
N     #define  SL_WLAN_DISCONNECT_AUTH_TIMEOUT                                        (202)
N     #define  SL_WLAN_DISCONNECT_ASSOC_TIMEOUT                                       (203)
N     #define  SL_WLAN_DISCONNECT_SECURITY_FAILURE                                    (204)
N     #define  SL_WLAN_DISCONNECT_WHILE_CONNNECTING                                   (208)
N     #define  SL_WLAN_DISCONNECT_MISSING_CERT                                        (209)
N     #define  SL_WLAN_DISCONNECT_CERTIFICATE_EXPIRED                                 (210)
N
N
N
N#define  SL_WLAN_STATUS_DISCONNECTED    (0)
N#define  SL_WLAN_STATUS_SCANING         (1)
N#define  SL_WLAN_STATUS_CONNECTING      (2)
N#define  SL_WLAN_STATUS_CONNECTED       (3)
N
N#define SL_WLAN_PROVISIONING_GENERAL_ERROR                                           (0)
N#define SL_WLAN_PROVISIONING_CONFIRMATION_STATUS_FAIL_NETWORK_NOT_FOUND              (1)
N#define SL_WLAN_PROVISIONING_CONFIRMATION_STATUS_FAIL_CONNECTION_FAILED              (2)
N#define SL_WLAN_PROVISIONING_CONFIRMATION_STATUS_CONNECTION_SUCCESS_IP_NOT_ACQUIRED  (3)
N#define SL_WLAN_PROVISIONING_CONFIRMATION_STATUS_SUCCESS_FEEDBACK_FAILED             (4)
N#define SL_WLAN_PROVISIONING_CONFIRMATION_STATUS_SUCCESS                             (5)
N#define SL_WLAN_PROVISIONING_ERROR_ABORT                                             (6)
N#define SL_WLAN_PROVISIONING_ERROR_ABORT_INVALID_PARAM                               (7)
N#define SL_WLAN_PROVISIONING_ERROR_ABORT_HTTP_SERVER_DISABLED                        (8)
N#define SL_WLAN_PROVISIONING_ERROR_ABORT_PROFILE_LIST_FULL                           (9)
N#define SL_WLAN_PROVISIONING_ERROR_ABORT_PROVISIONING_ALREADY_STARTED                (10)
N#define SL_WLAN_PROVISIONING_AUTO_STARTED                                            (11)
N#define SL_WLAN_PROVISIONING_STOPPED                                                 (12)
N#define SL_WLAN_PROVISIONING_SMART_CONFIG_SYNCED                                     (13)
N#define SL_WLAN_PROVISIONING_SMART_CONFIG_SYNC_TIMEOUT                               (14)
N#define SL_WLAN_PROVISIONING_CONFIRMATION_WLAN_CONNECT                               (15)
N#define SL_WLAN_PROVISIONING_CONFIRMATION_IP_ACQUIRED                                (16)
N#define SL_WLAN_PROVISIONING_EXTERNAL_CONFIGURATION_READY                            (17)
N
N#define SL_WLAN_SEC_TYPE_OPEN                                                        (0)
N#define SL_WLAN_SEC_TYPE_WEP                                                         (1)
N#define SL_WLAN_SEC_TYPE_WPA                                                         (2) /* deprecated */
N#define SL_WLAN_SEC_TYPE_WPA_WPA2                                                    (2)
N#define SL_WLAN_SEC_TYPE_WPS_PBC                                                     (3)
N#define SL_WLAN_SEC_TYPE_WPS_PIN                                                     (4)
N#define SL_WLAN_SEC_TYPE_WPA_ENT                                                     (5)
N#define SL_WLAN_SEC_TYPE_P2P_PBC                                                     (6)
N#define SL_WLAN_SEC_TYPE_P2P_PIN_KEYPAD                                              (7)
N#define SL_WLAN_SEC_TYPE_P2P_PIN_DISPLAY                                             (8)
N#define SL_WLAN_SEC_TYPE_P2P_PIN_AUTO                                                (9) /* NOT Supported yet */
N#define SL_WLAN_SEC_TYPE_WEP_SHARED                                                  (10)
N
N#define SL_TLS                                                                       (0x1)
N#define SL_MSCHAP                                                                    (0x0)
N#define SL_PSK                                                                       (0x2)
N#define SL_TTLS                                                                      (0x10)
N#define SL_PEAP0                                                                     (0x20)
N#define SL_PEAP1                                                                     (0x40)
N#define SL_FAST                                                                      (0x80)
N
N#define SL_WLAN_FAST_AUTH_PROVISIONING                                               (0x02)
N#define SL_WLAN_FAST_UNAUTH_PROVISIONING                                             (0x01)
N#define SL_WLAN_FAST_NO_PROVISIONING                                                 (0x00)
N         
N#define SL_WLAN_PROVISIONING_CMD_START_MODE_AP                                       (0)
N#define SL_WLAN_PROVISIONING_CMD_START_MODE_SC                                       (1)
N#define SL_WLAN_PROVISIONING_CMD_START_MODE_APSC                                     (2)
N#define SL_WLAN_PROVISIONING_CMD_START_MODE_APSC_EXTERNAL_CONFIGURATION              (3)
N#define SL_WLAN_PROVISIONING_CMD_STOP                                                (4)
N#define SL_WLAN_PROVISIONING_CMD_ABORT_EXTERNAL_CONFIRMATION                         (5)
N
N/* Provisining API Flags */
N#define SL_WLAN_PROVISIONING_CMD_FLAG_EXTERNAL_CONFIRMATION                          (0x00000001)
N
N/* to be used only in provisioning stop command */
N#define SL_WLAN_PROVISIONING_REMAIN_IN_CURRENT_ROLE                                  (0xFF)
N
N
N#define SL_WLAN_EAPMETHOD_PHASE2_SHIFT                                               (8)
N#define SL_WLAN_EAPMETHOD_PAIRWISE_CIPHER_SHIFT                                      (19)
N#define SL_WLAN_EAPMETHOD_GROUP_CIPHER_SHIFT                                         (27)
N
N#define SL_WLAN_WPA_CIPHER_CCMP                                                      (0x1)
N#define SL_WLAN_WPA_CIPHER_TKIP                                                      (0x2)
N#define SL_WLAN_CC31XX_DEFAULT_CIPHER                                                (SL_WLAN_WPA_CIPHER_CCMP | SL_WLAN_WPA_CIPHER_TKIP)
N
N#define SL_WLAN_EAPMETHOD(phase1,phase2,pairwise_cipher,group_cipher)      \
N                                                    ((phase1) | \
N                                                    ((phase2) << SL_WLAN_EAPMETHOD_PHASE2_SHIFT ) |\
N                                                    ((_u32)(pairwise_cipher) << SL_WLAN_EAPMETHOD_PAIRWISE_CIPHER_SHIFT ) |\
N                                                    ((_u32)(group_cipher) << SL_WLAN_EAPMETHOD_GROUP_CIPHER_SHIFT ))
X#define SL_WLAN_EAPMETHOD(phase1,phase2,pairwise_cipher,group_cipher)                                                          ((phase1) |                                                     ((phase2) << SL_WLAN_EAPMETHOD_PHASE2_SHIFT ) |                                                    ((_u32)(pairwise_cipher) << SL_WLAN_EAPMETHOD_PAIRWISE_CIPHER_SHIFT ) |                                                    ((_u32)(group_cipher) << SL_WLAN_EAPMETHOD_GROUP_CIPHER_SHIFT ))
N
N/*                                                                         phase1    phase2                                     pairwise_cipher               group_cipher         */
N#define SL_WLAN_ENT_EAP_METHOD_TLS                       SL_WLAN_EAPMETHOD(SL_TLS,   0,                                 SL_WLAN_CC31XX_DEFAULT_CIPHER , SL_WLAN_CC31XX_DEFAULT_CIPHER)
N#define SL_WLAN_ENT_EAP_METHOD_TTLS_TLS                  SL_WLAN_EAPMETHOD(SL_TTLS,  SL_TLS,                            SL_WLAN_CC31XX_DEFAULT_CIPHER , SL_WLAN_CC31XX_DEFAULT_CIPHER)
N#define SL_WLAN_ENT_EAP_METHOD_TTLS_MSCHAPv2             SL_WLAN_EAPMETHOD(SL_TTLS,  SL_MSCHAP,                         SL_WLAN_CC31XX_DEFAULT_CIPHER , SL_WLAN_CC31XX_DEFAULT_CIPHER)
N#define SL_WLAN_ENT_EAP_METHOD_TTLS_PSK                  SL_WLAN_EAPMETHOD(SL_TTLS,  SL_PSK,                            SL_WLAN_CC31XX_DEFAULT_CIPHER , SL_WLAN_CC31XX_DEFAULT_CIPHER)
N#define SL_WLAN_ENT_EAP_METHOD_PEAP0_TLS                 SL_WLAN_EAPMETHOD(SL_PEAP0, SL_TLS,                            SL_WLAN_CC31XX_DEFAULT_CIPHER , SL_WLAN_CC31XX_DEFAULT_CIPHER)
N#define SL_WLAN_ENT_EAP_METHOD_PEAP0_MSCHAPv2            SL_WLAN_EAPMETHOD(SL_PEAP0, SL_MSCHAP,                         SL_WLAN_CC31XX_DEFAULT_CIPHER , SL_WLAN_CC31XX_DEFAULT_CIPHER)
N#define SL_WLAN_ENT_EAP_METHOD_PEAP0_PSK                 SL_WLAN_EAPMETHOD(SL_PEAP0, SL_PSK,                            SL_WLAN_CC31XX_DEFAULT_CIPHER , SL_WLAN_CC31XX_DEFAULT_CIPHER)
N#define SL_WLAN_ENT_EAP_METHOD_PEAP1_TLS                 SL_WLAN_EAPMETHOD(SL_PEAP1, SL_TLS,                            SL_WLAN_CC31XX_DEFAULT_CIPHER , SL_WLAN_CC31XX_DEFAULT_CIPHER)
N#define SL_WLAN_ENT_EAP_METHOD_PEAP1_PSK                 SL_WLAN_EAPMETHOD(SL_PEAP1, SL_PSK,                            SL_WLAN_CC31XX_DEFAULT_CIPHER , SL_WLAN_CC31XX_DEFAULT_CIPHER)
N#define SL_WLAN_ENT_EAP_METHOD_FAST_AUTH_PROVISIONING    SL_WLAN_EAPMETHOD(SL_FAST,  SL_WLAN_FAST_AUTH_PROVISIONING,    SL_WLAN_CC31XX_DEFAULT_CIPHER , SL_WLAN_CC31XX_DEFAULT_CIPHER)
N#define SL_WLAN_ENT_EAP_METHOD_FAST_UNAUTH_PROVISIONING  SL_WLAN_EAPMETHOD(SL_FAST,  SL_WLAN_FAST_UNAUTH_PROVISIONING,  SL_WLAN_CC31XX_DEFAULT_CIPHER , SL_WLAN_CC31XX_DEFAULT_CIPHER)
N#define SL_WLAN_ENT_EAP_METHOD_FAST_NO_PROVISIONING      SL_WLAN_EAPMETHOD(SL_FAST,  SL_WLAN_FAST_NO_PROVISIONING,      SL_WLAN_CC31XX_DEFAULT_CIPHER , SL_WLAN_CC31XX_DEFAULT_CIPHER)
N
N#define SL_WLAN_LONG_PREAMBLE                         (0)
N#define SL_WLAN_SHORT_PREAMBLE                        (1)
N          
N#define SL_WLAN_RAW_RF_TX_PARAMS_CHANNEL_SHIFT        (0)
N#define SL_WLAN_RAW_RF_TX_PARAMS_RATE_SHIFT           (6)
N#define SL_WLAN_RAW_RF_TX_PARAMS_POWER_SHIFT          (11)
N#define SL_WLAN_RAW_RF_TX_PARAMS_PREAMBLE_SHIFT       (15)
N        
N#define SL_WLAN_RAW_RF_TX_PARAMS(chan,rate,power,preamble) \
N                                                    ((chan << SL_WLAN_RAW_RF_TX_PARAMS_CHANNEL_SHIFT) | \
N                                                    (rate << SL_WLAN_RAW_RF_TX_PARAMS_RATE_SHIFT) | \
N                                                    (power << SL_WLAN_RAW_RF_TX_PARAMS_POWER_SHIFT) | \
N                                                    (preamble << SL_WLAN_RAW_RF_TX_PARAMS_PREAMBLE_SHIFT))
X#define SL_WLAN_RAW_RF_TX_PARAMS(chan,rate,power,preamble)                                                     ((chan << SL_WLAN_RAW_RF_TX_PARAMS_CHANNEL_SHIFT) |                                                     (rate << SL_WLAN_RAW_RF_TX_PARAMS_RATE_SHIFT) |                                                     (power << SL_WLAN_RAW_RF_TX_PARAMS_POWER_SHIFT) |                                                     (preamble << SL_WLAN_RAW_RF_TX_PARAMS_PREAMBLE_SHIFT))
N
N
N/* wlan config application IDs */
N#define SL_WLAN_CFG_AP_ID                             (0)
N#define SL_WLAN_CFG_GENERAL_PARAM_ID                  (1)
N#define SL_WLAN_CFG_P2P_PARAM_ID                      (2)
N#define SL_WLAN_CFG_AP_ACCESS_LIST_ID                 (3)
N#define SL_WLAN_RX_FILTERS_ID                         (4)
N#define SL_WLAN_CONNECTION_INFO                       (5)
N
N/* wlan AP Config set/get options */
N#define SL_WLAN_AP_OPT_SSID                           (0)
N#define SL_WLAN_AP_OPT_CHANNEL                        (3)
N#define SL_WLAN_AP_OPT_HIDDEN_SSID                    (4)
N#define SL_WLAN_AP_OPT_SECURITY_TYPE                  (6)
N#define SL_WLAN_AP_OPT_PASSWORD                       (7)
N#define SL_WLAN_GENERAL_PARAM_OPT_COUNTRY_CODE        (9)
N#define SL_WLAN_GENERAL_PARAM_OPT_STA_TX_POWER        (10)
N#define SL_WLAN_GENERAL_PARAM_OPT_AP_TX_POWER         (11)
N#define SL_WLAN_GENERAL_PARAM_DISABLE_ENT_SERVER_AUTH (32) 
N#define SL_WLAN_GENERAL_PARAM_OPT_SUSPEND_PROFILES    (33)
N
N#define SL_WLAN_P2P_OPT_DEV_NAME                      (12)
N#define SL_WLAN_P2P_OPT_DEV_TYPE                      (13)
N#define SL_WLAN_P2P_OPT_CHANNEL_N_REGS                (14)
N#define SL_WLAN_GENERAL_PARAM_OPT_INFO_ELEMENT        (16)
N#define SL_WLAN_GENERAL_PARAM_OPT_SCAN_PARAMS         (18)  /* change the scan channels and RSSI threshold using this configuration option */
N#define SL_WLAN_AP_OPT_MAX_STATIONS                   (19)
N#define SL_WLAN_AP_ACCESS_LIST_ADD_MAC                (20)
N#define SL_WLAN_AP_ACCESS_LIST_DEL_MAC                (21)
N#define SL_WLAN_AP_ACCESS_LIST_DEL_IDX                (22)
N#define SL_WLAN_AP_ACCESS_LIST_NUM_ENTRIES            (24)
N#define SL_WLAN_AP_ACCESS_LIST_MODE                   (25)
N#define SL_WLAN_AP_OPT_MAX_STA_AGING                  (26)
N
N#define SL_WLAN_RX_FILTER_STATE                       (27)
N#define SL_WLAN_RX_FILTER_REMOVE                      (28)
N#define SL_WLAN_RX_FILTER_STORE                       (29)
N#define SL_WLAN_RX_FILTER_UPDATE_ARGS                 (30)
N#define SL_WLAN_RX_FILTER_SYS_STATE                   (31)
N
N/* SmartConfig CIPHER options */
N#define SL_WLAN_SMART_CONFIG_CIPHER_SFLASH            (0)      /* password is not delivered by the application. The Simple Manager should
N                                                                  check if the keys are stored in the Flash. */
N#define SL_WLAN_SMART_CONFIG_CIPHER_AES               (1)      /* AES (other types are not supported) */
N#define SL_WLAN_SMART_CONFIG_CIPHER_NONE              (0xFF)   /* do not check in the flash */
N
N
N#define SL_WLAN_POLICY_CONNECTION                     (0x10)
N#define SL_WLAN_POLICY_SCAN                           (0x20)
N#define SL_WLAN_POLICY_PM                             (0x30)
N#define SL_WLAN_POLICY_P2P                            (0x40)
N
N#define SL_WLAN_VAL_2_MASK(position,value)            ((1 & (value))<<(position))
N#define SL_WLAN_MASK_2_VAL(position,mask)             (((1 << position) & (mask)) >> (position))
N
N#define SL_WLAN_CONNECTION_POLICY(Auto,Fast,anyP2P,autoProvisioning)         (SL_WLAN_VAL_2_MASK(0,Auto) | SL_WLAN_VAL_2_MASK(1,Fast) | SL_WLAN_VAL_2_MASK(2,0) | SL_WLAN_VAL_2_MASK(3,anyP2P) | SL_WLAN_VAL_2_MASK(4,0) | SL_WLAN_VAL_2_MASK(5,autoProvisioning))
N#define SL_WLAN_SCAN_POLICY_EN(policy)                (SL_WLAN_MASK_2_VAL(0,policy))
N#define SL_WLAN_SCAN_POLICY(Enable,Enable_Hidden)     (SL_WLAN_VAL_2_MASK(0,Enable) | SL_WLAN_VAL_2_MASK(1,Enable_Hidden))
N
N
N#define SL_WLAN_ENABLE_SCAN                           (1)
N#define SL_WLAN_DISABLE_SCAN                          (0)
N#define SL_WLAN_ALLOW_HIDDEN_SSID_RESULTS             (1)
N#define SL_WLAN_BLOCK_HIDDEN_SSID_RESULTS             (0)
N          
N#define SL_WLAN_NORMAL_POLICY                         (0)
N#define SL_WLAN_LOW_LATENCY_POLICY                    (1)
N#define SL_WLAN_LOW_POWER_POLICY                      (2)
N#define SL_WLAN_ALWAYS_ON_POLICY                      (3)
N#define SL_WLAN_LONG_SLEEP_INTERVAL_POLICY            (4)
N          
N#define SL_WLAN_P2P_ROLE_NEGOTIATE                    (3)
N#define SL_WLAN_P2P_ROLE_GROUP_OWNER                  (15)
N#define SL_WLAN_P2P_ROLE_CLIENT                       (0)
N         
N#define SL_WLAN_P2P_NEG_INITIATOR_ACTIVE              (0)
N#define SL_WLAN_P2P_NEG_INITIATOR_PASSIVE             (1)
N#define SL_WLAN_P2P_NEG_INITIATOR_RAND_BACKOFF        (2)
N        
N#define SL_WLAN_POLICY_VAL_2_OPTIONS(position,mask,policy)    ((mask & policy) << position )
N
N#define SL_WLAN_P2P_POLICY(p2pNegType,p2pNegInitiator)   (SL_WLAN_POLICY_VAL_2_OPTIONS(0,0xF,(p2pNegType > SL_WLAN_P2P_ROLE_GROUP_OWNER ? SL_WLAN_P2P_ROLE_GROUP_OWNER : p2pNegType)) | \
N                                                     SL_WLAN_POLICY_VAL_2_OPTIONS(4,0x1,(p2pNegType > SL_WLAN_P2P_ROLE_GROUP_OWNER ? 1:0)) | \
N                                                     SL_WLAN_POLICY_VAL_2_OPTIONS(5,0x3, p2pNegInitiator))
X#define SL_WLAN_P2P_POLICY(p2pNegType,p2pNegInitiator)   (SL_WLAN_POLICY_VAL_2_OPTIONS(0,0xF,(p2pNegType > SL_WLAN_P2P_ROLE_GROUP_OWNER ? SL_WLAN_P2P_ROLE_GROUP_OWNER : p2pNegType)) |                                                      SL_WLAN_POLICY_VAL_2_OPTIONS(4,0x1,(p2pNegType > SL_WLAN_P2P_ROLE_GROUP_OWNER ? 1:0)) |                                                      SL_WLAN_POLICY_VAL_2_OPTIONS(5,0x3, p2pNegInitiator))
N
N
N/* Info elements */
N#define SL_WLAN_INFO_ELEMENT_DEFAULT_ID               (0) /* 221 will be used */
N
N/* info element size is up to 252 bytes (+ 3 bytes of OUI). */
N#define SL_WLAN_INFO_ELEMENT_MAX_SIZE                 (252)
N
N/* For AP - the total length of all info elements is 300 bytes (for example - 4 info elements of 75 bytes each) */
N#define SL_WLAN_INFO_ELEMENT_MAX_TOTAL_LENGTH_AP      (300)
N
N/* For P2P - the total length of all info elements is 160 bytes (for example - 4 info elements of 40 bytes each) */
N#define SL_WLAN_INFO_ELEMENT_MAX_TOTAL_LENGTH_P2P_GO  (160)
N
N#define SL_WLAN_INFO_ELEMENT_AP_ROLE                  (0)
N#define SL_WLAN_INFO_ELEMENT_P2P_GO_ROLE              (1)
N
N/* we support up to 4 info elements per Role. */
N#define SL_WLAN_MAX_PRIVATE_INFO_ELEMENTS_SUPPROTED   (4)
N
N#define SL_WLAN_INFO_ELEMENT_DEFAULT_OUI_0            (0x08)
N#define SL_WLAN_INFO_ELEMENT_DEFAULT_OUI_1            (0x00)
N#define SL_WLAN_INFO_ELEMENT_DEFAULT_OUI_2            (0x28)
N
N#define SL_WLAN_INFO_ELEMENT_DEFAULT_OUI              (0x000000)  /* 08, 00, 28 will be used */
N
N#define SL_WLAN_AP_ACCESS_LIST_MODE_DISABLED          0
N#define SL_WLAN_AP_ACCESS_LIST_MODE_DENY_LIST         1
N#define SL_WLAN_MAX_ACCESS_LIST_STATIONS              8
N
N
N/* Scan results security information */
N#define SL_WLAN_SCAN_RESULT_GROUP_CIPHER(SecurityInfo)                      (SecurityInfo & 0xF)   /* Possible values: NONE,SL_WLAN_CIPHER_BITMAP_TKIP,SL_WLAN_CIPHER_BITMAP_CCMP */
N#define SL_WLAN_SCAN_RESULT_UNICAST_CIPHER_BITMAP(SecurityInfo)             ((SecurityInfo & 0xF0) >> 4 ) /* Possible values: NONE,SL_WLAN_CIPHER_BITMAP_WEP40,SL_WLAN_CIPHER_BITMAP_WEP104,SL_WLAN_CIPHER_BITMAP_TKIP,SL_WLAN_CIPHER_BITMAP_CCMP*/
N#define SL_WLAN_SCAN_RESULT_HIDDEN_SSID(SecurityInfo)                       (SecurityInfo & 0x2000 ) >> 13 /* Possible values: TRUE/FALSE */    
N#define SL_WLAN_SCAN_RESULT_KEY_MGMT_SUITES_BITMAP(SecurityInfo)            (SecurityInfo & 0x1800 ) >> 11  /* Possible values: SL_WLAN_KEY_MGMT_SUITE_802_1_X, SL_WLAN_KEY_MGMT_SUITE_PSK */
N#define SL_WLAN_SCAN_RESULT_SEC_TYPE_BITMAP(SecurityInfo)                   (SecurityInfo & 0x700   ) >> 8  /* Possible values: SL_WLAN_SECURITY_TYPE_BITMAP_OPEN, SL_WLAN_SECURITY_TYPE_BITMAP_WEP, SL_WLAN_SECURITY_TYPE_BITMAP_WPA, SL_WLAN_SECURITY_TYPE_BITMAP_WPA2, 0x6 (mix mode) SL_WLAN_SECURITY_TYPE_BITMAP_WPA | SL_WLAN_SECURITY_TYPE_BITMAP_WPA2 */
N
N#define SL_WLAN_SECURITY_TYPE_BITMAP_OPEN             0x0
N#define SL_WLAN_SECURITY_TYPE_BITMAP_WEP              0x1
N#define SL_WLAN_SECURITY_TYPE_BITMAP_WPA              0x2
N#define SL_WLAN_SECURITY_TYPE_BITMAP_WPA2             0x4
N
N#define SL_WLAN_CIPHER_BITMAP_WEP40                   0x1
N#define SL_WLAN_CIPHER_BITMAP_WEP104                  0x2
N#define SL_WLAN_CIPHER_BITMAP_TKIP                    0x4
N#define SL_WLAN_CIPHER_BITMAP_CCMP                    0x8
N
N#define SL_WLAN_KEY_MGMT_SUITE_802_1_X                1
N#define SL_WLAN_KEY_MGMT_SUITE_PSK                    2
N
N
N
N#define SL_WLAN_RX_FILTER_MAX_FILTERS                 (64)    /* Max number of filters is 64 filters */
N#define SL_WLAN_RX_FILTER_MAX_SYS_FILTERS_SETS        (32)    /* The Max number of system filters */
N#define SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS   (2)
N#define SL_WLAN_RX_FILTER_NUM_OF_FILTER_PAYLOAD_ARGS  (2)
N#define SL_WLAN_RX_FILTER_RANGE_ARGS                  (2)
N#define SL_WLAN_RX_FILTER_NUM_USER_EVENT_ID           (64)
N#define SL_WLAN_RX_FILTER_MAX_USER_EVENT_ID           ( ( SL_WLAN_RX_FILTER_NUM_USER_EVENT_ID ) - 1 )
N
N/*  Bit manipulation for 8 bit */
N#define SL_WLAN_ISBITSET8(x,i)      ((x[i>>3] & (0x80>>(i&7)))!=0)  /* Is bit set, 8 bit unsigned numbers = x , location = i */
N#define SL_WLAN_SETBIT8(x,i)        x[i>>3]|=(0x80>>(i&7));         /* Set bit,8 bit unsigned numbers = x , location = i */
N#define SL_WLAN_CLEARBIT8(x,i)      x[i>>3]&=(0x80>>(i&7))^0xFF;    /* Clear bit,8 bit unsigned numbers = x , location = i */
N
N
N/*****************************************************************************/
N/* Structure/Enum declarations                                               */
N/*****************************************************************************/
N
Ntypedef enum
N{
N    SL_WLAN_RATE_1M         = 1,
N    SL_WLAN_RATE_2M         = 2,
N    SL_WLAN_RATE_5_5M       = 3,
N    SL_WLAN_RATE_11M        = 4,
N    SL_WLAN_RATE_6M         = 6,
N    SL_WLAN_RATE_9M         = 7,
N    SL_WLAN_RATE_12M        = 8,
N    SL_WLAN_RATE_18M        = 9,
N    SL_WLAN_RATE_24M        = 10,
N    SL_WLAN_RATE_36M        = 11,
N    SL_WLAN_RATE_48M        = 12,
N    SL_WLAN_RATE_54M        = 13,
N    SL_WLAN_RATE_MCS_0      = 14,
N    SL_WLAN_RATE_MCS_1      = 15,
N    SL_WLAN_RATE_MCS_2      = 16,
N    SL_WLAN_RATE_MCS_3      = 17,
N    SL_WLAN_RATE_MCS_4      = 18,
N    SL_WLAN_RATE_MCS_5      = 19,
N    SL_WLAN_RATE_MCS_6      = 20,
N    SL_WLAN_RATE_MCS_7      = 21,
N    SL_WLAN_MAX_NUM_RATES   = 0xFF
N}SlWlanRateIndex_e;
N
Ntypedef enum
N{
N    SL_WLAN_DEV_PW_DEFAULT      = 0,
N    SL_WLAN_DEV_PW_PIN_KEYPAD   = 1,
N    SL_WLAN_DEV_PW_PUSH_BUTTON  = 4,
N    SL_WLAN_DEV_PW_PIN_DISPLAY  = 5
N} SlWlanP2pDevPwdMethod_e;
N
Ntypedef struct
N{
N    _u32    Status;
X    unsigned long    Status;
N    _u32    SsidLen;
X    unsigned long    SsidLen;
N    _u8     Ssid[32];
X    unsigned char     Ssid[32];
N    _u32    PrivateTokenLen;
X    unsigned long    PrivateTokenLen;
N    _u8     PrivateToken[32];
X    unsigned char     PrivateToken[32];
N}SlWlanSmartConfigStartAsyncResponse_t;
N
Ntypedef struct
N{
N    _u16    Status;
X    unsigned short    Status;
N    _u16    Padding;
X    unsigned short    Padding;
N}SlWlanSmartConfigStopAsyncResponse_t;
N
Ntypedef struct
N{
N    _u16    Status;
X    unsigned short    Status;
N    _u16    Padding;
X    unsigned short    Padding;
N}SlWlanConnFailureAsyncResponse_t;
N
Ntypedef struct
N{
N    _u16    Status;
X    unsigned short    Status;
N    _u16    Padding;
X    unsigned short    Padding;
N}SlWlanProvisioningStatusAsyncResponse_t;
N
N/* rx filter event struct
N  this event will be sent from the SL device
N  as a result of a passed rx filter
N  example:
N  suppose we have a filter with an action and we set the following:
N  SlWlanRxFilterAction_t Action;
N  Action.UserId = 2;
N  When the filter result is pass, an SlWlanEventRxFilterInfo_t event will be passed to the user as follows:
N  Type will be set to 0
N  bit 2 in UserActionIdBitmap will be set in this event, because 2 is the user input for the action arg above.
N  an SlWlanEventRxFilterInfo_t event may have several bits set as a result of several rx filters causing different
N  events to pass */
N
Ntypedef struct
N{
N    _u8     Type;                                                          /* Currently only event type 0 is supported. */
X    unsigned char     Type;                                                           
N    _u8     UserActionIdBitmap[SL_WLAN_RX_FILTER_NUM_USER_EVENT_ID / 8];   /* Bit X is set indicates that the filter with event action arg X passed. */
X    unsigned char     UserActionIdBitmap[(64) / 8];    
N}SlWlanEventRxFilterInfo_t;
N
Ntypedef enum
N{
N    ROLE_STA      = 0,
N    ROLE_RESERVED = 1,
N    ROLE_AP       = 2,
N    ROLE_P2P      = 3
N}SlWlanMode_e;
N
Ntypedef struct
N{
N    _u8     SsidLen;
X    unsigned char     SsidLen;
N    _u8     SsidName[32];
X    unsigned char     SsidName[32];
N    _u8     Bssid[6];
X    unsigned char     Bssid[6];
N    _u8     Padding;
X    unsigned char     Padding;
N} SlWlanEventConnect_t;
N
Ntypedef struct
N{
N    _u8     SsidLen;
X    unsigned char     SsidLen;
N    _u8     SsidName[32];
X    unsigned char     SsidName[32];
N    _u8     Bssid[6];
X    unsigned char     Bssid[6];
N    _u8     ReasonCode;
X    unsigned char     ReasonCode;
N} SlWlanEventDisconnect_t;
N
Ntypedef struct
N{
N    _u8   Mac[6];
X    unsigned char   Mac[6];
N    _u8   Padding[2];
X    unsigned char   Padding[2];
N}SlWlanEventSTAAdded_t, SlWlanEventSTARemoved_t;
N
N
Ntypedef struct
N{
N    _u8     SsidLen;
X    unsigned char     SsidLen;
N    _u8     SsidName[32];
X    unsigned char     SsidName[32];
N    _u8     Bssid[6];
X    unsigned char     Bssid[6];
N    _u8     Reserved;
X    unsigned char     Reserved;
N    _u8     GoDeviceNameLen;
X    unsigned char     GoDeviceNameLen;
N    _u8     GoDeviceName[32];
X    unsigned char     GoDeviceName[32];
N    _u8     Padding[3];
X    unsigned char     Padding[3];
N} SlWlanEventP2PConnect_t;
N
Ntypedef struct
N{
N    _u8     SsidLen;
X    unsigned char     SsidLen;
N    _u8     SsidName[32];
X    unsigned char     SsidName[32];
N    _u8     Bssid[6];
X    unsigned char     Bssid[6];
N    _u8     ReasonCode;
X    unsigned char     ReasonCode;
N    _u8     GoDeviceNameLen;
X    unsigned char     GoDeviceNameLen;
N    _u8     GoDeviceName[32];
X    unsigned char     GoDeviceName[32];
N    _u8     Padding[3];
X    unsigned char     Padding[3];
N} SlWlanEventP2PDisconnect_t;
N
Ntypedef struct
N{
N    _u8     Mac[6];
X    unsigned char     Mac[6];
N    _u8     ClDeviceNameLen;
X    unsigned char     ClDeviceNameLen;
N    _u8     ClDeviceName[32];
X    unsigned char     ClDeviceName[32];
N    _u8     OwnSsidLen;
X    unsigned char     OwnSsidLen;
N    _u8     OwnSsid[32];
X    unsigned char     OwnSsid[32];
N}SlWlanEventP2PClientAdded_t, SlWlanEventP2PClientRemoved_t;
N
Ntypedef struct
N{
N    _u8     GoDeviceNameLen;
X    unsigned char     GoDeviceNameLen;
N    _u8     GoDeviceName[32];
X    unsigned char     GoDeviceName[32];
N    _u8     Mac[6];
X    unsigned char     Mac[6];
N    _u8     WpsMethod;
X    unsigned char     WpsMethod;
N}SlWlanEventP2PDevFound_t, SlWlanEventP2PRequest_t;
N
N/**************************************************/
Ntypedef struct
N{
N    _u16    Status;
X    unsigned short    Status;
N    _u16    Padding;
X    unsigned short    Padding;
N}SlWlanEventP2PConnectFail_t;
N
Ntypedef struct
N{
N    _u8  ProvisioningStatus;
X    unsigned char  ProvisioningStatus;
N    _u8  Role;
X    unsigned char  Role;
N    _u8  WlanStatus;
X    unsigned char  WlanStatus;
N    _u8  Ssidlen;
X    unsigned char  Ssidlen;
N    _u8  Ssid[32];
X    unsigned char  Ssid[32];
N    _u32 Reserved;
X    unsigned long Reserved;
N}SlWlanEventProvisioningStatus_t;
N
Ntypedef struct
N{
N    _u32    Status;
X    unsigned long    Status;
N    _u32    SsidLen;
X    unsigned long    SsidLen;
N    _u8     Ssid[32];
X    unsigned char     Ssid[32];
N    _u32    ReservedLen;
X    unsigned long    ReservedLen;
N    _u8     Reserved[32];
X    unsigned char     Reserved[32];
N} SlWlanEventProvisioningProfileAdded_t;
N
Ntypedef union
N{
N    SlWlanEventConnect_t                         Connect;                    /* SL_WLAN_EVENT_CONNECT */
N    SlWlanEventDisconnect_t                      Disconnect;                 /* SL_WLAN_EVENT_DISCONNECT */
N    SlWlanEventSTAAdded_t                        STAAdded;                   /* SL_WLAN_EVENT_STA_ADDED */
N    SlWlanEventSTARemoved_t                      STARemoved;                 /* SL_WLAN_EVENT_STA_REMOVED */
N    SlWlanEventP2PConnect_t                      P2PConnect;                 /* SL_WLAN_EVENT_P2P_CONNECT */
N    SlWlanEventP2PDisconnect_t                   P2PDisconnect;              /* SL_WLAN_EVENT_P2P_DISCONNECT */
N    SlWlanEventP2PClientAdded_t                  P2PClientAdded;             /* SL_WLAN_EVENT_P2P_CLIENT_ADDED */
N    SlWlanEventP2PClientRemoved_t                P2PClientRemoved;           /* SL_WLAN_EVENT_P2P_CLIENT_REMOVED */
N    SlWlanEventP2PDevFound_t                     P2PDevFound;                /* SL_WLAN_EVENT_P2P_DEVFOUND */
N    SlWlanEventP2PRequest_t                      P2PRequest;                 /* SL_WLAN_EVENT_P2P_REQUEST */
N    SlWlanEventP2PConnectFail_t                  P2PConnectFail;             /* SL_WLAN_EVENT_P2P_CONNECTFAIL */
N    SlWlanEventRxFilterInfo_t                    RxFilterInfo;               /* SL_WLAN_EVENT_RXFILTER */
N    SlWlanEventProvisioningStatus_t              ProvisioningStatus;         /* SL_WLAN_EVENT_PROVISIONING_STATUS */
N    SlWlanEventProvisioningProfileAdded_t        ProvisioningProfileAdded;   /* SL_WLAN_EVENT_PROVISIONING_PROFILE_ADDED */
N
N} SlWlanEventData_u;
N
Ntypedef struct
N{
N   _u32                 Id;
X   unsigned long                 Id;
N   SlWlanEventData_u    Data;
N} SlWlanEvent_t;
N
Ntypedef struct
N{
N    _u32  ReceivedValidPacketsNumber;                    /* sum of the packets that been received OK (include filtered) */
X    unsigned long  ReceivedValidPacketsNumber;                     
N    _u32  ReceivedFcsErrorPacketsNumber;                 /* sum of the packets that been dropped due to FCS error */
X    unsigned long  ReceivedFcsErrorPacketsNumber;                  
N    _u32  ReceivedAddressMismatchPacketsNumber;          /* sum of the packets that been received but filtered out by one of the HW filters */
X    unsigned long  ReceivedAddressMismatchPacketsNumber;           
N    _i16  AvarageDataCtrlRssi;                           /* average RSSI for all valid data packets received */
X    signed short  AvarageDataCtrlRssi;                            
N    _i16  AvarageMgMntRssi;                              /* average RSSI for all valid management packets received */
X    signed short  AvarageMgMntRssi;                               
N    _u16  RateHistogram[SL_WLAN_NUM_OF_RATE_INDEXES];    /* rate histogram for all valid packets received */
X    unsigned short  RateHistogram[(20)];     
N    _u16  RssiHistogram[SL_WLAN_SIZE_OF_RSSI_HISTOGRAM]; /* RSSI histogram from -40 until -87 (all below and above\n RSSI will appear in the first and last cells */
X    unsigned short  RssiHistogram[(6)];  
N    _u32  StartTimeStamp;                                /* the time stamp started collecting the statistics in uSec */
X    unsigned long  StartTimeStamp;                                 
N    _u32  GetTimeStamp;                                  /* the time stamp called the get statistics command */
X    unsigned long  GetTimeStamp;                                   
N}SlWlanGetRxStatResponse_t;
N
Ntypedef struct
N{
N    _u8 Ssid[SL_WLAN_SSID_MAX_LENGTH];
X    unsigned char Ssid[(32)];
N    _u8 Bssid[SL_WLAN_BSSID_LENGTH];
X    unsigned char Bssid[(6)];
N    _u8 SsidLen;
X    unsigned char SsidLen;
N    _i8 Rssi;
X    signed char Rssi;
N    _i16 SecurityInfo;
X    signed short SecurityInfo;
N    _i8 Channel;
X    signed char Channel;
N    _i8 Reserved[1];
X    signed char Reserved[1];
N}SlWlanNetworkEntry_t;
N
Ntypedef struct
N{
N    _u8   Type;
X    unsigned char   Type;
N    _i8*  Key;
X    signed char*  Key;
N    _u8   KeyLen;
X    unsigned char   KeyLen;
N}SlWlanSecParams_t;
N
Ntypedef struct
N{
N    _i8*  User;
X    signed char*  User;
N    _u8   UserLen;
X    unsigned char   UserLen;
N    _i8*  AnonUser;
X    signed char*  AnonUser;
N    _u8   AnonUserLen;
X    unsigned char   AnonUserLen;
N    _u8   CertIndex;  /* not supported */
X    unsigned char   CertIndex;   
N    _u32  EapMethod;
X    unsigned long  EapMethod;
N}SlWlanSecParamsExt_t;
N
Ntypedef struct
N{
N    _i8   User[64];
X    signed char   User[64];
N    _u8   UserLen;
X    unsigned char   UserLen;
N    _i8   AnonUser[64];
X    signed char   AnonUser[64];
N    _u8   AnonUserLen;
X    unsigned char   AnonUserLen;
N    _u8   CertIndex;  /* not supported */
X    unsigned char   CertIndex;   
N    _u32  EapMethod;
X    unsigned long  EapMethod;
N}SlWlanGetSecParamsExt_t;
N
N#define SL_WLAN_CONNECTION_PROTOCOL_STA     1
N#define SL_WLAN_CONNECTION_PROTOCOL_P2PCL   2
N
Ntypedef union
N{
N    SlWlanEventConnect_t       StaConnect;
N    SlWlanEventP2PConnect_t    P2PConnect;
N} SlWlanConnectionInfo_u;
N
Ntypedef enum
N{
N    SL_WLAN_DISCONNECTED = 0,
N    SL_WLAN_CONNECTED_STA,
N    SL_WLAN_CONNECTED_P2PCL,
N    SL_WLAN_CONNECTED_P2PGO,
N    SL_WLAN_AP_CONNECTED_STATIONS
N}SlWlanConnStatusFlags_e;
N
Ntypedef struct
N{
N    _u8 Mode;       /* ROLE_STA, ROLE_AP, ROLE_P2P */
X    unsigned char Mode;        
N    _u8 ConnStatus; /* SlWlanConnStatusFlags_e */
X    unsigned char ConnStatus;  
N    _u8 SecType;    /* Current connection security type - (0 in case of disconnect or AP mode) SL_WLAN_SEC_TYPE_OPEN, SL_WLAN_SEC_TYPE_WEP, SL_WLAN_SEC_TYPE_WPA_WPA2, SL_WLAN_SEC_TYPE_WPA_ENT, SL_WLAN_SEC_TYPE_WPS_PBC, SL_WLAN_SEC_TYPE_WPS_PIN */
X    unsigned char SecType;     
N    _u8 Reserved;
X    unsigned char Reserved;
N    SlWlanConnectionInfo_u ConnectionInfo;
N}SlWlanConnStatusParam_t;
N
Ntypedef struct
N{
N    _u32   ChannelsMask;
X    unsigned long   ChannelsMask;
N    _i32   RssiThreshold;
X    signed long   RssiThreshold;
N}SlWlanScanParamCommand_t;
N
Ntypedef struct
N{
N    _u8   Id;
X    unsigned char   Id;
N    _u8   Oui[3];
X    unsigned char   Oui[3];
N    _u16  Length;
X    unsigned short  Length;
N    _u8   Data[252];
X    unsigned char   Data[252];
N} SlWlanInfoElement_t;
N
Ntypedef struct
N{
N    _u8          Index;  /* 0 - SL_WLAN_MAX_PRIVATE_INFO_ELEMENTS_SUPPROTED */
X    unsigned char          Index;   
N    _u8          Role;   /* bit0: AP = 0, GO = 1                    */
X    unsigned char          Role;    
N    SlWlanInfoElement_t   IE;
N} SlWlanSetInfoElement_t;
N
Ntypedef struct
N{
N    _u16        Reserved;
X    unsigned short        Reserved;
N    _u16        Reserved2;
X    unsigned short        Reserved2;
N    _u16        MaxSleepTimeMs;   /* max sleep time in mSec For setting Long Sleep Interval policy use */
X    unsigned short        MaxSleepTimeMs;    
N    _u16        Reserved3;
X    unsigned short        Reserved3;
N} SlWlanPmPolicyParams_t;
N
Ntypedef  _i8    SlWlanRxFilterID_t; /* Unique filter ID which is allocated by the system , negative number means error */
Xtypedef  signed char    SlWlanRxFilterID_t;  
N
N/*  Representation of filters Id as a bit field
N    The bit field is used to declare which filters are involved
N    in operation. Number of filter can be up to 128 filters.
N    i.e. 128 bits are needed. On the current release, up to 64 filters can be defined. */
Ntypedef _u8   SlWlanRxFilterIdMask_t[128/8];
Xtypedef unsigned char   SlWlanRxFilterIdMask_t[128/8];
N
Ntypedef _u8  SlWlanRxFilterSysFilters_t; /* Describes the supported system filter sets*/
Xtypedef unsigned char  SlWlanRxFilterSysFilters_t;  
N/* possible values for SlWlanRxFilterSysFilters_t */
N#define SL_WLAN_RX_FILTER_ARP_AUTO_REPLY_SYS_FILTERS       (0)
N#define SL_WLAN_RX_FILTER_MULTICASTSIPV4_SYS_FILTERS       (1)
N#define SL_WLAN_RX_FILTER_MULTICASTSIPV6_SYS_FILTERS       (2)
N#define SL_WLAN_RX_FILTER_MULTICASTSWIFI_SYS_FILTERS       (3)
N#define SL_WLAN_RX_FILTER_SELF_MAC_ADDR_DROP_SYS_FILTERS   (4)
N
N/*  Describes the supported system filter sets, each bit represents different system filter set
N    The filter sets are defined at SlWlanRxFilterSysFilters_t  */
Ntypedef _u8   SlWlanRxFilterSysFiltersMask_t[SL_WLAN_RX_FILTER_MAX_SYS_FILTERS_SETS/8];
Xtypedef unsigned char   SlWlanRxFilterSysFiltersMask_t[(32)/8];
N
Ntypedef struct 
N{
N    _u16    Offset;     /*  Offset in payload - Where in the payload to search for the pattern */
X    unsigned short    Offset;      
N    _u8     Length;     /* Pattern Length */
X    unsigned char     Length;      
N    _u8     Reserved;
X    unsigned char     Reserved;
N    _u8     Value[16];  /* Up to 16 bytes long (based on pattern length above) */
X    unsigned char     Value[16];   
N}SlWlanRxFilterPatternArg_t;
N
Ntypedef _u8 SlWlanRxFilterRuleType_t; /* Different filter types */
Xtypedef unsigned char SlWlanRxFilterRuleType_t;  
N/* possible values for SlWlanRxFilterRuleType_t */
N#define SL_WLAN_RX_FILTER_HEADER                    (0)
N#define SL_WLAN_RX_FILTER_COMBINATION               (1)
N
Ntypedef _u8 SlWlanRxFilterFlags_u;
Xtypedef unsigned char SlWlanRxFilterFlags_u;
N/* Possible values for SlWlanRxFilterFlags_u */
N#define SL_WLAN_RX_FILTER_BINARY                    (0x1)
N#define SL_WLAN_RX_FILTER_PERSISTENT                (0x8)
N#define SL_WLAN_RX_FILTER_ENABLE                    (0x10)
N
N/* Used as comparison function for the header type arguments */
Ntypedef _u8 SlWlanRxFilterRuleHeaderCompareFunction_t;
Xtypedef unsigned char SlWlanRxFilterRuleHeaderCompareFunction_t;
N/* Possible values for SlWlanRxFilterRuleHeaderCompareFunction_t */
N#define SL_WLAN_RX_FILTER_CMP_FUNC_IN_BETWEEN       (0)
N#define SL_WLAN_RX_FILTER_CMP_FUNC_EQUAL            (1)
N#define SL_WLAN_RX_FILTER_CMP_FUNC_NOT_EQUAL_TO     (2)
N#define SL_WLAN_RX_FILTER_CMP_FUNC_NOT_IN_BETWEEN   (3)
N
Ntypedef _u8 SlWlanRxFilterTriggerCompareFunction_t;
Xtypedef unsigned char SlWlanRxFilterTriggerCompareFunction_t;
N/* Possible values for SlWlanRxFilterTriggerCompareFunction_t */
N#define SL_WLAN_RX_FILTER_TRIGGER_CMP_FUNC_EQUAL                        (0)
N#define SL_WLAN_RX_FILTER_TRIGGER_CMP_FUNC_NOT_EQUAL_TO                 (1) /*   arg1 == protocolVal ,not supported in current release */
N#define SL_WLAN_RX_FILTER_TRIGGER_CMP_FUNC_SMALLER_THAN                 (2) /*   arg1 == protocolVal */
N#define SL_WLAN_RX_FILTER_TRIGGER_CMP_FUNC_BIGGER_THAN                  (3) /*   arg1 == protocolVal */
N
Ntypedef _u8 SlWlanRxFilterRuleHeaderField_t; /* Provides list of possible header types which may be defined as part of the rule */
Xtypedef unsigned char SlWlanRxFilterRuleHeaderField_t;  
N/* Possible values for SlWlanRxFilterRuleHeaderField_t */
N#define SL_WLAN_RX_FILTER_HFIELD_NULL                     (0)
N#define SL_WLAN_RX_FILTER_HFIELD_FRAME_TYPE               (1) /* 802.11 control\data\management */
N#define SL_WLAN_RX_FILTER_HFIELD_FRAME_SUBTYPE            (2) /*  802.11 beacon\probe\.. */
N#define SL_WLAN_RX_FILTER_HFIELD_BSSID                    (3)  /*  802.11 bssid type */
N#define SL_WLAN_RX_FILTER_HFIELD_MAC_SRC_ADDR             (4)
N#define SL_WLAN_RX_FILTER_HFIELD_MAC_DST_ADDR             (5)
N#define SL_WLAN_RX_FILTER_HFIELD_FRAME_LENGTH             (6)
N#define SL_WLAN_RX_FILTER_HFIELD_ETHER_TYPE               (7)
N#define SL_WLAN_RX_FILTER_HFIELD_IP_VERSION               (8)
N#define SL_WLAN_RX_FILTER_HFIELD_IP_PROTOCOL              (9)  /* TCP / UDP / ICMP / ICMPv6 / IGMP */
N#define SL_WLAN_RX_FILTER_HFIELD_IPV4_SRC_ADDR            (10)
N#define SL_WLAN_RX_FILTER_HFIELD_IPV4_DST_ADDR            (11)
N#define SL_WLAN_RX_FILTER_HFIELD_IPV6_SRC_ADRR            (12)
N#define SL_WLAN_RX_FILTER_HFIELD_IPV6_DST_ADDR            (13)
N#define SL_WLAN_RX_FILTER_HFIELD_PORT_SRC                 (14)
N#define SL_WLAN_RX_FILTER_HFIELD_PORT_DST                 (15)
N#define SL_WLAN_RX_FILTER_HFIELD_L4_PAYLOAD_PATTERN       (19) /* use to look for patterns on the TCP and UDP payloads (after TCP/UDP header) */
N#define SL_WLAN_RX_FILTER_HFIELD_L1_PAYLOAD_PATTERN       (20) /* use to look for patterns on the PHY payload (i.e. beginning of WLAN MAC header) */
N#define SL_WLAN_RX_FILTER_HFIELD_MAX_FIELD                (21) /* Definition */
N
N/* Holds the header ARGS which are used in case of HDR rule */
Ntypedef union 
N{
N    /* buffer for pattern matching in payload up to 16 bytes (Binary Values) */
N    SlWlanRxFilterPatternArg_t  Pattern;
N
N    /* Buffer for ipv4 address filter. binary arguments, number of argument may be up to SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS*/
N    _u8 Ipv4[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS][4]; /*  Binary Values for comparison */
X    unsigned char Ipv4[(2)][4];  
N
N    /* Buffer for ipv4 address filter. Ascii arguments - IPv4 address: 4 bytes: ddd.ddd.ddd.ddd - 15 chars. Number of argument may be up to SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS*/
N    _u8 Ipv4Ascii[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS][16]; /*  Ascii Values for comparison */
X    unsigned char Ipv4Ascii[(2)][16];  
N
N    /* Buffer for ipv6 address filter. binary arguments, Ascii format is not supported. number of argument may be up to SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS*/
N    _u8 Ipv6[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS][16]; /*  Binary Values for comparison */
X    unsigned char Ipv6[(2)][16];  
N
N    /* Buffer for mac address filter. binary arguments.  number of argument may be up to SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS*/
N    _u8 Mac[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS][6]; /*  Binary Values for comparison */
X    unsigned char Mac[(2)][6];  
N
N    /* Buffer for mac address filter. Ascii arguments - MAC address:  6 bytes: xx:xx:xx:xx:xx:xx - 17 chars.  number of argument may be up to SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS */
N    _u8 MacAscii[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS][18]; /*  Ascii Values for comparison */
X    unsigned char MacAscii[(2)][18];  
N
N    /* Buffer for BSSID address filter. binary arguments.  number of argument may be up to SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS*/
N    _u8 Bssid[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS][6]; /*  Binary Values for comparison */
X    unsigned char Bssid[(2)][6];  
N
N    /* Buffer for frame length filter. number of argument may be up to SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS */
N    _u32 FrameLength[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS]; /*  Binary Values for comparison */
X    unsigned long FrameLength[(2)];  
N
N    /* Buffer for port filter. number of argument may be up to SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS */
N    _u16 Port[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS]; /*  Binary Values for comparison */
X    unsigned short Port[(2)];  
N
N    /* Buffer for Ether filter. number of argument may be up to SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS (according to host endianity) */
N    _u32 EtherType[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS]; /*  Binary Values for comparison */
X    unsigned long EtherType[(2)];  
N
N    /* Buffer for ip version filter. Buffer for binary arguments. IP Version - 4 for IPV4 and 6 for IPV6  */
N    _u8 IpVersion;
X    unsigned char IpVersion;
N
N    /* Buffer for frame type filter. Buffer for binary arguments. Frame Type (0 - management, 1 - Control, 2 - Data)  */
N    _u8 Frametype[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS];
X    unsigned char Frametype[(2)];
N
N    /* Buffer for frame subtype filter. Buffer for binary arguments. Frame Sub Type (checkout the full list in the 802.11 spec). e.g. Beacon=0x80, Data=0x08, Qos-Data=0x04, ACK=0xD4, etc. */
N    _u8 FrameSubtype[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS];
X    unsigned char FrameSubtype[(2)];
N
N    /* Buffer for protocol type filter. Buffer for binary arguments. e.g. 1  ICMP (IPV4 only), 2 - IGMP (IPV4 only), 6  TCP. 17  UDP, 58  ICMPV6 */
N    _u8 IpProtocol[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS];
X    unsigned char IpProtocol[(2)];
N
N    /* Buffer for ip version filter. Buffer for ASCII arguments. Use for IP version field comparison settings: "IPV4", "IPV6"  */
N    _u8 IpVersionAscii[4];
X    unsigned char IpVersionAscii[4];
N
N    /* Buffer for frame type filter. Buffer for ASCII arguments. Use for Frame type field comparison settings: "MGMT", "CTRL", "DATA"  */
N    _u8 FrametypeAscii[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS][4];
X    unsigned char FrametypeAscii[(2)][4];
N
N    /* Buffer for protocol type filter. Buffer for ASCII arguments. Use for protocol field comparison settings: "ICMP", "IGMP", "TCP, "UDP", "ICMP6"  */
N    /* Note: Use memcpy with these strings instead of strcpy (no \0 should be at the end, as the array is 5 bytes long and ICMP6 is already 5 bytes long without the \0) */
N    _u8 IpProtocolAscii[SL_WLAN_RX_FILTER_NUM_OF_FILTER_HEADER_ARGS][5];
X    unsigned char IpProtocolAscii[(2)][5];
N
N}SlWlanRxFilterHeaderArg_u;
N
N/* Defines the Header Args and mask */
Ntypedef struct
N{
N    SlWlanRxFilterHeaderArg_u                   Value; /* Argument for the comparison function */
N    _u8                                         Mask[16];  /* the mask is used in order to enable partial comparison (bit level), Use the 0xFFFFFFFF in case you don't want to use mask */
X    unsigned char                                         Mask[16];   
N
N}SlWlanRxFilterRuleHeaderArgs_t;
N
N/* defines the Header rule. The header rule defines the compare function on the protocol header
N   For example destMacAddre is between ( 12:6::78:77,  12:6::78:90 ) */
Ntypedef struct 
N{
N    SlWlanRxFilterRuleHeaderArgs_t              Args; /* Filter arguemnts */
N    SlWlanRxFilterRuleHeaderField_t             Field; /* Packet HDR field which will be compared to the argument */
N    SlWlanRxFilterRuleHeaderCompareFunction_t   CompareFunc; /*  type of the comparison function */
N    _u8                                         Padding[2];
X    unsigned char                                         Padding[2];
N}SlWlanRxFilterRuleHeader_t;
N
N/* Optional operators for the combination type filterID1 is located in the first arg , filterId2 is the second arg */
Ntypedef _u8 SlWlanRxFilterRuleCombinationOperator_t;
Xtypedef unsigned char SlWlanRxFilterRuleCombinationOperator_t;
N/* Possible values for SlWlanRxFilterRuleCombinationOperator_t */
N#define SL_WLAN_RX_FILTER_COMBINED_FUNC_NOT     (0) /* filterID1 */
N#define SL_WLAN_RX_FILTER_COMBINED_FUNC_AND     (1) /* filterID1 && filterID2 */
N#define SL_WLAN_RX_FILTER_COMBINED_FUNC_OR      (2) /* filterID1 && filterID2 */
N
N/* Defines the structure which define the combination type filter
N   The combined filter enable to make operation on one or two filter,
N   for example filterId1 or and(filterId2,filterId3). */
Ntypedef struct 
N{
N    SlWlanRxFilterRuleCombinationOperator_t     Operator; /* combination operator */
N    SlWlanRxFilterID_t                          CombinationFilterId[SL_WLAN_RX_FILTER_RANGE_ARGS]; /* filterID, may be one or two depends on the combination operator type */
X    SlWlanRxFilterID_t                          CombinationFilterId[(2)];  
N    _u8                                         Padding;
X    unsigned char                                         Padding;
N}SlWlanRxFilterRuleCombination_t;
N
N/* Rule structure composed of behavioral flags and the filter rule definitions */
Ntypedef union 
N{
N    SlWlanRxFilterRuleHeader_t                  Header; /* Filter is from type Header */
N    SlWlanRxFilterRuleCombination_t             Combination; /*  Filter is from type Combination */
N}SlWlanRxFilterRule_u;
N
N/* Bit field which represents the roleId possible values
N   In the current release only Station (with or without promiscuous modes) and AP roles are supported.
N   Activating filters before P2P negotiations (i.e. decision whether role is CL or GO) may result with
N   unexpected behaviour. After this stage, filters can be activated whereas STA role is the equivalent of P2P CL role
N   AP role is the equivalent of P2P GO role.
N */
Ntypedef _u8 SlWlanRxFilterTriggerRoles_t;
Xtypedef unsigned char SlWlanRxFilterTriggerRoles_t;
N/* Possible values for SlWlanRxFilterTriggerRoles_t */
N#define SL_WLAN_RX_FILTER_ROLE_AP                            (1)
N#define SL_WLAN_RX_FILTER_ROLE_STA                           (2)
N#define SL_WLAN_RX_FILTER_ROLE_TRANCIEVER                    (4)
N#define SL_WLAN_RX_FILTER_ROLE_NULL                          (0)
N
Ntypedef _u8 SlWlanRxFilterTriggerConnectionStates_t;
Xtypedef unsigned char SlWlanRxFilterTriggerConnectionStates_t;
N/* Possible values for SlWlanRxFilterTriggerConnectionStates_t */
N#define SL_WLAN_RX_FILTER_STATE_STA_CONNECTED     (0x1)
N#define SL_WLAN_RX_FILTER_STATE_STA_NOT_CONNECTED (0x2)
N#define SL_WLAN_RX_FILTER_STATE_STA_HAS_IP        (0x4)
N#define SL_WLAN_RX_FILTER_STATE_STA_HAS_NO_IP     (0x8)
N
N/* There are 8 possible counter. if no counter is needed set to NO_TRIGGER_COUNTER */
Ntypedef _u8 SlWlanRxFilterCounterId_t;
Xtypedef unsigned char SlWlanRxFilterCounterId_t;
N/* Possible values for SlWlanRxFilterCounterId_t */
N#define SL_WLAN_RX_FILTER_NO_TRIGGER_COUNTER                (0)
N#define SL_WLAN_RX_FILTER_COUNTER1                          (1)
N#define SL_WLAN_RX_FILTER_COUNTER2                          (2)
N#define SL_WLAN_RX_FILTER_COUNTER3                          (3)
N#define SL_WLAN_RX_FILTER_COUNTER4                          (4)
N#define SL_WLAN_RX_FILTER_COUNTER5                          (5)
N#define SL_WLAN_RX_FILTER_COUNTER6                          (6)
N#define SL_WLAN_RX_FILTER_COUNTER7                          (7)
N#define SL_WLAN_RX_FILTER_COUNTER8                          (8)
N#define SL_WLAN_RX_FILTER_MAX_COUNTER                       (9)
N
N/* The filter trigger, determine when the filter is triggered,
N   The filter is triggered in the following condition :\n
N   1. The filter parent is triggered\n
N   2. The requested connection type exists, i.e. wlan_connect\n
N   3. The filter role is the same as the system role\n */
Ntypedef struct
N{
N    SlWlanRxFilterID_t                      ParentFilterID; /* The parent filter ID, this is the way to build filter tree.  NULL value means tree root */
N    SlWlanRxFilterCounterId_t               Counter; /* Trigger only when reach counter threshold */
N    SlWlanRxFilterTriggerConnectionStates_t ConnectionState; /* Trigger only with specific connection state */
N    SlWlanRxFilterTriggerRoles_t            Role; /* Trigger only with specific role */
N    _u32                                    CounterVal;  /* Value for the counter if set */
X    unsigned long                                    CounterVal;   
N    SlWlanRxFilterTriggerCompareFunction_t  CompareFunction; /* The compare function reffers to the counter if set */
N    _u8                                     Padding[3];
X    unsigned char                                     Padding[3];
N} SlWlanRxFilterTrigger_t;
N
N/* The actions are executed only if the filter is matched,\n
N *  In case of false match the packet is transfered to the HOST. \n
N *  The action is composed of bit field structure, up to 2 actions can be defined per filter.\n  */
Ntypedef _u8 SlWlanRxFilterActionType_t;
Xtypedef unsigned char SlWlanRxFilterActionType_t;
N/* Possible values for SlWlanRxFilterActionType_t */
N#define SL_WLAN_RX_FILTER_ACTION_NULL               (0x0) /* No action to execute*/
N#define SL_WLAN_RX_FILTER_ACTION_DROP               (0x1) /* If not dropped ,The packet is passed to the next filter or in case it is the last filter to the host */
N#define SL_WLAN_RX_FILTER_ACTION_ON_REG_INCREASE    (0x4) /* action increase counter registers */
N#define SL_WLAN_RX_FILTER_ACTION_ON_REG_DECREASE    (0x8) /* action decrease counter registers */
N#define SL_WLAN_RX_FILTER_ACTION_ON_REG_RESET       (0x10)/* action reset counter registers */
N#define SL_WLAN_RX_FILTER_ACTION_SEND_TEMPLATE      (0x20)/* unsupported */
N#define SL_WLAN_RX_FILTER_ACTION_EVENT_TO_HOST      (0x40)/* action can send events to host */
N
N/* Several actions can be defined The action is executed in case the filter rule is matched. */
Ntypedef struct
N{
N    SlWlanRxFilterActionType_t Type; /* Determine which actions are supported */
N    _u8    Counter;    /* The counter in use. In case the action is of type increase\decrease\reset this arg will contain the counter number, The counter number values are as in  ::SlWlanRxFilterCounterId_t.\n*/
X    unsigned char    Counter;     
N    _u16   Reserved;   /* Must be set to zero */
X    unsigned short   Reserved;    
N    _u8    UserId;     /* In case action set to host event, user can set id which will return in the event arguments */
X    unsigned char    UserId;      
N    _u8    Padding[3];
X    unsigned char    Padding[3];
N
N} SlWlanRxFilterAction_t;
N
N/* The supported operation: SL_WLAN_RX_FILTER_STATE, SL_WLAN_RX_FILTER_REMOVE */
Ntypedef struct
N{
N    SlWlanRxFilterIdMask_t FilterBitmap;
N    _u8 Padding[4];
X    unsigned char Padding[4];
N
N} SlWlanRxFilterOperationCommandBuff_t;
N
N/* The supported operation: SL_WLAN_RX_FILTER_UPDATE_ARGS */
Ntypedef struct
N{
N    _u8  FilterId;
X    unsigned char  FilterId;
N    _u8  BinaryOrAscii; /* Set 1 for Binary argument representation, 0 - for Ascii representation */
X    unsigned char  BinaryOrAscii;  
N    _u8 Padding[2];
X    unsigned char Padding[2];
N    SlWlanRxFilterRuleHeaderArgs_t Args;
N    
N
N} SlWlanRxFilterUpdateArgsCommandBuff_t;
N
N/* Filters bitmap enable\disable status return value */
Ntypedef struct 
N{
N    SlWlanRxFilterIdMask_t FilterIdMask; /* The filter set bit map */
N
N}SlWlanRxFilterRetrieveStateBuff_t;
N
N/* Disbale/Enable system filters */
Ntypedef struct
N{
N    SlWlanRxFilterSysFiltersMask_t  FilterBitmap; /* The filter set bit map */
N
N} SlWlanRxFilterSysFiltersSetStateBuff_t;
N
N/* System filters status return value */
Ntypedef struct
N{
N    SlWlanRxFilterSysFiltersMask_t  FilterBitmap; /* The filter get bit map */
N
N} SlWlanRxFilterSysFiltersRetrieveStateBuff_t;
N
N/*****************************************************************************/
N/* Function prototypes                                                                       */
N/*****************************************************************************/
N
N
N/*!
N    \brief Connect to wlan network as a station
N
N    \param[in]      pName       Up to 32 bytes in case of STA the name is the SSID of the Access Point
N    \param[in]      NameLen     Name length
N    \param[in]      pMacAddr    6 bytes for MAC address
N    \param[in]      pSecParams  Security parameters (use NULL key for SL_WLAN_SEC_TYPE_OPEN)\n
N                                security types options: 
N                                - SL_WLAN_SEC_TYPE_OPEN
N                                - SL_WLAN_SEC_TYPE_WEP
N                                - SL_WLAN_SEC_TYPE_WEP_SHARED
N                                - SL_WLAN_SEC_TYPE_WPA_WPA2
N                                - SL_WLAN_SEC_TYPE_WPA_ENT
N                                - SL_WLAN_SEC_TYPE_WPS_PBC
N                                - SL_WLAN_SEC_TYPE_WPS_PIN
N
N    \param[in]      pSecExtParams  Enterprise parameters (set NULL in case Enterprise parameters is not in use)
N
N    \return         Zero on success, or negative error code on failure
N
N
N    \sa             sl_WlanDisconnect
N    \note           Belongs to \ref ext_api
N    \warning        In this version only single enterprise mode could be used\n
N                    SL_WLAN_SEC_TYPE_WPA is a deprecated definition, the new definition is SL_WLAN_SEC_TYPE_WPA_WPA2
N    \par Example
N    
N    - Connect without security:
N    \code
N            SlWlanSecParams_t secParams;
N            secParams.Key = "";
N            secParams.KeyLen = 0;
N            secParams.Type = SL_WLAN_SEC_TYPE_OPEN;
N            sl_WlanConnect("ssid_name", strlen("ssid_name"),0,&secParams,0);
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanConnect)
X#if (1)
N_i16 sl_WlanConnect(const _i8*  pName,const  _i16 NameLen,const _u8 *pMacAddr,const SlWlanSecParams_t* pSecParams ,const SlWlanSecParamsExt_t* pSecExtParams);
Xsigned short sl_WlanConnect(const signed char*  pName,const  signed short NameLen,const unsigned char *pMacAddr,const SlWlanSecParams_t* pSecParams ,const SlWlanSecParamsExt_t* pSecExtParams);
N#endif
N
N/*!
N    \brief Wlan disconnect
N
N    Disconnect connection
N
N    \return         Zero disconnected done successfully, other already disconnected
N
N    \sa             sl_WlanConnect
N    \note           belongs to \ref ext_api
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanDisconnect)
X#if (1)
N_i16 sl_WlanDisconnect(void);
Xsigned short sl_WlanDisconnect(void);
N#endif
N
N/*!
N    \brief Add profile
N
N    When auto start is enabled, the device connects to a
N    station from the profiles table. Up to 7 profiles (SL_WLAN_MAX_PROFILES) are
N    supported.\n If several profiles configured the device chose
N    the highest priority profile, within each priority group,
N    device will chose profile based on security policy, signal
N    strength, etc parameters.
N
N    \param[in]      pName          Up to 32 bytes in case of STA the name is the
N                                   SSID of the Access Point.\n
N                                   In case of P2P the name is the remote device name.
N    \param[in]      NameLen     Name length
N    \param[in]      pMacAddr    6 bytes for MAC address
N    \param[in]      pSecParams  Security parameters (use NULL key for SL_WLAN_SEC_TYPE_OPEN)\n
N                                Security types options:
N                                - SL_WLAN_SEC_TYPE_OPEN
N                                - SL_WLAN_SEC_TYPE_WEP
N                                - SL_WLAN_SEC_TYPE_WEP_SHARED
N                                - SL_WLAN_SEC_TYPE_WPA_WPA2
N                                - SL_WLAN_SEC_TYPE_WPA_ENT
N                                - SL_WLAN_SEC_TYPE_WPS_PBC
N                                - SL_WLAN_SEC_TYPE_WPS_PIN
N
N    \param[in]      pSecExtParams  Enterprise parameters - identity, identity length,
N                                   Anonymous, Anonymous length, CertIndex (not supported,
N                                   certificates need to be placed in a specific file ID),
N                                   EapMethod.\n Use NULL in case Enterprise parameters is not in use
N
N    \param[in]      Priority    Profile priority. Lowest priority: 0, Highest priority: 15.
N    \param[in]      Options     Not supported
N
N    \return         Profile stored index on success, or negative error code on failure.
N    \par Persistent
N                    Profiles are <b>Persistent</b>
N    \sa             sl_WlanProfileGet , sl_WlanProfileDel
N    \note           belongs to \ref ext_api
N    \warning        Only one Enterprise profile is supported.\n
N                    Please Note that in case of adding an existing profile (compared by pName,pMACAddr and security type)
N                    the old profile will be deleted and the same index will be returned.\n
N                    SL_WLAN_SEC_TYPE_WPA is a deprecated definition, the new definition is SL_WLAN_SEC_TYPE_WPA_WPA2
N
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanProfileAdd)
X#if (1)
N_i16 sl_WlanProfileAdd(const _i8*  pName,const  _i16 NameLen,const _u8 *pMacAddr,const SlWlanSecParams_t* pSecParams ,const SlWlanSecParamsExt_t* pSecExtParams,const _u32 Priority,const _u32  Options);
Xsigned short sl_WlanProfileAdd(const signed char*  pName,const  signed short NameLen,const unsigned char *pMacAddr,const SlWlanSecParams_t* pSecParams ,const SlWlanSecParamsExt_t* pSecExtParams,const unsigned long Priority,const unsigned long  Options);
N#endif
N
N/*!
N    \brief Get profile
N
N    Read profile from the device
N
N    \param[in]      Index          Profile stored index, if index does not exists error is return
N    \param[out]     pName          Up to 32 bytes, in case of sta mode the name of the Access Point\n
N                                   In case of p2p mode the name of the Remote Device
N    \param[out]     pNameLen       Name length
N    \param[out]     pMacAddr       6 bytes for MAC address
N    \param[out]     pSecParams     Security parameters. Security types options: 
N                                    - SL_WLAN_SEC_TYPE_OPEN
N                                    - SL_WLAN_SEC_TYPE_WEP
N                                    - SL_WLAN_SEC_TYPE_WEP_SHARED
N                                    - SL_WLAN_SEC_TYPE_WPA_WPA2
N                                    - SL_WLAN_SEC_TYPE_WPA_ENT
N                                    - SL_WLAN_SEC_TYPE_WPS_PBC
N                                    - SL_WLAN_SEC_TYPE_WPS_PIN
N                                   Key and key length are not return. In case of p2p security type pin the key refers to pin code
N                                   return due to security reasons.
N    \param[out]     pSecExtParams  Enterprise parameters - identity, identity
N                                   length, Anonymous, Anonymous length
N                                   CertIndex (not supported), EapMethod.
N    \param[out]     pPriority      Profile priority
N
N    \return         Profile security type is returned (0 or positive number) on success, or negative error code on failure
N
N    \sa             sl_WlanProfileAdd , sl_WlanProfileDel
N    \note           belongs to \ref ext_api
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanProfileGet)
X#if (1)
N_i16 sl_WlanProfileGet(const _i16 Index,_i8*  pName, _i16 *pNameLen, _u8 *pMacAddr, SlWlanSecParams_t* pSecParams, SlWlanGetSecParamsExt_t* pSecExtParams, _u32 *pPriority);
Xsigned short sl_WlanProfileGet(const signed short Index,signed char*  pName, signed short *pNameLen, unsigned char *pMacAddr, SlWlanSecParams_t* pSecParams, SlWlanGetSecParamsExt_t* pSecExtParams, unsigned long *pPriority);
N#endif
N
N/*!
N    \brief Delete WLAN profile
N
N    Delete WLAN profile
N
N    \param[in]   Index  number of profile to delete. Possible values are 0 to 6.\n
N                 Index value SL_WLAN_DEL_ALL_PROFILES will delete all saved profiles
N
N    \return  Zero on success or a negative error code on failure
N    \par Persistent    
N            Profile deletion is  <b>Persistent</b>
N    \sa   sl_WlanProfileAdd , sl_WlanProfileGet
N    \note           belongs to \ref ext_api
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanProfileDel)
X#if (1)
N_i16 sl_WlanProfileDel(const _i16 Index);
Xsigned short sl_WlanProfileDel(const signed short Index);
N#endif
N
N/*!
N    \brief Set policy values
N
N    \param[in]      Type      Type of policy to be modified. The Options are:
N                              - SL_WLAN_POLICY_CONNECTION
N                              - SL_WLAN_POLICY_SCAN
N                              - SL_WLAN_POLICY_PM
N                              - SL_WLAN_POLICY_P2P
N    \param[in]      Policy    The option value which depends on action type
N    \param[in]      pVal      An optional value pointer
N    \param[in]      ValLen    An optional value length, in bytes
N    \return         Zero on success or negative error code on failure.
N    \par Persistent 
N            All parameters are <b>System Persistent</b>\n
N            Note that for SL_WLAN_POLICY_SCAN - only the interval will be saved.
N        
N    \sa             sl_WlanPolicyGet
N    \note           belongs to \ref ext_api
N    \warning
N    \par    Example
N    
N      <b>SL_WLAN_POLICY_CONNECTION: </b><br> defines options available to connect the CC31xx device to the AP: 
N      The options below could be combined to a single action, if more than one action is required. 
N
N    - Auto Connect: If is set, the CC31xx device tries to automatically reconnect to one of its stored profiles,
N      each time the connection fails or the device is rebooted. To set this option, use: 
N    \code    
N        sl_WlanPolicySet(SL_WLAN_POLICY_CONNECTION,SL_WLAN_CONNECTION_POLICY(1,0,0,0),NULL,0) 
N    \endcode
N    <br>
N
N
N    - Fast Connect: If  is set, the CC31xx device tries to establish a fast connection to AP. 
N      To set this option, use: 
N    \code
N        sl_WlanPolicySet(SL_WLAN_POLICY_CONNECTION,SL_WLAN_CONNECTION_POLICY(0,1,0,0),NULL,0)
N    \endcode
N    <br>
N
N    - P2P: If is set (relevant for P2P mode only),  CC31xx/CC32xx device tries to automatically 
N      connect to the first P2P device available, supporting push button only. To set this option, use: 
N    \code
N        sl_WlanPolicySet(SL_WLAN_POLICY_CONNECTION,SL_WLAN_CONNECTION_POLICY(0,0,1,0),NULL,0)
N    \endcode
N    <br>
N
N    - Auto Provisioning - If is set, the CC31xx device will automatically start the provisioning process 
N      after a long period of disconnection when profiles exist to set this option, use: 
N    \code
N        sl_WlanPolicySet(SL_WLAN_POLICY_CONNECTION,SL_WLAN_CONNECTION_POLICY(0,0,0,1),NULL,0)            
N    \endcode \n
N    
N
N    <b>SL_WLAN_POLICY_SCAN:</b><br> defines system scan time interval. \nDefault interval is 10 minutes.
N    After settings scan interval, an immediate scan is activated.\n The next scan will be based on the interval settings. 
N    For AP scan, minimun interval is 10 seconds.
N
N    -  With hidden SSID: For example, setting scan interval to 1 minute interval use including hidden ssid: 
N    \code
N        _u32 intervalInSeconds = 60;    
N        sl_WlanPolicySet(SL_WLAN_POLICY_SCAN,SL_WLAN_SCAN_POLICY(1,1), (_u8 *)&intervalInSeconds,sizeof(intervalInSeconds)); 
N    \endcode
N    <br>
N
N    -  No hidden SSID: setting scan interval to 1 minute interval use, not including hidden ssid: 
N    \code
N        _u32 intervalInSeconds = 60;    
N        sl_WlanPolicySet(SL_WLAN_POLICY_SCAN,SL_WLAN_SCAN_POLICY(1,0), (_u8 *)&intervalInSeconds,sizeof(intervalInSeconds));
N    \endcode
N    <br>
N
N    -  Disable scan:    
N    \code
N        #define SL_WLAN_DISABLE_SCAN 0
N        _u32 intervalInSeconds = 0;
N        sl_WlanPolicySet(SL_WLAN_POLICY_SCAN,SL_WLAN_DISABLE_SCAN,(_u8 *)&intervalInSeconds,sizeof(intervalInSeconds));
N    \endcode 
N    <br>
N
N    <b>SL_WLAN_POLICY_PM: </b><br> defines a power management policy for Station mode only:
N    -  Normal power management (default) policy use: 
N    \code
N        sl_WlanPolicySet(SL_WLAN_POLICY_PM , SL_WLAN_NORMAL_POLICY, NULL,0)
N    \endcode
N    <br>
N
N    - Low latency power management policy use: 
N    \code
N        sl_WlanPolicySet(SL_WLAN_POLICY_PM , SL_WLAN_LOW_LATENCY_POLICY, NULL,0)
N    \endcode
N    <br>
N
N    - Low power management policy use: 
N    \code
N        sl_WlanPolicySet(SL_WLAN_POLICY_PM , SL_WLAN_LOW_POWER_POLICY, NULL,0) 
N    \endcode
N    <br>
N
N    - Always on power management policy use: 
N    \code
N        sl_WlanPolicySet(SL_WLAN_POLICY_PM , SL_WLAN_ALWAYS_ON_POLICY, NULL,0)
N    \endcode
N    <br>
N
N    - Long Sleep Interval policy use: 
N    \code        
N    SlWlanPmPolicyParams_t PmPolicyParams;
N    memset(&PmPolicyParams,0,sizeof(SlWlanPmPolicyParams_t));
N    PmPolicyParams.MaxSleepTimeMs = 800;  //max sleep time in mSec
N    sl_WlanPolicySet(SL_WLAN_POLICY_PM , SL_WLAN_LONG_SLEEP_INTERVAL_POLICY, (_u8*)&PmPolicyParams,sizeof(PmPolicyParams)); 
N    \endcode
N    <br>
N
N    <b>SL_WLAN_POLICY_P2P: </b><br> defines p2p negotiation policy parameters for P2P role:
N    - To set intent negotiation value, set on of the following:\n
N        SL_WLAN_P2P_ROLE_NEGOTIATE   - intent 3 \n
N        SL_WLAN_P2P_ROLE_GROUP_OWNER - intent 15 \n
N        SL_WLAN_P2P_ROLE_CLIENT      - intent 0 \n
N    <br>
N    - To set negotiation initiator value (initiator policy of first negotiation action frame), set on of the following: \n
N        SL_WLAN_P2P_NEG_INITIATOR_ACTIVE \n
N        SL_WLAN_P2P_NEG_INITIATOR_PASSIVE \n
N        SL_WLAN_P2P_NEG_INITIATOR_RAND_BACKOFF \n
N    \code
N        sl_WlanPolicySet(SL_WLAN_POLICY_P2P, SL_WLAN_P2P_POLICY(SL_WLAN_P2P_ROLE_NEGOTIATE,SL_WLAN_P2P_NEG_INITIATOR_RAND_BACKOFF),NULL,0);
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanPolicySet)
X#if (1)
N_i16 sl_WlanPolicySet(const _u8 Type , const _u8 Policy, _u8 *pVal,const _u8 ValLen);
Xsigned short sl_WlanPolicySet(const unsigned char Type , const unsigned char Policy, unsigned char *pVal,const unsigned char ValLen);
N#endif
N/*!
N    \brief Get policy values
N
N    \param[in]      Type     
N                        - SL_WLAN_POLICY_CONNECTION 
N                        - SL_WLAN_POLICY_SCAN 
N                        - SL_WLAN_POLICY_PM, SL_WLAN_POLICY_P2P
N    \param[out]     pPolicy       argument may be set to any value 
N    \param[out]     pVal         The returned values, depends on each policy type, will be stored in the allocated buffer pointed by pVal
N                    with a maximum buffer length set by the calling function and pointed to by argument *pValLen
N    \param[out]     pValLen        actual value lenght
N    \return         Zero on success, or negative error code on failure
N
N    \sa             sl_WlanPolicySet
N
N    \note           belongs to \ref ext_api
N
N    \warning        The value pointed by the argument *pValLen should be set to a value different from 0 and
N                    greater than the buffer length returned from the SL device. Otherwise, an error will be returned.
N
N    \par Example
N    
N    - SL_WLAN_POLICY_CONNECTION - Get connection policy:
N    \code
N    _u8 Policy = 0;
N    int length = sizeof(PolicyOption);
N    int ret;
N    ret = sl_WlanPolicyGet(SL_WLAN_POLICY_CONNECTION ,&Policy,0,(_u8*)&length);
N               
N    if (Policy & SL_WLAN_CONNECTION_POLICY(1, 1 , 0 , 0 ))
N    {
N        printf("Connection Policy is set to Auto + Fast");
N    }
N    \endcode
N    <br>
N
N    - SL_WLAN_POLICY_SCAN - Get scan policy:
N    \code                
N    int ScanInterval = 0;  //default value is 600 seconds
N    _u8 Policy = 0;       //default value is 0 (disabled)
N    int ret;
N    length = sizeof(ScanInterval);
N    ret = sl_WlanPolicyGet(SL_WLAN_POLICY_SCAN ,&Policy,(_u8*)&ScanInterval,(_u8*)&length);
N      
N    if (Policy & SL_WLAN_SCAN_POLICY(0 ,1))
N    {
N        printf("Scan Policy is set to Scan visible ssid ");
N    }
N    if (Policy & SL_WLAN_SCAN_POLICY(1, 0))
N    {
N        printf("Scan Policy is set to Scan hidden ssid ");
N    }
N    \endcode
N    <br>
N
N    - SL_WLAN_POLICY_PM - Get power management policy:
N    \code
N    _u8 Policy = 0;
N    int ret;
N    SlWlanPmPolicyParams_t PmPolicyParams;
N    length = sizeof(PmPolicyParams);
N    ret = sl_WlanPolicyGet(SL_POLICY_PM ,&Policy,&PmPolicyParams,(_u8*)&length);
N    if (Policy ==  SL_WLAN_LONG_SLEEP_INTERVAL_POLICY )
N    {
N        printf("Connection Policy is set to LONG SLEEP INTERVAL POLICY with inteval = %d ",PmPolicyParams.MaxSleepTimeMs);
N    }
N    \endcode
N    <br>
N
N    -  SL_WLAN_POLICY_P2P - Get P2P policy:
N    \code       
N    _u8 Policy = 0;
N    int ret;
N    length = sizeof(Policy);
N    ret = sl_WlanPolicyGet(SL_WLAN_POLICY_P2P ,&Policy,0,(_u8*)&length);
N    //SL_WLAN_P2P_POLICY(p2pNegType, p2pNegInitiator)
N    if (Policy &  SL_WLAN_P2P_POLICY(0,SL_WLAN_P2P_NEG_INITIATOR_RAND_BACKOFF))
N    {
N        printf("P2P Policy is set to Rand backoff");
N    }
N    if (Policy &  SL_WLAN_P2P_POLICY(SL_WLAN_P2P_ROLE_NEGOTIATE,0))
N    {
N        printf("P2P Policy is set to Role Negotiate");
N    }
N    \endcode
N    <br>
N
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanPolicyGet)
X#if (1)
N_i16 sl_WlanPolicyGet(const _u8 Type ,_u8 *pPolicy,_u8 *pVal,_u8 *pValLen);
Xsigned short sl_WlanPolicyGet(const unsigned char Type ,unsigned char *pPolicy,unsigned char *pVal,unsigned char *pValLen);
N#endif
N/*!
N    \brief Gets the WLAN scan operation results
N
N    Gets scan results , gets entry from scan result table
N
N    \param[in]   Index      Starting index identifier (range 0-29) for getting scan results
N    \param[in]   Count      How many entries to fetch. Max is (30-"Index").
N    \param[out]  pEntries      Pointer to an allocated SlWlanNetworkEntry_t.
N                            The number of array items should match "Count" \n
N                            sec_type: 
N                                - SL_WLAN_SCAN_SEC_TYPE_OPEN 
N                                - SL_WLAN_SCAN_SEC_TYPE_WEP 
N                                - SL_WLAN_SCAN_SEC_TYPE_WPA 
N                                - SL_WLAN_SCAN_SEC_TYPE_WPA2
N
N    \return  Number of valid networks list items
N    \sa
N    \note       belongs to \ref ext_api
N    \warning    This command do not initiate any active scanning action
N    \par        Example
N
N    - Fetching max 10 results:
N    \code       
N    SlWlanNetworkEntry_t netEntries[10];
N    _u8 i;
N    _i16 resultsCount = sl_WlanGetNetworkList(0,10,&netEntries[0]);
N    for(i=0; i< resultsCount; i++)
N    {
N        printf("%d. ",i+1);
N        printf("SSID: %.32s        ",netEntries[i].Ssid);
N        printf("BSSID: %x:%x:%x:%x:%x:%x    ",netEntries[i].Bssid[0],netEntries[i].Bssid[1],netEntries[i].Bssid[2],netEntries[i].Bssid[3],netEntries[i].Bssid[4],netEntries[i].Bssid[5]);
N        printf("Channel: %d    ",netEntries[i].Channel);
N        printf("RSSI: %d    ",netEntries[i].Rssi);
N        printf("Security type: %d    ",SL_WLAN_SCAN_RESULT_SEC_TYPE_BITMAP(netEntries[i].SecurityInfo));
N        printf("Group Cipher: %d    ",SL_WLAN_SCAN_RESULT_GROUP_CIPHER(netEntries[i].SecurityInfo));
N        printf("Unicast Cipher bitmap: %d    ",SL_WLAN_SCAN_RESULT_UNICAST_CIPHER_BITMAP(netEntries[i].SecurityInfo));
N        printf("Key Mgmt suites bitmap: %d    ",SL_WLAN_SCAN_RESULT_KEY_MGMT_SUITES_BITMAP(netEntries[i].SecurityInfo));
N        printf("Hidden SSID: %d\r\n",SL_WLAN_SCAN_RESULT_HIDDEN_SSID(netEntries[i].SecurityInfo));
N    }
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanGetNetworkList)
X#if (1)
N_i16 sl_WlanGetNetworkList(const _u8 Index,const  _u8 Count, SlWlanNetworkEntry_t *pEntries);
Xsigned short sl_WlanGetNetworkList(const unsigned char Index,const  unsigned char Count, SlWlanNetworkEntry_t *pEntries);
N#endif
N
N/*!
N    \brief   Start collecting wlan RX statistics, for unlimited time.
N
N    \par Parameters 
N        None
N    \return  Zero on success, or negative error code on failure
N
N    \sa      sl_WlanRxStatStop      sl_WlanRxStatGet
N    \note    Belongs to \ref ext_api
N    \warning This API is deprecated and should be removed for next release
N    \par     Example
N
N    - Getting wlan RX statistics:
N    \code
N    void RxStatCollectTwice()
N    {
N        SlWlanGetRxStatResponse_t rxStat;
N        _i16 rawSocket;
N        _i8 DataFrame[200];
N        struct SlTimeval_t timeval;
N        timeval.tv_sec =  0;             // Seconds
N        timeval.tv_usec = 20000;         // Microseconds. 10000 microseconds resolution
N
N        sl_WlanRxStatStart();  // set statistics mode
N
N        rawSocket = sl_Socket(SL_AF_RF, SL_SOCK_RAW, eChannel);
N        // set timeout - in case we have no activity for the specified channel
N        sl_SetSockOpt(rawSocket,SL_SOL_SOCKET,SL_SO_RCVTIMEO, &timeval, sizeof(timeval));    // Enable receive timeout
N        status = sl_Recv(rawSocket, DataFrame, sizeof(DataFrame), 0);
N
N        Sleep(1000); // sleep for 1 sec
N        sl_WlanRxStatGet(&rxStat,0); // statistics has been cleared upon read
N        Sleep(1000); // sleep for 1 sec
N        sl_WlanRxStatGet(&rxStat,0);
N    }
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanRxStatStart)
X#if (1)
N_i16 sl_WlanRxStatStart(void);
Xsigned short sl_WlanRxStatStart(void);
N#endif
N
N/*!
N    \brief    Stop collecting wlan RX statistic, (if previous called sl_WlanRxStatStart)
N
N    \par      Parameters
N              None
N    \return   Zero on success, or negative error code on failure
N
N    \sa       sl_WlanRxStatStart      sl_WlanRxStatGet
N    \note     Belongs to \ref ext_api
N    \warning  This API is deprecated and should be removed for next release
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanRxStatStop)
X#if (1)
N_i16 sl_WlanRxStatStop(void);
Xsigned short sl_WlanRxStatStop(void);
N#endif
N
N
N/*!
N    \brief Get wlan RX statistics. Upon calling this command, the statistics counters will be cleared.
N
N    \param[in]  pRxStat       Pointer to SlWlanGetRxStatResponse_t filled with Rx statistics results
N    \param[in]  Flags         Should be 0  ( not applicable right now, will be added the future )
N    \return     Zero on success, or negative error code on failure
N
N    \sa         sl_WlanRxStatStart  sl_WlanRxStatStop
N    \note       Belongs to \ref ext_api
N    \warning
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanRxStatGet)
X#if (1)
N_i16 sl_WlanRxStatGet(SlWlanGetRxStatResponse_t *pRxStat,const _u32 Flags);
Xsigned short sl_WlanRxStatGet(SlWlanGetRxStatResponse_t *pRxStat,const unsigned long Flags);
N#endif
N
N
N/*!
N    \brief  The simpleLink will switch to the appropriate role according to the provisioning mode requested
N            and will start the provisioning process.
N
N    \param[in]  ProvisioningCmd            
N                                            - SL_WLAN_PROVISIONING_CMD_START_MODE_AP                          0: Start AP provisioning (AP role)
N                                            - SL_WLAN_PROVISIONING_CMD_START_MODE_SC                          1: Start Smart Config provisioning (STA role)
N                                            - SL_WLAN_PROVISIONING_CMD_START_MODE_APSC                        2: Start AP+Smart Config provisioning (AP role)
N                                            - SL_WLAN_PROVISIONING_CMD_START_MODE_APSC_EXTERNAL_CONFIGURATION 3: Start AP + Smart Config + WAC provisioning (AP role)
N                                            - SL_WLAN_PROVISIONING_CMD_STOP                                   4: Stop provisioning
N                                            - SL_WLAN_PROVISIONING_CMD_ABORT_EXTERNAL_CONFIGURATIONC          5:
N    \param[in]  RequestedRoleAfterSuccess   The role that the SimpleLink will switch to in case of a successful provisioning.
N                                            0: STA
N                                            2: AP
N                                            0xFF: stay in current role (relevant only in provisioning_stop)
N    \param[in]  InactivityTimeoutSec -      The period of time (in seconds) the system waits before it automatically
N                                            stops the provisioning process when no activity is detected.
N                                            set to 0 in order to stop provisioning. Minimum InactivityTimeoutSec is 30 seconds.
N    \param[in]  pSmartConfigKey             Smart Config key: public key for smart config process (relevent for smart config only)
N    \param[in]  Flags                       Can have the following values:
N                                                   - SL_WLAN_PROVISIONING_CMD_FLAG_EXTERNAL_CONFIRMATION - Confirmation phase will be completed externaly by host (e.g. via cloud assist)
N
N
N    \return     Zero on success, or negative error code on failure
N
N    \sa
N    \warning
N    \par       Example
N
N    - Start Provisioning - start as STA after success with inactivity timeout of 10 minutes:
N    \code
N        sl_WlanProvisioning(SL_WLAN_PROVISIONING_CMD_START_MODE_APSC, ROLE_STA, 600, "Key0Key0Key0Key0", 0x0);
N    \endcode
N    <br>
N
N    - Stop Provisioning:
N    \code
N        sl_WlanProvisioning(SL_WLAN_PROVISIONING_CMD_STOP,0xFF,0,NULL, 0x0);
N    \endcode
N    <br>
N
N    - Start AP Provisioning with inactivity timeout of 10 minutes
N    \code
N        sl_WlanProvisioning(SL_WLAN_PROVISIONING_CMD_START_MODE_APSC,ROLE_AP,600,NULL, 0x0);
N    \endcode
N    <br>
N
N    - Start AP Provisioning with inactivity timeout of 10 minutes and complete confirmation via user cloud assist
N    \code
N        sl_WlanProvisioning(SL_WLAN_PROVISIONING_CMD_START_MODE_APSC, ROLE_AP, 600, NULL, SL_WLAN_PROVISIONING_CMD_FLAG_EXTERNAL_CONFIRMATION);
N    \endcode
N    <br>
N
N*/
N
N#if _SL_INCLUDE_FUNC(sl_WlanProvisioning)
X#if (1)
N_i16 sl_WlanProvisioning(_u8 ProvisioningCmd, _u8 RequestedRoleAfterSuccess, _u16 InactivityTimeoutSec,  char *pSmartConfigKey, _u32 Flags);
Xsigned short sl_WlanProvisioning(unsigned char ProvisioningCmd, unsigned char RequestedRoleAfterSuccess, unsigned short InactivityTimeoutSec,  char *pSmartConfigKey, unsigned long Flags);
N#endif
N
N
N
N/*!
N    \brief Wlan set mode
N
N    Setting WLAN mode
N
N    \param[in] Mode  WLAN mode to start the CC31xx device. Possible options are
N                    - ROLE_STA - for WLAN station mode
N                    - ROLE_AP  - for WLAN AP mode
N                    - ROLE_P2P  -for WLAN P2P mode
N    \return   Zero on success, or negative error code on failure
N    \par Persistent 
N          Mode is <b>Persistent</b>
N    \sa        sl_Start sl_Stop
N    \note      Belongs to \ref ext_api
N    \warning   After setting the mode the system must be restarted for activating the new mode
N    \par       Example
N
N    - Switch from any role to STA:
N    \code
N        sl_WlanSetMode(ROLE_STA);
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanSetMode)
X#if (1)
N_i16 sl_WlanSetMode(const _u8  Mode);
Xsigned short sl_WlanSetMode(const unsigned char  Mode);
N#endif
N
N
N/*!
N    \brief     Setting WLAN configurations
N
N    \param[in] ConfigId -  configuration id
N                          - <b>SL_WLAN_CFG_AP_ID</b>
N                          - <b>SL_WLAN_CFG_GENERAL_PARAM_ID</b>
N                          - <b>SL_WLAN_CFG_P2P_PARAM_ID</b>
N                          - <b>SL_WLAN_RX_FILTERS_ID</b>
N
N    \param[in] ConfigOpt - configurations option
N                          - <b>SL_WLAN_CFG_AP_ID</b>
N                              - <b>SL_WLAN_AP_OPT_SSID</b> \n
N                                      Set SSID for AP mode. \n
N                                      This options takes <b>_u8</b> buffer as parameter
N                              - <b>SL_WLAN_AP_OPT_CHANNEL</b> \n
N                                      Set channel for AP mode. \n
N                                      The channel is dependant on the country code which is set. i.e. for "US" the channel should be in the range of [1-11] \n
N                                      This option takes <b>_u8</b> as a parameter
N                              - <b>SL_WLAN_AP_OPT_HIDDEN_SSID</b> \n
N                                      Set Hidden SSID Mode for AP mode.Hidden options: \n
N                                         0: disabled \n
N                                         1: Send empty (length=0) SSID in beacon and ignore probe request for broadcast SSID \n
N                                         2: Clear SSID (ASCII 0), but keep the original length (this may be required with some \n
N                                            clients that do not support empty SSID) and ignore probe requests for broadcast SSID \n
N                                      This option takes <b>_u8</b> as a parameter
N                              - <b>SL_WLAN_AP_OPT_SECURITY_TYPE</b> \n
N                                      Set Security type for AP mode. Security options are:
N                                      - Open security: SL_WLAN_SEC_TYPE_OPEN
N                                      - WEP security:  SL_WLAN_SEC_TYPE_WEP
N                                      - WPA security:  SL_WLAN_SEC_TYPE_WPA_WPA2  \n
N                                      This option takes <b>_u8</b> pointer as a parameter
N                              - <b>SL_WLAN_AP_OPT_PASSWORD</b> \n
N                                      Set Password for for AP mode (for WEP or for WPA): \n
N                                      Password - for WPA: 8 - 63 characters \n
N                                      for WEP: 5 / 13 characters (ascii) \n
N                                      This options takes <b>_u8</b> buffer as parameter
N                              - <b>SL_WLAN_AP_OPT_MAX_STATIONS</b> \n
N                                      Set Max AP stations - 1..4 - Note: can be less than the number of currently connected stations \n
N                                      max_stations - 1 characters \n
N                                      This options takes <b>_u8</b> buffer as parameter
N                              - <b>SL_WLAN_AP_OPT_MAX_STA_AGING</b> \n
N                                      Set Max station aging time - default is 60 seconds \n
N                                      max_stations - 2 characters \n
N                                      This options takes <b>_u16</b> buffer as parameter
N                              - <b>SL_WLAN_AP_ACCESS_LIST_MODE</b> \n
N                                      Set AP access list mode - DISABLE, DENY_LIST \n
N                                      mode - 1 characters \n
N                                      This options takes <b>_u8</b> buffer as parameter
N                              - <b>SL_WLAN_AP_ACCESS_LIST_ADD_MAC</b> \n
N                                      Add MAC address to the AP access list: \n
N                                      mac_addr - 6 characters \n
N                                      This options takes <b>_u8</b> buffer as parameter
N                              - <b>SL_WLAN_AP_ACCESS_LIST_DEL_MAC</b> \n
N                                      Del MAC address from the AP access list: \n
N                                      mac_addr - 6 characters \n
N                                      This options takes <b>_u8</b> buffer as parameter
N                              - <b>SL_WLAN_AP_ACCESS_LIST_DEL_IDX</b> \n
N                                      Delete MAC address from index in the AP access list: \n
N                                      index - 1 character \n
N                                      This options takes <b>_u8</b> buffer as parameter
N
N                          - <b>SL_WLAN_CFG_GENERAL_PARAM_ID</b>
N                              - <b>SL_WLAN_GENERAL_PARAM_OPT_COUNTRY_CODE</b> \n
N                                      Set Country Code for AP mode \n
N                                      This options takes <b>_u8</b> 2 bytes buffer as parameter
N                              - <b>SL_WLAN_GENERAL_PARAM_OPT_STA_TX_POWER</b> \n
N                                      Set STA mode Tx power level \n
N                                      Number between 0-15, as dB offset from max power (0 will set MAX power) \n
N                                      This options takes <b>_u8</b> as parameter
N                              - <b>SL_WLAN_GENERAL_PARAM_OPT_AP_TX_POWER</b>
N                                      Set AP mode Tx power level \n
N                                      Number between 0-15, as dB offset from max power (0 will set MAX power) \n
N                                      This options takes <b>_u8</b> as parameter
N                              - <b>SL_WLAN_GENERAL_PARAM_OPT_INFO_ELEMENT</b>
N                                      Set Info Element for AP mode. \n
N                                      The Application can set up to SL_WLAN_MAX_PRIVATE_INFO_ELEMENTS_SUPPROTED info elements per Role (AP / P2P GO).  \n
N                                      To delete an info element use the relevant index and length = 0. \n
N                                      For AP - no more than SL_WLAN_INFO_ELEMENT_MAX_TOTAL_LENGTH_AP bytes can be stored for all info elements. \n
N                                      For P2P GO - no more than SL_WLAN_INFO_ELEMENT_MAX_TOTAL_LENGTH_P2P_GO bytes can be stored for all info elements.  \n
N                                      This option takes SlWlanSetInfoElement_t as parameter
N                              - <b>SL_WLAN_GENERAL_PARAM_OPT_SCAN_PARAMS</b>
N                                      Set scan parameters: RSSI threshold and channel mask.
N                              - <b>SL_WLAN_GENERAL_PARAM_OPT_SUSPEND_PROFILES</b>
N                                      Set suspended profiles mask (set bits 2 and 4 to suspend profiles 2 and 4).
N                               - <b>SL_WLAN_GENERAL_PARAM_DISABLE_ENT_SERVER_AUTH</b>
N                                      This option enables to skip server authentication and is valid for one
N                                      use, when manually connection to an enterprise network
N                                      
N
N                          - <b>SL_WLAN_CFG_P2P_PARAM_ID</b>
N                              - <b>SL_WLAN_P2P_OPT_DEV_TYPE</b> \n
N                                      Set P2P Device type.Maximum length of 17 characters. Device type is published under P2P I.E, \n
N                                      allows to make devices easier to recognize. \n
N                                      In case no device type is set, the default type is "1-0050F204-1"  \n
N                                      This options takes <b>_u8</b> buffer as parameter
N                              - <b>SL_WLAN_P2P_OPT_CHANNEL_N_REGS</b> \n
N                                     Set P2P Channels. \n
N                                     listen channel (either 1/6/11 for 2.4GHz) \n
N                                     listen regulatory class (81 for 2.4GHz)   \n
N                                     oper channel (either 1/6/11 for 2.4GHz)   \n
N                                     oper regulatory class (81 for 2.4GHz)     \n
N                                     listen channel and regulatory class will determine the device listen channel during p2p find listen phase \n
N                                     oper channel and regulatory class will determine the operating channel preferred by this device (in case it is group owner this will be the operating channel) \n
N                                     channels should be one of the social channels (1/6/11). In case no listen/oper channel selected, a random 1/6/11 will be selected.
N                                     This option takes pointer to <b>_u8[4]</b> as parameter
N
N                          - <b>SL_WLAN_RX_FILTERS_ID</b>
N                              - <b>SL_WLAN_RX_FILTER_STATE</b> \n
N                                      Enable or disable filters. The buffer input is SlWlanRxFilterOperationCommandBuff_t\n
N                              - <b>SL_WLAN_RX_FILTER_SYS_STATE</b> \n
N                                      Enable or disable system filters. The buffer input is SlWlanRxFilterSysFiltersSetStateBuff_t\n
N                              - <b>SL_WLAN_RX_FILTER_REMOVE</b> \n
N                                      Remove filters. The buffer input is SlWlanRxFilterOperationCommandBuff_t\n
N                              - <b>SL_WLAN_RX_FILTER_STORE</b> \n
N                                      Save the filters as persistent. \n
N                              - <b>SL_WLAN_RX_FILTER_UPDATE_ARGS</b> \n
N                                      Update filter arguments. The buffer input is SlWlanRxFilterUpdateArgsCommandBuff_t\n
N
N    \param[in] ConfigLen - configurations len
N
N    \param[in] pValues -   configurations values
N    
N    \return    Zero on success, or negative error code on failure
N
N    \par Persistent
N                        <b>System Persistent</b>:        
N                                - SL_WLAN_CFG_GENERAL_PARAM_ID
N                                - SL_WLAN_CFG_P2P_PARAM_ID
N                                
N                        <b>Reset</b>:
N                                - SL_WLAN_CFG_AP_ID
N                                
N                        <b>Non- Persistent</b>:
N                                  - SL_WLAN_GENERAL_PARAM_DISABLE_ENT_SERVER_AUTH
N    \sa
N    \note
N    \warning
N    \par   Examples
N
N    - SL_WLAN_AP_OPT_SSID:
N    \code
N        _u8  str[33];
N        memset(str, 0, 33);
N        memcpy(str, ssid, len);  // ssid string of 32 characters
N        sl_WlanSet(SL_WLAN_CFG_AP_ID, SL_WLAN_AP_OPT_SSID, strlen(ssid), str);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_OPT_CHANNEL:
N    \code 
N        _u8  val = channel;
N        sl_WlanSet(SL_WLAN_CFG_AP_ID, SL_WLAN_AP_OPT_CHANNEL, 1, (_u8 *)&val);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_OPT_HIDDEN_SSID:
N    \code
N        _u8  val = hidden;
N        sl_WlanSet(SL_WLAN_CFG_AP_ID, SL_WLAN_AP_OPT_HIDDEN_SSID, 1, (_u8 *)&val);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_OPT_SECURITY_TYPE:
N    \code
N        _u8  val = SL_WLAN_SEC_TYPE_WPA_WPA2;
N        sl_WlanSet(SL_WLAN_CFG_AP_ID, SL_WLAN_AP_OPT_SECURITY_TYPE, 1, (_u8 *)&val);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_OPT_PASSWORD: 
N    \code
N        _u8  str[65];
N        _u16  len = strlen(password);
N        memset(str, 0, 65);
N        memcpy(str, password, len);
N        sl_WlanSet(SL_WLAN_CFG_AP_ID, SL_WLAN_AP_OPT_PASSWORD, len, (_u8 *)str);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_OPT_MAX_STATIONS:
N    \code
N        _u8 max_ap_stations = 3;
N        sl_WlanSet(SL_WLAN_CFG_AP_ID, SL_WLAN_AP_OPT_MAX_STATIONS, sizeof(max_ap_stations), (_u8 *)&max_ap_stations);
N    \endcode
N    <br>
N    
N    - SL_WLAN_AP_OPT_MAX_STA_AGING:
N    \code
N        _u16 max_ap_sta_aging = 60;
N        sl_WlanSet(SL_WLAN_CFG_AP_ID, SL_WLAN_AP_OPT_MAX_STA_AGING, sizeof(max_ap_sta_aging), (_u8 *)&max_ap_sta_aging);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_ACCESS_LIST_MODE:
N    \code
N        _u8  access list_mode = SL_WLAN_AP_ACCESS_LIST_MODE_DENY_LIST;
N        sl_WlanSet(SL_WLAN_CFG_AP_ID, SL_WLAN_AP_ACCESS_LIST_MODE, sizeof(access list_mode), (_u8 *)&access list_mode);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_ACCESS_LIST_ADD_MAC:
N    \code
N        _u8  sta_mac[6] = { 0x00, 0x22, 0x33, 0x44, 0x55, 0x66 };
N        sl_WlanSet(SL_WLAN_CFG_AP_ID, SL_WLAN_AP_ACCESS_LIST_ADD_MAC, sizeof(sta_mac), (_u8 *)&sta_mac);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_ACCESS_LIST_DEL_MAC:
N    \code
N        _u8  sta_mac[6] = { 0x00, 0x22, 0x33, 0x44, 0x55, 0x66 };
N        sl_WlanSet(SL_WLAN_CFG_AP_ID, SL_WLAN_AP_ACCESS_LIST_DEL_MAC, sizeof(sta_mac), (_u8 *)&sta_mac);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_ACCESS_LIST_DEL_IDX:
N    \code
N        _u8  sta_index = 0;
N        sl_WlanSet(SL_WLAN_CFG_AP_ID, SL_WLAN_AP_ACCESS_LIST_DEL_IDX, sizeof(sta_index), (_u8 *)&sta_index);
N    \endcode
N    <br>
N
N    - SL_WLAN_GENERAL_PARAM_OPT_STA_TX_POWER:
N    \code
N        _u8  stapower=(_u8)power;
N        sl_WlanSet(SL_WLAN_CFG_GENERAL_PARAM_ID, SL_WLAN_GENERAL_PARAM_OPT_STA_TX_POWER,1,(_u8 *)&stapower);
N    \endcode
N    <br>
N
N    - SL_WLAN_GENERAL_PARAM_OPT_COUNTRY_CODE:
N    \code
N        _u8*  str = (_u8 *) country;  // string of 2 characters. i.e. - "US"
N        sl_WlanSet(SL_WLAN_CFG_GENERAL_PARAM_ID, SL_WLAN_GENERAL_PARAM_OPT_COUNTRY_CODE, 2, str);
N    \endcode
N    <br>
N
N    - SL_WLAN_GENERAL_PARAM_OPT_AP_TX_POWER:
N    \code
N        _u8  appower=(_u8)power;
N        sl_WlanSet(SL_WLAN_CFG_GENERAL_PARAM_ID, SL_WLAN_GENERAL_PARAM_OPT_AP_TX_POWER,1,(_u8 *)&appower);
N    \endcode
N    <br>
N
N    - SL_WLAN_GENERAL_PARAM_OPT_SUSPEND_PROFILES
N    \code
N        _u32  suspendedProfilesMask=(_u32)mask;
N        sl_WlanSet(SL_WLAN_CFG_GENERAL_PARAM_ID, SL_WLAN_GENERAL_PARAM_OPT_SUSPEND_PROFILES,sizeof(suspendedProfilesMask),(_u32 *)&suspendedProfilesMask);
N    \endcode
N    <br>
N
N    - SL_WLAN_P2P_OPT_DEV_TYPE:
N    \code
N        _u8   str[17];
N        _u16  len = strlen(device_type);
N        memset(str, 0, 17);
N        memcpy(str, device_type, len);
N        sl_WlanSet(SL_WLAN_CFG_P2P_PARAM_ID, SL_WLAN_P2P_OPT_DEV_TYPE, len, str);
N    \endcode
N    <br>
N
N    - SL_WLAN_P2P_OPT_CHANNEL_N_REGS
N    \code
N        _u8  str[4];
N        str[0] = (_u8)11;           // listen channel
N        str[1] = (_u8)81;           // listen regulatory class
N        str[2] = (_u8)6;            // oper channel
N        str[3] = (_u8)81;           // oper regulatory class
N        sl_WlanSet(SL_WLAN_CFG_P2P_PARAM_ID, SL_WLAN_P2P_OPT_CHANNEL_N_REGS, 4, str);
N    \endcode
N    <br>
N
N    - SL_WLAN_GENERAL_PARAM_OPT_INFO_ELEMENT:
N     \code
N        SlWlanSetInfoElement_t    infoele;
N        infoele.Index     = Index;                  // Index of the info element. range: 0 - SL_WLAN_MAX_PRIVATE_INFO_ELEMENTS_SUPPROTED
N        infoele.Role      = Role;                   // SL_WLAN_INFO_ELEMENT_AP_ROLE (0) or SL_WLAN_INFO_ELEMENT_P2P_GO_ROLE (1)
N        infoele.IE.Id     =  Id;                    // Info element ID. if SL_WLAN_INFO_ELEMENT_DEFAULT_ID (0) is set, ID will be set to 221.
N        // Organization unique ID. If all 3 bytes are zero - it will be replaced with 08,00,28.
N        infoele.IE.Oui[0] =  Oui0;                  // Organization unique ID first Byte
N        infoele.IE.Oui[1] =  Oui1;                  // Organization unique ID second Byte
N        infoele.IE.Oui[2] =  Oui2;                  // Organization unique ID third Byte
N        infoele.IE.Length = Len;                    // Length of the info element. must be smaller than 253 bytes
N        memset(infoele.IE.Data, 0, SL_WLAN_INFO_ELEMENT_MAX_SIZE);
N        if ( Len <= SL_WLAN_INFO_ELEMENT_MAX_SIZE )
N        {
N            memcpy(infoele.IE.Data, IE, Len);           // Info element. length of the info element is [0-252]
N            sl_WlanSet(SL_WLAN_CFG_GENERAL_PARAM_ID,SL_WLAN_GENERAL_PARAM_OPT_INFO_ELEMENT,sizeof(SlWlanSetInfoElement_t),(_u8* ) &infoele);
N        }
N    \endcode
N    <br>
N
N    - SL_WLAN_GENERAL_PARAM_OPT_SCAN_PARAMS:
N    \code
N        SlWlanScanParamCommand_t ScanParamConfig;
N        ScanParamConfig.RssiThreshold = -70;
N        ScanParamConfig.ChannelsMask = 0x1FFF;
N        sl_WlanSet(SL_WLAN_CFG_GENERAL_PARAM_ID,SL_WLAN_GENERAL_PARAM_OPT_SCAN_PARAMS,sizeof(ScanParamConfig),(_u8* ) &ScanParamConfig);
N    \endcode
N    <br>
N
N    - SL_WLAN_GENERAL_PARAM_DISABLE_ENT_SERVER_AUTH:
N    \code
N        _u8 param = 1; // 1 means disable the server authentication
N        sl_WlanSet(SL_WLAN_CFG_GENERAL_PARAM_ID,SL_WLAN_GENERAL_PARAM_DISABLE_ENT_SERVER_AUTH,1,&param);
N    \endcode
N    <br>
N    - SL_WLAN_RX_FILTER_STORE: 
N    \code
N     sl_WlanSet(SL_WLAN_RX_FILTERS_ID, SL_WLAN_RX_FILTER_STORE, 0, NULL);
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_WlanSet)
X#if (1)
N_i16 sl_WlanSet(const _u16 ConfigId ,const _u16 ConfigOpt,const _u16 ConfigLen,const  _u8 *pValues);
Xsigned short sl_WlanSet(const unsigned short ConfigId ,const unsigned short ConfigOpt,const unsigned short ConfigLen,const  unsigned char *pValues);
N#endif
N
N/*!
N    \brief     Getting WLAN configurations
N
N    \param[in] ConfigId -  configuration id
N                          - <b>SL_WLAN_CFG_AP_ID</b>
N                          - <b>SL_WLAN_CFG_GENERAL_PARAM_ID</b>
N                          - <b>SL_WLAN_CFG_P2P_PARAM_ID</b>
N                          - <b>SL_WLAN_CFG_AP_ACCESS_LIST_ID</b>
N                          - <b>SL_WLAN_RX_FILTERS_ID</b>
N
N    \param[out] pConfigOpt - get configurations option
N                          - <b>SL_WLAN_CFG_AP_ID</b>
N                              - <b>SL_WLAN_AP_OPT_SSID</b> \n
N                                      Get SSID for AP mode. \n
N                                      Get up to 32 characters of SSID \n
N                                      This options takes <b>_u8</b> as parameter
N                              - <b>SL_WLAN_AP_OPT_CHANNEL</b> \n
N                                      Get channel for AP mode. \n
N                                      This option takes <b>_u8</b> as a parameter
N                              - <b>SL_WLAN_AP_OPT_HIDDEN_SSID</b> \n
N                                      Get Hidden SSID Mode for AP mode.Hidden options: \n
N                                         0: disabled \n
N                                         1: Send empty (length=0) SSID in beacon and ignore probe request for broadcast SSID \n
N                                         2: Clear SSID (ASCII 0), but keep the original length (this may be required with some \n
N                                            clients that do not support empty SSID) and ignore probe requests for broadcast SSID \n
N                                      This option takes <b>_u8</b> as a parameter
N                              - <b>SL_WLAN_AP_OPT_SECURITY_TYPE</b> \n
N                                      Get Security type for AP mode. Security options are:
N                                      - Open security: SL_WLAN_SEC_TYPE_OPEN
N                                      - WEP security:  SL_WLAN_SEC_TYPE_WEP
N                                      - WPA security:  SL_WLAN_SEC_TYPE_WPA_WPA2  \n
N                                      This option takes <b>_u8</b> as a parameter
N                              - <b>SL_WLAN_AP_OPT_PASSWORD</b> \n
N                                      Get Password for for AP mode (for WEP or for WPA): \n
N                                      Returns password - string, fills up to 64 characters. \n
N                                      This options takes <b>_u8</b> buffer as parameter
N                              - <b>SL_WLAN_AP_OPT_MAX_STATIONS</b> \n
N                                      Get Max AP allowed stations: \n
N                                      This options takes <b>_u8</b> buffer as parameter
N                              - <b>SL_WLAN_AP_OPT_MAX_STA_AGING</b> \n
N                                      Get AP aging time in seconds: \n
N                                      This options takes <b>_u16</b> buffer as parameter
N                              - <b>SL_WLAN_AP_ACCESS_LIST_NUM_ENTRIES</b> \n
N                                      Get AP access list number of entries: \n
N                                      This options takes <b>_u8</b> buffer as parameter
N                              - <b>SL_WLAN_CFG_AP_ACCESS_LIST_ID</b>
N                                -  The option is the start index in the access list \n
N                                      Get the AP access list from start index, the number of entries in the list is extracted from the request length.
N                          - <b>SL_WLAN_CFG_GENERAL_PARAM_ID</b>
N                              - <b> SL_WLAN_GENERAL_PARAM_OPT_SCAN_PARAMS </b> \n
N                                      Get scan parameters.
N                                      This option uses SlWlanScanParamCommand_t as parameter
N                              - <b>SL_WLAN_GENERAL_PARAM_OPT_COUNTRY_CODE</b> \n
N                                      Get Country Code for AP mode \n
N                                      This options takes <b>_u8</b> buffer as parameter
N                              - <b>SL_WLAN_GENERAL_PARAM_OPT_STA_TX_POWER</b> \n
N                                      Get STA mode Tx power level \n
N                                      Number between 0-15, as dB offset from max power (0 indicates MAX power) \n
N                                      This options takes <b>_u8</b> as parameter
N                              - <b>SL_WLAN_GENERAL_PARAM_OPT_AP_TX_POWER</b>
N                                      Get AP mode Tx power level \n
N                                      Number between 0-15, as dB offset from max power (0 indicates MAX power) \n
N                                      This options takes <b>_u8</b> as parameter
N                          - <b>SL_WLAN_CFG_P2P_PARAM_ID</b>
N                              - <b>SL_WLAN_P2P_OPT_CHANNEL_N_REGS</b> \n
N                                     Get P2P Channels. \n
N                                     listen channel (either 1/6/11 for 2.4GHz) \n
N                                     listen regulatory class (81 for 2.4GHz)   \n
N                                     oper channel (either 1/6/11 for 2.4GHz)   \n
N                                     oper regulatory class (81 for 2.4GHz)     \n
N                                     listen channel and regulatory class will determine the device listen channel during p2p find listen phase \n
N                                     oper channel and regulatory class will determine the operating channel preferred by this device (in case it is group owner this will be the operating channel) \n
N                                     channels should be one of the social channels (1/6/11). In case no listen/oper channel selected, a random 1/6/11 will be selected. \n
N                                     This option takes pointer to <b>_u8[4]</b> as parameter
N                          - <b>SL_WLAN_RX_FILTERS_ID</b>
N                                - <b>SL_WLAN_RX_FILTER_STATE</b> \n
N                                    Retrieves the filters enable/disable status. The buffer input is SlWlanRxFilterRetrieveStateBuff_t \n
N                                - <b>SL_WLAN_RX_FILTER_SYS_STATE</b> \n
N                                    Retrieves the system filters enable/disable status. The buffer input is SlWlanRxFilterSysFiltersRetrieveStateBuff_t:
N
N    \param[out] pConfigLen - The length of the allocated memory as input, when the
N                                        function complete, the value of this parameter would be
N                                        the len that actually read from the device.
N                                        If the device return length that is longer from the input
N                                        value, the function will cut the end of the returned structure
N                                        and will return SL_ESMALLBUF.
N
N
N    \param[out] pValues - get configurations values
N    \return    Zero on success, or negative error code on failure
N    \sa   sl_WlanSet
N    \note
N            In case the device was started as AP mode, but no SSID was set, the Get SSID will return "mysimplelink" and not "mysimplelink-xxyyzz"
N    \warning
N    \par    Examples
N    
N    - SL_WLAN_GENERAL_PARAM_OPT_SCAN_PARAMS:
N    \code
N        SlWlanScanParamCommand_t ScanParamConfig;
N        _u16 Option = SL_WLAN_GENERAL_PARAM_OPT_SCAN_PARAMS;
N        _u16 OptionLen = sizeof(SlWlanScanParamCommand_t);
N        sl_WlanGet(SL_WLAN_CFG_GENERAL_PARAM_ID ,&Option,&OptionLen,(_u8 *)&ScanParamConfig);
N    \endcode
N    <br>
N
N    - SL_WLAN_GENERAL_PARAM_OPT_AP_TX_POWER:
N    \code
N        _i32 TXPower = 0;
N        _u16 Option = SL_WLAN_GENERAL_PARAM_OPT_AP_TX_POWER;
N        _u16 OptionLen = sizeof(TXPower);
N        sl_WlanGet(SL_WLAN_CFG_GENERAL_PARAM_ID ,&Option,&OptionLen,(_u8 *)&TXPower);
N    \endcode
N    <br>
N
N    - SL_WLAN_GENERAL_PARAM_OPTSTA_TX_POWER:
N    \code
N        _i32 TXPower = 0;
N        _u16 Option = SL_WLAN_GENERAL_PARAM_OPT_STA_TX_POWER;
N        _u16 OptionLen = sizeof(TXPower);
N        sl_WlanGet(SL_WLAN_CFG_GENERAL_PARAM_ID ,&Option,&OptionLen,(_u8 *)&TXPower);
N    \endcode
N    <br>
N
N    - SL_WLAN_P2P_OPT_DEV_TYPE:
N    \code
N        _i8 device_type[18];
N        _u16 len = 18;
N        _u16 config_opt = SL_WLAN_P2P_OPT_DEV_TYPE;
N        sl_WlanGet(SL_WLAN_CFG_P2P_PARAM_ID, &config_opt , &len, (_u8* )device_type);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_OPT_SSID:
N    \code
N        _i8 ssid[33];
N        _u16 len = 33;
N        sl_Memset(ssid,0,33);
N        _u16  config_opt = SL_WLAN_AP_OPT_SSID;
N        sl_WlanGet(SL_WLAN_CFG_AP_ID, &config_opt , &len, (_u8* )ssid);
N    \endcode
N    <br>
N
N    - SL_WLAN_GENERAL_PARAM_OPT_COUNTRY_CODE:
N    \code
N        _i8 country[3];
N        _u16 len = 3;
N        _u16  config_opt = SL_WLAN_GENERAL_PARAM_OPT_COUNTRY_CODE;
N        sl_WlanGet(SL_WLAN_CFG_GENERAL_PARAM_ID, &config_opt, &len, (_u8* )country);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_OPT_CHANNEL:
N    \code
N        _i8 channel;
N        _u16 len = 1;
N        _u16  config_opt = SL_WLAN_AP_OPT_CHANNEL;
N        sl_WlanGet(SL_WLAN_CFG_AP_ID, &config_opt, &len, (_u8* )&channel);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_OPT_HIDDEN_SSID:
N    \code
N        _u8 hidden;
N        _u16 len = 1;
N        _u16  config_opt = SL_WLAN_AP_OPT_HIDDEN_SSID;
N        sl_WlanGet(SL_WLAN_CFG_AP_ID, &config_opt, &len, (_u8* )&hidden);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_OPT_SECURITY_TYPE:
N    \code
N        _u8 sec_type;
N        _u16 len = 1;
N        _u16  config_opt = SL_WLAN_AP_OPT_SECURITY_TYPE;
N        sl_WlanGet(SL_WLAN_CFG_AP_ID, &config_opt, &len, (_u8* )&sec_type);
N    \endcode
N    <br>
N    
N    - SL_WLAN_AP_OPT_PASSWORD:
N    \code
N        _u8 password[64];
N        _u16 len = 64;
N        sl_Memset(password,0,64);
N        _u16 config_opt = SL_WLAN_AP_OPT_PASSWORD;
N        sl_WlanGet(SL_WLAN_CFG_AP_ID, &config_opt, &len, (_u8* )password);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_OPT_MAX_STATIONS:
N    \code
N        _u8 max_ap_stations
N        _u16 len = 1;
N        _u16  config_opt = SL_WLAN_AP_OPT_MAX_STATIONS;
N        sl_WlanGet(SL_WLAN_CFG_AP_ID, &config_opt, &len, (_u8 *)&max_ap_stations);
N    \endcode
N    <br>
N
N    - SL_WLAN_AP_OPT_MAX_STA_AGING:
N    \code
N        _u16 ap_sta_aging;
N        _u16 len = 2;
N        _u16  config_opt = SL_WLAN_AP_OPT_MAX_STA_AGING;
N        sl_WlanGet(SL_WLAN_CFG_AP_ID, &config_opt, &len, (_u8 *)&ap_sta_aging);
N    \endcode
N    <br>
N    
N    - SL_WLAN_AP_ACCESS_LIST_NUM_ENTRIES:
N    \code
N        _u8 aclist_num_entries;
N        _u16 config_opt = SL_WLAN_AP_ACCESS_LIST_NUM_ENTRIES;
N        _u16 len = sizeof(aclist_num_entries);
N        sl_WlanGet(SL_WLAN_CFG_AP_ID, &config_opt, &len, (_u8 *)&aclist_num_entries);
N    \endcode
N    <br>
N
N    - SL_WLAN_CFG_AP_ACCESS_LIST_ID:
N    \code
N        _u8 aclist_mac[SL_WLAN_MAX_ACCESS_LIST_STATIONS][MAC_LEN];
N        unsigned char aclist_num_entries;
N        unsigned short config_opt;
N        unsigned short len;
N        int actual_aclist_num_entries;
N        unsigned short start_aclist_index;
N        unsigned short aclist_info_len;
N        int i;
N
N        start_aclist_index = 0;
N        aclist_info_len = 2*MAC_LEN;
N        sl_WlanGet(SL_WLAN_CFG_AP_ACCESS_LIST_ID, &start_aclist_index, &aclist_info_len, (_u8 *)&aclist_mac[start_aclist_index]);
N
N        actual_aclist_num_entries = aclist_info_len / MAC_LEN;
N        printf("-Print AP Deny list, num stations = %d\n", actual_aclist_num_entries);
N        for (i=0; i<actual_aclist_num_entries; i++)
N        {
N                _u8 *pMac = aclist_mac[i+start_aclist_index];
N                printf("    MAC %d:  %02x:%02x:%02x:%02x:%02x:%02x\n", i, pMac[0], pMac[1], pMac[2], pMac[3], pMac[4], pMac[5]);
N        }
N    \endcode
N    <br>
N
N    - SL_WLAN_P2P_OPT_CHANNEL_N_REGS:
N    \code
N        _u16 listen_channel,listen_reg,oper_channel,oper_reg;
N        _u16 len = 4;
N        _u16  config_opt = SL_WLAN_P2P_OPT_CHANNEL_N_REGS;
N        _u8 channel_n_regs[4];
N        sl_WlanGet(SL_WLAN_CFG_P2P_PARAM_ID, &config_opt, &len, (_u8* )channel_n_regs);
N        listen_channel = channel_n_regs[0];
N        listen_reg = channel_n_regs[1];
N        oper_channel = channel_n_regs[2];
N        oper_reg = channel_n_regs[3];
N    \endcode
N    <br>
N
N    - SL_WLAN_RX_FILTER_STATE:
N    \code
N        int ret = 0;
N        SlWlanRxFilterIdMask_t  FilterIdMask;
N        _u16 len = sizeof(SlWlanRxFilterIdMask_t);;
N        _u16  config_opt = SL_WLAN_RX_FILTER_STATE;
N        memset(FilterIdMask,0,sizeof(FilterIdMask));
N        ret = sl_WlanGet(SL_WLAN_RX_FILTERS_ID, &config_opt , &len, (_u8* )FilterIdMask);
N    \endcode
N    <br>
N
N    - SL_WLAN_RX_FILTER_SYS_STATE:
N    \code
N        int ret = 0;
N        SlWlanRxFilterSysFiltersMask_t  FilterSysIdMask;
N        _u16 len = sizeof(SlWlanRxFilterSysFiltersMask_t);;
N        _u16  config_opt = SL_WLAN_RX_FILTER_SYS_STATE;
N        memset(FilterSysIdMask,0,sizeof(FilterSysIdMask));
N        ret = sl_WlanGet(SL_WLAN_RX_FILTERS_ID, &config_opt , &len, (_u8* )FilterSysIdMask);
N    \endcode
N    <br>
N
N    - SL_WLAN_CONNECTION_INFO:
N    \code
N        _i16 RetVal = 0 ;
N        _u16 Len = sizeof(SlWlanConnStatusParam_t) ;
N        SlWlanConnStatusParam_t WlanConnectInfo ;
N        RetVal = sl_WlanGet(SL_WLAN_CONNECTION_INFO, NULL , &Len, (_u8*)&WlanConnectInfo);
N   \endcode
N    <br>
N
N*/
N
N#if _SL_INCLUDE_FUNC(sl_WlanGet)
X#if (1)
N_i16 sl_WlanGet(const _u16 ConfigId, _u16 *pConfigOpt,_u16 *pConfigLen, _u8 *pValues);
Xsigned short sl_WlanGet(const unsigned short ConfigId, unsigned short *pConfigOpt,unsigned short *pConfigLen, unsigned char *pValues);
N#endif
N
N/*!
N  \brief Adds new filter rule to the system
N
N  \param[in]    RuleType    The rule type
N                                - SL_WLAN_RX_FILTER_HEADER
N                                - SL_WLAN_RX_FILTER_COMBINATION
N  
N  \param[in]    Flags       Flags which set the type of header rule Args and sets the persistent flag
N                                - SL_WLAN_RX_FILTER_BINARY
N                                - SL_WLAN_RX_FILTER_PERSISTENT
N                                - SL_WLAN_RX_FILTER_ENABLE
N  
N  \param[in]    pRule       Determine the filter rule logic
N  \param[in]    pTrigger    Determine when the rule is triggered also sets rule parent.
N  \param[in]    pAction     Sets the action to be executed in case the match functions pass
N  \param[out]   pFilterId   The filterId which was created
N
N  \par          Persistent  Save the filters for persistent can be done by calling  with SL_WLAN_RX_FILTER_STORE
N
N  \return       Zero on success, or negative error code on failure
N  \sa
N  \note
N  \warning
N */
N#if _SL_INCLUDE_FUNC(sl_WlanRxFilterAdd)
X#if (1)
N_i16 sl_WlanRxFilterAdd(    SlWlanRxFilterRuleType_t                RuleType,
Xsigned short sl_WlanRxFilterAdd(    SlWlanRxFilterRuleType_t                RuleType,
N                            SlWlanRxFilterFlags_u                   Flags,
N                            const SlWlanRxFilterRule_u* const       pRule,
N                            const SlWlanRxFilterTrigger_t* const    pTrigger,
N                            const SlWlanRxFilterAction_t* const     pAction,
N                            SlWlanRxFilterID_t*                     pFilterId);
N
N#endif
N
N/*!
N
N Close the Doxygen group.
N @}
N
N */
N
N#ifdef  __cplusplus
S}
N#endif /*  __cplusplus */
N
N#endif    /*  __WLAN_H__ */
N
L 413 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N#include "device.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/device.h" 1
N/*
N * device.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N#include <ti/drivers/net/wifi/simplelink.h>
N
N#ifndef __DEVICE_H__
N#define __DEVICE_H__
N
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*!
N    \defgroup Device 
N    \short Controls the behaviour of the CC31xx/CC32xx device (start/stop, events masking and obtaining specific device status)
N
N*/
N
N/*!
N
N    \addtogroup Device
N    @{
N
N*/
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N/* Convert event id to event mask to be used in sl_DeviceEventMaskSet and sl_DeviceEventMaskGet */     
N#define SL_DEVICE_EVENT_BIT(EventId)        (SL_WLAN_VAL_2_MASK(EventId,1) )     
N
N
N
Ntypedef enum
N{
N    SL_DEVICE_EVENT_FATAL_DEVICE_ABORT = 1,
N    SL_DEVICE_EVENT_FATAL_DRIVER_ABORT,
N    SL_DEVICE_EVENT_FATAL_SYNC_LOSS,
N    SL_DEVICE_EVENT_FATAL_NO_CMD_ACK,
N    SL_DEVICE_EVENT_FATAL_CMD_TIMEOUT,
N    SL_DEVICE_EVENT_RESET_REQUEST,
N    SL_DEVICE_EVENT_ERROR,
N    SL_DEVICE_EVENT_MAX
N
N} SlDeviceEventId_e;
N
Ntypedef struct
N{
N    _i16    Status;
X    signed short    Status;
N    _u16    Caller;
X    unsigned short    Caller;
N}SlDeviceEventResetRequest_t;
N
Ntypedef enum
N{
N    SL_DEVICE_SOURCE_OTHER,
N    SL_DEVICE_SOURCE_WLAN,
N    SL_DEVICE_SOURCE_NETCFG,
N    SL_DEVICE_SOURCE_NETAPP, 
N    SL_DEVICE_SOURCE_SECURITY,
N
N    SL_DEVICE_SOURCE_LAST = 0xFF /* last one */
N}SlDeviceSource_e;
N
Ntypedef struct
N{
N    SlDeviceSource_e    Source;
N    _i16                Code;
X    signed short                Code;
N}SlDeviceEventError_t;
N
Ntypedef union
N{
N    SlDeviceEventResetRequest_t    ResetRequest;
N    SlDeviceEventError_t        Error;
N}SlDeviceEventData_u;
N
N
N
Ntypedef enum
N{
N    SL_DEVICE_RESET_REQUEST_CALLER_PROVISIONING,
N    SL_DEVICE_RESET_REQUEST_CALLER_PROVISIONING_EXTERNAL_CONFIGURATION,
N    SL_DEVICE_RESET_REQUEST_NUM_OF_CALLERS
N}SlDeviceResetRequestCaller_e;
N
Ntypedef struct
N{
N    _u32                Id;
X    unsigned long                Id;
N    SlDeviceEventData_u    Data;
N}SlDeviceEvent_t;
N
N/*!
N    \cond DOXYGEN_REMOVE
N*/
Nvoid slcb_DeviceEvtHdlr(SlDeviceEvent_t* pEvent);
N/*!
N    \endcond
N*/
N
Ntypedef struct
N{
N    _u32                Code;
X    unsigned long                Code;
N    _u32                Value;
X    unsigned long                Value;
N} SlDeviceFatalDeviceAssert_t;
N
N
Ntypedef struct
N{
N    _u32 Code;
X    unsigned long Code;
N} SlDeviceFatalNoCmdAck_t, SlDeviceFatalCmdTimeout_t;
N
N
Ntypedef union
N{    
N    SlDeviceFatalDeviceAssert_t        DeviceAssert;
N    SlDeviceFatalNoCmdAck_t            NoCmdAck;
N    SlDeviceFatalCmdTimeout_t        CmdTimeout;
N}SlDeviceFatalData_u;
N
N
Ntypedef struct
N{
N    _u32                    Id;
X    unsigned long                    Id;
N    SlDeviceFatalData_u        Data;
N}SlDeviceFatal_t;
N
N
N
N/*
N    Declare the different IDs for sl_DeviceGet and sl_DeviceSet
N */  
N#define SL_DEVICE_GENERAL                          (1)
N#define SL_DEVICE_IOT                                (4)
N#define SL_DEVICE_STATUS                          (2)
N
N/*
N    Declare the different Options for SL_DEVICE_GENERAL in sl_DeviceGet and sl_DeviceSet
N */  
N#define SL_DEVICE_GENERAL_DATE_TIME (11)
N#define SL_DEVICE_GENERAL_PERSISTENT (5)
N#define SL_DEVICE_GENERAL_VERSION   (12)
N
N/*
N    Declare the different Options for SL_DEVICE_IOT in sl_DeviceGet and sl_DeviceSet
N*/  
N#define SL_DEVICE_IOT_UDID              (41)
N
N/* Events list to mask/unmask*/
N#define SL_DEVICE_EVENT_CLASS_DEVICE                     (1)
N#define SL_DEVICE_EVENT_CLASS_WLAN                       (2)
N#define SL_DEVICE_EVENT_CLASS_BSD                        (3)
N#define SL_DEVICE_EVENT_CLASS_NETAPP                     (4)
N#define SL_DEVICE_EVENT_CLASS_NETCFG                     (5)
N#define SL_DEVICE_EVENT_CLASS_FS                         (6)
N#define SL_DEVICE_EVENT_CLASS_NETUTIL                     (7)
N
N
N/******************  DEVICE CLASS status ****************/
N#define SL_DEVICE_EVENT_DROPPED_DEVICE_ASYNC_GENERAL_ERROR       (0x00000001L)
N#define SL_DEVICE_STATUS_DEVICE_SMART_CONFIG_ACTIVE              (0x80000000L)
N  
N/******************  WLAN CLASS status ****************/
N#define SL_DEVICE_EVENT_DROPPED_WLAN_WLANASYNCONNECTEDRESPONSE        (0x00000001L)
N#define SL_DEVICE_EVENT_DROPPED_WLAN_WLANASYNCDISCONNECTEDRESPONSE    (0x00000002L)
N#define SL_DEVICE_EVENT_DROPPED_WLAN_STA_CONNECTED                    (0x00000004L)
N#define SL_DEVICE_EVENT_DROPPED_WLAN_STA_DISCONNECTED                 (0x00000008L)
N#define SL_DEVICE_EVENT_DROPPED_WLAN_P2P_DEV_FOUND                    (0x00000010L)
N#define SL_DEVICE_EVENT_DROPPED_WLAN_CONNECTION_FAILED                (0x00000020L)
N#define SL_DEVICE_EVENT_DROPPED_WLAN_P2P_NEG_REQ_RECEIVED             (0x00000040L)
N#define SL_DEVICE_EVENT_DROPPED_WLAN_RX_FILTERS                       (0x00000080L)
N#define SL_DEVICE_STATUS_WLAN_STA_CONNECTED                           (0x80000000L)
N                      
N/******************  NETAPP CLASS status ****************/
N#define SL_DEVICE_EVENT_DROPPED_NETAPP_IPACQUIRED                      (0x00000001L)
N#define SL_DEVICE_EVENT_DROPPED_NETAPP_IPACQUIRED_V6                   (0x00000002L)
N#define SL_DEVICE_EVENT_DROPPED_NETAPP_IP_LEASED                       (0x00000004L)
N#define SL_DEVICE_EVENT_DROPPED_NETAPP_IP_RELEASED                     (0x00000008L)
N#define SL_DEVICE_EVENT_DROPPED_NETAPP_IPV4_LOST                       (0x00000010L)
N#define SL_DEVICE_EVENT_DROPPED_NETAPP_DHCP_ACQUIRE_TIMEOUT               (0x00000020L)
N#define SL_DEVICE_EVENT_DROPPED_NETAPP_IP_COLLISION                    (0x00000040L)
N#define SL_DEVICE_EVENT_DROPPED_NETAPP_IPV6_LOST                       (0x00000080L)
N                      
N/******************  BSD CLASS status ****************/
N#define SL_DEVICE_EVENT_DROPPED_SOCKET_TXFAILEDASYNCRESPONSE        (0x00000001L)
N  
N/******************  FS CLASS  ****************/
N  
N
N
N/*****************************************************************************/
N/* Structure/Enum declarations                                               */
N/*****************************************************************************/
N
N#ifdef SL_IF_TYPE_UART
Stypedef struct  
S{
S    _u32             BaudRate;
S    _u8              FlowControlEnable;
S    _u8              CommPort;
S} SlDeviceUartIfParams_t;
N#endif
N
N#ifdef SL_IF_TYPE_UART
S
S#define SL_DEVICE_BAUD_9600        (9600L)
S#define SL_DEVICE_BAUD_14400    (14400L)
S#define SL_DEVICE_BAUD_19200    (19200L)
S#define SL_DEVICE_BAUD_38400    (38400L)
S#define SL_DEVICE_BAUD_57600    (57600L)
S#define SL_DEVICE_BAUD_115200    (115200L)
S#define SL_DEVICE_BAUD_230400    (230400L)
S#define SL_DEVICE_BAUD_460800    (460800L)
S#define SL_DEVICE_BAUD_921600    (921600L)
S
N#endif
N
Ntypedef struct
N{
N    _u32                ChipId;
X    unsigned long                ChipId;
N    _u8                 FwVersion[4];
X    unsigned char                 FwVersion[4];
N    _u8                 PhyVersion[4];
X    unsigned char                 PhyVersion[4];
N    _u8                 NwpVersion[4];
X    unsigned char                 NwpVersion[4];
N    _u16                RomVersion;
X    unsigned short                RomVersion;
N    _u16                Padding;
X    unsigned short                Padding;
N}SlDeviceVersion_t;
N
N
Ntypedef struct  
N{
N       /* time */
N    _u32                tm_sec;
X    unsigned long                tm_sec;
N    _u32                tm_min;
X    unsigned long                tm_min;
N    _u32                tm_hour;
X    unsigned long                tm_hour;
N       /* date */
N    _u32                tm_day; /* 1-31 */
X    unsigned long                tm_day;  
N    _u32                tm_mon; /* 1-12 */
X    unsigned long                tm_mon;  
N    _u32                tm_year; /*  YYYY 4 digits  */
X    unsigned long                tm_year;  
N    _u32                tm_week_day; /* not required */
X    unsigned long                tm_week_day;  
N    _u32                tm_year_day; /* not required */ 
X    unsigned long                tm_year_day;   
N    _u32                reserved[3];  
X    unsigned long                reserved[3];  
N}SlDateTime_t;
N
N
N/******************************************************************************/
N/* Type declarations                                                          */
N/******************************************************************************/
Ntypedef struct  
N{
N    _u32    ChipId;
X    unsigned long    ChipId;
N    _u32    MoreData;
X    unsigned long    MoreData;
N}SlDeviceInitInfo_t;
N
Ntypedef void (*P_INIT_CALLBACK)(_u32 Status, SlDeviceInitInfo_t *DeviceInitInfo);
Xtypedef void (*P_INIT_CALLBACK)(unsigned long Status, SlDeviceInitInfo_t *DeviceInitInfo);
N
N/*****************************************************************************/
N/* Function prototypes                                                       */
N/*****************************************************************************/
N
N/*!
N    \brief Start the SimpleLink device
N    
N    This function initialize the communication interface, set the enable pin 
N    of the device, and call to the init complete callback.
N
N    \param[in]      pIfHdl              Opened Interface Object. In case the interface 
N                                        must be opened outside the SimpleLink Driver, the
N                                        user might give the handler to be used in \n
N                                        any access of the communication interface with the 
N                                        device (UART/SPI). \n
N                                        The SimpleLink driver will open an interface port
N                                        only if this parameter is null! \n
N    \param[in]      pDevName            The name of the device to open. Could be used when 
N                                        the pIfHdl is null, to transfer information to the 
N                                        open interface function \n
N                                        This pointer could be used to pass additional information to
N                                        sl_IfOpen in case it is required (e.g. UART com port name)
N    \param[in]      pInitCallBack       Pointer to function that would be called
N                                        on completion of the initialization process.\n
N                                        If this parameter is NULL the function is 
N                                        blocked until the device initialization 
N                                        is completed, otherwise the function returns 
N                                        immediately.
N
N    \return         Returns the current active role (STA/AP/P2P) or an error code:
N                    - ROLE_STA, ROLE_AP, ROLE_P2P in case of success, 
N                      otherwise in failure one of the following is return:
N                    - SL_ERROR_ROLE_STA_ERR  (Failure to load MAC/PHY in STA role)
N                    - SL_ERROR_ROLE_AP_ERR  (Failure to load MAC/PHY in AP role)
N                    - SL_ERROR_ROLE_P2P_ERR  (Failure to load MAC/PHY in P2P role)
N                    - SL_ERROR_CALIB_FAIL (Failure of calibration)
N                    - SL_ERROR_FS_CORRUPTED_ERR (FS is corrupted, Return to Factory Image or Program new image should be invoked (see sl_FsCtl, sl_FsProgram))
N                    - SL_ERROR_FS_ALERT_ERR (Device is locked, Return to Factory Image or Program new image should be invoked (see sl_FsCtl, sl_FsProgram))
N                    - SL_ERROR_RESTORE_IMAGE_COMPLETE (Return to factory image completed, perform reset)
N                    - SL_ERROR_GENERAL_ERR (General error during init)
N
N     \sa             sl_Stop
N
N    \note           Belongs to \ref basic_api
N
N    \warning        This function must be called before any other SimpleLink API is used, or after sl_Stop is called for reinit the device
N    \par            Example:
N
N    - Open interface without callback routine. The interface name and handler are
N      handled by the sl_IfOpen routine: 
N    \code            
N        if( sl_Start(NULL, NULL, NULL) < 0 )
N        {
N            LOG("Error opening interface to device\n"); 
N        }
N    \endcode
N    <br>
N
N    - Open interface with a callback routine:
N    \code
N        void SimpleLinkInitCallback(_u32 status)
N        {
N            LOG("Handle SimpleLink Interface acording to ststus %d\n", status);
N        }
N                    
N        void main(void) 
N        {
N            if  (sl_Start(NULL, NULL, SimpleLinkInitCallback) < 0)
N            {
N                LOG("Error opening interface to device\n");
N            }
N        }
N    \endcode
N
N*/
N#if _SL_INCLUDE_FUNC(sl_Start)
X#if (1)
N_i16 sl_Start(const void* pIfHdl, _i8*  pDevName, const P_INIT_CALLBACK pInitCallBack);
Xsigned short sl_Start(const void* pIfHdl, signed char*  pDevName, const P_INIT_CALLBACK pInitCallBack);
N#endif
N
N/*!
N    \brief Stop the SimpleLink device
N
N    This function clears the enable pin of the device, closes the communication \n
N    interface and invokes the stop complete callback 
N
N    \param[in]      Timeout                       Stop timeout in msec. Should be used to give the device time to finish \n 
N                                                  any transmission/reception that is not completed when the function was called. \n
N                    Additional options:
N                    - 0                             Enter to hibernate immediately \n
N                    - 0xFFFF                        Host waits for device's response before \n
N                                                    hibernating, without timeout protection \n      
N                    - 0 < Timeout[msec] < 0xFFFF    Host waits for device's response before \n
N                                                    hibernating, with a defined timeout protection \n
N                                                    This timeout defines the max time to wait. The NWP \n
N                                                    response can be sent earlier than this timeout.
N
N    \return         Zero on success, or a negative value if an error occurred     
N 
N    \sa             sl_Start
N
N    \note           This API will shutdown the device and invoke the "i/f close" function regardless \n
N                    if it was opened implicitly or explicitly. \n
N                    It is up to the platform interface library to properly handle interface close \n
N                    routine \n
N                    Belongs to \ref basic_api \n
N    \warning     
N*/
N#if _SL_INCLUDE_FUNC(sl_Stop)
X#if (1)
N_i16 sl_Stop(const _u16 Timeout);
Xsigned short sl_Stop(const unsigned short Timeout);
N#endif
N
N
N/*!
N    \brief     Setting device configurations
N
N    \param[in] DeviceSetId   configuration id:  
N                                                - SL_DEVICE_GENERAL
N
N    \param[in] Option        configurations option: 
N                                                    - SL_DEVICE_GENERAL_DATE_TIME
N                                                    - SL_DEVICE_GENERAL_PERSISTENT
N    \param[in] ConfigLen     configurations len
N    \param[in] pValues       configurations values
N    
N    \return    Zero on success, or a negative value if an error occurred
N    \par Persistent
N        SL_DEVICE_GENERAL_DATE_TIME - Non-Persistent (Kept during hibernate)
N        SL_DEVICE_GENERAL_PERSISTENT - Persistent
N    \sa         
N    \note 
N    \warning     
N    \par   Examples:
N
N    - Setting device time and date example:
N    \code
N         SlDateTime_t dateTime= {0};
N         dateTime.tm_day =   (_u32)23;          // Day of month (DD format) range 1-31
N         dateTime.tm_mon =   (_u32)6;           // Month (MM format) in the range of 1-12 
N         dateTime.tm_year =  (_u32)2014;        // Year (YYYY format) 
N         dateTime.tm_hour =  (_u32)17;          // Hours in the range of 0-23
N         dateTime.tm_min =   (_u32)55;          // Minutes in the range of 0-59
N         dateTime.tm_sec =   (_u32)22;          // Seconds in the range of  0-59
N         sl_DeviceSet(SL_DEVICE_GENERAL,
N                   SL_DEVICE_GENERAL_DATE_TIME,
N                   sizeof(SlDateTime_t),
N                   (_u8 *)(&dateTime));
N    \endcode
N    <br>
N
N    - Setting system persistent configuration: <br>
N      Sets the default system-wide configuration persistence mode. 
N      In case true, all APIs that follow 'system configured' persistence (see persistence attribute noted per API) shall maintain the configured settings. 
N      In case false, all calls to APIs that follow 'system configured' persistence shall be volatile. Configuration should revert to default after reset or power recycle
N    \code
N        _u8 persistent = 1;
N        sl_DeviceSet(SL_DEVICE_GENERAL,
N                   SL_DEVICE_GENERAL_PERSISTENT,
N                   sizeof(_u8),
N                   (_u8 *)(&persistent));
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_DeviceSet)
X#if (1)
N_i16 sl_DeviceSet(const _u8 DeviceSetId ,const _u8 Option,const _u16 ConfigLen,const _u8 *pValues);
Xsigned short sl_DeviceSet(const unsigned char DeviceSetId ,const unsigned char Option,const unsigned short ConfigLen,const unsigned char *pValues);
N#endif
N
N/*!
N    \brief      Internal function for getting device configurations
N    \param[in]  DeviceGetId   configuration id:
N                                                - SL_DEVICE_STATUS
N                                                - SL_DEVICE_GENERAL
N                                                - SL_DEVICE_IOT
N
N    \param[out] pOption   Get configurations option:
N                                                - SL_DEVICE_STATUS:
N                                                    - SL_DEVICE_EVENT_CLASS_DEVICE
N                                                    - SL_DEVICE_EVENT_CLASS_WLAN  
N                                                    - SL_DEVICE_EVENT_CLASS_BSD   
N                                                    - SL_DEVICE_EVENT_CLASS_NETAPP
N                                                    - SL_DEVICE_EVENT_CLASS_NETCFG
N                                                    - SL_DEVICE_EVENT_CLASS_FS 
N                                                - SL_DEVICE_GENERAL:
N                                                    - SL_DEVICE_GENERAL_VERSION
N                                                    - SL_DEVICE_GENERAL_DATE_TIME  
N                                                    - SL_DEVICE_GENERAL_PERSISTENT   
N                                                - SL_DEVICE_IOT:
N                                                    - SL_DEVICE_IOT_UDID
N                                        
N    \param[out] pConfigLen   The length of the allocated memory as input, when the
N                             function complete, the value of this parameter would be
N                             the len that actually read from the device.\n 
N                             If the device return length that is longer from the input 
N                             value, the function will cut the end of the returned structure
N                             and will return SL_ESMALLBUF
N    \param[out] pValues      Get requested configurations values
N    \return     Zero on success, or a negative value if an error occurred
N    \sa         
N    \note 
N    \warning  
N    \par        Examples
N
N    - Getting WLAN class status (status is always cleared on read):
N    \code
N         _u32 statusWlan;
N         _u8 pConfigOpt;
N         _u16 pConfigLen;
N         pConfigOpt = SL_DEVICE_EVENT_CLASS_WLAN;
N         pConfigLen = sizeof(_u32);
N         sl_DeviceGet(SL_DEVICE_STATUS,&pConfigOpt,&pConfigLen,(_u8 *)(&statusWlan));
N         if (SL_DEVICE_STATUS_WLAN_STA_CONNECTED & statusWlan )
N         {
N            printf("Device is connected\n");
N         }
N         if (SL_DEVICE_EVENT_DROPPED_WLAN_RX_FILTERS & statusWlan )
N         {
N            printf("RX filer event dropped\n");
N         }
N
N     \endcode
N     <br>
N
N    -  Getting version:
N    \code
N        SlDeviceVersion_t ver;
N        pConfigLen = sizeof(ver);
N        pConfigOpt = SL_DEVICE_GENERAL_VERSION;
N        sl_DeviceGet(SL_DEVICE_GENERAL,&pConfigOpt,&pConfigLen,(_u8 *)(&ver));
N        printf("CHIP %d\nMAC 31.%d.%d.%d.%d\nPHY %d.%d.%d.%d\nNWP %d.%d.%d.%d\nROM %d\nHOST %d.%d.%d.%d\n",
N                         ver.ChipId,
N                         ver.FwVersion[0],ver.FwVersion[1],
N                         ver.FwVersion[2],ver.FwVersion[3],
N                         ver.PhyVersion[0],ver.PhyVersion[1],
N                         ver.PhyVersion[2],ver.PhyVersion[3],
N                         ver.NwpVersion[0],ver.NwpVersion[1],ver.NwpVersion[2],ver.NwpVersion[3],
N                         ver.RomVersion,
N                         SL_MAJOR_VERSION_NUM,SL_MINOR_VERSION_NUM,SL_VERSION_NUM,SL_SUB_VERSION_NUM);
N
N    \endcode
N    <br>
N
N    - Getting Device time and date:
N    \code
N         SlDateTime_t dateTime =  {0};  
N         _i16 configLen = sizeof(SlDateTime_t); 
N         _i8 configOpt = SL_DEVICE_GENERAL_DATE_TIME;
N         sl_DeviceGet(SL_DEVICE_GENERAL,&configOpt, &configLen,(_u8 *)(&dateTime)); 
N         
N         printf("Day %d,Mon %d,Year %d,Hour %,Min %d,Sec %d\n",dateTime.tm_day,dateTime.tm_mon,dateTime.tm_year,
N                 dateTime.tm_hour,dateTime.tm_min,dateTime.tm_sec);
N     \endcode
N
N    - Getting persistency system configuration:
N    \code
N        _i16 configLen = sizeof(_u8); 
N        _i8 configOpt = SL_DEVICE_GENERAL_PERSISTENT;
N        sl_DeviceGet(SL_DEVICE_GENERAL,&configOpt, &configLen,&persistent); 
N    \endcode
N
N*/
N#if _SL_INCLUDE_FUNC(sl_DeviceGet)
X#if (1)
N_i16 sl_DeviceGet(const _u8 DeviceGetId, _u8 *pOption,_u16 *pConfigLen, _u8 *pValues);
Xsigned short sl_DeviceGet(const unsigned char DeviceGetId, unsigned char *pOption,unsigned short *pConfigLen, unsigned char *pValues);
N#endif
N
N
N/*!
N    \brief          Set asynchronous event mask
N    
N    Mask asynchronous events from the device.\n 
N    Masked events do not generate asynchronous messages from the device.\n
N    By default - all events are active
N
N
N
N    \param[in]      EventClass          The classification groups that the 
N                                        mask is referred to. Need to be one of
N                                        the following:
N                                        - SL_DEVICE_EVENT_CLASS_DEVICE
N                                        - SL_DEVICE_EVENT_CLASS_WLAN  
N                                        - SL_DEVICE_EVENT_CLASS_BSD   
N                                        - SL_DEVICE_EVENT_CLASS_NETAPP
N                                        - SL_DEVICE_EVENT_CLASS_NETCFG
N                                        - SL_DEVICE_EVENT_CLASS_FS 
N
N
N    \param[in]      Mask               Event Mask bitmap. Valid mask are (per group):
N                                        - SL_DEVICE_EVENT_CLASS_WLAN user events
N                                          - SL_WLAN_EVENT_CONNECT    
N                                          - SL_WLAN_EVENT_P2P_CONNECT
N                                          - SL_WLAN_EVENT_DISCONNECT
N                                          - SL_WLAN_EVENT_P2P_DISCONNECT
N                                          - SL_WLAN_EVENT_STA_ADDED
N                                          - SL_WLAN_EVENT_STA_REMOVED
N                                          - SL_WLAN_EVENT_P2P_CLIENT_ADDED
N                                          - SL_WLAN_EVENT_P2P_CLIENT_REMOVED
N                                          - SL_WLAN_EVENT_P2P_DEVFOUND
N                                          - SL_WLAN_EVENT_P2P_REQUEST
N                                          - SL_WLAN_EVENT_P2P_CONNECTFAIL
N                                          - SL_WLAN_EVENT_PROVISIONING_STATUS
N                                          - SL_WLAN_EVENT_PROVISIONING_PROFILE_ADDED
N                                          - SL_WLAN_EVENT_RXFILTER
N
N                                        - SL_DEVICE_EVENT_CLASS_DEVICE user events
N                                          - SL_DEVICE_EVENT_ERROR
N
N                                        - SL_DEVICE_EVENT_CLASS_BSD user events
N                                          - SL_SOCKET_TX_FAILED_EVENT     
N                                          - SL_SOCKET_ASYNC_EVENT 
N
N                                        - SL_DEVICE_EVENT_CLASS_NETAPP user events
N                                          - SL_NETAPP_EVENT_IPV4_ACQUIRED 
N                                          - SL_NETAPP_EVENT_IPV6_ACQUIRED
N                                          - SL_NETAPP_EVENT_DHCPV4_LEASED
N                                          - SL_NETAPP_EVENT_DHCPV4_RELEASED
N                                          - SL_NETAPP_EVENT_IP_COLLISION
N                                          - SL_NETAPP_EVENT_IPV4_LOST
N                                          - SL_NETAPP_EVENT_DHCP_IPV4_ACQUIRE_TIMEOUT
N                                          - SL_NETAPP_EVENT_IPV6_LOST
N
N     
N    \return          Zero on success, or a negative value if an error occurred        
N    \par Persistent  System Persistent
N    \sa              sl_DeviceEventMaskGet
N
N    \note            Belongs to \ref ext_api \n
N    \warning     
N    \par             Example
N
N    - Masking connection/disconnection async events from WLAN class: 
N    \code
N        sl_DeviceEventMaskSet(SL_DEVICE_EVENT_CLASS_WLAN, (SL_DEVICE_EVENT_BIT(SL_WLAN_EVENT_CONNECT) | SL_DEVICE_EVENT_BIT(SL_WLAN_EVENT_DISCONNECT) ) );
N    \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_DeviceEventMaskSet)
X#if (1)
N_i16 sl_DeviceEventMaskSet(const _u8 EventClass ,const _u32 Mask);
Xsigned short sl_DeviceEventMaskSet(const unsigned char EventClass ,const unsigned long Mask);
N#endif
N
N/*!
N    \brief Get current event mask of the device
N    
N    Return the events bit mask from the device. In case event is 
N    masked, the device will not send that event.  
N    
N    \param[in]      EventClass          The classification groups that the 
N                                        mask is referred to. Need to be one of
N                                        the following:
N                                        - SL_DEVICE_EVENT_CLASS_GLOBAL
N                                        - SL_DEVICE_EVENT_CLASS_DEVICE
N                                        - SL_DEVICE_EVENT_CLASS_WLAN  
N                                        - SL_DEVICE_EVENT_CLASS_BSD   
N                                        - SL_DEVICE_EVENT_CLASS_NETAPP
N                                        - SL_DEVICE_EVENT_CLASS_NETCFG
N                                        - SL_DEVICE_EVENT_CLASS_FS 
N
N    \param[out]      pMask              Pointer to mask bitmap where the 
N                                        value should be stored. Bitmasks are the same as in \ref sl_DeviceEventMaskSet
N     
N    \return         Zero on success, or a negative value if an error occurred       
N     
N    \sa             sl_DeviceEventMaskSet         
N
N    \note           Belongs to \ref ext_api
N
N    \warning     
N    \par           Example
N
N    - Getting an event mask for WLAN class:
N    \code
N        _u32 maskWlan;
N        sl_DeviceEventMaskGet(SL_DEVICE_EVENT_CLASS_WLAN,&maskWlan);
N   \endcode
N*/
N#if _SL_INCLUDE_FUNC(sl_DeviceEventMaskGet)
X#if (1)
N_i16 sl_DeviceEventMaskGet(const _u8 EventClass,_u32 *pMask);
Xsigned short sl_DeviceEventMaskGet(const unsigned char EventClass,unsigned long *pMask);
N#endif
N
N
N/*!
N    \brief The SimpleLink task entry
N
N    This function must be called from the main loop or from dedicated thread in
N    the following cases:
N        - Non-Os Platform - should be called from the mail loop
N        - Multi Threaded Platform when the user does not implement the external spawn functions - 
N           should be called from dedicated thread allocated to the SimpleLink driver.
N           In this mode the function never return.
N
N    \par parameters            
N            None 
N    
N    \return         None
N    \sa
N    \note           Belongs to \ref basic_api
N
N    \warning        This function must be called from a thread that is start running before 
N                    any call to other SimpleLink API
N*/
N#if _SL_INCLUDE_FUNC(sl_Task)
X#if (1)
Nvoid* sl_Task(void* pEntry);
N#endif
N
N
N
N
N/*!
N    \brief Setting the internal uart mode 
N
N    \param[in]      pUartParams          Pointer to the uart configuration parameter set: 
N                                         - baudrate     - up to 711 Kbps
N                                         - flow control - enable/disable 
N                                         - comm port    - the comm port number
N    
N    \return         On success zero is returned, otherwise - Failed.   
N    \sa
N    \note           Belongs to \ref basic_api
N
N    \warning        This function must consider the host uart capability
N*/
N#ifdef SL_IF_TYPE_UART
S#if _SL_INCLUDE_FUNC(sl_DeviceUartSetMode)
S_i16 sl_DeviceUartSetMode(const SlDeviceUartIfParams_t* pUartParams);
S#endif
N#endif
N
N/*!
N
N Close the Doxygen group.
N @}
N
N */
N
N
N#ifdef  __cplusplus
S}
N#endif /*  __cplusplus */
N
N#endif  /*  __DEVICE_H__ */
N
N
L 414 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N#include "netcfg.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/netcfg.h" 1
N/*
N * netcfg.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N#include <ti/drivers/net/wifi/simplelink.h>
N
N    
N#ifndef __NETCFG_H__
N#define __NETCFG_H__
N
N
N#ifdef    __cplusplus
Sextern "C" {
N#endif
N
N/*!
N    \defgroup NetCfg 
N    \short Controls the configuration of the device addresses (i.e. IP and MAC addresses)
N
N*/
N
N/*!
N
N    \addtogroup NetCfg
N    @{
N
N*/
N
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N
N#define SL_MAC_ADDR_LEN                              (6)
N#define SL_IPV6_ADDR_LEN                             (16)
N#define SL_IPV4_VAL(add_3,add_2,add_1,add_0)         ((((_u32)add_3 << 24) & 0xFF000000) | (((_u32)add_2 << 16) & 0xFF0000) | (((_u32)add_1 << 8) & 0xFF00) | ((_u32)add_0 & 0xFF) )
N#define SL_IPV4_BYTE(val,index)                      ( (val >> (index*8)) & 0xFF )
N
N
N#define SL_NETCFG_IF_IPV6_STA_LOCAL                  (0x4)    /* disable ipv6 local */
N#define SL_NETCFG_IF_IPV6_STA_GLOBAL                 (0x8)    /* disable ipv6 global */
N#define SL_NETCFG_IF_DISABLE_IPV4_DHCP               (0x40)   /* disable ipv4 dhcp */
N#define SL_NETCFG_IF_IPV6_LOCAL_STATIC               (0x80)   /* enable ipv6 local static */
N#define SL_NETCFG_IF_IPV6_LOCAL_STATELESS            (0x100)  /* enable ipv6 local stateless */
N#define SL_NETCFG_IF_IPV6_LOCAL_STATEFUL             (0x200)  /* enable ipv6 local statefull */
N#define SL_NETCFG_IF_IPV6_GLOBAL_STATIC              (0x400)  /* enable ipv6 global static */
N#define SL_NETCFG_IF_IPV6_GLOBAL_STATEFUL            (0x800)  /* enable ipv6 global statefull */
N#define SL_NETCFG_IF_DISABLE_IPV4_LLA                (0x1000) /* disable LLA feature. Relevant only in IPV4 */
N#define SL_NETCFG_IF_ENABLE_DHCP_RELEASE             (0x2000) /* Enables DHCP release when WLAN disconnect command is issued */
N#define SL_NETCFG_IF_IPV6_GLOBAL_STATELESS           (0x4000) /* enable ipv6 global stateless */
N#define SL_NETCFG_IF_DISABLE_FAST_RENEW              (0x8000) /* fast renew disabled */
N
N
N#define    SL_NETCFG_IF_STATE                        (0)
N#define SL_NETCFG_ADDR_DHCP                          (1)
N#define SL_NETCFG_ADDR_DHCP_LLA                      (2)
N#define SL_NETCFG_ADDR_RELEASE_IP                    (3)
N#define SL_NETCFG_ADDR_STATIC                        (4)
N#define SL_NETCFG_ADDR_STATELESS                     (5)
N#define SL_NETCFG_ADDR_STATEFUL                      (6)
N#define SL_NETCFG_ADDR_RELEASE_IP_SET                (7)
N#define SL_NETCFG_ADDR_RELEASE_IP_OFF                (8)
N#define SL_NETCFG_ADDR_ENABLE_FAST_RENEW             (9)
N#define SL_NETCFG_ADDR_DISABLE_FAST_RENEW            (10)
N#define SL_NETCFG_ADDR_FAST_RENEW_MODE_NO_WAIT_ACK   (11)
N#define SL_NETCFG_ADDR_FAST_RENEW_MODE_WAIT_ACK      (12)
N
N
N/*****************************************************************************/
N/* Structure/Enum declarations                                               */
N/*****************************************************************************/
Ntypedef enum
N{
N    SL_NETCFG_MAC_ADDRESS_SET                   = 1,
N    SL_NETCFG_MAC_ADDRESS_GET                   = 2,
N    SL_NETCFG_AP_STATIONS_NUM_CONNECTED         = 3,
N    SL_NETCFG_AP_STATIONS_INFO_LIST             = 4,
N    SL_NETCFG_AP_STATION_DISCONNECT             = 5,
N    SL_NETCFG_IF                                = 6,
N    SL_NETCFG_IPV4_STA_ADDR_MODE                = 7,
N    SL_NETCFG_IPV4_AP_ADDR_MODE                 = 8,
N    SL_NETCFG_IPV6_ADDR_LOCAL                   = 9,
N    SL_NETCFG_IPV6_ADDR_GLOBAL                  = 10,
N    SL_NETCFG_IPV4_DHCP_CLIENT                  = 11,
N    SL_NETCFG_IPV4_DNS_CLIENT                   = 12,
N    MAX_SETTINGS = 0xFF
N}SlNetCfg_e;
N
Ntypedef struct
N{    
N    _u32 DnsSecondServerAddr;
X    unsigned long DnsSecondServerAddr;
N}SlNetCfgIpV4DnsClientArgs_t;
N
N
Ntypedef struct
N{    
N    _u32  Ip;
X    unsigned long  Ip;
N    _u32  Gateway;
X    unsigned long  Gateway;
N    _u32  Mask;
X    unsigned long  Mask;
N    _u32  Dns[2];
X    unsigned long  Dns[2];
N    _u32  DhcpServer;
X    unsigned long  DhcpServer;
N    _u32  LeaseTime;
X    unsigned long  LeaseTime;
N    _u32  TimeToRenew;
X    unsigned long  TimeToRenew;
N    _u8   DhcpState;
X    unsigned char   DhcpState;
N    _u8   Reserved[3];
X    unsigned char   Reserved[3];
N} SlNetCfgIpv4DhcpClient_t;
N
Ntypedef enum
N{
N    SL_NETCFG_DHCP_CLIENT_UNKNOWN = 0,
N    SL_NETCFG_DHCP_CLIENT_DISABLED,
N    SL_NETCFG_DHCP_CLIENT_ENABLED,
N    SL_NETCFG_DHCP_CLIENT_BOUND,
N    SL_NETCFG_DHCP_CLIENT_RENEW,
N    SL_NETCFG_DHCP_CLIENT_REBIND
N}SlNetCfgIpv4DhcpClientState_e;
N
N
Ntypedef enum
N{
N    SL_NETCFG_DHCP_OPT_DISABLE_LLA = 0x2,                   /* 1=LLA disabled, 0=LLA enabled. */
N    SL_NETCFG_DHCP_OPT_RELEASE_IP_BEFORE_DISCONNECT = 0x4,  /* 1=DHCP release enabled, 0=DHCP release disabled */
N    MAX_SL_NETCFG_DHCP_OPT = 0xFF
N} SlNetCfgDhcpOption_e;
N
Ntypedef struct
N{
N    _u32  Ip;
X    unsigned long  Ip;
N    _u32  IpMask;
X    unsigned long  IpMask;
N    _u32  IpGateway;
X    unsigned long  IpGateway;
N    _u32  IpDnsServer;
X    unsigned long  IpDnsServer;
N}SlNetCfgIpV4Args_t;
N
Ntypedef struct
N{
N    _u32  Ip[4];
X    unsigned long  Ip[4];
N    _u32  IpDnsServer[4];
X    unsigned long  IpDnsServer[4];
N    _u32  IpV6Flags; /* bit 0: Indicate if the address is valid for use in the network (IPv6 DAD completed) . If not, try again later or set a different address. 1=Valid. Relevant for sl_NetCfgGet only. */
X    unsigned long  IpV6Flags;  
N}SlNetCfgIpV6Args_t;
N
N#define _SL_NETCFG_IPV6_ADDR_BIT_STATUS     0x01 
N#define SL_IS_IPV6_ADDR_VALID(IpV6Flags)    (IpV6Flags & _SL_NETCFG_IPV6_ADDR_BIT_STATUS) 
N
N#define NET_CFG_STA_INFO_STATUS_DHCP_ADDR   1
N
Ntypedef struct
N{
N    _u32 Ip;
X    unsigned long Ip;
N    _u8  MacAddr[6];
X    unsigned char  MacAddr[6];
N    _u16 Status;
X    unsigned short Status;
N    _u8  Name[32]; 
X    unsigned char  Name[32]; 
N} SlNetCfgStaInfo_t;
N
N/*****************************************************************************/
N/* Function prototypes                                                       */
N/*****************************************************************************/
N
N/*!
N    \brief     Setting network configurations
N
N    \param[in] ConfigId   Configuration id: 
N                                            - SL_NETCFG_IF
N                                            - SL_NETCFG_IPV4_STA_ADDR_MODE
N                                            - SL_NETCFG_IPV6_ADDR_LOCAL
N                                            - SL_NETCFG_IPV6_ADDR_GLOBAL
N                                            - SL_NETCFG_IPV4_AP_ADDR_MODE
N                                            - SL_NETCFG_MAC_ADDRESS_SET
N                                            - SL_NETCFG_AP_STATION_DISCONNECT
N    \param[in] ConfigOpt  Configurations option: 
N                                            - SL_NETCFG_IF_STATE            
N                                            - SL_NETCFG_ADDR_DHCP           
N                                            - SL_NETCFG_ADDR_DHCP_LLA       
N                                            - SL_NETCFG_ADDR_RELEASE_IP     
N                                            - SL_NETCFG_ADDR_STATIC          
N                                            - SL_NETCFG_ADDR_STATELESS      
N                                            - SL_NETCFG_ADDR_STATEFUL       
N                                            - SL_NETCFG_ADDR_RELEASE_IP_SET 
N                                            - SL_NETCFG_ADDR_RELEASE_IP_OFF 
N    \param[in] ConfigLen  Configurations len
N    \param[in] pValues    Configurations values
N    \par                  Persistent                 
N    \par 
N                          <b>Reset</b>:                
N                                            - SL_IPV4_AP_P2P_GO_STATIC_ENABLE
N                                            - SL_NETCFG_MAC_ADDRESS_SET
N    \par
N                          <b>Non- Persistent</b>:                 
N                                            - SL_NETCFG_AP_STATION_DISCONNECT
N    \par
N                          <b>System Persistent</b>: 
N                                            - SL_NETCFG_IPV4_STA_ADDR_MODE
N                                            - SL_NETCFG_IF_STATE
N                                            - SL_NETCFG_IPV6_ADDR_LOCAL
N                                            - SL_NETCFG_IPV6_ADDR_GLOBAL
N
N    \return    Non-negative value on success, or -1 for failure
N    \sa        sl_NetCfgGet
N    \note
N    \warning
N
N    \par      Examples
N
N    - SL_NETCFG_MAC_ADDRESS_SET: <br>
N      Setting MAC address to the Device.
N      The new MAC address will override the default MAC address and it be saved in the FileSystem.
N      Requires restarting the device for updating this setting.
N    \code
N        _u8 MAC_Address[6];
N        MAC_Address[0] = 0x8;
N        MAC_Address[1] = 0x0;
N        MAC_Address[2] = 0x28;
N        MAC_Address[3] = 0x22;
N        MAC_Address[4] = 0x69;
N        MAC_Address[5] = 0x31;
N        sl_NetCfgSet(SL_NETCFG_MAC_ADDRESS_SET,1,SL_MAC_ADDR_LEN,(_u8 *)MAC_Address);
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - <b>SL_NETCFG_IPV4_STA_ADDR_MODE</b><br>:
N    
N    - SL_NETCFG_ADDR_STATIC: <br>
N    Setting a static IP address to the device working in STA mode or P2P client.
N    The IP address will be stored in the FileSystem.
N    \code 
N        SlNetCfgIpV4Args_t ipV4;
N        ipV4.Ip          = (_u32)SL_IPV4_VAL(10,1,1,201);            // _u32 IP address 
N        ipV4.IpMask      = (_u32)SL_IPV4_VAL(255,255,255,0);         // _u32 Subnet mask for this STA/P2P
N        ipV4.IpGateway   = (_u32)SL_IPV4_VAL(10,1,1,1);              // _u32 Default gateway address
N        ipV4.IpDnsServer = (_u32)SL_IPV4_VAL(8,16,32,64);            // _u32 DNS server address
N
N        sl_NetCfgSet(SL_NETCFG_IPV4_STA_ADDR_MODE,SL_NETCFG_ADDR_STATIC,sizeof(SlNetCfgIpV4Args_t),(_u8 *)&ipV4); 
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - SL_NETCFG_ADDR_DHCP:<br>
N    Setting IP address by DHCP to FileSystem using WLAN sta mode or P2P client.
N    This should be done once if using Serial Flash.
N    This is the system's default mode for acquiring an IP address after WLAN connection.
N    \code 
N        sl_NetCfgSet(SL_NETCFG_IPV4_STA_ADDR_MODE,SL_NETCFG_ADDR_DHCP,0,0);
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - SL_NETCFG_ADDR_DHCP_LLA: <br>
N    Setting DHCP LLA will runs LLA mechanism in case DHCP fails to acquire an address
N    SL_NETCFG_DHCP_OPT_RELEASE_IP_BEFORE_DISCONNECT - If set, enables sending a DHCP release frame to the server if user issues a WLAN disconnect command.
N    \code 
N        sl_NetCfgSet(SL_NETCFG_IPV4_STA_ADDR_MODE,SL_NETCFG_ADDR_DHCP_LLA,0,0);
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - SL_NETCFG_ADDR_RELEASE_IP_SET: <br>
N    Setting release ip before disconnect enables sending a DHCP release frame to the server if user issues a WLAN disconnect command.
N    \code
N        sl_NetCfgSet(SL_NETCFG_IPV4_STA_ADDR_MODE,SL_NETCFG_ADDR_RELEASE_IP_SET,0,0); 
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - SL_NETCFG_ADDR_RELEASE_IP_OFF:<br>
N    Setting release ip before disconnect disables sending a DHCP release frame to the server if user issues a WLAN disconnect command.
N    \code 
N        sl_NetCfgSet(SL_NETCFG_IPV4_STA_ADDR_MODE,SL_NETCFG_ADDR_RELEASE_IP_OFF,0,0); 
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - SL_NETCFG_IPV4_AP_ADDR_MODE:<br>
N    Setting a static IP address to the device working in AP mode or P2P go.
N    The IP address will be stored in the FileSystem. Requires restart.
N    \code                                                             
N        SlNetCfgIpV4Args_t ipV4;
N        ipV4.Ip          = (_u32)SL_IPV4_VAL(10,1,1,201);            // _u32 IP address 
N        ipV4.IpMask      = (_u32)SL_IPV4_VAL(255,255,255,0);         // _u32 Subnet mask for this AP/P2P
N        ipV4.IpGateway   = (_u32)SL_IPV4_VAL(10,1,1,1);              // _u32 Default gateway address
N        ipV4.IpDnsServer = (_u32)SL_IPV4_VAL(8,16,32,64);            // _u32 DNS server address
N
N        sl_NetCfgSet(SL_NETCFG_IPV4_AP_ADDR_MODE,SL_NETCFG_ADDR_STATIC,sizeof(SlNetCfgIpV4Args_t),(_u8 *)&ipV4);
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - SL_NETCFG_IF:<br>
N    Enable\Disable IPV6 interface - Local or/and Global address (Global could not be enabled without Local)
N    \code
N        _u32 IfBitmap = 0;
N
N        IfBitmap = SL_NETCFG_IF_IPV6_STA_LOCAL | SL_NETCFG_IF_IPV6_STA_GLOBAL;
N        sl_NetCfgSet(SL_NETCFG_IF,SL_NETCFG_IF_STATE,sizeof(IfBitmap),&IfBitmap);
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - SL_NETCFG_IPV6_ADDR_LOCAL: <br>
N    Setting a IPv6 Local static address to the device working in STA mode.
N    The IP address will be stored in the FileSystem. Requires restart.
N    \code       
N          SlNetCfgIpV6Args_t ipV6;
N        _u32 IfBitmap = 0;
N
N        IfBitmap = SL_NETCFG_IF_IPV6_STA_LOCAL;
N        sl_NetCfgSet(SL_NETCFG_IF,SL_NETCFG_IF_STATE,sizeof(IfBitmap),&IfBitmap);
N
N        ipV6.Ip[0] = 0xfe800000;
N        ipV6.Ip[1] = 0x00000000;
N        ipV6.Ip[2] = 0x00004040;
N        ipV6.Ip[3] = 0x0000ce65;
N
N        sl_NetCfgSet(SL_NETCFG_IPV6_ADDR_LOCAL,SL_NETCFG_ADDR_STATIC,sizeof(SlNetCfgIpV6Args_t),(_u8 *)&ipV6);
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - SL_NETCFG_IPV6_ADDR_LOCAL: <br>
N    Setting a IPv6 Local stateless address to the device working in STA mode.
N    The IP address will be stored in the FileSystem. Requires restart.
N    \code       
N        _u32 IfBitmap = 0;
N        IfBitmap = SL_NETCFG_IF_IPV6_STA_LOCAL;
N        sl_NetCfgSet(SL_NETCFG_IF,SL_NETCFG_IF_STATE,sizeof(IfBitmap),&IfBitmap);
N        sl_NetCfgSet(SL_NETCFG_IPV6_ADDR_LOCAL,SL_NETCFG_ADDR_STATELESS,0,0);
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - SL_NETCFG_IPV6_ADDR_LOCAL: <br>
N    Setting a IPv6 Local statefull address to the device working in STA mode.
N    The IP address will be stored in the FileSystem. Requires restart.
N    \code
N        _u32 IfBitmap = 0;
N
N        IfBitmap = SL_NETCFG_IF_IPV6_STA_LOCAL;
N        sl_NetCfgSet(SL_NETCFG_IF,SL_NETCFG_IF_STATE,sizeof(IfBitmap),&IfBitmap);
N        sl_NetCfgSet(SL_NETCFG_IPV6_ADDR_LOCAL,SL_NETCFG_ADDR_STATEFUL,0,0);
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - SL_NETCFG_IPV6_ADDR_GLOBAL:<br>
N    Setting a IPv6 Global static address to the device working in STA mode.
N    The IP address will be stored in the FileSystem. Requires restart.
N    \code       
N        SlNetCfgIpV6Args_t ipV6;
N        _u32 IfBitmap = 0;
N
N        ipV6.Ip[0] = 0xfe80;
N        ipV6.Ip[1] = 0x03a;
N        ipV6.Ip[2] = 0x4040;
N        ipV6.Ip[3] = 0xce65;
N
N        ipV6.IpDnsServer[0] = 0xa780;
N        ipV6.IpDnsServer[1] = 0x65e;
N        ipV6.IpDnsServer[2] = 0x8;
N        ipV6.IpDnsServer[3] = 0xce00;
N
N        IfBitmap = SL_NETCFG_IF_IPV6_STA_GLOBAL;
N        sl_NetCfgSet(SL_NETCFG_IF,SL_NETCFG_IF_STATE,sizeof(IfBitmap),&IfBitmap);
N        sl_NetCfgSet(SL_NETCFG_IPV6_ADDR_GLOBAL,SL_NETCFG_ADDR_STATIC,sizeof(SlNetCfgIpV6Args_t),(_u8 *)&ipV6);
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - SL_NETCFG_IPV6_ADDR_GLOBAL:<br>
N    Setting a IPv6 Global statefull address to the device working in STA mode.
N    The IP address will be stored in the FileSystem. Requires restart.
N    \code
N        _u32 IfBitmap = 0;
N        IfBitmap = SL_NETCFG_IF_IPV6_STA_GLOBAL;
N        sl_NetCfgSet(SL_NETCFG_IF,SL_NETCFG_IF_STATE,sizeof(IfBitmap),&IfBitmap);
N        sl_NetCfgSet(SL_NETCFG_IPV6_ADDR_GLOBAL,SL_NETCFG_ADDR_STATEFUL,0,0);
N        sl_Stop(0);
N        sl_Start(NULL,NULL,NULL);
N    \endcode
N    <br>
N
N    - SL_NETCFG_AP_STATION_DISCONNECT:<br>
N    Disconnet AP station by mac address.
N    The AP connected stations list can be read by sl_NetCfgGet with options: SL_AP_STATIONS_NUM_CONNECTED, SL_AP_STATIONS_INFO_LIST
N    \code
N        _u8  ap_sta_mac[6] = { 0x00, 0x22, 0x33, 0x44, 0x55, 0x66 };     
N        sl_NetCfgSet(SL_NETCFG_AP_STATION_DISCONNECT,1,SL_MAC_ADDR_LEN,(_u8 *)ap_sta_mac);
N    \endcode 
N    <br>
N
N    - SL_NETCFG_IPV4_DNS_CLIENT:<br>
N    Set secondary DNS address (DHCP and static configuration) not persistent
N    \code                                                                        
N        _i32 Status;
N        SlNetCfgIpV4DnsClientArgs_t DnsOpt;
N        DnsOpt.DnsSecondServerAddr  =  SL_IPV4_VAL(8,8,8,8); ;
N        Status = sl_NetCfgSet(SL_NETCFG_IPV4_DNS_CLIENT,0,sizeof(SlNetCfgIpV4DnsClientArgs_t),(unsigned char *)&DnsOpt);
N        if( Status )
N        {
N            // error
N        }
N    \endcode
N
N*/
N#if _SL_INCLUDE_FUNC(sl_NetCfgSet)
X#if (1)
N_i16 sl_NetCfgSet(const _u16 ConfigId,const _u16 ConfigOpt,const _u16 ConfigLen,const _u8 *pValues);
Xsigned short sl_NetCfgSet(const unsigned short ConfigId,const unsigned short ConfigOpt,const unsigned short ConfigLen,const unsigned char *pValues);
N#endif
N
N
N/*!
N    \brief      Getting network configurations
N   
N    \param[in]  ConfigId      Configuration id
N
N    \param[out] pConfigOpt    Get configurations option 
N
N    \param[out] pConfigLen    The length of the allocated memory as input, when the
N                              function complete, the value of this parameter would be
N                              the len that actually read from the device.\n 
N                              If the device return length that is longer from the input 
N                              value, the function will cut the end of the returned structure
N                              and will return ESMALLBUF
N
N    \param[out] pValues - get configurations values
N    \return     Zero on success, or -1 on failure
N    \sa         sl_NetCfgSet
N    \note
N    \warning
N    \par        Examples
N
N    - SL_NETCFG_MAC_ADDRESS_GET: <br>
N     Get the device MAC address.
N     The returned MAC address is taken from FileSystem first. If the MAC address was not set by SL_MAC_ADDRESS_SET, the default MAC address
N     is retrieved from HW.
N    \code
N        _u8 macAddressVal[SL_MAC_ADDR_LEN];
N        _u16 macAddressLen = SL_MAC_ADDR_LEN;
N        _u16 ConfigOpt = 0;
N        sl_NetCfgGet(SL_NETCFG_MAC_ADDRESS_GET,&ConfigOpt,&macAddressLen,(_u8 *)macAddressVal);
N    \endcode
N    <br>
N
N    - SL_NETCFG_IPV4_STA_ADDR_MODE: <br>
N      Get IP address from WLAN station or P2P client. A DHCP flag is returned to indicate if the IP address is static or from DHCP. 
N    \code
N        _u16 len = sizeof(SlNetCfgIpV4Args_t);
N        _u16 ConfigOpt = 0;   //return value could be one of the following: SL_NETCFG_ADDR_DHCP / SL_NETCFG_ADDR_DHCP_LLA / SL_NETCFG_ADDR_STATIC
N        SlNetCfgIpV4Args_t ipV4 = {0};
N        sl_NetCfgGet(SL_NETCFG_IPV4_STA_ADDR_MODE,&ConfigOpt,&len,(_u8 *)&ipV4);
N
N        printf("DHCP is %s IP %d.%d.%d.%d MASK %d.%d.%d.%d GW %d.%d.%d.%d DNS %d.%d.%d.%d\n",
N            (ConfigOpt == SL_NETCFG_ADDR_DHCP) ? "ON" : "OFF",
N            SL_IPV4_BYTE(ipV4.Ip,3),SL_IPV4_BYTE(ipV4.Ip,2),SL_IPV4_BYTE(ipV4.Ip,1),SL_IPV4_BYTE(ipV4.Ip,0),
N            SL_IPV4_BYTE(ipV4.IpMask,3),SL_IPV4_BYTE(ipV4.IpMask,2),SL_IPV4_BYTE(ipV4.IpMask,1),SL_IPV4_BYTE(ipV4.IpMask,0),
N            SL_IPV4_BYTE(ipV4.IpGateway,3),SL_IPV4_BYTE(ipV4.IpGateway,2),SL_IPV4_BYTE(ipV4.IpGateway,1),SL_IPV4_BYTE(ipV4.IpGateway,0),
N            SL_IPV4_BYTE(ipV4.IpDnsServer,3),SL_IPV4_BYTE(ipV4.IpDnsServer,2),SL_IPV4_BYTE(ipV4.IpDnsServer,1),SL_IPV4_BYTE(ipV4.IpDnsServer,0));
N    \endcode
N    <br>
N
N    - SL_NETCFG_IPV4_AP_ADDR_MODE: <br>
N      Get static IP address for AP or P2P go.
N    \code
N        _u16 len = sizeof(SlNetCfgIpV4Args_t);
N        _u16 ConfigOpt = 0;  //return value could be one of the following: SL_NETCFG_ADDR_DHCP / SL_NETCFG_ADDR_DHCP_LLA / SL_NETCFG_ADDR_STATIC
N        SlNetCfgIpV4Args_t ipV4 = {0};
N        sl_NetCfgGet(SL_NETCFG_IPV4_AP_ADDR_MODE,&ConfigOpt,&len,(_u8 *)&ipV4);
N
N        printf("DHCP is %s IP %d.%d.%d.%d MASK %d.%d.%d.%d GW %d.%d.%d.%d DNS %d.%d.%d.%d\n",
N            (ConfigOpt == SL_NETCFG_ADDR_DHCP) ? "ON" : "OFF",                                                           
N            SL_IPV4_BYTE(ipV4.Ip,3),SL_IPV4_BYTE(ipV4.Ip,2),SL_IPV4_BYTE(ipV4.Ip,1),SL_IPV4_BYTE(ipV4.Ip,0), 
N            SL_IPV4_BYTE(ipV4.IpMask,3),SL_IPV4_BYTE(ipV4.IpMask,2),SL_IPV4_BYTE(ipV4.IpMask,1),SL_IPV4_BYTE(ipV4.IpMask,0),         
N            SL_IPV4_BYTE(ipV4.IpGateway,3),SL_IPV4_BYTE(ipV4.IpGateway,2),SL_IPV4_BYTE(ipV4.IpGateway,1),SL_IPV4_BYTE(ipV4.IpGateway,0),                 
N            SL_IPV4_BYTE(ipV4.IpDnsServer,3),SL_IPV4_BYTE(ipV4.IpDnsServer,2),SL_IPV4_BYTE(ipV4.IpDnsServer,1),SL_IPV4_BYTE(ipV4.IpDnsServer,0));
N    \endcode
N    <br>
N
N    - SL_NETCFG_IF: <br>
N    Get interface bitmap
N    \code
N        _u16 len;
N        _u32 IfBitmap;
N        len = sizeof(IfBitmap);
N        sl_NetCfgGet(SL_NETCFG_IF,NULL,&len,(_u8 *)&IfBitmap);
N    \endcode
N    <br>
N
N    - SL_NETCFG_IPV6_ADDR_LOCAL: <br>
N    Get IPV6 Local address (ipV6.ipV6IsValid holds the address status. 1=Valid, ipv6 DAD completed and address is valid for use) 
N    \code
N        SlNetCfgIpV6Args_t ipV6;
N        _u16 len = sizeof(SlNetCfgIpV6Args_t);
N        _u16 ConfigOpt = 0;  //return value could be one of the following: SL_NETCFG_ADDR_STATIC / SL_NETCFG_ADDR_STATELESS / SL_NETCFG_ADDR_STATEFUL
N       
N        sl_NetCfgGet(SL_NETCFG_IPV6_ADDR_LOCAL,&ConfigOpt,&len,(_u8 *)&ipV6);
N        if (SL_IS_IPV6_ADDR_VALID(ipV6.IpV6Flags))
N        {
N            printf("Ipv6 Local Address is valid: %8x:%8x:%8x:%8x\n", ipV6.Ip[0],ipV6.Ip[0],ipV6.Ip[0],ipV6.Ip[0]);
N        }
N        else
N        {
N            printf("Ipv6 Local Address is not valid, wait for DAD to complete or configure a different address");
N        }
N
N    \endcode
N    <br>
N
N    - SL_NETCFG_IPV6_ADDR_GLOBAL:<br>
N    Get IPV6 Global address (ipV6.ipV6IsValid holds the address status. 1=Valid, ipv6 DAD completed and address is valid for use) 
N    \code
N        SlNetCfgIpV6Args_t ipV6;
N        _u16 len = sizeof(SlNetCfgIpV6Args_t);
N        _u16 ConfigOpt = 0;  //return value could be one of the following: SL_NETCFG_ADDR_STATIC  / SL_NETCFG_ADDR_STATEFUL
N       
N        if (SL_IS_IPV6_ADDR_VALID(ipV6.IpV6Flags))
N        {
N            printf("Ipv6 Global Address is valid: %8x:%8x:%8x:%8x\n", ipV6.Ip[0],ipV6.Ip[0],ipV6.Ip[0],ipV6.Ip[0]);
N        }
N        else
N        {
N            printf("Ipv6 Global Address is not valid, wait for DAD to complete or configure a different address");
N        }
N
N    \endcode
N    <br>
N
N    - SL_NETCFG_AP_STATIONS_NUM_CONNECTED: <br>
N      Get AP numbber of connected stations.   
N    \code
N        _u8 num_ap_connected_sta;
N        _u16 len = sizeof(num_ap_connected_sta);
N        sl_NetCfgGet(SL_NETCFG_AP_STATIONS_NUM_CONNECTED, NULL, &len, &num_ap_connected_sta);
N        printf("AP number of connected stations = %d\n", num_ap_connected_sta);
N
N    \endcode
N    <br>
N
N    - SL_NETCFG_AP_STATIONS_INFO_LIST: <br>
N       Get AP full list of connected stationss.
N    \code
N        SlNetCfgStaInfo_t ApStaList[4]; 
N        _u16 sta_info_len;
N        _u16 start_sta_index = 0;
N        int actual_num_sta;
N        int i;
N
N        start_sta_index = 0;
N        sta_info_len = sizeof(ApStaList);
N        sl_NetCfgGet(SL_NETCFG_AP_STATIONS_INFO_LIST, &start_sta_index, &sta_info_len, (_u8 *)ApStaList);
N        
N        actual_num_sta = sta_info_len / sizeof(SlNetCfgStaInfo_t);
N        printf("-Print SL_NETCFG_AP_STATIONS_INFO_LIST actual num_stations = %d (upon sta_info_len = %d)\n", actual_num_sta, sta_info_len);
N
N        for (i=0; i<actual_num_sta; i++)
N        {
N            SlNetCfgStaInfo_t *staInfo = &ApStaList[i];
N            printf("  Ap Station %d is connected\n", i);
N            printf("    NAME: %s\n", staInfo->Name);
N            printf("    MAC:  %02x:%02x:%02x:%02x:%02x:%02x\n", staInfo->MacAddr[0], staInfo->MacAddr[1], staInfo->MacAddr[2], staInfo->MacAddr[3], staInfo->MacAddr[4], staInfo->MacAddr[5]);
N            printf("    IP:   %d.%d.%d.%d\n", SL_IPV4_BYTE(staInfo->Ip,3), SL_IPV4_BYTE(staInfo->Ip,2), SL_IPV4_BYTE(staInfo->Ip,1), SL_IPV4_BYTE(staInfo->Ip,0));
N        }
N
N    \endcode
N    <br>
N
N    - SL_NETCFG_IPV4_DNS_CLIENT: <br>
N      Set secondary DNS address (DHCP and static configuration) 
N    \code                                                               
N        _u16 ConfigOpt = 0;
N        _i32 Status;
N        _u16 pConfigLen = sizeof(SlNetCfgIpV4DnsClientArgs_t);
N        SlNetCfgIpV4DnsClientArgs_t DnsOpt;
N        Status = sl_NetCfgGet(SL_NETCFG_IPV4_DNS_CLIENT,&ConfigOpt,&pConfigLen,&DnsOpt);
N        if( Status )
N        {
N            // error 
N        }
N    \endcode
N
N    - SL_NETCFG_IPV4_DHCP_CLIENT: <br>
N      Get DHCP Client info 
N    \code                                                               
N        _u16 ConfigOpt = 0;
N        _u16 pConfigLen = sizeof(SlNetCfgIpv4DhcpClient_t);
N        SlNetCfgIpv4DhcpClient_t dhcpCl;
N        SlNetCfgIpV4Args_t ipV4 = {0};
N
N        ret = sl_NetCfgGet(SL_NETCFG_IPV4_DHCP_CLIENT, &ConfigOpt, &pConfigLen, (_u8 *)&dhcpCl);
N        if(ret < 0)
N        {
N            printf("Error = %d\n", ret);
N        }
N    \endcode
N
N*/
N#if _SL_INCLUDE_FUNC(sl_NetCfgGet)
X#if (1)
N_i16 sl_NetCfgGet(const _u16 ConfigId ,_u16 *pConfigOpt, _u16 *pConfigLen, _u8 *pValues);
Xsigned short sl_NetCfgGet(const unsigned short ConfigId ,unsigned short *pConfigOpt, unsigned short *pConfigLen, unsigned char *pValues);
N#endif
N
N/*!
N
N Close the Doxygen group.
N @}
N
N */
N
N
N#ifdef  __cplusplus
S}
N#endif /*  __cplusplus */
N
N#endif    /*  __NETCFG_H__ */
N
L 415 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N#include "netutil.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/netutil.h" 1
N/*
N * netutil.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N#ifndef __NETUTIL_H__
N#define __NETUTIL_H__
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N#include <ti/drivers/net/wifi/simplelink.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*!
N    \defgroup NetUtil 
N    \short Networking related commands and configuration
N
N*/
N
N/*!
N
N    \addtogroup NetUtil
N    @{
N
N*/
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N
N/* Set/get options */
N#define SL_NETUTIL_CRYPTO_PUBLIC_KEY                      (1)
N#define SL_NETUTIL_CRYPTO_PUBLIC_KEY_INFO                 (2)
N#define SL_NETUTIL_TRUE_RANDOM                            (3)
N
N/* Commands */
N#define SL_NETUTIL_CRYPTO_CMD_CREATE_CERT                 (1)
N#define SL_NETUTIL_CRYPTO_CMD_SIGN_MSG                    (2)
N#define SL_NETUTIL_CRYPTO_CMD_VERIFY_MSG                  (3)
N#define SL_NETUTIL_CRYPTO_CMD_TEMP_KEYS                   (4)
N#define SL_NETUTIL_CRYPTO_CMD_INSTALL_OP                  (5)
N#define SL_NETUTIL_CMD_ARP_LOOKUP                         (6)
N
N/*****************************************************************************/
N/* Errors returned from the general error async event                        */
N/*****************************************************************************/
N
N
N/*****************************************************************************/
N/* Structure/Enum declarations                                               */
N/*****************************************************************************/
N
N/* Defines the size of the buffer that will be alocated */
N/* (on the stack) by the sl_UtilsCmd API.               */
N#define SL_NETUTIL_CMD_BUFFER_SIZE                        (256)
N
N/* Enumaration of Signature types */
N#define SL_NETUTIL_CRYPTO_SIG_SHAwDSA                     (0)
N#define SL_NETUTIL_CRYPTO_SIG_MD2wRSA                     (1)
N#define SL_NETUTIL_CRYPTO_SIG_MD5wRSA                     (2)
N#define SL_NETUTIL_CRYPTO_SIG_SHAwRSA                     (3)
N#define SL_NETUTIL_CRYPTO_SIG_SHAwECDSA                   (4)
N#define SL_NETUTIL_CRYPTO_SIG_SHA256wRSA                  (5)
N#define SL_NETUTIL_CRYPTO_SIG_SHA256wECDSA                (6)
N#define SL_NETUTIL_CRYPTO_SIG_SHA384wRSA                  (7)
N#define SL_NETUTIL_CRYPTO_SIG_SHA384wECDSA                (8)
N#define SL_NETUTIL_CRYPTO_SIG_SHA512wRSA                  (9)
N#define SL_NETUTIL_CRYPTO_SIG_SHA512wECDSA                (10)
N#define SL_NETUTIL_CRYPTO_SIG_DIGESTwECDSA                (11)
N/* Add more signature-Types here */
N
N/* Digest length definitions */
N#define SL_NETUTIL_CRYPTO_DGST_MD2_LEN_BYTES              (16)
N#define SL_NETUTIL_CRYPTO_DGST_MD5_LEN_BYTES              (16)
N#define SL_NETUTIL_CRYPTO_DGST_SHA_LEN_BYTES              (20)
N#define SL_NETUTIL_CRYPTO_DGST_SHA256_LEN_BYTES           (32)
N#define SL_NETUTIL_CRYPTO_DGST_SHA384_LEN_BYTES           (48)
N#define SL_NETUTIL_CRYPTO_DGST_SHA512_LEN_BYTES           (64)
N
N
N/* Enumeration of Create-Certificate sub-commands */
N#define SL_NETUTIL_CRYPTO_CERT_INIT                       (1)
N#define SL_NETUTIL_CRYPTO_CERT_SIGN_AND_SAVE              (2)
N#define SL_NETUTIL_CRYPTO_CERT_VER                        (3)
N#define SL_NETUTIL_CRYPTO_CERT_SERIAL                     (4)
N#define SL_NETUTIL_CRYPTO_CERT_SIG_TYPE                   (5)
N#define SL_NETUTIL_CRYPTO_CSR_SIGN_AND_SAVE               (6)
N#if 0 /* reserved for Issuer information - currently not supported */
S#define SL_NETUTIL_CRYPTO_CERT_ISSUER_COUNTRY             (6)
S#define SL_NETUTIL_CRYPTO_CERT_ISSUER_STATE               (7)
S#define SL_NETUTIL_CRYPTO_CERT_ISSUER_LOCALITY            (8)
S#define SL_NETUTIL_CRYPTO_CERT_ISSUER_SUR                 (9)
S#define SL_NETUTIL_CRYPTO_CERT_ISSUER_ORG                 (10)
S#define SL_NETUTIL_CRYPTO_CERT_ISSUER_ORG_UNIT            (11)
S#define SL_NETUTIL_CRYPTO_CERT_ISSUER_COMMON_NAME         (12)
S#define SL_NETUTIL_CRYPTO_CERT_ISSUER_EMAIL               (13)
N#endif /* End - issuer information */
N#define SL_NETUTIL_CRYPTO_CERT_DAYS_VALID                 (14)
N#define SL_NETUTIL_CRYPTO_CERT_SUBJECT_COUNTRY            (15)
N#define SL_NETUTIL_CRYPTO_CERT_SUBJECT_STATE              (16)
N#define SL_NETUTIL_CRYPTO_CERT_SUBJECT_LOCALITY           (17)
N#define SL_NETUTIL_CRYPTO_CERT_SUBJECT_SUR                (18)
N#define SL_NETUTIL_CRYPTO_CERT_SUBJECT_ORG                (19)
N#define SL_NETUTIL_CRYPTO_CERT_SUBJECT_ORG_UNIT           (20)
N#define SL_NETUTIL_CRYPTO_CERT_SUBJECT_COMMON_NAME        (21)
N#define SL_NETUTIL_CRYPTO_CERT_SUBJECT_EMAIL              (22)
N#define SL_NETUTIL_CRYPTO_CERT_IS_CA                      (23)
N
N
N/* Enumeration of "Temp-Keys" commands */
N#define SL_NETUTIL_CRYPTO_TEMP_KEYS_CREATE                (1)
N#define SL_NETUTIL_CRYPTO_TEMP_KEYS_REMOVE                (2)
N
N/* Enumeration of "Install/Uninstall" sub-commands */
N#define SL_NETUTIL_CRYPTO_INSTALL_SUB_CMD                 (1)
N#define SL_NETUTIL_CRYPTO_UNINSTALL_SUB_CMD               (2)
N
N
N/* The reserved key for IOT Usage */
N#define SL_NETUTIL_CRYPTO_SERVICES_IOT_RESERVED_INDEX     (0)
N
N/* The Temporary key for FS Usage */
N#define SL_NETUTIL_CRYPTO_FS_TEMP_KEYS_OBJ_ID             (1)
N
N
N/**********************************************/
N/* Public Key Info Structures and Definitions */
N/**********************************************/
N
N/* Enumeration of Elliptic Curve "named" curves */
N#define SL_NETUTIL_CRYPTO_EC_NAMED_CURVE_NONE             (0)
N#define SL_NETUTIL_CRYPTO_EC_NAMED_CURVE_SECP256R1        (1)
N
N/* PLACE HOLDER for future definitions of custom-curve parameters */
Ntypedef struct
N{
N    _u8    Padding[4];
X    unsigned char    Padding[4];
N} SlNetUtilCryptoEcCustomCurveParam_t;
N
N
N/* Union holding the Elliptic Curve parameters. */
Ntypedef union
N{
N    _u8                                  NamedCurveParams;  /* parameters for named-curve (the curve identifier) */
X    unsigned char                                  NamedCurveParams;   
N    SlNetUtilCryptoEcCustomCurveParam_t  CustomCurveParams; /* parameters for custom curves */
N} SlNetUtilCryptoEcCurveParams_u;
N
N
N/* curve-type definitions */
N#define SL_NETUTIL_CRYPTO_EC_CURVE_TYPE_NAMED             (1)  /* ECC Named Curve type */
N#define SL_NETUTIL_CRYPTO_EC_CURVE_TYPE_CUSTOM            (2)  /* ECC Custom curve type */
N
N
N/* Enumeration of the supported public-key algorithms */
N#define SL_NETUTIL_CRYPTO_PUB_KEY_ALGO_NONE               (0)
N#define SL_NETUTIL_CRYPTO_PUB_KEY_ALGO_EC                 (1)
N
N
N/* Structure for holding the Elliptic Curve Key parameters */
Ntypedef struct
N{   
N    _u8                             CurveType;          /* defines curve type - custom or named */
X    unsigned char                             CurveType;           
N    SlNetUtilCryptoEcCurveParams_u  CurveParams;        /* specific parameters of the curve (depends on curve_type) */
N} SlNetUtilCryptoEcKeyParams_t;
N
N/* Union for holding the Public Key parameters, depends on key algorithm */
Ntypedef union
N{
N
N    SlNetUtilCryptoEcKeyParams_t    EcParams;           /* parameters for Elliptic Curve key */
N
N    /* add containers for other key types and algos here*/
N} SlNetUtilCryptoPubKeyParams_u;
N
N/* structure for holding all the meta-data about a key-pair  */
Ntypedef struct
N{
N    _u8                            KeyAlgo;
X    unsigned char                            KeyAlgo;
N    SlNetUtilCryptoPubKeyParams_u  KeyParams;
N    _u8                            KeyFileNameLen;
X    unsigned char                            KeyFileNameLen;
N    _u8                            CertFileNameLen;
X    unsigned char                            CertFileNameLen;
N}SlNetUtilCryptoPubKeyInfo_t;
N
N/********************************************/
N/* NetUtil-Crypto Cmd "Attributes" structures */
N/********************************************/
N/* structure for holding all the attributes for a "Sign" Command */
Ntypedef struct
N{
N    _u32       ObjId;
X    unsigned long       ObjId;
N    _u32       SigType;
X    unsigned long       SigType;
N    _u32       Flags;
X    unsigned long       Flags;
N} SlNetUtilCryptoCmdSignAttrib_t;
N
N
N/* structure for holding all the attributes for a "Verify" Command */
Ntypedef struct
N{
N    _u32       ObjId;
X    unsigned long       ObjId;
N    _u32       SigType;
X    unsigned long       SigType;
N    _u32       Flags;
X    unsigned long       Flags;
N    _u16       MsgLen;
X    unsigned short       MsgLen;
N    _u16       SigLen;
X    unsigned short       SigLen;
N} SlNetUtilCryptoCmdVerifyAttrib_t;
N
N/* structure for holding all the attributes for a "Create Certificate" Command */
Ntypedef struct
N{
N    _u32       ObjId;
X    unsigned long       ObjId;
N    _u32       Flags;
X    unsigned long       Flags;
N    _u16       SubCmd;
X    unsigned short       SubCmd;
N} SlNetUtilCryptoCmdCreateCertAttrib_t;
N
N/* structure for holding all the attributes for  "Key management" Commands: */
N/* Temp-Key (create and delete), Install and un-Install.                    */
Ntypedef struct
N{
N    _u32       ObjId;
X    unsigned long       ObjId;
N    _u32       Flags;
X    unsigned long       Flags;
N    _u16       SubCmd;
X    unsigned short       SubCmd;
N} SlNetUtilCryptoCmdKeyMgnt_t;
N
N/* structure for holding all the attributes for a "SL_NETUTIL_CMD_ARP_LOOKUP" Command */
Ntypedef struct
N{
N    _u16 NumOfRetries; /* number of retires for ARP request, range 1-20 */
X    unsigned short NumOfRetries;  
N    _u16 Timeout;      /* timeout between ARP requests, range 10-500 mSec , 10 mSec resolution*/
X    unsigned short Timeout;       
N}NetUtilCmdArpLookupAttrib_t;
N
N
N/******************************************************************************/
N/* Type declarations                                                          */
N/******************************************************************************/
N
N/*****************************************************************************/
N/* Function prototypes                                                       */
N/*****************************************************************************/
N
N/*!
N    \brief     Function for setting configurations of utilities  
N   
N    \param[in] Option       Identifier of the specific "set" operation to perform 
N    \param[in] ObjID        ID of the relevant object that this set operation will be performed on
N    \param[in] ValueLen     Length of the value parameter
N    \param[in] pValues      Pointer to the buffer holding the configurations values
N
N    \return    Zero on success, or negative error code on failure
N    \sa        sl_NetUtilGet  sl_NetUtilCmd
N    \note 
N    \warning     
N*/
N#if _SL_INCLUDE_FUNC(sl_NetUtilSet)
X#if (1)
N_i32 sl_NetUtilSet(const _u16 Option, const _u32 ObjID, const _u8 *pValues,  const _u16 ValueLen);
Xsigned long sl_NetUtilSet(const unsigned short Option, const unsigned long ObjID, const unsigned char *pValues,  const unsigned short ValueLen);
N#endif
N
N/*!
N    \brief     Function for getting configurations of utilities  
N    \param[in]     Option        Identifier of the specific "get" operation to perform 
N                                - <b>SL_NETUTIL_CRYPTO_PUBLIC_KEY</b>  \n
N                                Used to retrieve the public key from an installed key-pair. \n
N                                Saved in a certain index.
N                                - <b>SL_NETUTIL_TRUE_RANDOM</b>  \n
N                                Generates a random number using the internal TRNG of the NWP. \n
N    \param[in]     ObjID        ID of the relevant object that this set operation will be performed on
N    \param[in,out] pValueLen    Pointer to the length of the value parameter\n
N                                On input - provides the length of the buffer that the application allocates, and
N                                will hold the output\n
N                                On output - provides the actual length of the received data
N    \param[out]    pValues      Pointer to the buffer that the application allocates, and will hold
N                                the received data.
N    \return        Zero on success, or negative error code on failure.
N    \sa            sl_NetUtilSet sl_NetUtilCmd
N    \note 
N    \warning
N    \par    Examples
N    - SL_NETUTIL_CRYPTO_PUBLIC_KEY:
N    \code
N    int16_t Status;
N    uint8_t configOpt = 0;
N    uint32_t objId = 0;
N    uint16_t configLen = 0;
N    uint8_t key_buf[256];
N
N    configOpt = SL_NETUTIL_CRYPTO_PUBLIC_KEY;
N
N    objId = 1;
N    configLen = 255;
N    //get the Public key
N    Status = sl_NetUtilGet(configOpt, objId, key_buf, &configLen);
N    \endcode
N
N    - SL_NETUTIL_TRUE_RANDOM:
N    \code
N    uint32_t randNum;
N    int32_t len = sizeof(uint32_t);
N
N    sl_NetUtilGet(SL_NETUTIL_TRUE_RANDOM, 0, (uint8_t *)&randNum, &len);
N    \endcode
N    <br>
N*/
N#if _SL_INCLUDE_FUNC(sl_NetUtilGet)
X#if (1)
N_i16 sl_NetUtilGet(const _u16 Option, const _u32 ObjID, _u8 *pValues, _u16 *pValueLen);
Xsigned short sl_NetUtilGet(const unsigned short Option, const unsigned long ObjID, unsigned char *pValues, unsigned short *pValueLen);
N#endif
N
N/*!
N    \brief     Function for performing utilities-related commands
N    \param[in]      Cmd             Identifier of the specific Command to perform
N                                    - <b>SL_NETUTIL_CRYPTO_CMD_INSTALL_OP</b>  \n
N                                            Install / Uninstall key pairs in one or more of the crypto utils
N                                            key-pair management mechanism. \n
N                                            Key Must be an ECC key-pair using SECP256R1 curve and already programmed to file system,
N                                            in DER format.\n
N                                            Key installation is persistent.
N                                    - <b>SL_NETUTIL_CRYPTO_CMD_TEMP_KEYS</b>  \n
N                                            Creates or removes a temporary key pair. \n
N                                            Key pair is created internally by the NWP.
N                                            Key pair is not persistent over power cycle.
N                                    - <b>SL_NETUTIL_CRYPTO_CMD_SIGN_MSG</b>  \n
N                                            Signs with a digital signature a data buffer using ECDSA algorithm. \n
N                                    - <b>SL_NETUTIL_CRYPTO_CMD_VERIFY_MSG</b>  \n
N                                    Verify a digital signature given with a data buffer using ECDSA algorithm. \n
N    \param[in]      pAttrib         Pointer to the buffer holding the Attribute values
N    \param[in]      AttribLen       Length of the Attribute-values 
N    \param[in]      pInputValues    Pointer to the buffer holding the input-value
N    \param[in]      InputLen        Length of the input-value
N    \param[out]     pOutputValues   Pointer to the buffer that the application allocates, and will hold the received data.
N    \param[in,out]  pOutputLen      Length of the output-value \n
N                                    On input - provides the length of the buffer that the application allocates, and
N                                    will hold the output\n
N                                    On output - provides the actual length of the received output-values
N    \return    Zero on success, or negative error code on failure
N    \sa       sl_NetUtilGet sl_NetUtilSet  
N    \note
N    \warning
N    \par   Examples
N
N    - SL_NETUTIL_CRYPTO_CMD_INSTALL_OP (install / uninstall crypto keys):
N    \code
N    // Install a key
N    SlNetUtilCryptoCmdKeyMgnt_t keyAttrib;
N    SlNetUtilCryptoPubKeyInfo_t *pInfoKey;
N    uint8_t name[FILE_NAME_SIZE];
N    int32_t Status;
N    int16_t resultLen;
N
N    keyAttrib.ObjId = 5; // Key would be stored at index 5
N    keyAttrib.SubCmd = SL_NETUTIL_CRYPTO_INSTALL_SUB_CMD;
N    pInfoKey->KeyAlgo = SL_NETUTIL_CRYPTO_PUB_KEY_ALGO_EC;
N    pInfoKey->KeyParams.EcParams.CurveType = SL_NETUTIL_CRYPTO_EC_CURVE_TYPE_NAMED;                          //ECC curve
N    pInfoKey->KeyParams.EcParams.CurveParams.NamedCurveParams = SL_NETUTIL_CRYPTO_EC_NAMED_CURVE_SECP256R1; // SECP256R1 curve only.
N
N    pInfoKey->CertFileNameLen = 0;
N    name = ((uint8_t *)pInfoKey) + sizeof(SlNetUtilCryptoPubKeyInfo_t);
N    name += pInfoKey->CertFileNameLen;
N    strcpy((char *)name, "extkey.der"); // Private key name in file system.
N    pInfoKey->KeyFileNameLen = strlen("extkey.der")+1;
N
N    Status = sl_NetUtilCmd(SL_NETUTIL_CRYPTO_CMD_INSTALL_OP,
N                          (uint8_t *)&keyAttrib, sizeof(SlNetUtilCryptoCmdKeyMgnt_t),
N                          (uint8_t *)pInfo,
N                          sizeof(SlNetUtilCryptoPubKeyInfo_t) + pInfoKey->KeyFileNameLen,
N                          NULL, &resultLen);
N
N    // Uninstall the Key:
N    resultLen = 0;
N    keyAttrib.ObjId = 5;
N    keyAttrib.SubCmd = SL_NETUTIL_CRYPTO_UNINSTALL_SUB_CMD;
N
N    Status = sl_NetUtilCmd(SL_NETUTIL_CRYPTO_CMD_INSTALL_OP, (uint8_t *)&keyAttrib,
N                           sizeof(SlNetUtilCryptoCmdKeyMgnt_t), NULL, 0 , NULL, &resultLen);
N    \endcode
N
N    - SL_NETUTIL_CRYPTO_CMD_TEMP_KEYS, (Create a temporary key ):
N    \code
N
N    SlNetUtilCryptoCmdKeyMgnt_t keyAttrib;
N    int32_t Status;
N    uint16_t resultLen;
N    keyAttrib.ObjId = 1; // key index is 1
N    keyAttrib.SubCmd = SL_NETUTIL_CRYPTO_TEMP_KEYS_CREATE;
N
N    Status = sl_NetUtilCmd(SL_NETUTIL_CRYPTO_CMD_TEMP_KEYS,
N             (uint8_t *)&keyAttrib, sizeof(SlNetUtilCryptoCmdKeyMgnt_t),
N             NULL, 0 , NULL, &resultLen);
N    \endcode
N
N    - SL_NETUTIL_CRYPTO_CMD_TEMP_KEYS, (Create a temporary key ):
N    \code
N
N    SlNetUtilCryptoCmdKeyMgnt_t keyAttrib;
N    int32_t Status;
N    uint16_t resultLen;
N    keyAttrib.ObjId = 1; // key index is 1
N    keyAttrib.SubCmd = SL_NETUTIL_CRYPTO_TEMP_KEYS_CREATE;
N
N    Status = sl_NetUtilCmd(SL_NETUTIL_CRYPTO_CMD_TEMP_KEYS,
N             (uint8_t *)&keyAttrib, sizeof(SlNetUtilCryptoCmdKeyMgnt_t),
N             NULL, 0 , NULL, &resultLen);
N    \endcode
N
N    - SL_NETUTIL_CRYPTO_CMD_SIGN_MSG, (Sign a data buffer):
N    \code
N    int32_t Status;
N    int32_t configLen;
N    uint8_t messageBuff[1500];
N    uint8_t sig_buf[256];      // This buffer shall contain the digital signature.
N    SlNetUtilCryptoCmdSignAttrib_t signAttrib;
N
N    signAttrib.Flags = 0;
N    signAttrib.ObjId = 3;
N    signAttrib.SigType = SL_NETUTIL_CRYPTO_SIG_SHAwECDSA; // this is the only type supported
N    configLen = 255;
N
N    Status = sl_NetUtilCmd(SL_NETUTIL_CRYPTO_CMD_SIGN_MSG, (uint8_t *)&signAttrib,
N                           sizeof(SlNetUtilCryptoCmdSignAttrib_t),
N                           messageBuff, sizeof(messageBuf), sig_buf, &configLen);
N    \endcode
N
N    - SL_NETUTIL_CRYPTO_CMD_VERIFY_MSG, (Verify a data buffer):
N    \code
N
N    int32_t Status;
N    int32_t configLen;
N    uint8_t verifyBuf[2048];
N    uint8_t messageBuff[1500];
N    uint8_t sig_buf[256];                                        // This buffer contains the digital signature.
N    int32_t verifyResult;
N    SlNetUtilCryptoCmdVerifyAttrib_t verAttrib;
N
N    memcpy(verifyBuf, messageBuf, sizeof(messageBuf));           // copy the message to verify buffer.
N    memcpy(verifyBuf + sizeof(messageBuff), sig_buf, configLen); // Append the signature to message buffer.
N
N    verAttrib.Flags = 0;
N    verAttrib.ObjId = 3;
N    verAttrib.SigType = SL_NETUTIL_CRYPTO_SIG_SHAwECDSA;         // this is the only type supported, if other hash algorithm
N                                                                 // is wanted, SL_NETUTIL_CRYPTO_SIG_DIGESTwECDSA is used and
N                                                                 // the verifyBuf should be the digest and MsgLen should be
N                                                                 // the digest size
N    verAttrib.MsgLen = sizeof(messageBuff);
N    verAttrib.SigLen = configLen;
N    configLen = 255;
N    resultLen = 4;
N
N    Status = sl_NetUtilCmd(SL_NETUTIL_CRYPTO_CMD_VERIFY_MSG, (uint8_t *)&verAttrib,
N                           sizeof(SlNetUtilCryptoCmdVerifyAttrib_t),
N                           verifyBuf, sizeof(messageBuf) + configLen,
N                           (uint8_t *)&verifyResult , &resultLen);
N    \endcode
N    <br>
N
N*/
N#if _SL_INCLUDE_FUNC(sl_NetUtilCmd)
X#if (1)
N_i16 sl_NetUtilCmd(const _u16 Cmd,  const _u8 *pAttrib, const _u16 AttribLen,
Xsigned short sl_NetUtilCmd(const unsigned short Cmd,  const unsigned char *pAttrib, const unsigned short AttribLen,
N                 const _u8 *pInputValues, const _u16 InputLen,
X                 const unsigned char *pInputValues, const unsigned short InputLen,
N                 _u8 *pOutputValues,_u16 *pOutputLen );
X                 unsigned char *pOutputValues,unsigned short *pOutputLen );
N#endif
N
N/*!
N
N Close the Doxygen group.
N @}
N
N */
N
N
N#ifdef  __cplusplus
S}
N#endif /*  __cplusplus */
N
N#endif  /*  __NETUTIL_H__ */
N
N
L 416 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N#include "errors.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/errors.h" 1
N/*
N * errors.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N
N
N#ifndef __ERROR_H__
N#define __ERROR_H__
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N#define SL_RET_CODE_OK                                                  (0L)    /* Success */
N
N#define SL_ERROR_GENERAL_DEVICE                                         (-6L)   /* General device error */
N
N/* BSD SOCKET ERRORS CODES */
N
N#define SL_ERROR_BSD_SOC_ERROR                                          (-1L)   /* Failure */
N#define SL_ERROR_BSD_INEXE                                              (-8L)   /* socket command in execution  */
N#define SL_ERROR_BSD_EBADF                                              (-9L)   /* Bad file number */
N#define SL_ERROR_BSD_ENSOCK                                             (-10L)  /* The system limit on the total number of open socket, has been reached */
N#define SL_ERROR_BSD_EAGAIN                                             (-11L)  /* Try again */
N#define SL_ERROR_BSD_EWOULDBLOCK                                        SL_ERROR_BSD_EAGAIN
N#define SL_ERROR_BSD_ENOMEM                                             (-12L)  /* Out of memory */
N#define SL_ERROR_BSD_EACCES                                             (-13L)  /* Permission denied */
N#define SL_ERROR_BSD_EFAULT                                             (-14L)  /* Bad address */
N#define SL_ERROR_BSD_ECLOSE                                             (-15L)  /* close socket operation failed to transmit all queued packets */
N#define SL_ERROR_BSD_EALREADY_ENABLED                                   (-21L)  /* Transceiver - Transceiver already ON. there could be only one */
N#define SL_ERROR_BSD_EINVAL                                             (-22L)  /* Invalid argument */
N#define SL_ERROR_BSD_EAUTO_CONNECT_OR_CONNECTING                        (-69L)  /* Transceiver - During connection, connected or auto mode started */
N#define SL_ERROR_BSD_CONNECTION_PENDING                                 (-72L)  /* Transceiver - Device is connected, disconnect first to open transceiver */
N#define SL_ERROR_BSD_EUNSUPPORTED_ROLE                                  (-86L)  /* Transceiver - Trying to start when WLAN role is AP or P2P GO */
N#define SL_ERROR_BSD_EDESTADDRREQ                                       (-89L)  /* Destination address required */
N#define SL_ERROR_BSD_EPROTOTYPE                                         (-91L)  /* Protocol wrong type for socket */
N#define SL_ERROR_BSD_ENOPROTOOPT                                        (-92L)  /* Protocol not available */
N#define SL_ERROR_BSD_EPROTONOSUPPORT                                    (-93L)  /* Protocol not supported */
N#define SL_ERROR_BSD_ESOCKTNOSUPPORT                                    (-94L)  /* Socket type not supported */
N#define SL_ERROR_BSD_EOPNOTSUPP                                         (-95L)  /* Operation not supported on transport endpoint */
N#define SL_ERROR_BSD_EAFNOSUPPORT                                       (-97L)  /* Address family not supported by protocol */
N#define SL_ERROR_BSD_EADDRINUSE                                         (-98L)  /* Address already in use */
N#define SL_ERROR_BSD_EADDRNOTAVAIL                                      (-99L)  /* Cannot assign requested address */
N#define SL_ERROR_BSD_ENETUNREACH                                        (-101L) /* Network is unreachable */
N#define SL_ERROR_BSD_ENOBUFS                                            (-105L) /* No buffer space available */
N#define SL_ERROR_BSD_EOBUFF                                             SL_ENOBUFS
N#define SL_ERROR_BSD_EISCONN                                            (-106L) /* Transport endpoint is already connected */
N#define SL_ERROR_BSD_ENOTCONN                                           (-107L) /* Transport endpoint is not connected */
N#define SL_ERROR_BSD_ETIMEDOUT                                          (-110L) /* Connection timed out */
N#define SL_ERROR_BSD_ECONNREFUSED                                       (-111L) /* Connection refused */
N#define SL_ERROR_BSD_EALREADY                                           (-114L) /* Non blocking connect in progress, try again */
N
N/* ssl tls security start with -300 offset */
N#define SL_ERROR_BSD_ESEC_CLOSE_NOTIFY                                  (-300L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_UNEXPECTED_MESSAGE                            (-310L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_BAD_RECORD_MAC                                (-320L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_DECRYPTION_FAILED                             (-321L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_RECORD_OVERFLOW                               (-322L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_DECOMPRESSION_FAILURE                         (-330L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_HANDSHAKE_FAILURE                             (-340L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_NO_CERTIFICATE                                (-341L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_BAD_CERTIFICATE                               (-342L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_UNSUPPORTED_CERTIFICATE                       (-343L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_ILLEGAL_PARAMETER                             (-347L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_ACCESS_DENIED                                 (-349L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_DECODE_ERROR                                  (-350L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_DECRYPT_ERROR1                                (-351L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_EXPORT_RESTRICTION                            (-360L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_PROTOCOL_VERSION                              (-370L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_INSUFFICIENT_SECURITY                         (-371L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_INTERNAL_ERROR                                (-380L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_USER_CANCELLED                                (-390L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_NO_RENEGOTIATION                              (-400L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_UNSUPPORTED_EXTENSION                         (-410L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_CERTIFICATE_UNOBTAINABLE                      (-411L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_UNRECOGNIZED_NAME                             (-412L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_BAD_CERTIFICATE_STATUS_RESPONSE               (-413L) /* ssl/tls alerts */
N#define SL_ERROR_BSD_ESEC_BAD_CERTIFICATE_HASH_VALUE                    (-414L) /* ssl/tls alerts */
N/* propierty secure */
N#define SL_ERROR_BSD_ESECGENERAL                                        (-450L) /* error secure level general error */
N#define SL_ERROR_BSD_ESECDECRYPT                                        (-451L) /* error secure level, decrypt recv packet fail */
N#define SL_ERROR_BSD_ESECCLOSED                                         (-452L) /* secure layrer is closed by other size , tcp is still connected  */
N#define SL_ERROR_BSD_ESECSNOVERIFY                                      (-453L) /* Connected without server verification */
N#define SL_ERROR_BSD_ESECNOCAFILE                                       (-454L) /* error secure level CA file not found*/
N#define SL_ERROR_BSD_ESECMEMORY                                         (-455L) /* error secure level No memory  space available */
N#define SL_ERROR_BSD_ESECBADCAFILE                                      (-456L) /* error secure level bad CA file */
N#define SL_ERROR_BSD_ESECBADCERTFILE                                    (-457L) /* error secure level bad Certificate file */
N#define SL_ERROR_BSD_ESECBADPRIVATEFILE                                 (-458L) /* error secure level bad private file */
N#define SL_ERROR_BSD_ESECBADDHFILE                                      (-459L) /* error secure level bad DH file */
N#define SL_ERROR_BSD_ESECT00MANYSSLOPENED                               (-460L) /* MAX SSL Sockets are opened */
N#define SL_ERROR_BSD_ESECDATEERROR                                      (-461L) /* connected with certificate date verification error */
N#define SL_ERROR_BSD_ESECHANDSHAKETIMEDOUT                              (-462L) /* connection timed out due to handshake time */
N#define SL_ERROR_BSD_ESECTXBUFFERNOTEMPTY                               (-463L) /* cannot start ssl connection while send buffer is full */
N#define SL_ERROR_BSD_ESECRXBUFFERNOTEMPTY                               (-464L) /* cannot start ssl connection while recv buffer is full */
N#define SL_ERROR_BSD_ESECSSLDURINGHANDSHAKE                             (-465L) /* cannot use while in hanshaking */
N#define SL_ERROR_BSD_ESECNOTALLOWEDWHENLISTENING                        (-466L) /* the operation is not allowed when listening, do before listen*/
N#define SL_ERROR_BSD_ESECCERTIFICATEREVOKED                             (-467L) /* connected but on of the certificates in the chain is revoked */
N#define SL_ERROR_BSD_ESECUNKNOWNROOTCA                                  (-468L) /* connected but the root CA used to validate the peer is unknown */
N#define SL_ERROR_BSD_ESECWRONGPEERCERT                                  (-469L) /* wrong peer cert (server cert) was received while trying to connect to server */
N#define SL_ERROR_BSD_ESECTCPDISCONNECTEDUNCOMPLETERECORD                (-470L) /* the other side disconnected the TCP layer and didn't send the whole ssl record */
N
N#define SL_ERROR_BSD_ESEC_BUFFER_E                                      (-632L) /* output buffer too small or input too large */
N#define SL_ERROR_BSD_ESEC_ALGO_ID_E                                     (-633L) /* setting algo id error */
N#define SL_ERROR_BSD_ESEC_PUBLIC_KEY_E                                  (-634L) /* setting public key error */
N#define SL_ERROR_BSD_ESEC_DATE_E                                        (-635L) /* setting date validity error */
N#define SL_ERROR_BSD_ESEC_SUBJECT_E                                     (-636L) /* setting subject name error */
N#define SL_ERROR_BSD_ESEC_ISSUER_E                                      (-637L) /* setting issuer  name error */
N#define SL_ERROR_BSD_ESEC_CA_TRUE_E                                     (-638L) /* setting CA basic constraint true error */
N#define SL_ERROR_BSD_ESEC_EXTENSIONS_E                                  (-639L) /* setting extensions error */
N#define SL_ERROR_BSD_ESEC_ASN_PARSE_E                                   (-640L) /* ASN parsing error, invalid input */
N#define SL_ERROR_BSD_ESEC_ASN_VERSION_E                                 (-641L) /* ASN version error, invalid number */
N#define SL_ERROR_BSD_ESEC_ASN_GETINT_E                                  (-642L) /* ASN get big int error, invalid data */
N#define SL_ERROR_BSD_ESEC_ASN_RSA_KEY_E                                 (-643L) /* ASN key init error, invalid input */
N#define SL_ERROR_BSD_ESEC_ASN_OBJECT_ID_E                               (-644L) /* ASN object id error, invalid id */
N#define SL_ERROR_BSD_ESEC_ASN_TAG_NULL_E                                (-645L) /* ASN tag error, not null */
N#define SL_ERROR_BSD_ESEC_ASN_EXPECT_0_E                                (-646L) /* ASN expect error, not zero */
N#define SL_ERROR_BSD_ESEC_ASN_BITSTR_E                                  (-647L) /* ASN bit string error, wrong id */
N#define SL_ERROR_BSD_ESEC_ASN_UNKNOWN_OID_E                             (-648L) /* ASN oid error, unknown sum id */
N#define SL_ERROR_BSD_ESEC_ASN_DATE_SZ_E                                 (-649L) /* ASN date error, bad size */
N#define SL_ERROR_BSD_ESEC_ASN_BEFORE_DATE_E                             (-650L) /* ASN date error, current date before */
N#define SL_ERROR_BSD_ESEC_ASN_AFTER_DATE_E                              (-651L) /* ASN date error, current date after */
N#define SL_ERROR_BSD_ESEC_ASN_SIG_OID_E                                 (-652L) /* ASN signature error, mismatched oid */
N#define SL_ERROR_BSD_ESEC_ASN_TIME_E                                    (-653L) /* ASN time error, unknown time type */
N#define SL_ERROR_BSD_ESEC_ASN_INPUT_E                                   (-654L) /* ASN input error, not enough data */
N#define SL_ERROR_BSD_ESEC_ASN_SIG_CONFIRM_E                             (-655L) /* ASN sig error, confirm failure */
N#define SL_ERROR_BSD_ESEC_ASN_SIG_HASH_E                                (-656L) /* ASN sig error, unsupported hash type */
N#define SL_ERROR_BSD_ESEC_ASN_SIG_KEY_E                                 (-657L) /* ASN sig error, unsupported key type */
N#define SL_ERROR_BSD_ESEC_ASN_DH_KEY_E                                  (-658L) /* ASN key init error, invalid input */
N#define SL_ERROR_BSD_ESEC_ASN_NTRU_KEY_E                                (-659L) /* ASN ntru key decode error, invalid input */
N#define SL_ERROR_BSD_ESEC_ASN_CRIT_EXT_E                                (-660L) /* ASN unsupported critical extension */
N#define SL_ERROR_BSD_ESEC_ECC_BAD_ARG_E                                 (-670L) /* ECC input argument of wrong type */
N#define SL_ERROR_BSD_ESEC_ASN_ECC_KEY_E                                 (-671L) /* ASN ECC bad input */
N#define SL_ERROR_BSD_ESEC_ECC_CURVE_OID_E                               (-672L) /* Unsupported ECC OID curve type */
N#define SL_ERROR_BSD_ESEC_BAD_FUNC_ARG                                  (-673L) /* Bad function argument provided */
N#define SL_ERROR_BSD_ESEC_NOT_COMPILED_IN                               (-674L) /* Feature not compiled in */
N#define SL_ERROR_BSD_ESEC_UNICODE_SIZE_E                                (-675L) /* Unicode password too big */
N#define SL_ERROR_BSD_ESEC_NO_PASSWORD                                   (-676L) /* no password provided by user */
N#define SL_ERROR_BSD_ESEC_ALT_NAME_E                                    (-677L) /* alt name size problem, too big */
N#define SL_ERROR_BSD_ESEC_ASN_NO_SIGNER_E                               (-688L) /* ASN no signer to confirm failure */
N#define SL_ERROR_BSD_ESEC_ASN_CRL_CONFIRM_E                             (-689L) /* ASN CRL signature confirm failure */
N#define SL_ERROR_BSD_ESEC_ASN_CRL_NO_SIGNER_E                           (-690L) /* ASN CRL no signer to confirm failure */
N#define SL_ERROR_BSD_ESEC_ASN_OCSP_CONFIRM_E                            (-691L) /* ASN OCSP signature confirm failure */
N#define SL_ERROR_BSD_ESEC_VERIFY_FINISHED_ERROR                         (-704L) /* verify problem on finished */
N#define SL_ERROR_BSD_ESEC_VERIFY_MAC_ERROR                              (-705L) /* verify mac problem */
N#define SL_ERROR_BSD_ESEC_PARSE_ERROR                                   (-706L) /* parse error on header */
N#define SL_ERROR_BSD_ESEC_UNKNOWN_HANDSHAKE_TYPE                        (-707L) /* weird handshake type */
N#define SL_ERROR_BSD_ESEC_SOCKET_ERROR_E                                (-708L) /* error state on socket */
N#define SL_ERROR_BSD_ESEC_SOCKET_NODATA                                 (-709L) /* expected data, not there */
N#define SL_ERROR_BSD_ESEC_INCOMPLETE_DATA                               (-710L) /* don't have enough data to complete task */
N#define SL_ERROR_BSD_ESEC_UNKNOWN_RECORD_TYPE                           (-711L) /* unknown type in record hdr */
N#define SL_ERROR_BSD_ESEC_INNER_DECRYPT_ERROR                           (-712L) /* error during decryption */
N#define SL_ERROR_BSD_ESEC_FATAL_ERROR                                   (-713L) /* recvd alert fatal error */
N#define SL_ERROR_BSD_ESEC_ENCRYPT_ERROR                                 (-714L) /* error during encryption */
N#define SL_ERROR_BSD_ESEC_FREAD_ERROR                                   (-715L) /* fread problem */
N#define SL_ERROR_BSD_ESEC_NO_PEER_KEY                                   (-716L) /* need peer's key */
N#define SL_ERROR_BSD_ESEC_NO_PRIVATE_KEY                                (-717L) /* need the private key */
N#define SL_ERROR_BSD_ESEC_RSA_PRIVATE_ERROR                             (-718L) /* error during rsa priv op */
N#define SL_ERROR_BSD_ESEC_NO_DH_PARAMS                                  (-719L) /* server missing DH params */
N#define SL_ERROR_BSD_ESEC_BUILD_MSG_ERROR                               (-720L) /* build message failure */
N#define SL_ERROR_BSD_ESEC_BAD_HELLO                                     (-721L) /* client hello malformed */
N#define SL_ERROR_BSD_ESEC_DOMAIN_NAME_MISMATCH                          (-722L) /* peer subject name mismatch */
N#define SL_ERROR_BSD_ESEC_WANT_READ                                     (-723L) /* want read, call again */
N#define SL_ERROR_BSD_ESEC_NOT_READY_ERROR                               (-724L) /* handshake layer not ready */
N#define SL_ERROR_BSD_ESEC_PMS_VERSION_ERROR                             (-725L) /* pre m secret version error */
N#define SL_ERROR_BSD_ESEC_WANT_WRITE                                    (-727L) /* want write, call again */
N#define SL_ERROR_BSD_ESEC_BUFFER_ERROR                                  (-728L) /* malformed buffer input */
N#define SL_ERROR_BSD_ESEC_VERIFY_CERT_ERROR                             (-729L) /* verify cert error */
N#define SL_ERROR_BSD_ESEC_VERIFY_SIGN_ERROR                             (-730L) /* verify sign error */
N#define SL_ERROR_BSD_ESEC_LENGTH_ERROR                                  (-741L) /* record layer length error */
N#define SL_ERROR_BSD_ESEC_PEER_KEY_ERROR                                (-742L) /* can't decode peer key */
N#define SL_ERROR_BSD_ESEC_ZERO_RETURN                                   (-743L) /* peer sent close notify */
N#define SL_ERROR_BSD_ESEC_SIDE_ERROR                                    (-744L) /* wrong client/server type */
N#define SL_ERROR_BSD_ESEC_NO_PEER_CERT                                  (-745L) /* peer didn't send key */
N#define SL_ERROR_BSD_ESEC_ECC_CURVETYPE_ERROR                           (-750L) /* Bad ECC Curve Type */
N#define SL_ERROR_BSD_ESEC_ECC_CURVE_ERROR                               (-751L) /* Bad ECC Curve */
N#define SL_ERROR_BSD_ESEC_ECC_PEERKEY_ERROR                             (-752L) /* Bad Peer ECC Key */
N#define SL_ERROR_BSD_ESEC_ECC_MAKEKEY_ERROR                             (-753L) /* Bad Make ECC Key */
N#define SL_ERROR_BSD_ESEC_ECC_EXPORT_ERROR                              (-754L) /* Bad ECC Export Key */
N#define SL_ERROR_BSD_ESEC_ECC_SHARED_ERROR                              (-755L) /* Bad ECC Shared Secret */
N#define SL_ERROR_BSD_ESEC_NOT_CA_ERROR                                  (-757L) /* Not a CA cert error */
N#define SL_ERROR_BSD_ESEC_BAD_PATH_ERROR                                (-758L) /* Bad path for opendir */
N#define SL_ERROR_BSD_ESEC_BAD_CERT_MANAGER_ERROR                        (-759L) /* Bad Cert Manager */
N#define SL_ERROR_BSD_ESEC_OCSP_CERT_REVOKED                             (-760L) /* OCSP Certificate revoked */
N#define SL_ERROR_BSD_ESEC_CRL_CERT_REVOKED                              (-761L) /* CRL Certificate revoked */
N#define SL_ERROR_BSD_ESEC_CRL_MISSING                                   (-762L) /* CRL Not loaded */
N#define SL_ERROR_BSD_ESEC_MONITOR_RUNNING_E                             (-763L) /* CRL Monitor already running */
N#define SL_ERROR_BSD_ESEC_THREAD_CREATE_E                               (-764L) /* Thread Create Error */
N#define SL_ERROR_BSD_ESEC_OCSP_NEED_URL                                 (-765L) /* OCSP need an URL for lookup */
N#define SL_ERROR_BSD_ESEC_OCSP_CERT_UNKNOWN                             (-766L) /* OCSP responder doesn't know */
N#define SL_ERROR_BSD_ESEC_OCSP_LOOKUP_FAIL                              (-767L) /* OCSP lookup not successful */
N#define SL_ERROR_BSD_ESEC_MAX_CHAIN_ERROR                               (-768L) /* max chain depth exceeded */
N#define SL_ERROR_BSD_ESEC_NO_PEER_VERIFY                                (-778L) /* Need peer cert verify Error */
N#define SL_ERROR_BSD_ESEC_UNSUPPORTED_SUITE                             (-790L) /* unsupported cipher suite */
N#define SL_ERROR_BSD_ESEC_MATCH_SUITE_ERROR                             (-791L) /* can't match cipher suite */
N
N
N/* WLAN ERRORS CODES*/
N#define  SL_ERROR_WLAN_KEY_ERROR                                        (-2049L)
N#define  SL_ERROR_WLAN_INVALID_ROLE                                     (-2050L)
N#define  SL_ERROR_WLAN_PREFERRED_NETWORKS_FILE_LOAD_FAILED              (-2051L)
N#define  SL_ERROR_WLAN_CANNOT_CONFIG_SCAN_DURING_PROVISIONING           (-2052L)
N#define  SL_ERROR_WLAN_INVALID_SECURITY_TYPE                            (-2054L)
N#define  SL_ERROR_WLAN_PASSPHRASE_TOO_LONG                              (-2055L)
N#define  SL_ERROR_WLAN_EAP_WRONG_METHOD                                 (-2057L)
N#define  SL_ERROR_WLAN_PASSWORD_ERROR                                   (-2058L)
N#define  SL_ERROR_WLAN_EAP_ANONYMOUS_LEN_ERROR                          (-2059L)
N#define  SL_ERROR_WLAN_SSID_LEN_ERROR                                   (-2060L)
N#define  SL_ERROR_WLAN_USER_ID_LEN_ERROR                                (-2061L)
N#define  SL_ERROR_WLAN_PREFERRED_NETWORK_LIST_FULL                      (-2062L)
N#define  SL_ERROR_WLAN_PREFERRED_NETWORKS_FILE_WRITE_FAILED             (-2063L)
N#define  SL_ERROR_WLAN_ILLEGAL_WEP_KEY_INDEX                            (-2064L)
N#define  SL_ERROR_WLAN_INVALID_DWELL_TIME_VALUES                        (-2065L)
N#define  SL_ERROR_WLAN_INVALID_POLICY_TYPE                              (-2066L)
N#define  SL_ERROR_WLAN_PM_POLICY_INVALID_OPTION                         (-2067L)
N#define  SL_ERROR_WLAN_PM_POLICY_INVALID_PARAMS                         (-2068L)
N#define  SL_ERROR_WLAN_WIFI_NOT_CONNECTED                               (-2069L)
N#define  SL_ERROR_WLAN_ILLEGAL_CHANNEL                                  (-2070L)
N#define  SL_ERROR_WLAN_WIFI_ALREADY_DISCONNECTED                        (-2071L)
N#define  SL_ERROR_WLAN_TRANSCEIVER_ENABLED                              (-2072L)
N#define  SL_ERROR_WLAN_GET_NETWORK_LIST_EAGAIN                          (-2073L)
N#define  SL_ERROR_WLAN_GET_PROFILE_INVALID_INDEX                        (-2074L)
N#define  SL_ERROR_WLAN_FAST_CONN_DATA_INVALID                           (-2075L)
N#define  SL_ERROR_WLAN_NO_FREE_PROFILE                                  (-2076L)
N#define  SL_ERROR_WLAN_AP_SCAN_INTERVAL_TOO_LOW                         (-2077L)
N#define  SL_ERROR_WLAN_SCAN_POLICY_INVALID_PARAMS                       (-2078L)
N
N#define SL_RXFL_OK                                                      (0L)     /*  O.K */
N#define SL_ERROR_RXFL_RANGE_COMPARE_PARAMS_ARE_INVALID                  (-2079L)
N#define SL_ERROR_RXFL_RXFL_INVALID_PATTERN_LENGTH                       (-2080L) /* requested length for L1/L4 payload matching must not exceed 16 bytes */
N#define SL_ERROR_RXFL_ACTION_USER_EVENT_ID_TOO_BIG                      (-2081L) /* user action id for host event must not exceed SL_WLAN_RX_FILTER_MAX_USER_EVENT_ID */
N#define SL_ERROR_RXFL_OFFSET_TOO_BIG                                    (-2082L) /* requested offset for L1/L4 payload matching must not exceed 1535 bytes  */
N#define SL_ERROR_RXFL_STAT_UNSUPPORTED                                  (-2083L) /* get rx filters statistics not supported */
N#define SL_ERROR_RXFL_INVALID_FILTER_ARG_UPDATE                         (-2084L) /* invalid filter args request */
N#define SL_ERROR_RXFL_INVALID_SYSTEM_STATE_TRIGGER_FOR_FILTER_TYPE      (-2085L) /* system state not supported for this filter type */
N#define SL_ERROR_RXFL_INVALID_FUNC_ID_FOR_FILTER_TYPE                   (-2086L) /* function id not supported for this filter type */
N#define SL_ERROR_RXFL_DEPENDENT_FILTER_DO_NOT_EXIST_3                   (-2087L) /* filter parent doesn't exist */
N#define SL_ERROR_RXFL_OUTPUT_OR_INPUT_BUFFER_LENGTH_TOO_SMALL           (-2088L) /* ! The output buffer length is smaller than required for that operation */
N#define SL_ERROR_RXFL_DEPENDENT_FILTER_SOFTWARE_FILTER_NOT_FIT          (-2089L) /* Node filter can't be child of software filter and vice_versa */
N#define SL_ERROR_RXFL_DEPENDENCY_IS_NOT_PERSISTENT                      (-2090L) /*  Dependency filter is not persistent */
N#define SL_ERROR_RXFL_RXFL_ALLOCATION_PROBLEM                           (-2091L)
N#define SL_ERROR_RXFL_SYSTEM_STATE_NOT_SUPPORTED_FOR_THIS_FILTER        (-2092L) /*  System state is not supported */
N#define SL_ERROR_RXFL_TRIGGER_USE_REG5_TO_REG8                          (-2093L) /*  Only counters 5 - 8 are allowed, for Tigger */
N#define SL_ERROR_RXFL_TRIGGER_USE_REG1_TO_REG4                          (-2094L) /*  Only counters 1 - 4 are allowed, for trigger */
N#define SL_ERROR_RXFL_ACTION_USE_REG5_TO_REG8                           (-2095L) /*  Only counters 5 - 8 are allowed, for action */
N#define SL_ERROR_RXFL_ACTION_USE_REG1_TO_REG4                           (-2096L) /*  Only counters 1 - 4 are allowed, for action */
N#define SL_ERROR_RXFL_FIELD_SUPPORT_ONLY_EQUAL_AND_NOTEQUAL             (-2097L) /*  Rule compare function Id is out of range */
N#define SL_ERROR_RXFL_WRONG_MULTICAST_BROADCAST_ADDRESS                 (-2098L) /*  The address should be of type mutlicast or broadcast */
N#define SL_ERROR_RXFL_THE_FILTER_IS_NOT_OF_HEADER_TYPE                  (-2099L) /*  The filter should be of header type */
N#define SL_ERROR_RXFL_WRONG_COMPARE_FUNC_FOR_BROADCAST_ADDRESS          (-2100L) /*  The compare funcion is not suitable for broadcast address */
N#define SL_ERROR_RXFL_WRONG_MULTICAST_ADDRESS                           (-2101L) /*  The address should be of muticast type */
N#define SL_ERROR_RXFL_DEPENDENT_FILTER_IS_NOT_PERSISTENT                (-2102L) /*  The dependency filter is not persistent */
N#define SL_ERROR_RXFL_DEPENDENT_FILTER_IS_NOT_ENABLED                   (-2103L) /*  The dependency filter is not enabled */
N#define SL_ERROR_RXFL_FILTER_HAS_CHILDS                                 (-2104L) /*  The filter has childs and can't be removed */
N#define SL_ERROR_RXFL_CHILD_IS_ENABLED                                  (-2105L) /*  Can't disable filter while the child is enabled */
N#define SL_ERROR_RXFL_DEPENDENCY_IS_DISABLED                            (-2106L) /*  Can't enable filetr in case its depndency filter is disabled */
N#define SL_ERROR_RXFL_MAC_SEND_MATCHDB_FAILED                           (-2107L)
N#define SL_ERROR_RXFL_MAC_SEND_ARG_DB_FAILED                            (-2108L)
N#define SL_ERROR_RXFL_MAC_SEND_NODEDB_FAILED                            (-2109L)
N#define SL_ERROR_RXFL_MAC_OPERTATION_RESUME_FAILED                      (-2110L)
N#define SL_ERROR_RXFL_MAC_OPERTATION_HALT_FAILED                        (-2111L)
N#define SL_ERROR_RXFL_NUMBER_OF_CONNECTION_POINTS_EXCEEDED              (-2112L) /*  Number of connection points exceeded */
N#define SL_ERROR_RXFL_DEPENDENT_FILTER_DEPENDENCY_ACTION_IS_DROP        (-2113L) /*  The dependent filter has Drop action, thus the filter can't be created */
N#define SL_ERROR_RXFL_FILTER_DO_NOT_EXISTS                              (-2114L) /*  The filter doesn't exists */
N#define SL_ERROR_RXFL_DEPEDENCY_NOT_ON_THE_SAME_LAYER                   (-2115L) /*  The filter and its dependency must be on the same layer */
N#define SL_ERROR_RXFL_NUMBER_OF_ARGS_EXCEEDED                           (-2116L) /*  Number of arguments excceded */
N#define SL_ERROR_RXFL_ACTION_NO_REG_NUMBER                              (-2117L) /*  Action require counter number */
N#define SL_ERROR_RXFL_DEPENDENT_FILTER_LAYER_DO_NOT_FIT                 (-2118L) /*  the filter and its dependency should be from the same layer */
N#define SL_ERROR_RXFL_DEPENDENT_FILTER_SYSTEM_STATE_DO_NOT_FIT          (-2119L) /*  The filter and its dependency system state don't fit  */
N#define SL_ERROR_RXFL_DEPENDENT_FILTER_DO_NOT_EXIST_2                   (-2120L) /*  The parent filter don't exist  */
N#define SL_ERROR_RXFL_DEPENDENT_FILTER_DO_NOT_EXIST_1                   (-2121L) /*  The parent filter is null */
N#define SL_ERROR_RXFL_RULE_HEADER_ACTION_TYPE_NOT_SUPPORTED             (-2122L) /*  The action type is not supported */
N#define SL_ERROR_RXFL_RULE_HEADER_TRIGGER_COMPARE_FUNC_OUT_OF_RANGE     (-2123L) /*  The Trigger comparision function is out of range */
N#define SL_ERROR_RXFL_RULE_HEADER_TRIGGER_OUT_OF_RANGE                  (-2124L) /*  The Trigger is out of range */
N#define SL_ERROR_RXFL_RULE_HEADER_COMPARE_FUNC_OUT_OF_RANGE             (-2125L) /*  The rule compare function is out of range */
N#define SL_ERROR_RXFL_FRAME_TYPE_NOT_SUPPORTED                          (-2126L) /*  ASCII frame type string is illegal */
N#define SL_ERROR_RXFL_RULE_FIELD_ID_NOT_SUPPORTED                       (-2127L) /*  Rule field ID is out of range */
N#define SL_ERROR_RXFL_RULE_HEADER_FIELD_ID_ASCII_NOT_SUPPORTED          (-2128L) /*  This ASCII field ID is not supported */
N#define SL_ERROR_RXFL_RULE_HEADER_NOT_SUPPORTED                         (-2129L) /*  The header rule is not supported on current release */
N#define SL_ERROR_RXFL_RULE_HEADER_OUT_OF_RANGE                          (-2130L) /*  The header rule is out of range */
N#define SL_ERROR_RXFL_RULE_HEADER_COMBINATION_OPERATOR_OUT_OF_RANGE     (-2131L) /*  Combination function Id is out of ramge */
N#define SL_ERROR_RXFL_RULE_HEADER_FIELD_ID_OUT_OF_RANGE                 (-2132L) /*  rule field Id is out of range */
N#define SL_ERROR_RXFL_UPDATE_NOT_SUPPORTED                              (-2133L) /*  Update not supported */
N#define SL_ERROR_RXFL_NO_FILTER_DATABASE_ALLOCATE                       (-2134L)
N#define SL_ERROR_RXFL_ALLOCATION_FOR_GLOBALS_STRUCTURE_FAILED           (-2135L)
N#define SL_ERROR_RXFL_ALLOCATION_FOR_DB_NODE_FAILED                     (-2136L)
N#define SL_ERROR_RXFL_READ_FILE_FILTER_ID_ILLEGAL                       (-2137L)
N#define SL_ERROR_RXFL_READ_FILE_NUMBER_OF_FILTER_FAILED                 (-2138L)
N#define SL_ERROR_RXFL_READ_FILE_FAILED                                  (-2139L)
N#define SL_ERROR_RXFL_NO_FILTERS_ARE_DEFINED                            (-2140L) /*  No filters are defined in the system */
N#define SL_ERROR_RXFL_NUMBER_OF_FILTER_EXCEEDED                         (-2141L) /*  Number of max filters excceded */
N#define SL_ERROR_RXFL_BAD_FILE_MODE                                     (-2142L)
N#define SL_ERROR_RXFL_FAILED_READ_NVFILE                                (-2143L)
N#define SL_ERROR_RXFL_FAILED_INIT_STORAGE                               (-2144L)
N#define SL_ERROR_RXFL_CONTINUE_WRITE_MUST_BE_MOD_4                      (-2145L)
N#define SL_ERROR_RXFL_FAILED_LOAD_FILE                                  (-2146L)
N#define SL_ERROR_RXFL_INVALID_HANDLE                                    (-2147L)
N#define SL_ERROR_RXFL_FAILED_TO_WRITE                                   (-2148L)
N#define SL_ERROR_RXFL_OFFSET_OUT_OF_RANGE                               (-2149L)
N#define SL_ERROR_RXFL_ALLOC                                             (-2150L)
N#define SL_ERROR_RXFL_READ_DATA_LENGTH                                  (-2151L)
N#define SL_ERROR_RXFL_INVALID_FILE_ID                                   (-2152L)
N#define SL_ERROR_RXFL_FILE_FILTERS_NOT_EXISTS                           (-2153L)
N#define SL_ERROR_RXFL_FILE_ALREADY_IN_USE                               (-2154L)
N#define SL_ERROR_RXFL_INVALID_ARGS                                      (-2155L)
N#define SL_ERROR_RXFL_FAILED_TO_CREATE_FILE                             (-2156L)
N#define SL_ERROR_RXFL_FS_ALREADY_LOADED                                 (-2157L)
N#define SL_ERROR_RXFL_UNKNOWN                                           (-2158L)
N#define SL_ERROR_RXFL_FAILED_TO_CREATE_LOCK_OBJ                         (-2159L)
N#define SL_ERROR_RXFL_DEVICE_NOT_LOADED                                 (-2160L)
N#define SL_ERROR_RXFL_INVALID_MAGIC_NUM                                 (-2161L)
N#define SL_ERROR_RXFL_FAILED_TO_READ                                    (-2162L)
N#define SL_ERROR_RXFL_NOT_SUPPORTED                                     (-2163L)
N#define SL_ERROR_WLAN_INVALID_COUNTRY_CODE                              (-2164L)
N#define SL_ERROR_WLAN_NVMEM_ACCESS_FAILED                               (-2165L)
N#define SL_ERROR_WLAN_OLD_FILE_VERSION                                  (-2166L)
N#define SL_ERROR_WLAN_TX_POWER_OUT_OF_RANGE                             (-2167L)
N#define SL_ERROR_WLAN_INVALID_AP_PASSWORD_LENGTH                        (-2168L)
N#define SL_ERROR_WLAN_PROVISIONING_ABORT_PROVISIONING_ALREADY_STARTED   (-2169L)
N#define SL_ERROR_WLAN_PROVISIONING_ABORT_HTTP_SERVER_DISABLED           (-2170L)
N#define SL_ERROR_WLAN_PROVISIONING_ABORT_PROFILE_LIST_FULL              (-2171L)
N#define SL_ERROR_WLAN_PROVISIONING_ABORT_INVALID_PARAM                  (-2172L)
N#define SL_ERROR_WLAN_PROVISIONING_ABORT_GENERAL_ERROR                  (-2173L)
N#define SL_ERROR_WLAN_MULTICAST_EXCEED_MAX_ADDR                         (-2174L)
N#define SL_ERROR_WLAN_MULTICAST_INVAL_ADDR                              (-2175L)
N#define SL_ERROR_WLAN_AP_SCAN_INTERVAL_TOO_SHORT                        (-2176L)
N#define SL_ERROR_WLAN_PROVISIONING_CMD_NOT_EXPECTED                     (-2177L)
N
N
N#define SL_ERROR_WLAN_AP_ACCESS_LIST_NO_ADDRESS_TO_DELETE               (-2178L) /*  List is empty, no address to delete */
N#define SL_ERROR_WLAN_AP_ACCESS_LIST_FULL                               (-2179L) /*  access list is full */
N#define SL_ERROR_WLAN_AP_ACCESS_LIST_DISABLED                           (-2180L) /*  access list is disabled */
N#define SL_ERROR_WLAN_AP_ACCESS_LIST_MODE_NOT_SUPPORTED                 (-2181L) /*  Trying to switch to unsupported mode */
N#define SL_ERROR_WLAN_AP_STA_NOT_FOUND                                  (-2182L) /*  trying to disconnect station which is not connected */
N
N
N/* DEVICE ERRORS CODES*/
N#define SL_ERROR_SUPPLICANT_ERROR                                       (-4097L)
N#define SL_ERROR_HOSTAPD_INIT_FAIL                                      (-4098L)
N#define SL_ERROR_HOSTAPD_INIT_IF_FAIL                                   (-4099L)
N#define SL_ERROR_WLAN_DRV_INIT_FAIL                                     (-4100L)
N#define SL_ERROR_FS_FILE_TABLE_LOAD_FAILED                              (-4102L) /*  init file system failed */
N#define SL_ERROR_MDNS_ENABLE_FAIL                                       (-4103L) /*  mDNS enable failed */
N#define SL_ERROR_ROLE_STA_ERR                                           (-4107L) /*  Failure to load MAC/PHY in STA role */
N#define SL_ERROR_ROLE_AP_ERR                                            (-4108L) /*  Failure to load MAC/PHY in AP role */
N#define SL_ERROR_ROLE_P2P_ERR                                           (-4109L) /*  Failure to load MAC/PHY in P2P role */
N#define SL_ERROR_CALIB_FAIL                                             (-4110L) /*  Failure of calibration */
N#define SL_ERROR_FS_CORRUPTED_ERR                                       (-4111L) /*  FS is corrupted, Return to Factory Image or Program new image should be invoked (see sl_FsCtl, sl_FsProgram) */
N#define SL_ERROR_FS_ALERT_ERR                                           (-4112L) /*  Device is locked, Return to Factory Image or Program new image should be invoked (see sl_FsCtl, sl_FsProgram) */
N#define SL_ERROR_RESTORE_IMAGE_COMPLETE                                 (-4113L) /*  Return to factory image completed, perform reset */
N#define SL_ERROR_UNKNOWN_ERR                                            (-4114L)
N#define SL_ERROR_GENERAL_ERR                                            (-4115L) /*  General error during init */
N#define SL_ERROR_WRONG_ROLE                                             (-4116L)
N#define SL_ERROR_INCOMPLETE_PROGRAMMING                                 (-4117L) /*  Error during programming, Program new image should be invoked (see sl_FsProgram) */
N
N
N#define SL_ERROR_PENDING_TXRX_STOP_TIMEOUT_EXP                          (-4118L) /*  Timeout expired before completing all TX\RX */
N#define SL_ERROR_PENDING_TXRX_NO_TIMEOUT                                (-4119L) /*  No Timeout , still have pending  TX\RX */
N#define SL_ERROR_INVALID_PERSISTENT_CONFIGURATION                       (-4120L) /*  persistency configuration can only be set to 0 (disabled) or 1 (enabled) */
N
N/* NETAPP ERRORS CODES*/
N#define SL_ERROR_MDNS_CREATE_FAIL                                       (-6145L) /*  mDNS create failed */
N#define SL_ERROR_DEVICE_NAME_LEN_ERR                                    (-6146L) /*  Set Dev name error codes */
N#define SL_ERROR_DEVICE_NAME_INVALID                                    (-6147L) /*  Set Dev name error codes */
N#define SL_ERROR_DOMAIN_NAME_LEN_ERR                                    (-6148L) /*  Set domain name error codes */
N#define SL_ERROR_DOMAIN_NAME_INVALID                                    (-6149L) /*  Set domain name error codes */
N#define SL_ERROR_NET_APP_DNS_QUERY_NO_RESPONSE                          (-6150L) /*  DNS query failed, no response */
N#define SL_ERROR_NET_APP_DNS_ERROR                                      (-6151L) /*  DNS internal error */
N#define SL_ERROR_NET_APP_DNS_NO_SERVER                                  (-6152L) /*  No DNS server was specified */
N#define SL_ERROR_NET_APP_DNS_TIMEOUTR                                   (-6153L) /*  mDNS parameters error */
N#define SL_ERROR_NET_APP_DNS_QUERY_FAILED                               (-6154L) /*  DNS query failed; no DNS server sent an 'answer' */
N#define SL_ERROR_NET_APP_DNS_BAD_ADDRESS_ERROR                          (-6155L) /*  Improperly formatted IPv4 or IPv6 address  */
N#define SL_ERROR_NET_APP_DNS_SIZE_ERROR                                 (-6156L) /*  DNS destination size is too small */
N#define SL_ERROR_NET_APP_DNS_MALFORMED_PACKET                           (-6157L) /*  Improperly formed or corrupted DNS packet received */
N#define SL_ERROR_NET_APP_DNS_BAD_ID_ERROR                               (-6158L) /*  DNS packet from server does not match query ID */
N#define SL_ERROR_NET_APP_DNS_PARAM_ERROR                                (-6159L) /*  Invalid params */
N#define SL_ERROR_NET_APP_DNS_SERVER_NOT_FOUND                           (-6160L) /*  Server not found in Client list of DNS servers */
N#define SL_ERROR_NET_APP_DNS_PACKET_CREATE_ERROR                        (-6161L) /*  Error creating DNS packet */
N#define SL_ERROR_NET_APP_DNS_EMPTY_DNS_SERVER_LIST                      (-6162L) /*  DNS Client's list of DNS servers is empty */
N#define SL_ERROR_NET_APP_DNS_SERVER_AUTH_ERROR                          (-6163L) /*  Server not able to authenticate answer/authority data */
N#define SL_ERROR_NET_APP_DNS_ZERO_GATEWAY_IP_ADDRESS                    (-6164L) /*  DNS Client IP instance has a zero gateway IP address  */
N#define SL_ERROR_NET_APP_DNS_MISMATCHED_RESPONSE                        (-6165L) /*  Server response type does not match the query request */
N#define SL_ERROR_NET_APP_DNS_DUPLICATE_ENTRY                            (-6166L) /*  Duplicate entry exists in DNS server table */
N#define SL_ERROR_NET_APP_DNS_RETRY_A_QUERY                              (-6167L) /*  SOA status returned; web site only exists as IPv4 */
N#define SL_ERROR_NET_APP_DNS_INVALID_ADDRESS_TYPE                       (-6168L) /*  IP address type (e.g. IPv6L) not supported */
N#define SL_ERROR_NET_APP_DNS_IPV6_NOT_SUPPORTED                         (-6169L) /*  IPv6 disabled */
N#define SL_ERROR_NET_APP_DNS_NEED_MORE_RECORD_BUFFER                    (-6170L) /*  The buffer size is not enough. */
N#define SL_ERROR_NET_APP_MDNS_ERROR                                     (-6171L) /*  MDNS internal error. */
N#define SL_ERROR_NET_APP_MDNS_PARAM_ERROR                               (-6172L) /*  MDNS parameters error. */
N#define SL_ERROR_NET_APP_MDNS_CACHE_ERROR                               (-6173L) /*  The Cache size is not enough. */
N#define SL_ERROR_NET_APP_MDNS_UNSUPPORTED_TYPE                          (-6174L) /*  The unsupported resource record type. */
N#define SL_ERROR_NET_APP_MDNS_DATA_SIZE_ERROR                           (-6175L) /*  The data size is too big. */
N#define SL_ERROR_NET_APP_MDNS_AUTH_ERROR                                (-6176L) /*  Attempting to parse too large a data. */
N#define SL_ERROR_NET_APP_MDNS_PACKET_ERROR                              (-6177L) /*  The packet can not add the resource record. */
N#define SL_ERROR_NET_APP_MDNS_DEST_ADDRESS_ERROR                        (-6178L) /*  The destination address error. */
N#define SL_ERROR_NET_APP_MDNS_UDP_PORT_ERROR                            (-6179L) /*  The udp port error. */
N#define SL_ERROR_NET_APP_MDNS_NOT_LOCAL_LINK                            (-6180L) /*  The message that not originate from the local link. */
N#define SL_ERROR_NET_APP_MDNS_EXCEED_MAX_LABEL                          (-6181L) /*  The data exceed the max laber size. */
N#define SL_ERROR_NET_APP_MDNS_EXIST_UNIQUE_RR                           (-6182L) /*  At least one Unqiue record in the cache. */
N#define SL_ERROR_NET_APP_MDNS_EXIST_ANSWER                              (-6183L) /*  At least one answer record in the cache. */
N#define SL_ERROR_NET_APP_MDNS_EXIST_SAME_QUERY                          (-6184L) /*  Exist the same query. */
N#define SL_ERROR_NET_APP_MDNS_DUPLICATE_SERVICE                         (-6185L) /*  Duplicate service. */
N#define SL_ERROR_NET_APP_MDNS_NO_ANSWER                                 (-6186L) /*  No response for one-shot query. */
N#define SL_ERROR_NET_APP_MDNS_NO_KNOWN_ANSWER                           (-6187L) /*  No known answer for query. */
N#define SL_ERROR_NET_APP_MDNS_NAME_MISMATCH                             (-6188L) /*  The name mismatch. */
N#define SL_ERROR_NET_APP_MDNS_NOT_STARTED                               (-6189L) /*  MDNS does not start. */
N#define SL_ERROR_NET_APP_MDNS_HOST_NAME_ERROR                           (-6190L) /*  MDNS host name error. */
N#define SL_ERROR_NET_APP_MDNS_NO_MORE_ENTRIES                           (-6191L) /*  No more entries be found. */
N#define SL_ERROR_NET_APP_MDNS_SERVICE_TYPE_MISMATCH                     (-6192L) /*  The service type mismatch */
N#define SL_ERROR_NET_APP_MDNS_LOOKUP_INDEX_ERROR                        (-6193L) /*  Index is bigger than number of services. */
N#define SL_ERROR_NET_APP_MDNS_MAX_SERVICES_ERROR                        (-6194L)
N#define SL_ERROR_NET_APP_MDNS_IDENTICAL_SERVICES_ERROR                  (-6195L)
N#define SL_ERROR_NET_APP_MDNS_EXISTED_SERVICE_ERROR                     (-6196L)
N#define SL_ERROR_NET_APP_MDNS_ERROR_SERVICE_NAME_ERROR                  (-6197L)
N#define SL_ERROR_NET_APP_MDNS_RX_PACKET_ALLOCATION_ERROR                (-6198L)
N#define SL_ERROR_NET_APP_MDNS_BUFFER_SIZE_ERROR                         (-6199L)
N#define SL_ERROR_NET_APP_MDNS_NET_APP_SET_ERROR                         (-6200L)
N#define SL_ERROR_NET_APP_MDNS_GET_SERVICE_LIST_FLAG_ERROR               (-6201L)
N#define SL_ERROR_NET_APP_MDNS_MDNS_NO_CONFIGURATION_ERROR               (-6202L)
N#define SL_ERROR_NET_APP_MDNS_STATUS_ERROR                              (-6203L)
N#define SL_ERROR_NET_APP_ENOBUFS                                        (-6204L)
N#define SL_ERROR_NET_APP_DNS_IPV6_REQ_BUT_IPV6_DISABLED                 (-6205L) /*  trying to issue ipv6 DNS request but ipv6 is disabled */
N#define SL_ERROR_NET_APP_DNS_INVALID_FAMILY_TYPE                        (-6206L) /*  Family type is not ipv4 and not ipv6 */
N#define SL_ERROR_NET_APP_DNS_REQ_TOO_BIG                                (-6207L) /*  DNS request size is too big */
N#define SL_ERROR_NET_APP_DNS_ALLOC_ERROR                                (-6208L) /*  Allocation error */
N#define SL_ERROR_NET_APP_DNS_EXECUTION_ERROR                            (-6209L) /*  Execution error */
N#define SL_ERROR_NET_APP_P2P_ROLE_IS_NOT_CONFIGURED                     (-6210L) /*  role p2p is not configured yet, should be CL or GO in order to execute command */
N#define SL_ERROR_NET_APP_INCORECT_ROLE_FOR_APP                          (-6211L) /*  incorrect role for specific application */
N#define SL_ERROR_NET_APP_INCORECT_APP_MASK                              (-6212L) /*  mask does not match any app */
N#define SL_ERROR_NET_APP_MDNS_ALREADY_STARTED                           (-6213L) /*  mdns application already started */
N#define SL_ERROR_NET_APP_HTTP_SERVER_ALREADY_STARTED                    (-6214L) /*  http server application already started */
N
N#define SL_ERROR_NET_APP_HTTP_GENERAL_ERROR                             (-6216L) /*  New error - Http handle request failed */
N#define SL_ERROR_NET_APP_HTTP_INVALID_TIMEOUT                           (-6217L) /*  New error - Http timeout invalid argument */
N#define SL_ERROR_NET_APP_INVALID_URN_LENGTH                             (-6218L) /*  invalid URN length  */
N#define SL_ERROR_NET_APP_RX_BUFFER_LENGTH                               (-6219L) /*  size of the requested services is smaller than size of the user buffer */
N
N/* NETCFG ERRORS CODES*/
N#define SL_ERROR_STATIC_ADDR_SUBNET_ERROR                               (-8193L)
N#define SL_ERROR_INCORRECT_IPV6_STATIC_LOCAL_ADDR                       (-8194L) /*  Ipv6 Local address perfix is wrong */
N#define SL_ERROR_INCORRECT_IPV6_STATIC_GLOBAL_ADDR                      (-8195L) /*  Ipv6 Global address perfix is wrong */
N#define SL_ERROR_IPV6_LOCAL_ADDR_SHOULD_BE_SET_FIRST                    (-8195L) /*  Attempt to set ipv6 global address before ipv6 local address is set */
N
N
N/* FS ERRORS CODES*/
N#define SL_FS_OK                                                        (0L)
N#define SL_ERROR_FS_EXTRACTION_WILL_START_AFTER_RESET                   (-10241L)
N#define SL_ERROR_FS_NO_CERTIFICATE_STORE                                (-10242L)
N#define SL_ERROR_FS_IMAGE_SHOULD_BE_AUTHENTICATE                        (-10243L)
N#define SL_ERROR_FS_IMAGE_SHOULD_BE_ENCRYPTED                           (-10244L)
N#define SL_ERROR_FS_IMAGE_CANT_BE_ENCRYPTED                             (-10245L)
N#define SL_ERROR_FS_DEVELOPMENT_BOARD_WRONG_MAC                         (-10246L)
N#define SL_ERROR_FS_DEVICE_NOT_SECURED                                  (-10247L)
N#define SL_ERROR_FS_SYSTEM_FILE_ACCESS_DENIED                           (-10248L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_EXPECTING_USER_KEY                    (-10249L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_CLOSE_FILE                  (-10250L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_WRITE_FILE                  (-10251L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_OPEN_FILE                   (-10252L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_GET_IMAGE_HEADER            (-10253L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_GET_IMAGE_INFO              (-10254L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_SET_ID_NOT_EXIST                      (-10255L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_DELETE_FILE                 (-10256L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_FORMAT_FS                   (-10257L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_LOAD_FS                     (-10258L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_GET_DEV_INFO                (-10259L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_DELETE_STORAGE              (-10260L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_INCORRECT_IMAGE_LOCATION              (-10261L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_CREATE_IMAGE_FILE           (-10262L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_INIT                        (-10263L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_LOAD_FILE_TABLE             (-10264L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_ILLEGAL_COMMAND                       (-10266L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_WRITE_FAT                   (-10267L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_RET_FACTORY_DEFAULT         (-10268L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_FAILED_TO_READ_NV                     (-10269L)
N#define SL_ERROR_FS_PROGRAMMING_IMAGE_NOT_EXISTS                        (-10270L)
N#define SL_ERROR_FS_PROGRAMMING_IN_PROCESS                              (-10271L)
N#define SL_ERROR_FS_PROGRAMMING_ALREADY_STARTED                         (-10272L)
N#define SL_ERROR_FS_CERT_IN_THE_CHAIN_REVOKED_SECURITY_ALERT            (-10273L)
N#define SL_ERROR_FS_INIT_CERTIFICATE_STORE                              (-10274L)
N#define SL_ERROR_FS_PROGRAMMING_ILLEGAL_FILE                            (-10275L)
N#define SL_ERROR_FS_PROGRAMMING_NOT_STARTED                             (-10276L)
N#define SL_ERROR_FS_IMAGE_EXTRACT_NO_FILE_SYSTEM                        (-10277L)
N#define SL_ERROR_FS_WRONG_INPUT_SIZE                                    (-10278L)
N#define SL_ERROR_FS_BUNDLE_FILE_SHOULD_BE_CREATED_WITH_FAILSAFE         (-10279L)
N#define SL_ERROR_FS_BUNDLE_NOT_CONTAIN_FILES                            (-10280L)
N#define SL_ERROR_FS_BUNDLE_ALREADY_IN_STATE                             (-10281L)
N#define SL_ERROR_FS_BUNDLE_NOT_IN_CORRECT_STATE                         (-10282L)
N#define SL_ERROR_FS_BUNDLE_FILES_ARE_OPENED                             (-10283L)
N#define SL_ERROR_FS_INCORRECT_FILE_STATE_FOR_OPERATION                  (-10284L)
N#define SL_ERROR_FS_EMPTY_SFLASH                                        (-10285L)
N#define SL_ERROR_FS_FILE_IS_NOT_SECURE_AND_SIGN                         (-10286L)
N#define SL_ERROR_FS_ROOT_CA_IS_UNKOWN                                   (-10287L)
N#define SL_ERROR_FS_FILE_HAS_NOT_BEEN_CLOSE_CORRECTLY                   (-10288L)
N#define SL_ERROR_FS_WRONG_SIGNATURE_SECURITY_ALERT                      (-10289L)
N#define SL_ERROR_FS_WRONG_SIGNATURE_OR_CERTIFIC_NAME_LENGTH             (-10290L)
N#define SL_ERROR_FS_NOT_16_ALIGNED                                      (-10291L)
N#define SL_ERROR_FS_CERT_CHAIN_ERROR_SECURITY_ALERT                     (-10292L)
N#define SL_ERROR_FS_FILE_NAME_EXIST                                     (-10293L)
N#define SL_ERROR_FS_EXTENDED_BUF_ALREADY_ALLOC                          (-10294L)
N#define SL_ERROR_FS_FILE_SYSTEM_NOT_SECURED                             (-10295L)
N#define SL_ERROR_FS_OFFSET_NOT_16_BYTE_ALIGN                            (-10296L)
N#define SL_ERROR_FS_FAILED_READ_NVMEM                                   (-10297L)
N#define SL_ERROR_FS_WRONG_FILE_NAME                                     (-10298L)
N#define SL_ERROR_FS_FILE_SYSTEM_IS_LOCKED                               (-10299L)
N#define SL_ERROR_FS_SECURITY_ALERT                                      (-10300L)
N#define SL_ERROR_FS_FILE_INVALID_FILE_SIZE                              (-10301L)
N#define SL_ERROR_FS_INVALID_TOKEN                                       (-10302L)
N#define SL_ERROR_FS_NO_DEVICE_IS_LOADED                                 (-10303L)
N#define SL_ERROR_FS_SECURE_CONTENT_INTEGRITY_FAILURE                    (-10304L)
N#define SL_ERROR_FS_SECURE_CONTENT_RETRIVE_ASYMETRIC_KEY_ERROR          (-10305L)
N#define SL_ERROR_FS_OVERLAP_DETECTION_THRESHHOLD                        (-10306L)
N#define SL_ERROR_FS_FILE_HAS_RESERVED_NV_INDEX                          (-10307L)
N#define SL_ERROR_FS_FILE_MAX_SIZE_EXCEEDED                              (-10310L)
N#define SL_ERROR_FS_INVALID_READ_BUFFER                                 (-10311L)
N#define SL_ERROR_FS_INVALID_WRITE_BUFFER                                (-10312L)
N#define SL_ERROR_FS_FILE_IMAGE_IS_CORRUPTED                             (-10313L)
N#define SL_ERROR_FS_SIZE_OF_FILE_EXT_EXCEEDED                           (-10314L)
N#define SL_ERROR_FS_WARNING_FILE_NAME_NOT_KEPT                          (-10315L)
N#define SL_ERROR_FS_MAX_OPENED_FILE_EXCEEDED                            (-10316L)
N#define SL_ERROR_FS_FAILED_WRITE_NVMEM_HEADER                           (-10317L)
N#define SL_ERROR_FS_NO_AVAILABLE_NV_INDEX                               (-10318L)
N#define SL_ERROR_FS_FAILED_TO_ALLOCATE_MEM                              (-10319L)
N#define SL_ERROR_FS_OPERATION_BLOCKED_BY_VENDOR                         (-10320L)
N#define SL_ERROR_FS_FAILED_TO_READ_NVMEM_FILE_SYSTEM                    (-10321L)
N#define SL_ERROR_FS_NOT_ENOUGH_STORAGE_SPACE                            (-10322L)
N#define SL_ERROR_FS_INIT_WAS_NOT_CALLED                                 (-10323L)
N#define SL_ERROR_FS_FILE_SYSTEM_IS_BUSY                                 (-10324L)
N#define SL_ERROR_FS_INVALID_ACCESS_TYPE                                 (-10325L)
N#define SL_ERROR_FS_FILE_ALREADY_EXISTS                                 (-10326L)
N#define SL_ERROR_FS_PROGRAM_FAILURE                                     (-10327L)
N#define SL_ERROR_FS_NO_ENTRIES_AVAILABLE                                (-10328L)
N#define SL_ERROR_FS_FILE_ACCESS_IS_DIFFERENT                            (-10329L)
N#define SL_ERROR_FS_UNVALID_FILE_MODE                                   (-10330L)
N#define SL_ERROR_FS_FAILED_READ_NVFILE                                  (-10331L)
N#define SL_ERROR_FS_FAILED_INIT_STORAGE                                 (-10332L)
N#define SL_ERROR_FS_FILE_HAS_NO_FAILSAFE                                (-10333L)
N#define SL_ERROR_FS_NO_VALID_COPY_EXISTS                                (-10334L)
N#define SL_ERROR_FS_INVALID_HANDLE                                      (-10335L)
N#define SL_ERROR_FS_FAILED_TO_WRITE                                     (-10336L)
N#define SL_ERROR_FS_OFFSET_OUT_OF_RANGE                                 (-10337L)
N#define SL_ERROR_FS_NO_MEMORY                                           (-10338L)
N#define SL_ERROR_FS_INVALID_LENGTH_FOR_READ                             (-10339L)
N#define SL_ERROR_FS_WRONG_FILE_OPEN_FLAGS                               (-10340L)
N#define SL_ERROR_FS_FILE_NOT_EXISTS                                     (-10341L)
N#define SL_ERROR_FS_IGNORE_COMMIT_ROLLBAC_FLAG                          (-10342L) /* commit rollback flag is not supported upon creation */
N#define SL_ERROR_FS_INVALID_ARGS                                        (-10343L)
N#define SL_ERROR_FS_FILE_IS_PENDING_COMMIT                              (-10344L)
N#define SL_ERROR_FS_SECURE_CONTENT_SESSION_ALREADY_EXIST                (-10345L)
N#define SL_ERROR_FS_UNKNOWN                                             (-10346L)
N#define SL_ERROR_FS_FILE_NAME_RESERVED                                  (-10347L)
N#define SL_ERROR_FS_NO_FILE_SYSTEM                                      (-10348L)
N#define SL_ERROR_FS_INVALID_MAGIC_NUM                                   (-10349L)
N#define SL_ERROR_FS_FAILED_TO_READ_NVMEM                                (-10350L)
N#define SL_ERROR_FS_NOT_SUPPORTED                                       (-10351L)
N#define SL_ERROR_FS_JTAG_IS_OPENED_NO_FORMAT_TO_PRDUCTION               (-10352L)
N#define SL_ERROR_FS_CONFIG_FILE_RET_READ_FAILED                         (-10353L)
N#define SL_ERROR_FS_CONFIG_FILE_CHECSUM_ERROR_SECURITY_ALERT            (-10354L)
N#define SL_ERROR_FS_CONFIG_FILE_NO_SUCH_FILE                            (-10355L)
N#define SL_ERROR_FS_CONFIG_FILE_MEMORY_ALLOCATION_FAILED                (-10356L)
N#define SL_ERROR_FS_IMAGE_HEADER_READ_FAILED                            (-10357L)
N#define SL_ERROR_FS_CERT_STORE_DOWNGRADE                                (-10358L)
N#define SL_ERROR_FS_PROGRAMMING_IMAGE_NOT_VALID                         (-10359L)
N#define SL_ERROR_FS_PROGRAMMING_IMAGE_NOT_VERIFIED                      (-10360L)
N#define SL_ERROR_FS_RESERVE_SIZE_IS_SMALLER                             (-10361L)
N#define SL_ERROR_FS_WRONG_ALLOCATION_TABLE                              (-10362L)
N#define SL_ERROR_FS_ILLEGAL_SIGNATURE                                   (-10363L)
N#define SL_ERROR_FS_FILE_ALREADY_OPENED_IN_PENDING_STATE                (-10364L)
N#define SL_ERROR_FS_INVALID_TOKEN_SECURITY_ALERT                        (-10365L)
N#define SL_ERROR_FS_NOT_SECURE                                          (-10366L)
N#define SL_ERROR_FS_RESET_DURING_PROGRAMMING                            (-10367L)
N#define SL_ERROR_FS_CONFIG_FILE_RET_WRITE_FAILED                        (-10368L)
N#define SL_ERROR_FS_FILE_IS_ALREADY_OPENED                              (-10369L)
N#define SL_ERROR_FS_FILE_IS_OPEN_FOR_WRITE                              (-10370L)
N#define SL_ERROR_FS_ALERT_CANT_BE_SET_ON_NON_SECURE_DEVICE              (-10371L) /* Alerts can be configured on non-secure device. */
N#define SL_ERROR_FS_WRONG_CERTIFICATE_FILE_NAME                         (-10372L)
N
N
N/* NETUTIL ERRORS CODES */
N#define SL_ERROR_NETUTIL_CRYPTO_GENERAL                                 (-12289L)
N#define SL_ERROR_NETUTIL_CRYPTO_INVALID_INDEX                           (-12290L)
N#define SL_ERROR_NETUTIL_CRYPTO_INVALID_PARAM                           (-12291L)
N#define SL_ERROR_NETUTIL_CRYPTO_MEM_ALLOC                               (-12292L)
N#define SL_ERROR_NETUTIL_CRYPTO_INVALID_DB_VER                          (-12293L)
N#define SL_ERROR_NETUTIL_CRYPTO_UNSUPPORTED_OPTION                      (-12294L)
N#define SL_ERROR_NETUTIL_CRYPTO_BUFFER_TOO_SMALL                        (-12295L)
N#define SL_ERROR_NETUTIL_CRYPTO_EMPTY_DB_ENTRY                          (-12296L)
N#define SL_ERROR_NETUTIL_CRYPTO_NON_TEMPORARY_KEY                       (-12297L)
N#define SL_ERROR_NETUTIL_CRYPTO_DB_ENTRY_NOT_FREE                       (-12298L)
N#define SL_ERROR_NETUTIL_CRYPTO_CORRUPTED_DB_FILE                       (-12299L)
N
N
N/* GENERAL ERRORS CODES*/
N#define SL_ERROR_INVALID_OPCODE                                         (-14337L)
N#define SL_ERROR_INVALID_PARAM                                          (-14338L)
N#define SL_ERROR_STATUS_ERROR                                           (-14341L)
N#define SL_ERROR_NVMEM_ACCESS_FAILED                                    (-14342L)
N#define SL_ERROR_NOT_ALLOWED_NWP_LOCKED                                 (-14343L) /* Device is locked, Return to Factory Image or Program new image should be invoked (see sl_FsCtl, sl_FsProgram) */
N
N
N/* SECURITY ERRORS CODE */
N#define SL_ERROR_LOADING_CERTIFICATE_STORE                              (-28673L)
N
N/* Device is Locked! Return to Factory Image or Program new
N   image should be invoked (see sl_FsCtl, sl_FsProgram) */
N#define SL_ERROR_DEVICE_LOCKED_SECURITY_ALERT                           (-28674L)
N
N#define SL_ERROR_LENGTH_ERROR_PREFIX                                    (-30734L)
N#define SL_ERROR_WAKELOCK_ERROR_PREFIX                                  (-30735L)
N#define SL_ERROR_DRV_START_FAIL                                         (-30736L)
N#define SL_ERROR_VALIDATION_ERROR                                       (-30737L)
N#define SL_ERROR_SETUP_FAILURE                                          (-30738L)
N#define SL_ERROR_HTTP_SERVER_ENABLE_FAILED                              (-30739L)
N#define SL_ERROR_DHCP_SERVER_ENABLE_FAILED                              (-30740L)
N#define SL_ERROR_WPS_NO_PIN_OR_WRONG_PIN_LEN                            (-30741L)
N
N
N/* INTERNAL HOST ERRORS CODES*/
N
N/* Receive this error in case there are no resources to issue the command
N   If possible, increase the number of MAX_CONCURRENT_ACTIONS (result in memory increaseL)
N   If not, try again later */
N#define SL_POOL_IS_EMPTY                                                (-2000L)
N
N/* Receive this error in case a given length for RX buffer was too small.
N   Receive payload was bigger than the given buffer size. Therefore, payload is cut according to receive size
N   Recommend to increase buffer size */
N#define SL_ESMALLBUF                                                    (-2001L)
N
N/* Receive this error in case zero length is supplied to a "get" API
N   Recommend to supply length according to requested information (view options defines for helpL) */
N#define SL_EZEROLEN                                                     (-2002L)
N
N/* User supplied invalid parameter */
N#define SL_INVALPARAM                                                   (-2003L)
N
N/* Failed to open interface  */
N#define SL_BAD_INTERFACE                                                (-2004L)
N
N/* API has been aborted due to an error detected by host driver */
N#define SL_API_ABORTED                                                  (-2005L)
N
N/* Parameters are invalid */
N#define SL_RET_CODE_INVALID_INPUT                                       (-2006L)
N
N/* Driver internal error */
N#define SL_RET_CODE_SELF_ERROR                                          (-2007L)
N
N/* NWP internal error */
N#define SL_RET_CODE_NWP_IF_ERROR                                        (-2008L)
N
N/* malloc error */
N#define SL_RET_CODE_MALLOC_ERROR                                        (-2009L)
N
N/* protocol error */
N#define SL_RET_CODE_PROTOCOL_ERROR                                      (-2010L)
N
N/* API has been aborted, command is not allowed in device lock state */
N#define SL_RET_CODE_DEV_LOCKED                                          (-2011L)
N
N/* sl_Start cannot be invoked twice */
N#define SL_RET_CODE_DEV_ALREADY_STARTED                                 (-2012L)
N
N/* SL API is in progress */
N#define SL_RET_CODE_API_COMMAND_IN_PROGRESS                             (-2013L)
N
N/* Provisioning is in progress -  */
N#define SL_RET_CODE_PROVISIONING_IN_PROGRESS                            (-2014L)
N
N/* Wrong ping parameters - ping cannot be called with the following parameters: 
N1. infinite ping packet
N2. report only when finished 
N3. no callback supplied  */
N#define SL_RET_CODE_NET_APP_PING_INVALID_PARAMS                         (-2015L)
N
N/* SL select already in progress.
N   this error will be returned if app will try to call
N   sl_select blocking when there is already select trigger in progress */
N#define SL_RET_CODE_SOCKET_SELECT_IN_PROGRESS_ERROR                     (-2016L)
N
N#define SL_RET_CODE_STOP_IN_PROGRESS                                    (-2017L)
N
N/* The device has not been started yet  */
N#define SL_RET_CODE_DEV_NOT_STARTED                                     (-2018L)
N
N/* The event link was not found in the list */
N#define SL_RET_CODE_EVENT_LINK_NOT_FOUND                                (-2019L)
N
N#ifdef  __cplusplus
S}
N#endif /*  __cplusplus */
N
N#endif  /*  __ERROR_H__ */
L 417 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N#include "eventreg.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/eventreg.h" 1
N/*
N * eventreg.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N
N#ifndef EVENTREG_H_
N#define EVENTREG_H_
N
N#ifdef    __cplusplus
Sextern "C"
S{
N#endif
N
N/*!
N    \defgroup event_registration
N    \short Allows user to register event handlers dynamically. 
N
N*/
N/*!
N
N    \addtogroup event_registration
N    @{
N
N*/
N
Ntypedef enum
N{
N    SL_EVENT_HDL_FATAL_ERROR,
N    SL_EVENT_HDL_DEVICE_GENERAL,
N    SL_EVENT_HDL_WLAN,
N    SL_EVENT_HDL_NETAPP,
N    SL_EVENT_HDL_SOCKET,
N    SL_EVENT_HDL_HTTP_SERVER,
N    SL_EVENT_HDL_NETAPP_REQUEST,
N    SL_EVENT_HDL_MEM_FREE,
N    SL_EVENT_HDL_SOCKET_TRIGGER,
N    SL_NUM_OF_EVENT_TYPES
N}SlEventHandler_e;
N
Ntypedef struct SlEventsListNode_s
N{
N    void *event;
N    struct SlEventsListNode_s *next;
N}SlEventsListNode_t;
N
N#ifdef SL_RUNTIME_EVENT_REGISTERATION
N
N/*!
N    \brief register events in runtime
N
N    this api enables registration of the SimpleLink host driver in runtime.
N
N    \param[in]  EventHandlerType event type - SlEventHandler_e - to register
N
N    \param[in]  EventHandler pointer to the event handler
N
N    \return 0 on success, error otherwise
N
N    \sa     sl_RegisterEventHandler
N
N    \note   registration of event with NULL, clears any registered event.
N*/
N_i32 sl_RegisterEventHandler(SlEventHandler_e EventHandlerType , void* EventHandler);
Xsigned long sl_RegisterEventHandler(SlEventHandler_e EventHandlerType , void* EventHandler);
N
N
N
N_i32 _SlIsEventRegistered(SlEventHandler_e EventHandlerType);
Xsigned long _SlIsEventRegistered(SlEventHandler_e EventHandlerType);
N
N/******************************************************************************
N    sl_RegisterLibsEventHandler
N
N    \brief  this function registers event handlers from external libraries in runtime.
N
N    the allocation and memory maintenance of the SlEventsListNode_t is on the library
N    Responsibility.
N
N    RETURNS:        success or error code.
N******************************************************************************/
N
N_i32 sl_RegisterLibsEventHandler(SlEventHandler_e EventHandlerType , SlEventsListNode_t* EventHandlerNode);
Xsigned long sl_RegisterLibsEventHandler(SlEventHandler_e EventHandlerType , SlEventsListNode_t* EventHandlerNode);
N
N/******************************************************************************
N    sl_UnregisterLibsEventHandler
N
N    DESCRIPTION:
N    this function unregisters event handlers from external libraries in runtime.
N    the SlEventsListNode_t that was used for registration, must be used to unregister that event handler.
N
N    the allocation and memory maintenance of the SlEventsListNode_t is on the library
N    Responsibility.
N
N    RETURNS:        success or error code.
N******************************************************************************/
N_i32 sl_UnregisterLibsEventHandler(SlEventHandler_e EventHandlerType , SlEventsListNode_t* EventHandlerNode);
Xsigned long sl_UnregisterLibsEventHandler(SlEventHandler_e EventHandlerType , SlEventsListNode_t* EventHandlerNode);
N
N/*!
N
N Close the Doxygen group.
N @}
N
N */
N
N
Nvoid _SlDeviceFatalErrorEvtHdlr(SlDeviceFatal_t *pSlFatalErrorEvent);
Nvoid _SlDeviceGeneralEvtHdlr(SlDeviceEvent_t *pSlDeviceEvent);
Nvoid _SlWlanEvtHdlr(SlWlanEvent_t* pSlWlanEvent);
Nvoid _SlNetAppEvtHdlr(SlNetAppEvent_t* pSlNetAppEvent);
Nvoid _SlSockEvtHdlr(SlSockEvent_t* pSlSockEvent);
Nvoid _SlNetAppHttpServerHdlr(SlNetAppHttpServerEvent_t *pSlHttpServerEvent, SlNetAppHttpServerResponse_t *pSlHttpServerResponse);
Nvoid _SlNetAppRequestHdlr(SlNetAppRequest_t *pNetAppRequest, SlNetAppResponse_t *pNetAppResponse);
Nvoid _SlNetAppRequestMemFree (_u8 *buffer);
Xvoid _SlNetAppRequestMemFree (unsigned char *buffer);
Nvoid _SlSocketTriggerEventHandler(SlSockTriggerEvent_t* pSlSockTriggerEvent);
N
N#endif /* SL_RUNTIME_EVENT_REGISTERATION */
N
N
N#ifdef  __cplusplus
S}
N#endif /* __cplusplus */
N
N
N#endif /* EVENTREG_H_ */
L 418 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N
N/*!
N    \cond DOXYGEN_IGNORE
N*/
N /* In case of use dynamic event registration
N  * redirect the event to the internal mechanism */
N#if (defined(SL_RUNTIME_EVENT_REGISTERATION))
X#if (1L)
N
N#define _SlDrvHandleFatalErrorEvents            _SlDeviceFatalErrorEvtHdlr
N#define _SlDrvHandleGeneralEvents               _SlDeviceGeneralEvtHdlr
N#define _SlDrvHandleWlanEvents                  _SlWlanEvtHdlr
N#define _SlDrvHandleNetAppEvents                _SlNetAppEvtHdlr
N#define _SlDrvHandleSockEvents                  _SlSockEvtHdlr
N#define _SlDrvHandleHttpServerEvents            _SlNetAppHttpServerHdlr
N#define _SlDrvHandleNetAppRequestEvents         _SlNetAppRequestHdlr
N#define _SlDrvHandleNetAppRequestMemFreeEvents  _SlNetAppRequestMemFree
N#define _SlDrvHandleSocketTriggerEvents         _SlSocketTriggerEventHandler
N
N#else
S
S /* The fatal error events dispatcher which is
S  * initialized to the user handler */
S#ifdef slcb_DeviceFatalErrorEvtHdlr
S#define _SlDrvHandleFatalErrorEvents slcb_DeviceFatalErrorEvtHdlr
S#endif
S
S /* The general events dispatcher which is
S  * initialized to the user handler */
S#ifdef slcb_DeviceGeneralEvtHdlr
S#define _SlDrvHandleGeneralEvents slcb_DeviceGeneralEvtHdlr
S#endif
S
S /* The wlan events dispatcher which is
S  * initialized to the user handler */
S#ifdef slcb_WlanEvtHdlr
S#define _SlDrvHandleWlanEvents slcb_WlanEvtHdlr
S#endif
S
S /* The NetApp events dispatcher which is
S  * initialized to the user handler */
S#ifdef slcb_NetAppEvtHdlr
S#define _SlDrvHandleNetAppEvents slcb_NetAppEvtHdlr
S#endif
S
S /* The http server events dispatcher which is
S  * initialized to the user handler if exists */
S#ifdef slcb_NetAppHttpServerHdlr
S#define _SlDrvHandleHttpServerEvents slcb_NetAppHttpServerHdlr
S#endif
S
S /* The socket events dispatcher which is
S  * initialized to the user handler */
S#ifdef slcb_SockEvtHdlr
S#define _SlDrvHandleSockEvents slcb_SockEvtHdlr
S#endif
S
S
S/* The netapp requests dispatcher which is
S  * initialized to the user handler if exists */
S#ifdef slcb_NetAppRequestHdlr
S#define _SlDrvHandleNetAppRequestEvents slcb_NetAppRequestHdlr
S#endif
S
S/* The netapp request mem free requests dispatcher which is
S* initialized to the user handler if exists */
S#ifdef slcb_NetAppRequestMemFree
S#define _SlDrvHandleNetAppRequestMemFreeEvents slcb_NetAppRequestMemFree
S#endif
S
S/* The netapp requests dispatcher which is
S* initialized to the user handler if exists */
S#ifdef slcb_SocketTriggerEventHandler
S#define _SlDrvHandleSocketTriggerEvents slcb_SocketTriggerEventHandler
S#endif
S
S
N#endif
N
N#define SL_CONCAT(x,y)  x ## y
N#define SL_CONCAT2(x,y) SL_CONCAT(x,y)
N
N
N#if (!defined(SL_RUNTIME_EVENT_REGISTERATION))
X#if (!1L)
S
S/*
S * The section below handles the external lib event registration
S * according to the desired events it specified in its API header file.
S * The external lib should be first installed by the user (see user.h)
S */
S#ifdef SL_EXT_LIB_1
S
S/* General Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_GENERAL_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _GeneralEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib1GeneralEventHandler   SL_CONCAT2(SL_EXT_LIB_1, _GeneralEventHdl)
S    
S    #undef EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #define EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #endif
S    
S    /* Wlan Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_WLAN_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _WlanEventHdl) (SlWlanEvent_t *);
S    #define SlExtLib1WlanEventHandler   SL_CONCAT2(SL_EXT_LIB_1, _WlanEventHdl)
S    
S    #undef EXT_LIB_REGISTERED_WLAN_EVENTS
S    #define EXT_LIB_REGISTERED_WLAN_EVENTS
S    #endif
S    
S    /* NetApp Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_NETAPP_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _NetAppEventHdl) (SlNetAppEvent_t *);
S    #define SlExtLib1NetAppEventHandler SL_CONCAT2(SL_EXT_LIB_1, _NetAppEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #endif
S
S    /* Http Server Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_HTTP_SERVER_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _HttpServerEventHdl) (SlNetAppHttpServerEvent_t* , SlNetAppHttpServerResponse_t*);
S    #define SlExtLib1HttpServerEventHandler SL_CONCAT2(SL_EXT_LIB_1, _HttpServerEventHdl)
S
S    #undef EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #define EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #endif
S
S    /* Socket Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_SOCK_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _SockEventHdl) (SlSockEvent_t *);
S    #define SlExtLib1SockEventHandler SL_CONCAT2(SL_EXT_LIB_1, _SockEventHdl)
S
S    #undef EXT_LIB_REGISTERED_SOCK_EVENTS
S    #define EXT_LIB_REGISTERED_SOCK_EVENTS
S    #endif
S
S    /* Fatal Error Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_FATAL_ERROR_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _FatalErrorEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib1FatalErrorEventHandler   SL_CONCAT2(SL_EXT_LIB_1, _FatalErrorEventHdl)
S    
S    #undef EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #define EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #endif
S
S    /* NetApp requests events registration */
S    #if SL_CONCAT2(SL_EXT_LIB_1, _NOTIFY_NETAPP_REQUEST_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_1, _NetAppRequestEventHdl) (SlNetAppRequest_t*, SlNetAppResponse_t *);
S    #define SlExtLib1NetAppRequestEventHandler   SL_CONCAT2(SL_EXT_LIB_1, _NetAppRequestEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #endif
S
S#endif
S
S
S#ifdef SL_EXT_LIB_2
S
S    /* General Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_GENERAL_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _GeneralEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib2GeneralEventHandler   SL_CONCAT2(SL_EXT_LIB_2, _GeneralEventHdl)
S
S    #undef EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #define EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #endif
S
S    /* Wlan Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_WLAN_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _WlanEventHdl) (SlWlanEvent_t *);
S    #define SlExtLib2WlanEventHandler   SL_CONCAT2(SL_EXT_LIB_2, _WlanEventHdl)
S
S    #undef EXT_LIB_REGISTERED_WLAN_EVENTS
S    #define EXT_LIB_REGISTERED_WLAN_EVENTS
S    #endif
S
S    /* NetApp Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_NETAPP_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _NetAppEventHdl) (SlNetAppEvent_t *);
S    #define SlExtLib2NetAppEventHandler SL_CONCAT2(SL_EXT_LIB_2, _NetAppEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #endif
S
S    /* Http Server Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_HTTP_SERVER_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _HttpServerEventHdl) (SlNetAppHttpServerEvent_t* , SlNetAppHttpServerResponse_t*);
S    #define SlExtLib2HttpServerEventHandler SL_CONCAT2(SL_EXT_LIB_2, _HttpServerEventHdl)
S
S    #undef EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #define EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #endif
S
S    /* Socket Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_SOCK_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _SockEventHdl) (SlSockEvent_t *);
S    #define SlExtLib2SockEventHandler SL_CONCAT2(SL_EXT_LIB_2, _SockEventHdl)
S
S    #undef EXT_LIB_REGISTERED_SOCK_EVENTS
S    #define EXT_LIB_REGISTERED_SOCK_EVENTS
S    #endif
S
S    /* Fatal Error Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_FATAL_ERROR_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _FatalErrorEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib2FatalErrorEventHandler   SL_CONCAT2(SL_EXT_LIB_2, _FatalErrorEventHdl)
S
S    #undef EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #define EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #endif
S
S    /* NetApp requests events registration */
S    #if SL_CONCAT2(SL_EXT_LIB_2, _NOTIFY_NETAPP_REQUEST_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_2, _NetAppRequestEventHdl) (SlNetAppRequest_t*, SlNetAppResponse_t *);
S    #define SlExtLib1NetAppRequestEventHandler   SL_CONCAT2(SL_EXT_LIB_2, _NetAppRequestEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #endif
S
S#endif
S
S#ifdef SL_EXT_LIB_3
S
S  /* General Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_GENERAL_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _GeneralEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib3GeneralEventHandler   SL_CONCAT2(SL_EXT_LIB_3, _GeneralEventHdl)
S
S    #undef EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #define EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #endif
S
S    /* Wlan Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_WLAN_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _WlanEventHdl) (SlWlanEvent_t *);
S    #define SlExtLib3WlanEventHandler   SL_CONCAT2(SL_EXT_LIB_3, _WlanEventHdl)
S
S    #undef EXT_LIB_REGISTERED_WLAN_EVENTS
S    #define EXT_LIB_REGISTERED_WLAN_EVENTS
S    #endif
S
S    /* NetApp Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_NETAPP_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _NetAppEventHdl) (SlNetAppEvent_t *);
S    #define SlExtLib3NetAppEventHandler SL_CONCAT2(SL_EXT_LIB_3, _NetAppEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #endif
S
S    /* Http Server Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_HTTP_SERVER_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _HttpServerEventHdl) (SlNetAppHttpServerEvent_t* , SlNetAppHttpServerResponse_t*);
S    #define SlExtLib3HttpServerEventHandler SL_CONCAT2(SL_EXT_LIB_3, _HttpServerEventHdl)
S
S    #undef EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #define EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #endif
S
S    /* Socket Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_SOCK_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _SockEventHdl) (SlSockEvent_t *);
S    #define SlExtLib3SockEventHandler SL_CONCAT2(SL_EXT_LIB_3, _SockEventHdl)
S
S    #undef EXT_LIB_REGISTERED_SOCK_EVENTS
S    #define EXT_LIB_REGISTERED_SOCK_EVENTS
S    #endif
S
S
S    /* Fatal Error Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_FATAL_ERROR_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _FatalErrorEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib3FatalErrorEventHandler   SL_CONCAT2(SL_EXT_LIB_3, _FatalErrorEventHdl)
S
S    #undef EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #define EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #endif
S
S    /* NetApp requests events registration */
S    #if SL_CONCAT2(SL_EXT_LIB_3, _NOTIFY_NETAPP_REQUEST_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_3, _NetAppRequestEventHdl) (SlNetAppRequest_t*, SlNetAppResponse_t *);
S    #define SlExtLib1NetAppRequestEventHandler   SL_CONCAT2(SL_EXT_LIB_3, _NetAppRequestEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #endif
S
S#endif
S
S#ifdef SL_EXT_LIB_4
S
S    /* General Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_GENERAL_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _GeneralEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib4GeneralEventHandler   SL_CONCAT2(SL_EXT_LIB_4, _GeneralEventHdl)
S
S    #undef EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #define EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #endif
S
S    /* Wlan Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_WLAN_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _WlanEventHdl) (SlWlanEvent_t *);
S    #define SlExtLib4WlanEventHandler   SL_CONCAT2(SL_EXT_LIB_4, _WlanEventHdl)
S
S    #undef EXT_LIB_REGISTERED_WLAN_EVENTS
S    #define EXT_LIB_REGISTERED_WLAN_EVENTS
S    #endif
S
S    /* NetApp Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_NETAPP_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _NetAppEventHdl) (SlNetAppEvent_t *);
S    #define SlExtLib4NetAppEventHandler SL_CONCAT2(SL_EXT_LIB_4, _NetAppEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #endif
S
S    /* Http Server Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_HTTP_SERVER_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _HttpServerEventHdl) (SlNetAppHttpServerEvent_t* , SlNetAppHttpServerResponse_t*);
S    #define SlExtLib4HttpServerEventHandler SL_CONCAT2(SL_EXT_LIB_4, _HttpServerEventHdl)
S
S    #undef EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #define EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #endif
S
S    /* Socket Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_SOCK_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _SockEventHdl) (SlSockEvent_t *);
S    #define SlExtLib4SockEventHandler SL_CONCAT2(SL_EXT_LIB_4, _SockEventHdl)
S
S    #undef EXT_LIB_REGISTERED_SOCK_EVENTS
S    #define EXT_LIB_REGISTERED_SOCK_EVENTS
S    #endif
S
S    /* Fatal Error Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_FATAL_ERROR_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _FatalErrorEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib4FatalErrorEventHandler   SL_CONCAT2(SL_EXT_LIB_4, _FatalErrorEventHdl)
S
S    #undef EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #define EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #endif
S
S    /* NetApp requests events registration */
S    #if SL_CONCAT2(SL_EXT_LIB_4, _NOTIFY_NETAPP_REQUEST_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_4, _NetAppRequestEventHdl) (SlNetAppRequest_t*, SlNetAppResponse_t *);
S    #define SlExtLib1NetAppRequestEventHandler   SL_CONCAT2(SL_EXT_LIB_4, _NetAppRequestEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #endif
S
S#endif
S
S#ifdef SL_EXT_LIB_5
S
S    /* General Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_GENERAL_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _GeneralEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib5GeneralEventHandler   SL_CONCAT2(SL_EXT_LIB_5, _GeneralEventHdl)
S
S    #undef EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #define EXT_LIB_REGISTERED_GENERAL_EVENTS
S    #endif
S
S    /* Wlan Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_WLAN_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _WlanEventHdl) (SlWlanEvent_t *);
S    #define SlExtLib5WlanEventHandler   SL_CONCAT2(SL_EXT_LIB_5, _WlanEventHdl)
S
S    #undef EXT_LIB_REGISTERED_WLAN_EVENTS
S    #define EXT_LIB_REGISTERED_WLAN_EVENTS
S    #endif
S
S    /* NetApp Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_NETAPP_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _NetAppEventHdl) (SlNetAppEvent_t *);
S    #define SlExtLib5NetAppEventHandler SL_CONCAT2(SL_EXT_LIB_5, _NetAppEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_EVENTS
S    #endif
S
S    /* Http Server Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_HTTP_SERVER_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _HttpServerEventHdl) (SlNetAppHttpServerEvent_t* , SlNetAppHttpServerResponse_t*);
S    #define SlExtLib5HttpServerEventHandler SL_CONCAT2(SL_EXT_LIB_5, _HttpServerEventHdl)
S
S    #undef EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #define EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS
S    #endif
S
S    /* Socket Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_SOCK_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _SockEventHdl) (SlSockEvent_t *);
S    #define SlExtLib5SockEventHandler SL_CONCAT2(SL_EXT_LIB_5, _SockEventHdl)
S
S    #undef EXT_LIB_REGISTERED_SOCK_EVENTS
S    #define EXT_LIB_REGISTERED_SOCK_EVENTS
S    #endif
S
S    /* Fatal Error Event Registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_FATAL_ERROR_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _FatalErrorEventHdl) (SlDeviceEvent_t *);
S    #define SlExtLib5FatalErrorEventHandler   SL_CONCAT2(SL_EXT_LIB_5, _FatalErrorEventHdl)
S
S    #undef EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #define EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS
S    #endif
S
S    /* NetApp requests events registration */
S    #if SL_CONCAT2(SL_EXT_LIB_5, _NOTIFY_NETAPP_REQUEST_EVENT)
S    extern _SlEventPropogationStatus_e SL_CONCAT2(SL_EXT_LIB_5, _NetAppRequestEventHdl) (SlNetAppRequest_t*, SlNetAppResponse_t *);
S    #define SlExtLib1NetAppRequestEventHandler   SL_CONCAT2(SL_EXT_LIB_5, _NetAppRequestEventHdl)
S
S    #undef EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #define EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS
S    #endif
S
S#endif
S
S#if defined(EXT_LIB_REGISTERED_FATAL_ERROR_EVENTS)
Sextern void _SlDrvHandleFatalErrorEvents(SlDeviceEvent_t *slFatalErrorEvent);
S#endif
S
S#if defined(EXT_LIB_REGISTERED_GENERAL_EVENTS)
Sextern void _SlDrvHandleGeneralEvents(SlDeviceEvent_t *slGeneralEvent);
S#endif
S
S#if defined(EXT_LIB_REGISTERED_WLAN_EVENTS)
Sextern void _SlDrvHandleWlanEvents(SlWlanEvent_t *slWlanEvent);
S#endif
S
S#if defined (EXT_LIB_REGISTERED_NETAPP_EVENTS)
Sextern void _SlDrvHandleNetAppEvents(SlNetAppEvent_t *slNetAppEvent);
S#endif
S
S#if defined(EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS)
Sextern void _SlDrvHandleHttpServerEvents(SlNetAppHttpServerEvent_t *slHttpServerEvent, SlNetAppHttpServerResponse_t *slHttpServerResponse);
S#endif
S
S#if defined(EXT_LIB_REGISTERED_SOCK_EVENTS)
Sextern void _SlDrvHandleSockEvents(SlSockEvent_t *slSockEvent);
S#endif
S
S#if defined(EXT_LIB_REGISTERED_NETAPP_REQUEST_EVENTS)
Sextern void _SlDrvHandleNetAppRequestEvents(SlNetAppRequest_t *pNetAppRequest, SlNetAppResponse_t *pNetAppResponse);
S#endif
S
N#endif //#if (defined(SL_RUNTIME_EVENT_REGISTERATION))
N
Ntypedef _SlReturnVal_t (*_SlSpawnEntryFunc_t)(void* pValue);
N
N#define SL_SPAWN_FLAG_FROM_SL_IRQ_HANDLER    (0X1)
N
N#ifdef SL_PLATFORM_MULTI_THREADED
N    #include "source/spawn.h"
L 1 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/source/spawn.h" 1
N/*
N * spawn.h - CC31xx/CC32xx Host Driver Implementation
N *
N * Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/ 
N * 
N * 
N *  Redistribution and use in source and binary forms, with or without 
N *  modification, are permitted provided that the following conditions 
N *  are met:
N *
N *    Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer.
N *
N *    Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the   
N *    distribution.
N *
N *    Neither the name of Texas Instruments Incorporated nor the names of
N *    its contributors may be used to endorse or promote products derived
N *    from this software without specific prior written permission.
N *
N *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
N *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
N *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
N *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
N *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
N *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
N *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
N *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N*/
N#ifndef __SPAWN_H__
N#define __SPAWN_H__
N
N#ifdef    __cplusplus
Sextern "C" {
N#endif
N
N#if (defined (SL_PLATFORM_MULTI_THREADED)) && (!defined (SL_PLATFORM_EXTERNAL_SPAWN))
X#if (1L) && (!0L)
N
Nextern void* _SlInternalSpawnTaskEntry();
Nextern _i16 _SlInternalSpawn(_SlSpawnEntryFunc_t pEntry , void* pValue , _u32 flags);
Xextern signed short _SlInternalSpawn(_SlSpawnEntryFunc_t pEntry , void* pValue , unsigned long flags);
N
N#undef sl_Spawn
N#define sl_Spawn(pEntry,pValue,flags)               _SlInternalSpawn(pEntry,pValue,flags)
N
N#undef _SlTaskEntry
N#define _SlTaskEntry                                _SlInternalSpawnTaskEntry
N
N#endif
N
N#ifdef  __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif
L 880 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/simplelink.h" 2
N#else
S    #include "source/nonos.h"
N#endif
N
N/*!
N    \endcond
N*/
N
N
N/* Async functions description*/
N
N
N/*!
N    \brief Fatal Error event for inspecting fatal error
N
N    \param[out]      pSlFatalErrorEvent   pointer to SlDeviceFatal_t
N    \return None
N    \sa
N    \note
N    \warning
N    \par    Example
N    \code
N        For pSlDeviceFatal->Id = SL_DEVICE_EVENT_FATAL_DEVICE_ABORT
N                Indicates a severe error occured and the device stopped
N        Use pSlDeviceFatal->Data.DeviceAssert fields
N                    - Code: An idication of the abort type
N                    - Value: The abort data
N
N
N        For pSlDeviceFatal->Id = SL_DEVICE_EVENT_FATAL_NO_CMD_ACK
N                Indicates that the command sent to the device had no ack
N        Use pSlDeviceFatal->Data.NoCmdAck fields
N                    - Code: An idication of the cmd opcode
N
N        For pSlDeviceFatal->Id = SL_DEVICE_EVENT_FATAL_CMD_TIMEOUT
N                Indicates that the command got a timeout while waiting for its async response
N        Use pSlDeviceFatal->Data.CmdTimeout fields
N                    - Code: An idication of the asyncevent opcode
N
N
N        For pSlDeviceFatal->Id = SL_DEVICE_EVENT_FATAL_DRIVER_ABORT
N                Indicates a severe error occured in the driver
N        Use pSlDeviceFatal->Data.DeviceAssert fields
N                    - None.
N
N        For pSlDeviceFatal->Id = SL_DEVICE_EVENT_FATAL_SYNC_LOSS
N                Indicates a sync loss with the device
N        Use pSlDeviceFatal->Data.DeviceAssert fields
N                    - None.
N    \endcode
N    \code
N        Example for fatal error
N             printf(Abort type =%d Abort Data=0x%x\n\n",
N                   pSlDeviceFatal->Data.deviceReport.AbortType,
N                   pSlDeviceFatal->Data.deviceReport.AbortData);
N    \endcode
N*/
N#if (defined(slcb_DeviceFatalErrorEvtHdlr))
X#if (1L)
Nextern void slcb_DeviceFatalErrorEvtHdlr(SlDeviceFatal_t *pSlFatalErrorEvent);
Xextern void SimpleLinkFatalErrorEventHandler(SlDeviceFatal_t *pSlFatalErrorEvent);
N#endif
N
N
N/*!
N    \brief General async event for inspecting general events
N
N    \param[out]      pSlDeviceEvent   pointer to SlDeviceEvent_t
N    \return None
N    \sa
N    \note
N    \warning
N    \par    Example
N    \code
N          For pSlDeviceEvent->Id = SL_DEVICE_EVENT_RESET_REQUEST
N          Use pSlDeviceEvent->Data.ResetRequest fields
N                  - Status: An error code indication from the device
N                  - Source: The sender originator which is based on SlDeviceSource_e enum
N
N          For pSlDeviceEvent->Id = SL_DEVICE_EVENT_ERROR
N          Use pSlDeviceEvent->Data.Error fields
N                  - Code: An error code indication from the device
N                  - Source: The sender originator which is based on SlErrorSender_e enum
N    \endcode
N    \code
N        Example for error event:
N            printf(General Event Handler - ID=%d Sender=%d\n\n",
N                   pSlDeviceEvent->Data.Error.Code,  // the error code
N                   pSlDeviceEvent->Data.Error.Source); // the error source
N    \endcode
N
N*/
N#if (defined(slcb_DeviceGeneralEvtHdlr))
X#if (1L)
Nextern void slcb_DeviceGeneralEvtHdlr(SlDeviceEvent_t *pSlDeviceEvent);
Xextern void SimpleLinkGeneralEventHandler(SlDeviceEvent_t *pSlDeviceEvent);
N#endif
N
N/*!
N    \brief WLAN Async event handler
N
N    \param[out]      pSlWlanEvent   pointer to SlWlanEvent_t data
N    \return None
N    \sa
N    \note
N    \warning
N    \par             Example
N    \code
N         For pSlWlanEvent->Id = SL_WLAN_EVENT_CONNECT, STA connection indication event
N         Use pSlWlanEvent->Data.Connect main fields
N                 - SsidLen
N                 - SsidName
N                 - Bssid
N
N         For pSlWlanEvent->Id = SL_WLAN_EVENT_P2P_CONNECT, P2P client connection indication event
N         Use pSlWlanEvent->Data.P2PConnect main fields
N                 - SsidLen
N                 - SsidName
N                 - Bssid
N                 - GoDeviceNameLen
N                 - GoDeviceName
N
N         For pSlWlanEvent->Id = SL_WLAN_EVENT_DISCONNECT, STA client disconnection event
N         Use pSlWlanEvent->Data.Disconnect main fields:
N                 - SsidLen
N                 - SsidName
N                 - Bssid
N                 - ReasonCode
N
N         For pSlWlanEvent->Id = SL_WLAN_EVENT_P2P_DISCONNECT, P2P client disconnection event
N         Use pSlWlanEvent->Data.P2PDisconnect main fields:
N                 - SsidLen
N                 - SsidName
N                 - Bssid
N                 - ReasonCode
N                 - GoDeviceNameLen
N                 - GoDeviceName
N
N         For pSlWlanEvent->Id = SL_WLAN_EVENT_STA_ADDED, AP connected STA
N         Use pSlWlanEvent->Data.STAAdded fields:
N                 - Mac
N
N         For pSlWlanEvent->Id = SL_WLAN_EVENT_STA_REMOVED, AP disconnected STA
N         Use pSlWlanEvent->Data.STARemoved fields:
N                 - Mac
N
N         For pSlWlanEvent->Id = SL_WLAN_EVENT_P2P_CLIENT_ADDED, P2P(Go) connected P2P(Client)
N         Use pSlWlanEvent->Data.P2PClientAdded fields:
N                 - Mac
N                 - GoDeviceNameLen
N                 - GoDeviceName
N                 - OwnSsidLen
N                 - OwnSsid
N
N         For pSlWlanEvent->Id = SL_WLAN_EVENT_P2P_CLIENT_REMOVED, P2P(Go) disconnected P2P(Client)
N         Use pSlWlanEvent->Data.P2PClientRemoved fields:
N                 - Mac
N                 - GoDeviceNameLen
N                 - GoDeviceName
N                 - OwnSsidLen
N                 - OwnSsid
N
N         For pSlWlanEvent->Id = SL_WLAN_P2P_DEV_FOUND_EVENT
N         Use pSlWlanEvent->Data.P2PDevFound fields:
N                - GoDeviceNameLen
N                - GoDeviceName
N                - Mac
N                - WpsMethod
N
N         For pSlWlanEvent->Id = SL_WLAN_EVENT_P2P_REQUEST
N         Use pSlWlanEvent->Data.P2PRequest fields
N                - GoDeviceNameLen
N                - GoDeviceName
N                - Mac
N                - WpsMethod
N
N         For pSlWlanEvent->Id = SL_WLAN_EVENT_P2P_CONNECTFAIL, P2P only
N         Use pSlWlanEvent->Data.P2PConnectFail fields:
N                    - Status
N
N         For pSlWlanEvent->Id = SL_WLAN_EVENT_PROVISIONING_STATUS
N         Use pSlWlanEvent->Data.ProvisioningStatus fields
N                  - Status
N
N         For pSlWlanEvent->Id = SL_WLAN_EVENT_PROVISIONING_PROFILE_ADDED
N         Use pSlWlanEvent->Data.ProvisioningProfileAdded fields:
N                 - Status
N                 - SsidLen
N                 - Ssid
N                 - Reserved
N    \endcode
N*/
N#if (defined(slcb_WlanEvtHdlr))
X#if (1L)
Nextern void slcb_WlanEvtHdlr(SlWlanEvent_t* pSlWlanEvent);
Xextern void SimpleLinkWlanEventHandler(SlWlanEvent_t* pSlWlanEvent);
N#endif
N
N
N/*!
N    \brief NETAPP Async event handler
N
N    \param[out]      pSlNetAppEvent   pointer to SlNetAppEvent_t data
N    \return None
N    \sa
N    \note
N    \warning
N    \par    Example
N    \code
N        For pSlNetAppEvent->Id = SL_NETAPP_EVENT_IPV4_ACQUIRED/SL_NETAPP_EVENT_IPV6_ACQUIRED
N        Use pSlNetAppEvent->Data.ipAcquiredV4 (V6) fields
N           - ip
N           - gateway
N           - dns
N
N        For pSlNetAppEvent->Id = SL_NETAPP_IP_LEASED_EVENT, AP or P2P go dhcp lease event
N        Use pSlNetAppEvent->Data.ipLeased  fields
N           - ip_address
N           - lease_time
N           - mac
N
N        For pSlNetApp->Id = SL_NETAPP_IP_RELEASED_EVENT, AP or P2P go dhcp ip release event
N        Use pSlNetAppEvent->Data.ipReleased fields
N            - ip_address
N            - mac
N            - reason
N    \endcode
N*/
N#if (defined(slcb_NetAppEvtHdlr))
X#if (1L)
Nextern void slcb_NetAppEvtHdlr(SlNetAppEvent_t* pSlNetAppEvent);
Xextern void SimpleLinkNetAppEventHandler(SlNetAppEvent_t* pSlNetAppEvent);
N#endif
N
N/*!
N    \brief Socket Async event handler
N
N    \param[out]      pSlSockEvent   pointer to SlSockEvent_t data
N    \return None
N    \sa
N    \note
N    \warning
N    \par             Example
N    \code
N             For pSlSockEvent->Event = SL_SOCKET_TX_FAILED_EVENT
N             Use pSlSockEvent->SockTxFailData fields
N                    - sd
N                    - status
N             For pSlSockEvent->Event = SL_SOCKET_ASYNC_EVENT
N             Use pSlSockEvent->SockAsyncData fields
N                    - sd
N                    - type
N                        - SL_SSL_ACCEPT
N                        - SL_WLAN_RX_FRAGMENTATION_TOO_BIG
N                        - SL_OTHER_SIDE_CLOSE_SSL_DATA_NOT_ENCRYPTED
N                    - val
N    \endcode
N
N*/
N#if (defined(slcb_SockEvtHdlr))
X#if (1L)
Nextern void slcb_SockEvtHdlr(SlSockEvent_t* pSlSockEvent);
Xextern void SimpleLinkSockEventHandler(SlSockEvent_t* pSlSockEvent);
N#endif
N
N/*!
N    \brief HTTP server async event
N
N    \param[out] pSlHttpServerEvent   Pointer to SlNetAppHttpServerEvent_t
N    \param[in]  pSlHttpServerResponse Pointer to SlNetAppHttpServerResponse_t
N
N    \return     None
N    \sa         slcb_NetAppRequestHdlr
N    \note
N    \warning
N    \par        Example
N    \code
N          For pSlHttpServerResponse->Event = SL_NETAPP_HTTPGETTOKENVALUE_EVENT
N          Use pSlHttpServerEvent->EventData fields
N                - httpTokenName
N                - data
N                - len
N          And pSlHttpServerResponse->ResponseData fields
N                - data
N                - len
N
N          For pSlHttpServerEvent->Event = SL_NETAPP_HTTPPOSTTOKENVALUE_EVENT
N          Use pSlHttpServerEvent->EventData.httpPostData fields
N                - action
N                - token_name
N                - token_value
N          And pSlHttpServerResponse->ResponseData fields:
N                - data
N                - len
N    \endcode
N*/
N#if (defined(slcb_NetAppHttpServerHdlr))
X#if (1L)
Nextern void slcb_NetAppHttpServerHdlr(SlNetAppHttpServerEvent_t *pSlHttpServerEvent, SlNetAppHttpServerResponse_t *pSlHttpServerResponse);
Xextern void SimpleLinkHttpServerEventHandler(SlNetAppHttpServerEvent_t *pSlHttpServerEvent, SlNetAppHttpServerResponse_t *pSlHttpServerResponse);
N#endif
N
N/*!
N    \brief General netapp async event
N
N    \param[out] pNetAppRequest   Pointer to SlNetAppRequest_t
N    \param[in]  pNetAppResponse Pointer to SlNetAppResponse_t
N
N    \return     None
N    \sa         slcb_NetAppHttpServerHdlr
N    \note
N    \warning
N    \par        Example
N    \code
N        TBD
N    \endcode
N*/
N#if (defined(slcb_NetAppRequestHdlr))
X#if (1L)
Nextern void slcb_NetAppRequestHdlr(SlNetAppRequest_t *pNetAppRequest, SlNetAppResponse_t *pNetAppResponse);
Xextern void SimpleLinkNetAppRequestEventHandler(SlNetAppRequest_t *pNetAppRequest, SlNetAppResponse_t *pNetAppResponse);
N#endif
N
N/*!
N    \brief A handler for freeing the memory of the NetApp response.
N
N    \param[in,out] buffer        Pointer to the buffer to free
N
N    \return        None
N    \sa
N    \note
N    \warning
N    \par           Example
N    \code
N        TBD
N    \endcode
N*/
N#if (defined(slcb_NetAppRequestMemFree))
X#if (1L)
Nextern void slcb_NetAppRequestMemFree (_u8 *buffer);
Xextern void SimpleLinkNetAppRequestMemFreeEventHandler (unsigned char *buffer);
N#endif
N
N/*!
N    \brief      Get the timer counter value (timestamp).\n
N                The timer must count from zero to its MAX value.
N                For non-os application, this routine must be implemented.
N    \param      None
N    \return     Returns 32-bit timer counter value (ticks unit)
N    \sa
N    \note
N    \note       belongs to \ref porting_sec
N    \warning
N*/
N#if defined (slcb_GetTimestamp)
X#if 1L
Nextern _u32 slcb_GetTimestamp(void);
Xextern unsigned long TimerGetCurrentTimestamp(void);
N#endif
N
N
N/*!
N    \brief      Socket trigger routine.
N                This routine will notify the application that a netwrok activity has 
N                been completed on the required socket/s.
N    
N    \param[out] pSlSockTriggerEvent   pointer to SlSockTriggerEvent_t data
N    \return     None.
N    \sa
N    \note
N    \note       belongs to \ref porting_sec
N    \warning
N*/
N#if (defined(slcb_SocketTriggerEventHandler))
X#if (0L)
Sextern void slcb_SocketTriggerEventHandler(SlSockTriggerEvent_t* pSlSockTriggerEvent);
N#endif
N
N
N/*!
N Close the Doxygen group.
N @}
N
N */
N
N#ifdef  __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif    /*  __SIMPLELINK_H__ */
N
L 39 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/slnetifwifi.h" 2
N
N#ifndef __SLNETWIFI_SOCKET_H__
N#define __SLNETWIFI_SOCKET_H__
N
N
N#ifdef    __cplusplus
Sextern "C" {
N#endif
N
N/*!
N    \defgroup WiFi Socket Stack
N    \short Controls standard client/server sockets programming options and capabilities
N
N*/
N/*!
N
N    \addtogroup Socket
N    @{
N
N*/
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N
N/* prototype ifConf */
Nextern SlNetIf_Config_t SlNetIfConfigWifi;
N
N
N/*****************************************************************************/
N/* Structure/Enum declarations                                               */
N/*****************************************************************************/
N
N
N/*****************************************************************************/
N/* Function prototypes                                                       */
N/*****************************************************************************/
N
N/*!
N
N    \brief Create an endpoint for communication
N
N    The SlNetIfWifi_socket function creates a new socket of a certain socket
N    type, identified by an integer number, and allocates system resources to
N    it.\n
N    This function is called by the application layer to obtain a socket descriptor (handle).
N
N    \param[in] ifContext        Stores interface data if CreateContext function
N                                supported and implemented.
N    \param[in] domain           Specifies the protocol family of the created socket.
N                                For example:
N                                   - SLNETSOCK_AF_INET for network protocol IPv4
N                                   - SLNETSOCK_AF_INET6 for network protocol IPv6
N                                   - SLNETSOCK_AF_RF for starting transceiver mode.
N                                        Notes:
N                                        - sending and receiving any packet overriding 802.11 header
N                                        - for optimized power consumption the socket will be started in TX
N                                            only mode until receive command is activated
N    \param[in] type             Specifies the socket type, which determines the semantics of communication over
N                                the socket. The socket types supported by the system are implementation-dependent.
N                                Possible socket types include:
N                                   - SLNETSOCK_SOCK_STREAM (reliable stream-oriented service or Stream Sockets)
N                                   - SLNETSOCK_SOCK_DGRAM  (datagram service or Datagram Sockets)
N                                   - SLNETSOCK_SOCK_RAW    (raw protocols atop the network layer)
N                                   - when used with AF_RF:
N                                      - SLNETSOCK_SOCK_RX_MTR
N                                      - SLNETSOCK_SOCK_MAC_WITH_CCA
N                                      - SLNETSOCK_SOCK_MAC_WITH_NO_CCA
N                                      - SLNETSOCK_SOCK_BRIDGE
N                                      - SLNETSOCK_SOCK_ROUTER
N    \param[in] protocol         Specifies a particular transport to be used with the socket.\n
N                                The most common are
N                                    - SLNETSOCK_PROTO_TCP
N                                    - SLNETSOCK_PROTO_UDP
N                                    - SLNETSOCK_PROTO_RAW
N                                    - SLNETSOCK_PROTO_SECURE
N                                The value 0 may be used to select a default
N                                protocol from the selected domain and type
N    \param[in] sdContext        Allocate and store socket data if needed for
N                                using in other slnetwifi socket functions
N
N    \return                     On success, socket descriptor (handle) that is used for consequent socket operations. \n
N                                A successful return code should be a positive number (int16)\n
N                                On error, a negative value will be returned specifying the error code.
N                                   - SLNETERR_BSD_EAFNOSUPPORT    - illegal domain parameter
N                                   - SLNETERR_BSD_EPROTOTYPE      - illegal type parameter
N                                   - SLNETERR_BSD_EACCES          - permission denied
N                                   - SLNETERR_BSD_ENSOCK          - exceeded maximal number of socket
N                                   - SLNETERR_BSD_ENOMEM          - memory allocation error
N                                   - SLNETERR_BSD_EINVAL          - error in socket configuration
N                                   - SLNETERR_BSD_EPROTONOSUPPORT - illegal protocol parameter
N                                   - SLNETERR_BSD_EOPNOTSUPP      - illegal combination of protocol and type parameters
N
N    \sa                         SlNetIfWifi_socket
N    \note
N    \warning
N*/
Nint16_t SlNetIfWifi_socket(void *ifContext, int16_t Domain, int16_t Type, int16_t Protocol, void **sdContext);
N
N/*!
N    \brief Gracefully close socket
N
N    The SlNetIfWifi_close function causes the system to release resources allocated to a socket.  \n
N    In case of TCP, the connection is terminated.
N
N    \param[in] sd               Socket descriptor (handle), received in SlNetIfWifi_socket
N    \param[in] sdContext        May store socket data if implemented in the
N                                SlNetIfWifi_socket function.
N
N    \return                     Zero on success, or negative error code on failure
N
N    \sa                         SlNetIfWifi_socket
N    \note
N    \warning
N*/
Nint32_t SlNetIfWifi_close(int16_t sd, void *sdContext);
N
N/*!
N    \brief Accept a connection on a socket
N
N    The SlNetIfWifi_accept function is used with connection-based socket types (SOCK_STREAM).\n
N    It extracts the first connection request on the queue of pending
N    connections, creates a new connected socket, and returns a new file
N    descriptor referring to that socket.\n
N    The newly created socket is not in the listening state. The
N    original socket sd is unaffected by this call. \n
N    The argument sd is a socket that has been created with
N    SlNetIfWifi_socket(), bound to a local address with SlNetIfWifi_bind(), and is
N    listening for connections after a SlNetIfWifi_listen(). \n The argument
N     \e <b>addr</b> is a pointer to a sockaddr structure. This structure
N    is filled in with the address of the peer socket, as known to
N    the communications layer. \n The exact format of the address
N    returned addr is determined by the socket's address family. \n
N    The \b \e addrlen argument is a value-result argument: it
N    should initially contain the size of the structure pointed to
N    by addr, on return it will contain the actual length (in
N    bytes) of the address returned.
N
N    \param[in]  sd                Socket descriptor (handle)
N    \param[in]  sdContext         May store socket data if implemented in the
N                                  SlNetIfWifi_socket function.
N    \param[out] addr              The argument addr is a pointer
N                                  to a sockaddr structure. This
N                                  structure is filled in with the
N                                  address of the peer socket, as
N                                  known to the communications
N                                  layer. The exact format of the
N                                  address returned addr is
N                                  determined by the socket's
N                                  address\n
N                                  sockaddr:\n - code for the
N                                  address format.\n -
N                                  socket address, the length
N                                  depends on the code format
N    \param[out] addrlen           The addrlen argument is a value-result
N                                  argument: it should initially contain the
N                                  size of the structure pointed to by addr
N    \param[in]  flags             Specifies socket descriptor flags. \n
N                                  The available flags are:
N                                      - SLNETSOCK_SEC_START_SECURITY_SESSION_ONLY
N                                      - SLNETSOCK_SEC_BIND_CONTEXT_ONLY
N                                  Note: This flags can be used in order to start
N                                  security session if needed
N    \param[in]  acceptedSdContext Allocate and store data for the new socket
N                                  if needed in other to use it in other
N                                  slnetwifi socket functions
N
N    \return                       On success, a socket descriptor.\n
N                                  On a non-blocking accept a possible negative value is SLNETERR_BSD_EAGAIN.\n
N                                  On failure, negative error code.\n
N                                  SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system
N                                    In this case try again later or increase MAX_CONCURRENT_ACTIONS
N
N    \sa                           SlNetIfWifi_Socket  SlNetIfWifi_Bind  SlNetIfWifi_Listen
N    \note
N    \warning
N*/
Nint16_t SlNetIfWifi_accept(int16_t sd, void *sdContext, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen, uint8_t flags, void **acceptedSdContext);
N
N/*!
N    \brief Assign a name to a socket
N
N    This SlNetIfWifi_bind function gives the socket the local address addr.
N    addr is addrlen bytes long. \n Traditionally, this is called
N    When a socket is created with socket, it exists in a name
N    space (address family) but has no name assigned. \n
N    It is necessary to assign a local address before a SOCK_STREAM
N    socket may receive connections.
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] sdContext        May store socket data if implemented in the
N                                SlNetIfWifi_socket function.
N    \param[in] addr             Specifies the destination
N                                addrs\n sockaddr:\n - code for
N                                the address format.\n - socket address,
N                                the length depends on the code
N                                format
N    \param[in] addrlen          Contains the size of the structure pointed to by addr
N
N    \return                     Zero on success, or negative error code on failure
N
N    \sa                         SlNetIfWifi_Socket  SlNetIfWifi_accept  SlNetIfWifi_Listen
N    \note
N    \warning
N*/
Nint32_t SlNetIfWifi_bind(int16_t sd, void *sdContext, const SlNetSock_Addr_t *addr, int16_t addrlen);
N
N/*!
N    \brief Listen for connections on a socket
N
N    The willingness to accept incoming connections and a queue
N    limit for incoming connections are specified with SlNetIfWifi_listen(),
N    and then the connections are accepted with SlNetIfWifi_accept(). \n
N    The SlNetIfWifi_listen() call applies only to sockets of type SOCK_STREAM
N    The backlog parameter defines the maximum length the queue of
N    pending connections may grow to.
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] sdContext        May store socket data if implemented in the
N                                SlNetIfWifi_socket function.
N    \param[in] backlog          Specifies the listen queue depth.
N
N    \return                     Zero on success, or negative error code on failure
N
N    \sa                         SlNetIfWifi_Socket  SlNetIfWifi_accept  SlNetIfWifi_bind
N    \note
N    \warning
N*/
Nint32_t SlNetIfWifi_listen(int16_t sd, void *sdContext, int16_t backlog);
N
N/*!
N    \brief Initiate a connection on a socket
N
N    Function connects the socket referred to by the socket
N    descriptor sd, to the address specified by addr. \n The addrlen
N    argument specifies the size of addr. \n The format of the
N    address in addr is determined by the address space of the
N    socket. \n If it is of type SLNETSOCK_SOCK_DGRAM, this call
N    specifies the peer with which the socket is to be associated;
N    this address is that to which datagrams are to be sent, and
N    the only address from which datagrams are to be received. \n If
N    the socket is of type SLNETSOCK_SOCK_STREAM, this call
N    attempts to make a connection to another socket. \n The other
N    socket is specified by address, which is an address in the
N    communications space of the socket.
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in]  sdContext       May store socket data if implemented in the
N                                SlNetIfWifi_socket function.
N    \param[in] addr             Specifies the destination addr\n
N                                sockaddr:\n - code for the
N                                address format.\n -
N                                socket address, the length
N                                depends on the code format
N    \param[in] addrlen          Contains the size of the structure pointed
N                                to by addr
N    \param[in]  flags           Specifies socket descriptor flags. \n
N                                The available flags are:
N                                    - SLNETSOCK_SEC_START_SECURITY_SESSION_ONLY
N                                    - SLNETSOCK_SEC_BIND_CONTEXT_ONLY
N                                Note: This flags can be used in order to start
N                                security session if needed
N
N    \return                     On success, a socket descriptor (handle).\n
N                                On a non-blocking connect a possible negative value is NETSCOK_EALREADY.
N                                On failure, negative value.\n
N                                NETSCOK_POOL_IS_EMPTY may be return in case there are no resources in the system
N                                  In this case try again later or increase MAX_CONCURRENT_ACTIONS
N
N    \sa                         SlNetIfWifi_socket
N    \note
N    \warning
N*/
Nint32_t SlNetIfWifi_connect(int16_t sd, void *sdContext, const SlNetSock_Addr_t *addr, SlNetSocklen_t addrlen, uint8_t flags);
N
N/*!
N    \brief Get local address info by socket descriptor\n
N    Returns the local address info of the socket descriptor.
N
N    \param[in]  sd              Socket descriptor (handle)
N    \param[in]  sdContext       May store socket data if implemented in the
N                                SlNetIfWifi_socket function.
N    \param[out] addr            The argument addr is a pointer
N                                to a SlNetSock_Addr_t structure. This
N                                structure is filled in with the
N                                address of the peer socket, as
N                                known to the communications
N                                layer. The exact format of the
N                                address returned addr is
N                                determined by the socket's
N                                address\n
N                                SlNetSock_Addr_t:\n - code for the
N                                address format.\n -
N                                socket address, the length
N                                depends on the code format
N    \param[out] addrlen         The addrlen argument is a value-result
N                                argument: it should initially contain the
N                                size of the structure pointed to by addr
N
N    \return                     Zero on success, or negative on failure.\n
N
N
N    \sa     SlNetSock_create  SlNetSock_bind
N    \note   If the provided buffer is too small the returned address will be
N            truncated and the addrlen will contain the actual size of the
N            socket address
N    \warning
N*/
Nint32_t SlNetIfWifi_getSockName(int16_t sd, void *sdContext, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen);
N
N/*!
N    \brief Monitor socket activity
N
N    SlNetIfWifi_send allow a program to monitor multiple file descriptors,
N    waiting until one or more of the file descriptors become
N    "ready" for some class of I/O operation.
N    If trigger mode is enabled the active sdset is the one that retrieved in the first triggered call.
N    To enable the trigger mode, an handler must be statically registered to the slcb_SocketTriggerEventHandler (user.h)
N
N    \param[in]     ifContext   Stores interface data if CreateContext function
N                               supported and implemented.
N                               Can be used in all SlNetIf_Config_t functions
N    \param[in]     nsds        The highest-numbered file descriptor in any of the
N                               three sets, plus 1.
N    \param[in,out] readsds     Socket descriptors list for read monitoring and accept monitoring
N    \param[in,out] writesds    Socket descriptors list for connect monitoring only, write monitoring is not supported
N    \param[in,out] exceptsds   Socket descriptors list for exception monitoring, not supported.
N    \param[in]     timeout     Is an upper bound on the amount of time elapsed
N                               before SlNetIfWifi_send() returns. Null or above 0xffff seconds means
N                               infinity timeout. The minimum timeout is 10 milliseconds,
N                               less than 10 milliseconds will be set automatically to 10 milliseconds.
N                               Max microseconds supported is 0xfffc00.
N                               In trigger mode the timeout fields must be set to zero.
N
N    \return                    On success, SlNetIfWifi_send()  returns the number of
N                               file descriptors contained in the three returned
N                               descriptor sets (that is, the total number of bits that
N                               are set in readsds, writesds, exceptsds) which may be
N                               zero if the timeout expires before anything interesting
N                               happens.\n On error, a negative value is returned.
N                               readsds - return the sockets on which Read request will
N                               return without delay with valid data.\n
N                               writesds - return the sockets on which Write request
N                               will return without delay.\n
N                               exceptsds - return the sockets closed recently. \n
N                               SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system
N                                 In this case try again later or increase MAX_CONCURRENT_ACTIONS
N
N    \sa     SlNetIfWifi_socket
N    \note   If the timeout value set to less than 10ms it will automatically set
N            to 10ms to prevent overload of the system\n
N
N            Only one SlNetIfWifi_send can be handled at a time. \b
N            Calling this API while the same command is called from another thread, may result
N                in one of the following scenarios:
N            1. The command will wait (internal) until the previous command finish, and then be executed.
N            2. There are not enough resources and SLNETERR_BSD_ENOMEM error will return.
N            In this case, MAX_CONCURRENT_ACTIONS can be increased (result in memory increase) or try
N            again later to issue the command.
N            3. In case there is already a triggered SlNetIfWifi_send in progress, the following call will return
N            with SLNETSOCK_RET_CODE_SOCKET_SELECT_IN_PROGRESS_ERROR.
N
N    \warning
N*/
Nint32_t SlNetIfWifi_select(void *ifContext, int16_t nfds, SlNetSock_SdSet_t *readsds, SlNetSock_SdSet_t *writesds, SlNetSock_SdSet_t *exceptsds, SlNetSock_Timeval_t *timeout);
N
N
N/*!
N    \brief Set socket options-
N
N    The SlNetIfWifi_setSockOpt function manipulate the options associated with a socket.\n
N    Options may exist at multiple protocol levels; they are always
N    present at the uppermost socket level.\n
N
N    When manipulating socket options the level at which the option resides
N    and the name of the option must be specified.  To manipulate options at
N    the socket level, level is specified as SOL_SOCKET.  To manipulate
N    options at any other level the protocol number of the appropriate protocol
N    controlling the option is supplied.  For example, to indicate that an
N    option is to be interpreted by the TCP protocol, level should be set to
N    the protocol number of TCP; \n
N
N    The parameters optval and optlen are used to access opt_values
N    for SlNetIfWifi_setSockOpt().  For SlNetIfWifi_getSockOpt() they identify a
N    buffer in which the value for the requested option(s) are to
N    be returned.  For SlNetIfWifi_getSockOpt(), optlen is a value-result
N    parameter, initially containing the size of the buffer
N    pointed to by option_value, and modified on return to
N    indicate the actual size of the value returned.  If no option
N    value is to be supplied or returned, option_value may be
N    NULL.
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] sdContext        May store socket data if implemented in the
N                                SlNetIfWifi_socket function.
N    \param[in] level            Defines the protocol level for this option
N                                - <b>SLNETSOCK_LVL_SOCKET</b>   Socket level configurations (L4, transport layer)
N                                - <b>SLNETSOCK_LVL_IP</b>   IP level configurations (L3, network layer)
N                                - <b>SLNETSOCK_LVL_PHY</b>  Link level configurations (L2, link layer)
N    \param[in] optname          Defines the option name to interrogate
N                                - <b>SLNETSOCK_LVL_SOCKET</b>
N                                  - <b>SLNETSOCK_OPSOCK_RCV_BUF</b>  \n
N                                                 Sets tcp max recv window size. \n
N                                                 This options takes SlNetSock_Winsize_t struct as parameter
N                                  - <b>SLNETSOCK_OPSOCK_RCV_TIMEO</b>  \n
N                                                 Sets the timeout value that specifies the maximum amount of time an input function waits until it completes. \n
N                                                 Default: No timeout \n
N                                                 This options takes SlNetSock_Timeval_t struct as parameter
N                                  - <b>SLNETSOCK_OPSOCK_KEEPALIVE</b>  \n
N                                                 Enable or Disable periodic keep alive.
N                                                 Keeps TCP connections active by enabling the periodic transmission of messages \n
N                                                 Timeout is 5 minutes.\n
N                                                 Default: Enabled \n
N                                                 This options takes SlNetSock_Keepalive_t struct as parameter
N                                  - <b>SLNETSOCK_OPSOCK_KEEPALIVE_TIME</b>  \n
N                                                 Set keep alive timeout.
N                                                 Value is in seconds \n
N                                                 Default: 5 minutes \n
N                                  - <b>SLNETSOCK_OPSOCK_LINGER</b> \n
N                                                 Socket lingers on close pending remaining send/receive packets\n
N                                  - <b>SLNETSOCK_OPSOCK_NON_BLOCKING</b> \n
N                                                 Sets socket to non-blocking operation Impacts: connect, accept, send, sendto, recv and recvfrom. \n
N                                                 Default: Blocking.
N                                                 This options takes SlNetSock_Nonblocking_t struct as parameter
N                                  - <b>SLNETSOCK_OPSOCK_NON_IP_BOUNDARY</b>  \n
N                                                 Enable or Disable rx ip boundary.
N                                                 In connectionless socket (udp/raw), unread data is dropped (when SlNetIfWifi_recvfrom len parameter < data size), Enable this option in order to read the left data on the next SlNetIfWifi_recvfrom iteration
N                                                 Default: Disabled, IP boundary kept,  \n
N                                                 This options takes SlNetSock_NonIpBoundary_t struct as parameter
N                                - <b>SLNETSOCK_LVL_IP</b>
N                                  - <b>SLNETSOCK_OPIP_MULTICAST_TTL</b> \n
N                                                 Set the time-to-live value of outgoing multicast packets for this socket. \n
N                                                 This options takes <b>uint8_t</b> as parameter
N                                  - <b>SLNETSOCK_OPIP_ADD_MEMBERSHIP</b> \n
N                                                 UDP socket, Join a multicast group. \n
N                                                 This options takes SlNetSock_IpMreq_t struct as parameter
N                                  - <b>SLNETSOCK_OPIP_DROP_MEMBERSHIP</b> \n
N                                                 UDP socket, Leave a multicast group \n
N                                                 This options takes SlNetSock_IpMreq_t struct as parameter
N                                  - <b>SLNETSOCK_OPIP_HDRINCL</b> \n
N                                                 RAW socket only, the IPv4 layer generates an IP header when sending a packet unless \n
N                                                 the IP_HDRINCL socket option is enabled on the socket.    \n
N                                                 When it is enabled, the packet must contain an IP header. \n
N                                                 Default: disabled, IPv4 header generated by Network Stack \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - <b>SLNETSOCK_OPIP_RAW_RX_NO_HEADER</b> \n
N                                                 Raw socket remove IP header from received data. \n
N                                                 Default: data includes ip header \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - <b>SLNETSOCK_OPIP_RAW_IPV6_HDRINCL</b> (inactive) \n
N                                                 RAW socket only, the IPv6 layer generates an IP header when sending a packet unless \n
N                                                 the IP_HDRINCL socket option is enabled on the socket. When it is enabled, the packet must contain an IP header \n
N                                                 Default: disabled, IPv4 header generated by Network Stack \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                - <b>SLNETSOCK_LVL_PHY</b>
N                                  - <b>SLNETSOCK_OPPHY_CHANNEL</b> \n
N                                                 Sets channel in transceiver mode.
N                                                 This options takes <b>uint32_t</b> as channel number parameter
N                                  - <b>SLNETSOCK_OPPHY_RATE</b> \n
N                                                 RAW socket, set WLAN PHY transmit rate \n
N                                                 The values are based on SlWlanRateIndex_e    \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - <b>SLNETSOCK_OPPHY_TX_POWER</b> \n
N                                                 RAW socket, set WLAN PHY TX power \n
N                                                 Valid rage is 1-15 \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - <b>SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX</b> \n
N                                                 RAW socket, set number of frames to transmit in transceiver mode.
N                                                 Default: 1 packet
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - <b>SLNETSOCK_OPPHY_PREAMBLE</b> \n
N                                                 RAW socket, set WLAN PHY preamble for Long/Short\n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - <b>SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD</b> \n
N                                                 RAW socket, set WLAN Tx - Set CCA threshold. \n
N                                                 The values are based on SlNetSockTxInhibitThreshold_e \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - <b>SLNETSOCK_OPPHY_TX_TIMEOUT</b> \n
N                                                 RAW socket, set WLAN Tx - changes the TX timeout (lifetime) of transceiver frames. \n
N                                                 Value in Ms, maximum value is 10ms \n
N                                                 This options takes <b>uint32_t</b> as parameter
N                                  - <b>SLNETSOCK_OPPHY_ALLOW_ACKS </b> \n
N                                                 RAW socket, set WLAN Tx - Enable or Disable sending ACKs in transceiver mode \n
N                                                 0 = disabled / 1 = enabled \n
N                                                 This options takes <b>uint32_t</b> as parameter
N
N
N    \param[in] optval           Specifies a value for the option
N    \param[in] optlen           Specifies the length of the
N        option value
N
N    \return                     Zero on success, or negative error code on failure
N
N    \par Persistent
N                All params are <b>Non- Persistent</b>
N    \sa     SlNetIfWifi_getSockOpt
N    \note
N    \warning
N    \par    Examples
N
N    - SLNETSOCK_OPSOCK_RCV_BUF:
N    \code
N           SlNetSock_Winsize_t size;
N           size.winsize = 3000; // bytes
N           SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_RCV_BUF, (uint8_t *)&size, sizeof(size));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPSOCK_RCV_TIMEO:
N    \code
N        struct SlNetSock_Timeval_t timeVal;
N        timeVal.tv_sec =  1; // Seconds
N        timeVal.tv_usec = 0; // Microseconds. 10000 microseconds resolution
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_RCV_TIMEO, (uint8_t *)&timeVal, sizeof(timeVal)); // Enable receive timeout
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPSOCK_KEEPALIVE: //disable Keepalive
N    \code
N        SlNetSock_Keepalive_t enableOption;
N        enableOption.keepaliveEnabled = 0;
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_KEEPALIVE, (uint8_t *)&enableOption, sizeof(enableOption));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPSOCK_KEEPALIVE_TIME: //Set Keepalive timeout
N    \code
N        int16_t Status;
N        uint32_t TimeOut = 120;
N        SlNetIfWifi_setSockOpt(Sd, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_KEEPALIVE_TIME, (uint8_t *)&TimeOut, sizeof(TimeOut));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPSOCK_NON_BLOCKING: //Enable or disable nonblocking mode
N    \code
N           SlNetSock_Nonblocking_t enableOption;
N           enableOption.nonBlockingEnabled = 1;
N           SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_NON_BLOCKING, (uint8_t *)&enableOption, sizeof(enableOption));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPSOCK_NON_IP_BOUNDARY: //disable boundary
N    \code
N        SlNetSock_NonIpBoundary_t enableOption;
N        enableOption.nonIpBoundaryEnabled = 1;
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_NON_IP_BOUNDARY, (uint8_t *)&enableOption, sizeof(enableOption));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPSOCK_LINGER:
N    \code
N        SlNetSock_linger_t linger;
N        linger.l_onoff = 1;
N        linger.l_linger = 10;
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_LINGER, &linger, sizeof(linger));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPIP_MULTICAST_TTL:
N     \code
N           uint8_t ttl = 20;
N           SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_MULTICAST_TTL, &ttl, sizeof(ttl));
N     \endcode
N     <br>
N
N    - SLNETSOCK_OPIP_ADD_MEMBERSHIP:
N     \code
N           SlNetSock_IpMreq_t mreq;
N           SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPIP_DROP_MEMBERSHIP:
N    \code
N        SlNetSock_IpMreq_t mreq;
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_DROP_MEMBERSHIP, &mreq, sizeof(mreq));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPIP_RAW_RX_NO_HEADER:
N    \code
N        uint32_t header = 1;  // remove ip header
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_RAW_RX_NO_HEADER, &header, sizeof(header));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPIP_HDRINCL:
N    \code
N        uint32_t header = 1;
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_HDRINCL, &header, sizeof(header));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPIP_RAW_IPV6_HDRINCL:
N    \code
N        uint32_t header = 1;
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_RAW_IPV6_HDRINCL, &header, sizeof(header));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_CHANNEL:
N    \code
N        uint32_t newChannel = 6; // range is 1-13
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPPHY_CHANNEL, &newChannel, sizeof(newChannel));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_RATE:
N    \code
N        uint32_t rate = 6; // see wlan.h SlWlanRateIndex_e for values
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_RATE, &rate, sizeof(rate));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_TX_POWER:
N    \code
N        uint32_t txpower = 1; // valid range is 1-15
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_TX_POWER, &txpower, sizeof(txpower));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX:
N    \code
N        uint32_t numframes = 1;
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX, &numframes, sizeof(numframes));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_PREAMBLE:
N    \code
N        uint32_t preamble = 1;
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_PREAMBLE, &preamble, sizeof(preamble));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD:
N    \code
N        uint32_t thrshld = SLNETSOCK_TX_INHIBIT_THRESHOLD_MED;
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD , &thrshld, sizeof(thrshld));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_TX_TIMEOUT:
N    \code
N        uint32_t timeout = 50;
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_TX_TIMEOUT  , &timeout, sizeof(timeout));
N    \endcode
N    <br>
N
N    - SLNETSOCK_OPPHY_ALLOW_ACKS:
N    \code
N        uint32_t acks = 1; // 0 = disabled / 1 = enabled
N        SlNetIfWifi_setSockOpt(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_ALLOW_ACKS, &acks, sizeof(acks));
N    \endcode
N    <br>
N
N*/
Nint32_t SlNetIfWifi_setSockOpt(int16_t sd, void *sdContext, int16_t level, int16_t optname, void *optval, SlNetSocklen_t optlen);
N
N/*!
N    \brief Get socket options
N
N    The SlNetIfWifi_getSockOpt function gets the options associated with a socket.
N    Options may exist at multiple protocol levels; they are always
N    present at the uppermost socket level.\n
N
N    The parameters optval and optlen identify a
N    buffer in which the value for the requested option(s) are to
N    be returned.  optlen is a value-result
N    parameter, initially containing the size of the buffer
N    pointed to by option_value, and modified on return to
N    indicate the actual size of the value returned.  If no option
N    value is to be supplied or returned, option_value may be
N    NULL.
N
N    \param[in]  sd              Socket descriptor (handle)
N    \param[in]  sdContext       May store socket data if implemented in the
N                                SlNetIfWifi_socket function.
N    \param[in]  level           Defines the protocol level for this option
N    \param[in]  optname         defines the option name to interrogate
N    \param[out] optval          Specifies a value for the option
N    \param[out] optlen          Specifies the length of the
N                                option value
N
N    \return                     Zero on success, or negative error code on failure
N    \sa     SlNetIfWifi_setSockOpt
N    \note
N    \warning
N*/
Nint32_t SlNetIfWifi_getSockOpt(int16_t sd, void *sdContext, int16_t level, int16_t optname, void *optval, SlNetSocklen_t *optlen);
N
N/*!
N    \brief Read data from TCP socket
N
N    The SlNetIfWifi_recv function receives a message from a connection-mode socket
N
N    \param[in]  sd              Socket descriptor (handle)
N    \param[in]  sdContext       May store socket data if implemented in the
N                                SlNetIfWifi_socket function.
N    \param[out] buf             Points to the buffer where the
N                                message should be stored.
N    \param[in]  len             Specifies the length in bytes of
N                                the buffer pointed to by the buffer argument.
N                                Range: 1-16000 bytes
N    \param[in]  flags           Upper 8 bits specifies the security flags
N                                Lower 24 bits specifies the type of message
N                                reception. On this version, the lower 24 bits are not
N                                supported
N
N    \return                     Return the number of bytes received,
N                                or a negative value if an error occurred.\n
N                                Using a non-blocking recv a possible negative value is SLNETERR_BSD_EAGAIN.\n
N                                SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system
N                                  In this case try again later or increase MAX_CONCURRENT_ACTIONS
N
N    \sa     SlNetIfWifi_recvFrom
N    \note
N    \warning
N    \par    Examples
N
N    - Receiving data using TCP socket:
N    \code
N        SlNetSock_AddrIn_t  Addr;
N        SlNetSock_AddrIn_t  LocalAddr;
N        int16_t AddrSize = sizeof(SlNetSock_AddrIn_t);
N        int16_t SockID, newSockID;
N        int16_t Status;
N        int8_t Buf[RECV_BUF_LEN];
N
N        LocalAddr.sin_family = SLNETSOCK_AF_INET;
N        LocalAddr.sin_port = SlNetSock_htons(5001);
N        LocalAddr.sin_addr.s_addr = 0;
N
N        Addr.sin_family = SLNETSOCK_AF_INET;
N        Addr.sin_port = SlNetSock_htons(5001);
N        Addr.sin_addr.s_addr = SlNetSock_htonl(SLNETSOCK_IPV4_VAL(10,1,1,200));
N
N        SockID = SlNetIfWifi_socket(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_STREAM, 0, 0, 0);
N        Status = SlNetIfWifi_bind(SockID, (SlNetSock_Addr_t *)&LocalAddr, AddrSize);
N        Status = SlNetIfWifi_listen(SockID, 0);
N        newSockID = SlNetIfWifi_accept(SockID, (SlNetSock_Addr_t*)&Addr, (SlNetSocklen_t*) &AddrSize);
N        Status = SlNetIfWifi_recv(newSockID, Buf, 1460, 0);
N    \endcode
N    <br>
N
N    - Rx transceiver mode using a raw socket:
N    \code
N        int8_t buffer[1536];
N        int16_t sd;
N        uint16_t size;
N        SlNetSock_TransceiverRxOverHead_t *transHeader;
N        sd = SlNetIfWifi_socket(SLNETSOCK_AF_RF, SLNETSOCK_SOCK_RAW, 11, 0, 0); // channel 11
N        while(1)
N        {
N            size = SlNetIfWifi_recv(sd,buffer,1536,0);
N            transHeader = (SlNetSock_TransceiverRxOverHead_t *)buffer;
N            printf("RSSI is %d frame type is 0x%x size %d\n",transHeader->rssi,buffer[sizeof(SlNetSock_TransceiverRxOverHead_t)],size);
N        }
N    \endcode
N*/
Nint32_t SlNetIfWifi_recv(int16_t sd, void *sdContext, void *buf, uint32_t len, uint32_t flags);
N
N/*!
N    \brief Read data from socket
N
N    SlNetIfWifi_recvFrom function receives a message from a connection-mode or
N    connectionless-mode socket
N
N    \param[in]  sd              Socket descriptor (handle)
N    \param[in]  sdContext       May store socket data if implemented in the
N                                SlNetIfWifi_socket function.
N    \param[out] buf             Points to the buffer where the message should be stored.
N    \param[in]  len             Specifies the length in bytes of the buffer pointed to by the buffer argument.
N                                Range: 1-16000 bytes
N    \param[in]  flags           Upper 8 bits specifies the security flags
N                                Lower 24 bits specifies the type of message
N                                reception. On this version, the lower 24 bits are not
N                                supported
N    \param[in]  from            Pointer to an address structure
N                                indicating the source
N                                address.\n sockaddr:\n - code
N                                for the address format.\n - socket address,
N                                the length depends on the code
N                                format
N    \param[in]  fromlen         Source address structure
N                                size. This parameter MUST be set to the size of the structure pointed to by addr.
N
N
N    \return                     Return the number of bytes received,
N                                or a negative value if an error occurred.\n
N                                Using a non-blocking recv a possible negative value is SLNETERR_BSD_EAGAIN.
N                                SLNETSOCK_RET_CODE_INVALID_INPUT (-2) will be returned if fromlen has incorrect length. \n
N                                SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system
N                                  In this case try again later or increase MAX_CONCURRENT_ACTIONS
N
N    \sa     SlNetIfWifi_recv
N    \note
N    \warning
N    \par        Example
N
N    - Receiving data:
N    \code
N        SlNetSock_AddrIn_t  Addr;
N        SlNetSock_AddrIn_t  LocalAddr;
N        int16_t AddrSize = sizeof(SlNetSock_AddrIn_t);
N        int16_t SockID;
N        int16_t Status;
N        int8_t Buf[RECV_BUF_LEN];
N
N        LocalAddr.sin_family = SLNETSOCK_AF_INET;
N        LocalAddr.sin_port = SlNetSock_htons(5001);
N        LocalAddr.sin_addr.s_addr = 0;
N
N        SockID = SlNetIfWifi_socket(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_DGRAM, 0, 0, 0);
N        Status = SlNetIfWifi_bind(SockID, (SlNetSock_Addr_t *)&LocalAddr, AddrSize);
N        Status = SlNetIfWifi_recvFrom(SockID, Buf, 1472, 0, (SlNetSock_Addr_t *)&Addr, (SlNetSocklen_t*)&AddrSize);
N
N    \endcode
N*/
Nint32_t SlNetIfWifi_recvFrom(int16_t sd, void *sdContext, void *buf, uint32_t len, uint32_t flags, SlNetSock_Addr_t *from, SlNetSocklen_t *fromlen);
N
N/*!
N    \brief Write data to TCP socket
N
N    The SlNetIfWifi_send function is used to transmit a message to another socket.
N    Returns immediately after sending data to device.
N    In case of TCP failure an async event SLNETSOCK_SOCKET_TX_FAILED_EVENT is going to
N    be received.\n
N    In case of a RAW socket (transceiver mode), extra 4 bytes should be reserved at the end of the
N    frame data buffer for WLAN FCS
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] sdContext        May store socket data if implemented in the
N                                SlNetIfWifi_socket function.
N    \param[in] buf              Points to a buffer containing
N                                the message to be sent
N    \param[in] len              Message size in bytes. Range: 1-1460 bytes
N    \param[in] flags            Upper 8 bits specifies the security flags
N                                Lower 24 bits specifies the type of message
N                                reception. On this version, the lower 24 bits are not
N                                supported for TCP.
N                                For transceiver mode, the SLNETSOCK_WLAN_RAW_RF_TX_PARAMS macro can be used to determine
N                                transmission parameters (channel,rate,tx_power,preamble)
N
N    \return                     Zero on success, or negative error code on failure
N
N    \sa     SlNetIfWifi_sendTo
N    \note
N    \warning
N    \par        Example
N
N    - Sending data:
N    \code
N        SlNetSock_AddrIn_t  Addr;
N        int16_t AddrSize = sizeof(SlNetSock_AddrIn_t);
N        int16_t SockID;
N        int16_t Status;
N        int8_t Buf[SEND_BUF_LEN];
N
N        Addr.sin_family = SLNETSOCK_AF_INET;
N        Addr.sin_port = SlNetSock_htons(5001);
N        Addr.sin_addr.s_addr = SlNetSock_htonl(SLNETSOCK_IPV4_VAL(10,1,1,200));
N
N        SockID = SlNetIfWifi_socket(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_STREAM, 0, 0, 0);
N        Status = SlNetIfWifi_connect(SockID, (SlNetSock_Addr_t *)&Addr, AddrSize);
N        Status = SlNetIfWifi_send(SockID, Buf, 1460, 0 );
N    \endcode
N*/
Nint32_t SlNetIfWifi_send(int16_t sd, void *sdContext, const void *buf, uint32_t len, uint32_t flags);
N
N/*!
N    \brief Write data to socket
N
N    The SlNetIfWifi_sendTo function is used to transmit a message on a connectionless socket
N    (connection less socket SLNETSOCK_SOCK_DGRAM,  SLNETSOCK_SOCK_RAW).\n
N    Returns immediately after sending data to device.\n
N    In case of transmission failure an async event SLNETSOCK_SOCKET_TX_FAILED_EVENT is going to
N    be received.
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] sdContext        May store socket data if implemented in the
N                                SlNetIfWifi_socket function.
N    \param[in] buf              Points to a buffer containing
N                                the message to be sent
N    \param[in] len              message size in bytes. Range: 1-1460 bytes
N    \param[in] flags            Upper 8 bits specifies the security flags
N                                Lower 24 bits specifies the type of message
N                                reception. On this version, the lower 24 bits are not
N                                supported
N    \param[in] to               Pointer to an address structure
N                                indicating the destination
N                                address.\n sockaddr:\n - code
N                                for the address format.\n - socket address,
N                                the length depends on the code
N                                format
N    \param[in] tolen            Destination address structure size
N
N    \return                     Zero on success, or negative error code on failure
N
N    \sa     SlNetIfWifi_send
N    \note
N    \warning
N    \par    Example
N
N    - Sending data:
N    \code
N        SlNetSock_AddrIn_t  Addr;
N        int16_t AddrSize = sizeof(SlNetSock_AddrIn_t);
N        int16_t SockID;
N        int16_t Status;
N        int8_t Buf[SEND_BUF_LEN];
N
N        Addr.sin_family = SLNETSOCK_AF_INET;
N        Addr.sin_port = SlNetSock_htons(5001);
N        Addr.sin_addr.s_addr = SlNetSock_htonl(SLNETSOCK_IPV4_VAL(10,1,1,200));
N
N        SockID = SlNetIfWifi_socket(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_DGRAM, 0, 0, 0);
N        Status = SlNetIfWifi_sendTo(SockID, Buf, 1472, 0, (SlNetSock_Addr_t *)&Addr, AddrSize);
N    \endcode
N*/
Nint32_t SlNetIfWifi_sendTo(int16_t sd, void *sdContext, const void *buf, uint32_t len, uint32_t flags, const SlNetSock_Addr_t *to, SlNetSocklen_t tolen);
N
N
N/*!
N    \brief Start a security session on an opened socket
N
N    The SlNetIfWifi_sockstartSec function is used start a security session on
N    an opened socket. If the security handle is NULL the session would
N    be started with the default security settings.
N
N    \param[in] sd               Socket descriptor (handle)
N    \param[in] sdContext        May store socket data if implemented in the
N                                SlNetIfWifi_socket function.
N    \param[in] secAttrib        Secure attribute handle
N    \param[in] flags            Specifies flags. \n
N                                The available flags are:
N                                    - SLNETSOCK_SEC_START_SECURITY_SESSION_ONLY
N                                    - SLNETSOCK_SEC_BIND_CONTEXT_ONLY
N                                    - SLNETSOCK_SEC_IS_SERVER
N
N    \return                     Zero on success, or negative error code
N                                on failure
N
N    \sa
N    \note
N    \warning
N    \par    Example
N
N    - start security session on an opened socket:
N    \code
N
N    \endcode
N*/
Nint32_t SlNetIfWifi_sockstartSec(int16_t sd, void *sdContext, SlNetSockSecAttrib_t *secAttrib, uint8_t flags);
N
N
N/*!
N    \brief Get host IP by name\n
N    Obtain the IP Address of machine on network, by machine name.
N
N    \param[in]     ifContext    Stores interface data if CreateContext function
N                                supported and implemented.
N                                Can be used in all SlNetIf_Config_t functions
N    \param[in]     ifBitmap     Specifies the interfaces which the host ip
N                                needs to be retrieved from (according to
N                                the priority until one of them will return
N                                an answer).\n
N                                The values of the interface identifiers
N                                is defined with the prefix SLNETIF_ID_
N                                which defined in slnetif.h
N    \param[in]     name         Host name
N    \param[in]     nameLen      Name length
N    \param[out]    ipAddr       This parameter is filled in with
N                                host IP addresses. In case that host name is not
N                                resolved, out_ip_addr is zero.
N    \param[in,out] ipAddrLen    Holds the size of the ipAddr array, when function 
N                                successful, the ipAddrLen parameter will be updated with
N                                the number of the IP addresses found.
N    \param[in]     family       Protocol family
N                                
N    \return                     Zero on success, or negative on failure.\n
N                                SLNETUTIL_POOL_IS_EMPTY may be return in case
N                                there are no resources in the system\n
N                                    In this case try again later or increase
N                                    MAX_CONCURRENT_ACTIONS
N                                Possible DNS error codes:
N                                - SLNETUTIL_DNS_QUERY_NO_RESPONSE
N                                - SLNETUTIL_DNS_NO_SERVER
N                                - SLNETUTIL_DNS_QUERY_FAILED
N                                - SLNETUTIL_DNS_MALFORMED_PACKET
N                                - SLNETUTIL_DNS_MISMATCHED_RESPONSE
N
N    \sa
N    \note   Only one sl_NetAppDnsGetHostByName can be handled at a time.\n
N            Calling this API while the same command is called from another
N            thread, may result in one of the two scenarios:
N            1. The command will wait (internal) until the previous command
N               finish, and then be executed.
N            2. There are not enough resources and POOL_IS_EMPTY error will
N               return.\n
N               In this case, MAX_CONCURRENT_ACTIONS can be increased (result
N               in memory increase) or try again later to issue the command.
N    \warning
N            In case an IP address in a string format is set as input, without
N            any prefix (e.g. "1.2.3.4") the device will not try to access the
N            DNS and it will return the input address on the 'out_ip_addr' field
N    \par  Example
N    - Getting host by name:
N    \code
N    uint16_t DestIPListSize = 1;
N    uint32_t DestIP[1];
N    uint32_t ifID;
N    int16_t  SockId;
N    SlNetSock_AddrIn_t LocalAddr; //address of the server to connect to
N    int32_t LocalAddrSize;
N
N    SlNetIfWifi_getHostByName(0, "www.google.com", strlen("www.google.com"), (uint32_t *)DestIP, &DestIPListSize, SLNETSOCK_PF_INET);
N
N    LocalAddr.sin_family = SLNETSOCK_AF_INET;
N    LocalAddr.sin_addr.s_addr = SlNetUtil_htonl(DestIP[0]);
N    LocalAddr.sin_port = SlNetUtil_htons(80);
N    LocalAddrSize = sizeof(SlNetSock_AddrIn_t);
N
N    SockId = SlNetIfWifi_socket(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_STREAM, ifID, 0);
N
N    if (SockId >= 0)
N    {
N        status = SlNetIfWifi_connect(SockId, (SlNetSock_Addr_t *) &LocalAddr, LocalAddrSize);
N    }
N    \endcode
N*/
Nint32_t SlNetIfWifi_getHostByName(void *ifContext, char *name, const uint16_t nameLen, uint32_t *ipAddr, uint16_t *ipAddrLen, const uint8_t family);
N
N
N/*!
N    \brief Get IP Address of specific interface
N
N    The SlNetIfWifi_getIPAddr function retrieve the IP address of a specific
N    interface according to the Address Type, IPv4, IPv6 LOCAL
N    or IPv6 GLOBAL.\n
N
N    \n
N
N    \param[in]  ifContext     Stores interface data if CreateContext function
N                              supported and implemented.
N                              Can be used in all SlNetIf_Config_t functions
N    \param[in]  ifID          Specifies the interface which its connection
N                              state needs to be retrieved.\n
N                              The values of the interface identifier is
N                              defined with the prefix SLNETIF_ID_ which
N                              defined in slnetif.h
N    \param[in]  addrType      Address type:
N                                          - SLNETIF_IPV4_ADDR
N                                          - SLNETIF_IPV6_ADDR_LOCAL
N                                          - SLNETIF_IPV6_ADDR_GLOBAL
N    \param[out] addrConfig    Address config:
N                                          - SLNETIF_ADDR_CFG_UNKNOWN
N                                          - SLNETIF_ADDR_CFG_DHCP
N                                          - SLNETIF_ADDR_CFG_DHCP_LLA
N                                          - SLNETIF_ADDR_CFG_STATIC
N                                          - SLNETIF_ADDR_CFG_STATELESS
N                                          - SLNETIF_ADDR_CFG_STATEFUL
N    \param[out] ipAddr        IP Address according to the Address Type
N
N    \return                   Zero on success, or negative error code on failure
N
N    \sa     SlNetIfAddressType_e
N    \note
N    \warning
N    \par   Examples
N
N    \code
N        SlNetSock_In6Addr_t IPAdd;
N        uint16_t addressConfig = 0;
N        SlNetIfWifi_getIPAddr(SLNETIF_ID_1 ,SLNETIF_IPV6_ADDR_LOCAL ,&addressConfig ,(uint8_t *)ipAddr);
N    \endcode
N    <br>
N*/
Nint32_t SlNetIfWifi_getIPAddr(void *ifContext, SlNetIfAddressType_e addrType, uint16_t *addrConfig, uint32_t *ipAddr);
N
N
N/*!
N    \brief Get interface connection status
N
N    The SlNetIfWifi_getConnectionStatus function gets the connection status of the
N    interface (connected Or disconnected).\n
N
N    \param[in] ifContext   Stores interface data if CreateContext function
N                           supported and implemented.
N                           Can be used in all SlNetIf_Config_t functions
N
N    \return                Connection status of the interface on success,
N                           or negative error code on failure
N
N    \sa
N    \note
N    \warning
N    \par    Examples
N
N    \code
N        int16_t connection_status
N        connection_status = SlNetIfWifi_getConnectionStatus();
N    \endcode
N    <br>
N*/
Nint32_t SlNetIfWifi_getConnectionStatus(void *ifContext);
N
N
N/*!
N    \brief Load secured buffer to the network stack
N
N    The SlNetSock_secLoadObj function loads buffer/files into the inputted
N    network stack for future usage of the socket SSL/TLS connection.
N    This option is relevant for network stacks with file system and also for
N    network stacks that lack file system that can store the secured files.
N
N    \param[in] ifContext        Stores interface data if CreateContext function
N                                supported and implemented.
N                                Can be used in all SlNetIf_Config_t functions
N    \param[in] objType          Specifies the security object type which
N                                could be one of the following:\n
N                                   - SLNETIF_SEC_OBJ_TYPE_RSA_PRIVATE_KEY
N                                   - SLNETIF_SEC_OBJ_TYPE_CERTIFICATE
N                                   - SLNETIF_SEC_OBJ_TYPE_DH_KEY
N    \param[in] objName          Specifies the name/input identifier of the
N                                secured buffer loaded
N                                for file systems - this can be the file name
N                                for plain text buffer loading this can be the
N                                name of the object
N    \param[in] objNameLen       Specifies the buffer name length to be loaded.\n
N    \param[in] objBuff          Specifies the pointer to the secured buffer to
N                                be loaded.\n
N    \param[in] objBuffLen       Specifies the buffer length to be loaded.\n
N
N    \return                     On success, buffer type handler index to be
N                                used when attaching the secured buffer to a
N                                socket.\n
N                                A successful return code should be a positive
N                                number (int16)\n
N                                On error, a negative value will be returned
N                                specifying the error code.
N                                - SLNETERR_STATUS_ERROR - load operation failed
N
N    \sa                         SlNetIfWifi_setSockOpt
N    \note
N    \warning
N*/
Nint32_t SlNetIfWifi_loadSecObj(void *ifContext, uint16_t objType, char *objName, int16_t objNameLen, uint8_t *objBuff, int16_t objBuffLen);
N
N
N/*!
N    \brief Allocate and store interface data
N
N    The SlNetIfWifi_CreateContext function stores interface related data.\n
N
N    \param[in] ifContext  Allocate and store interface data if needed.
N                          Can be used in all slnetwifi interface functions
N
N    \return               Zero on success, or negative error code on failure.
N
N    \sa
N    \note
N    \warning
N    \par    Examples
N
N    \code
N        void *ifContext;
N        connection_status = SlNetIfWifi_CreateContext(&context);
N    \endcode
N    <br>
N*/
Nint32_t SlNetIfWifi_CreateContext(uint16_t ifID, const char *ifName, void **ifContext);
N
N
N/*!
N
N Close the Doxygen group.
N @}
N
N */
N
N
N#ifdef  __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __SOCKET_H__ */
N
N
L 39 "/vagrant/Q4_04/sdk_root/source/ti/drivers/net/wifi/slnetif/slnetifwifi.c" 2
N
N/*****************************************************************************/
N/* Macro declarations                                                        */
N/*****************************************************************************/
N
N/* Macro which split the 8bit security flags from the input flags            */
N#define SPLIT_SEC_AND_INPUT_FLAGS(inputFlags, secFlags)  (secFlags = inputFlags >> 24)
N
N/* Disable the 8bit security flags                                           */
N#define SECURITY_FLAGS_IN_32BIT_REPRESENTATION (0xFF000000)
N#define DISABLE_SEC_BITS_FROM_INPUT_FLAGS(inputFlags)  (inputFlags &= ~SECURITY_FLAGS_IN_32BIT_REPRESENTATION)
N
N/*****************************************************************************/
N/* Structure/Enum declarations                                               */
N/*****************************************************************************/
N
N/*****************************************************************************/
N/* Global declarations                                                       */
N/*****************************************************************************/
N
N/*!
N    SlNetIfConfigWifi structure contains all the function callbacks that are expected to be filled by the relevant network stack interface
N    Each interface has different capabilities, so not all the API's must be supported.
N    Interface that is not supporting a non-mandatory API are set to NULL 
N*/
NSlNetIf_Config_t SlNetIfConfigWifi = 
N{
N    SlNetIfWifi_socket,              // Callback function sockCreate in slnetif module
N    SlNetIfWifi_close,               // Callback function sockClose in slnetif module
N    NULL,                            // Callback function sockShutdown in slnetif module
X    0,                            
N    SlNetIfWifi_accept,              // Callback function sockAccept in slnetif module
N    SlNetIfWifi_bind,                // Callback function sockBind in slnetif module
N    SlNetIfWifi_listen,              // Callback function sockListen in slnetif module
N    SlNetIfWifi_connect,             // Callback function sockConnect in slnetif module
N    NULL,                            // Callback function sockGetPeerName in slnetif module
X    0,                            
N    NULL,                            // Callback function sockGetLocalName in slnetif module
X    0,                            
N    SlNetIfWifi_select,              // Callback function sockSelect in slnetif module
N    SlNetIfWifi_setSockOpt,          // Callback function sockSetOpt in slnetif module
N    SlNetIfWifi_getSockOpt,          // Callback function sockGetOpt in slnetif module
N    SlNetIfWifi_recv,                // Callback function sockRecv in slnetif module
N    SlNetIfWifi_recvFrom,            // Callback function sockRecvFrom in slnetif module
N    SlNetIfWifi_send,                // Callback function sockSend in slnetif module
N    SlNetIfWifi_sendTo,              // Callback function sockSendTo in slnetif module
N    SlNetIfWifi_sockstartSec,        // Callback function sockstartSec in slnetif module
N    SlNetIfWifi_getHostByName,       // Callback function utilGetHostByName in slnetif module
N    SlNetIfWifi_getIPAddr,           // Callback function ifGetIPAddr in slnetif module
N    SlNetIfWifi_getConnectionStatus, // Callback function ifGetConnectionStatus in slnetif module
N    SlNetIfWifi_loadSecObj,          // Callback function ifLoadSecObj in slnetif module
N    NULL                             // Callback function ifCreateContext in slnetif module
X    0                             
N};
N
Nstatic const int16_t StartSecOptName[10] = 
N{
N    SL_SO_SECURE_FILES_PRIVATE_KEY_FILE_NAME, 
X    (30), 
N    SL_SO_SECURE_FILES_CERTIFICATE_FILE_NAME,
X    (31),
N    SL_SO_SECURE_FILES_CA_FILE_NAME,
X    (32),
N    SL_SO_SECURE_FILES_PEER_CERT_OR_DH_KEY_FILE_NAME,
X    (33),
N    SL_SO_SECMETHOD,
X    (25),
N    SL_SO_SECURE_MASK,
X    (26),
N    SL_SO_SECURE_ALPN,
X    (40),
N    SL_SO_SECURE_EXT_CLIENT_CHLNG_RESP,
X    (41),
N    SL_SO_SECURE_DOMAIN_NAME_VERIFICATION,
X    (42),
N    SL_SO_SECURE_DISABLE_CERTIFICATE_STORE
X    (38)
N};
N
Nstatic const int16_t socketType[8] = 
N{
N    SL_SOCK_STREAM, 
X    (1), 
N    SL_SOCK_DGRAM,
X    (2),
N    SL_SOCK_RAW,
X    (3),
N    SLNETSOCK_SOCK_RX_MTR,
X    (4),
N    SL_SOCK_DGRAM,
X    (2),
N    SL_SOCK_RAW,
X    (3),
N    SLNETSOCK_SOCK_BRIDGE,
X    (7),
N    SLNETSOCK_SOCK_ROUTER,
X    (8),
N};
N
N/*****************************************************************************/
N/* Function prototypes                                                       */
N/*****************************************************************************/
N
N//*****************************************************************************
N//
N// SlNetIfWifi_socket - Create an endpoint for communication
N//
N//*****************************************************************************
Nint16_t SlNetIfWifi_socket(void *ifContext, int16_t Domain, int16_t Type, int16_t Protocol, void **sdContext)
N{
N    /* Create socket and return the return value of the function             */
N    int16_t mappedSocketType = socketType[Type - 1];
N    return (sl_Socket(Domain, mappedSocketType, Protocol));
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_close - Gracefully close socket
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_close(int16_t sd, void *sdContext)
N{
N    /* Close socket and return the return value of the function                */
N    return sl_Close(sd);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_accept - Accept a connection on a socket
N//
N//*****************************************************************************
Nint16_t SlNetIfWifi_accept(int16_t sd, void *sdContext, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen, uint8_t flags, void **acceptedSdContext)
N{
N    return sl_Accept(sd, (SlSockAddr_t *)addr, addrlen);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_bind - Assign a name to a socket
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_bind(int16_t sd, void *sdContext, const SlNetSock_Addr_t *addr, int16_t addrlen)
N{
N    return sl_Bind(sd, (const SlSockAddr_t *)addr, addrlen);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_listen - Listen for connections on a socket
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_listen(int16_t sd, void *sdContext, int16_t backlog)
N{
N    return sl_Listen(sd, backlog);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_connect - Initiate a connection on a socket 
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_connect(int16_t sd, void *sdContext, const SlNetSock_Addr_t *addr, SlNetSocklen_t addrlen, uint8_t flags)
N{
N    return sl_Connect(sd, (const SlSockAddr_t *)addr, addrlen);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_getSockName - Returns the local address info of the socket 
N//                         descriptor
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_getSockName(int16_t sd, void *sdContext, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen)
N{
N// Not implemented in NWP
N    return SLNETERR_INVALPARAM;
X    return (-2003L);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_select - Monitor socket activity
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_select(void *ifContext, int16_t nfds, SlNetSock_SdSet_t *readsds, SlNetSock_SdSet_t *writesds, SlNetSock_SdSet_t *exceptsds, SlNetSock_Timeval_t *timeout)
N{
N    return sl_Select(nfds, (SlFdSet_t *)readsds, (SlFdSet_t *)writesds, (SlFdSet_t *)exceptsds, (struct SlTimeval_t *)timeout);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_setSockOpt - Set socket options
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_setSockOpt(int16_t sd, void *sdContext, int16_t level, int16_t optname, void *optval, SlNetSocklen_t optlen)
N{
N    return sl_SetSockOpt(sd, level, optname, optval, optlen);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_getSockOpt - Get socket options
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_getSockOpt(int16_t sd, void *sdContext, int16_t level, int16_t optname, void *optval, SlNetSocklen_t *optlen)
N{
N    return sl_GetSockOpt(sd, level, optname, optval, optlen);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_recv - Read data from TCP socket
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_recv(int16_t sd, void *sdContext, void *buf, uint32_t len, uint32_t flags)
N{
N    DISABLE_SEC_BITS_FROM_INPUT_FLAGS(flags);
X    (flags &= ~(0xFF000000));
N    return sl_Recv(sd, buf, len, flags);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_recvFrom - Read data from socket
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_recvFrom(int16_t sd, void *sdContext, void *buf, uint32_t len, uint32_t flags, SlNetSock_Addr_t *from, SlNetSocklen_t *fromlen)
N{
N    DISABLE_SEC_BITS_FROM_INPUT_FLAGS(flags);
X    (flags &= ~(0xFF000000));
N    return sl_RecvFrom(sd, buf, len, flags, (SlSockAddr_t *)from, fromlen);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_send - Write data to TCP socket
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_send(int16_t sd, void *sdContext, const void *buf, uint32_t len, uint32_t flags)
N{
N    DISABLE_SEC_BITS_FROM_INPUT_FLAGS(flags);
X    (flags &= ~(0xFF000000));
N    return sl_Send(sd, buf, len, flags);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_sendTo - Write data to socket
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_sendTo(int16_t sd, void *sdContext, const void *buf, uint32_t len, uint32_t flags, const SlNetSock_Addr_t *to, SlNetSocklen_t tolen)
N{
N    DISABLE_SEC_BITS_FROM_INPUT_FLAGS(flags);
X    (flags &= ~(0xFF000000));
N    return sl_SendTo(sd, buf, len, flags, (const SlSockAddr_t *)to, tolen);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_sockstartSec - Start a security session on an opened socket
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_sockstartSec(int16_t sd, void *sdContext, SlNetSockSecAttrib_t *secAttrib, uint8_t flags)
N{
N    SlNetSock_SecAttribNode_t *tempSecAttrib = *secAttrib;
N    int32_t                   retVal         = SLNETERR_RET_CODE_OK;
X    int32_t                   retVal         = (0L);
N
N    if ( 0 != (flags & SLNETSOCK_SEC_BIND_CONTEXT_ONLY)  )
X    if ( 0 != (flags & (1 << 1))  )
N    {
N        /* run over all attributes and set them                              */
N        while (NULL != tempSecAttrib)
X        while (0 != tempSecAttrib)
N        {
N            if ( tempSecAttrib->attribName <= SLNETSOCK_SEC_ATTRIB_DISABLE_CERT_STORE)
N            {
N                retVal = sl_SetSockOpt(sd, SL_SOL_SOCKET, StartSecOptName[tempSecAttrib->attribName], tempSecAttrib->attribBuff, tempSecAttrib->attribBuffLen);
X                retVal = sl_SetSockOpt(sd, (1), StartSecOptName[tempSecAttrib->attribName], tempSecAttrib->attribBuff, tempSecAttrib->attribBuffLen);
N            }
N            else
N            {
N                return SLNETERR_RET_CODE_INVALID_INPUT;
X                return (-2006L);
N            }
N            tempSecAttrib = tempSecAttrib->next;
N        }
N    }
N
N    if ( 0 != (flags & SLNETSOCK_SEC_START_SECURITY_SESSION_ONLY)  )
X    if ( 0 != (flags & (1 << 0))  )
N    {
N        /* Start TLS session                                                     */
N        retVal = sl_StartTLS(sd);
N    }
N
N    return retVal;
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_getHostByName - Obtain the IP Address of machine on network, by 
N//                             machine name
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_getHostByName(void *ifContext, char *name, const uint16_t nameLen, uint32_t *ipAddr, uint16_t *ipAddrLen, const uint8_t family)
N{
N    int32_t  retVal = SLNETERR_RET_CODE_OK;
X    int32_t  retVal = (0L);
N    
N    /* sl_NetAppDnsGetHostByName can receive only one ipAddr variable, so
N       only the first slot of the array will be used and the ipAddrLen will
N       be updated to 1 when function is successfully                         */
N    retVal = sl_NetAppDnsGetHostByName((signed char *)name, nameLen, (_u32 *)ipAddr, family);
X    retVal = sl_NetAppDnsGetHostByName((signed char *)name, nameLen, (unsigned long *)ipAddr, family);
N    
N    if (retVal == SLNETERR_RET_CODE_OK)
X    if (retVal == (0L))
N    {
N        *ipAddrLen = 1;
N    }
N    
N    return retVal;
N    
N    
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_getIPAddr - Get IP Address of specific interface
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_getIPAddr(void *ifContext, SlNetIfAddressType_e addrType, uint16_t *addrConfig, uint32_t *ipAddr)
N{
N    uint16_t ipAddrLen = sizeof(ipAddr);
N    return sl_NetCfgGet(addrType, addrConfig, &ipAddrLen, (unsigned char *)ipAddr);
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_getConnectionStatus - Get interface connection status
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_getConnectionStatus(void *ifContext)
N{
N    SlWlanConnStatusParam_t connectionParams;
N    uint16_t                Opt    = 0;
N    int32_t                 retVal = 0;
N    uint16_t                Size   = 0;
N
N    memset(&connectionParams, 0, sizeof(SlWlanConnStatusParam_t));
N
N    retVal = sl_WlanGet(SL_WLAN_CONNECTION_INFO, &Opt, &Size, (uint8_t *)&connectionParams);
X    retVal = sl_WlanGet((5), &Opt, &Size, (uint8_t *)&connectionParams);
N
N    /* Check if the function returned an error                               */
N    if (retVal < SLNETERR_RET_CODE_OK)
X    if (retVal < (0L))
N    {
N        /* Return error code                                                 */
N        return retVal;
N    }
N    return connectionParams.ConnStatus;
N}
N
N
N//*****************************************************************************
N//
N// SlNetIfWifi_loadSecObj - Load secured buffer to the network stack
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_loadSecObj(void *ifContext, uint16_t objType, char *objName, int16_t objNameLen, uint8_t *objBuff, int16_t objBuffLen)
N{
N    char     *deviceFileName   = objName;
N    int32_t   DeviceFileHandle = -1;
N    int32_t   retVal;                //negative retVal is an error
N    uint32_t  Offset           = 0;
N    uint32_t  MasterToken      = 0;
N    int32_t   OpenFlags        = 0;
N
N    /* Check if the inputs exists                                        */
N    if ( (NULL == objName) || (NULL == objBuff) )
X    if ( (0 == objName) || (0 == objBuff) )
N    {
N        /* input not valid, return error code                            */
N        return SLNETERR_RET_CODE_INVALID_INPUT;
X        return (-2006L);
N    }
N
N    /* Create a file and write data. The file is secured, without
N       signature and with a fail safe commit                             */
N    OpenFlags = SL_FS_CREATE;
X    OpenFlags = ((unsigned long)0x1<<((17)+(10)));
N    OpenFlags |= SL_FS_OVERWRITE;
X    OpenFlags |= ((unsigned long)0x4<<((17)+(10)));
N    OpenFlags |= SL_FS_CREATE_SECURE;
X    OpenFlags |= ((unsigned long)0x2<<(17));
N    OpenFlags |= SL_FS_CREATE_NOSIGNATURE;
X    OpenFlags |= ((unsigned long)0x4<<(17));
N    OpenFlags |= SL_FS_CREATE_FAILSAFE;
X    OpenFlags |= ((unsigned long)0x1<<(17));
N
N    /* Create a secure file if not exists and open it for write.         */
N    DeviceFileHandle =  sl_FsOpen((unsigned char *)deviceFileName, OpenFlags | SL_FS_CREATE_MAX_SIZE( objBuffLen ), (unsigned long *)&MasterToken);
X    DeviceFileHandle =  sl_FsOpen((unsigned char *)deviceFileName, OpenFlags | ((((unsigned long)objBuffLen + 255) / 256 ) & (0x1FFFF) ), (unsigned long *)&MasterToken);
N
N    /* Check if file created successfully                                */
N    if ( DeviceFileHandle < SLNETERR_RET_CODE_OK )
X    if ( DeviceFileHandle < (0L) )
N    {
N        return DeviceFileHandle;
N    }
N
N    Offset = 0;
N    /* Write the buffer to the new file                                  */
N    retVal = sl_FsWrite(DeviceFileHandle, Offset, (unsigned char *)objBuff, objBuffLen);
N
N    /* Close the file                                                    */
N    retVal = sl_FsClose(DeviceFileHandle, NULL, NULL , 0);
X    retVal = sl_FsClose(DeviceFileHandle, 0, 0 , 0);
N
N    return retVal;
N}
N
N//*****************************************************************************
N//
N// SlNetIfWifi_CreateContext - Allocate and store interface data
N//
N//*****************************************************************************
Nint32_t SlNetIfWifi_CreateContext(uint16_t ifID, const char *ifName, void **context)
N{
N    return SLNETERR_RET_CODE_OK;
X    return (0L);
N}

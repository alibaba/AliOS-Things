"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setup = void 0;

var _path = _interopRequireDefault(require("path"));

var _glob = _interopRequireDefault(require("glob"));

var _utils = require("@node-minify/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * node-minify
 * Copyright(c) 2011-2020 Rodolphe Stoclin
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

/**
 * Default settings.
 */
const defaultSettings = {
  sync: false,
  options: {},
  buffer: 1000 * 1024,
  callback: false
};
/**
 * Run setup.
 *
 * @param {Object} inputSettings
 * @return {Object}
 */

const setup = inputSettings => {
  let settings = Object.assign(_utils.utils.clone(defaultSettings), inputSettings); // In memory

  if (settings.content) {
    checkMandatoriesMemoryContent(inputSettings);
    return settings;
  }

  checkMandatories(inputSettings);
  settings = Object.assign(settings, wildcards(settings.input, settings.publicFolder));
  settings = Object.assign(settings, checkOutput(settings.input, settings.output, settings.publicFolder, settings.replaceInPlace));
  settings = Object.assign(settings, setPublicFolder(settings.input, settings.publicFolder));
  return settings;
};
/**
 * Check the output path, searching for $1
 * if exist, returns the path remplacing $1 by file name
 *
 * @param {String|Array} input - Path file
 * @param {String} output - Path to the output file
 * @param {String} publicFolder - Path to the public folder
 * @param {Boolean} replaceInPlace - True to replace file in same folder
 * @return {Object}
 */


exports.setup = setup;

const checkOutput = (input, output, publicFolder, replaceInPlace) => {
  let reg = new RegExp('\\$1');

  if (reg.test(output)) {
    if (Array.isArray(input)) {
      const outputMin = input.map(file => _utils.utils.setFileNameMin(file, output, replaceInPlace ? null : publicFolder, replaceInPlace));
      return {
        output: outputMin
      };
    } else {
      return {
        output: _utils.utils.setFileNameMin(input, output, replaceInPlace ? null : publicFolder, replaceInPlace)
      };
    }
  }
};
/**
 * Handle wildcards in a path, get the real path of each files.
 *
 * @param {String|Array} input - Path with wildcards
 * @param {String} publicFolder - Path to the public folder
 * @return {Object}
 */


const wildcards = (input, publicFolder) => {
  // If it's a string
  if (!Array.isArray(input)) {
    return wildcardsString(input, publicFolder);
  }

  return wildcardsArray(input, publicFolder);
};
/**
 * Handle wildcards in a path (string only), get the real path of each files.
 *
 * @param {String} input - Path with wildcards
 * @param {String} publicFolder - Path to the public folder
 * @return {Object}
 */


const wildcardsString = (input, publicFolder) => {
  const output = {};

  if (input.indexOf('*') > -1) {
    output.input = getFilesFromWildcards(input, publicFolder);
  }

  return output;
};
/**
 * Handle wildcards in a path (array only), get the real path of each files.
 *
 * @param {Array} input - Path with wildcards
 * @param {String} publicFolder - Path to the public folder
 * @return {Object}
 */


const wildcardsArray = (input, publicFolder) => {
  let output = {};
  output.input = input; // Transform all wildcards to path file

  input.forEach(item => {
    output.input = output.input.concat(getFilesFromWildcards(item, publicFolder));
  }); // Remove all wildcards from array

  for (let i = 0; i < output.input.length; i++) {
    if (output.input[i].indexOf('*') > -1) {
      output.input.splice(i, 1);
      i--;
    }
  }

  return output;
};
/**
 * Get the real path of each files.
 *
 * @param {String} input - Path with wildcards
 * @param {String} publicFolder - Path to the public folder
 * @return {Object}
 */


const getFilesFromWildcards = (input, publicFolder) => {
  let output = [];

  if (input.indexOf('*') > -1) {
    output = _glob.default.sync((publicFolder || '') + input, null);
  }

  return output;
};
/**
 * Prepend the public folder to each file.
 *
 * @param {String|Array} input - Path to file(s)
 * @param {String} publicFolder - Path to the public folder
 * @return {Object}
 */


const setPublicFolder = (input, publicFolder) => {
  let output = {};

  if (typeof publicFolder !== 'string') {
    return output;
  }

  publicFolder = _path.default.normalize(publicFolder);

  if (Array.isArray(input)) {
    output.input = input.map(item => {
      // Check if publicFolder is already in path
      if (_path.default.normalize(item).indexOf(publicFolder) > -1) {
        return item;
      }

      return _path.default.normalize(publicFolder + item);
    });
    return output;
  }

  input = _path.default.normalize(input); // Check if publicFolder is already in path

  if (input.indexOf(publicFolder) > -1) {
    output.input = input;
    return output;
  }

  output.input = _path.default.normalize(publicFolder + input);
  return output;
};
/**
 * Check if some settings are here.
 *
 * @param {Object} settings
 */


const checkMandatories = settings => {
  ['compressor', 'input', 'output'].forEach(item => mandatory(item, settings));
};
/**
 * Check if some settings are here for memory content.
 *
 * @param {Object} settings
 */


const checkMandatoriesMemoryContent = settings => {
  ['compressor', 'content'].forEach(item => mandatory(item, settings));
};
/**
 * Check if the setting exist.
 *
 * @param {String} setting
 * @param {Object} settings
 */


const mandatory = (setting, settings) => {
  if (!settings[setting]) {
    throw new Error(setting + ' is mandatory.');
  }
};
/**
 * Expose `setup()`.
 */